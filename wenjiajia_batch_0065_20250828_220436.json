{
  "metadata": {
    "batch_number": 65,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:42.380218",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "85/C",
      "title": "C. Petya and Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an odd integer n (3 ≤ n < 105), which represents the number of tree nodes. Next n lines contain node descriptions. The (i + 1)-th line contains two space-separated integers. The first number is the number of parent of the i-st node and the second number is the key lying in the i-th node. The next line contains an integer k (1 ≤ k ≤ 105), which represents the number of keys for which you should count the average value of search results containing one mistake. Next k lines contain the actual keys, one key per line.All node keys and all search keys are positive integers, not exceeding 109. All n + k keys are distinct.All nodes are numbered from 1 to n. For the tree root \"-1\" (without the quote) will be given instead of the parent's node number. It is guaranteed that the correct binary search tree is given. For each node except for the root, it could be determined according to its key whether it is the left child or the right one.",
      "output_spec": "OutputPrint k real numbers which are the expectations of answers for the keys specified in the input. The answer should differ from the correct one with the measure of absolute or relative error not exceeding 10 - 9.",
      "sample_tests": "ExamplesInputCopy7-1 81 41 122 22 63 103 1411OutputCopy8.0000000000InputCopy3-1 51 31 76124689OutputCopy7.00000000007.00000000007.00000000003.00000000003.00000000003.0000000000",
      "description": "C. Petya and Tree\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an odd integer n (3 ≤ n < 105), which represents the number of tree nodes. Next n lines contain node descriptions. The (i + 1)-th line contains two space-separated integers. The first number is the number of parent of the i-st node and the second number is the key lying in the i-th node. The next line contains an integer k (1 ≤ k ≤ 105), which represents the number of keys for which you should count the average value of search results containing one mistake. Next k lines contain the actual keys, one key per line.All node keys and all search keys are positive integers, not exceeding 109. All n + k keys are distinct.All nodes are numbered from 1 to n. For the tree root \"-1\" (without the quote) will be given instead of the parent's node number. It is guaranteed that the correct binary search tree is given. For each node except for the root, it could be determined according to its key whether it is the left child or the right one.\n\nOutputPrint k real numbers which are the expectations of answers for the keys specified in the input. The answer should differ from the correct one with the measure of absolute or relative error not exceeding 10 - 9.\n\nInputCopy7-1 81 41 122 22 63 103 1411OutputCopy8.0000000000InputCopy3-1 51 31 76124689OutputCopy7.00000000007.00000000007.00000000003.00000000003.00000000003.0000000000\n\nInputCopy7-1 81 41 122 22 63 103 1411\n\nOutputCopy8.0000000000\n\nInputCopy3-1 51 31 76124689\n\nOutputCopy7.00000000007.00000000007.00000000003.00000000003.00000000003.0000000000\n\nNoteIn the first sample the search of key 1 with one error results in two paths in the trees: (1, 2, 5) and (1, 3, 6), in parentheses are listed numbers of nodes from the root to a leaf. The keys in the leaves of those paths are equal to 6 and 10 correspondingly, that's why the answer is equal to 8.",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round1 - Codeforces",
          "content": "We are glad to welcome all contestants of a qualifying contest \"Yandex.Algorithm 2011 - Round 1\". Today's round authors are Vitaly Goldshteyn, Ignat Kolesnichenko, Stanislav Pak and Denis Yarets. All we are employees or interns of Yandex. We really appreciate Artem Rakhov, Maria Belova and Mike Mirzayanov who helped us to prepare the contest. We hope that our tasks will be quite interesting and you will get much fun solving them. As you may know top 200 contestants after this round will be able to continue fighting for spots in the final round. Please pay attention that as well as during the previous qualifying round Codeforces functionality will be a little cut down for the time of the competition. Do not worry, all will return into place after the end of the round. Round will be rated for the official participants, and for those who failed to qualify and participate out of competition (unofficial).Good luck and high rating for everyone!Tasks analysis: C",
          "author": "frost_nova",
          "url": "https://codeforces.com/blog/entry/2008",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Яндекс.Алгоритм 2011 - Раунд 1 (Разбор задачи Е \"Сторожевые башни\") - Codeforces",
          "content": "В задаче нужно было разделить множество точек (мощностью n) на плоскости на два множества так, что бы в каждом множестве расстояние между парой самых удаленных точек было d, которое нужно минимизировать. А затем, уже при найденном минимальном d, посчитать количество способов разбиения с сохранением вышеописанного инварианта.Для начала научимся решать задачу за более медленную асимптотику. Зафиксируем бинарным поиском искомое расстояние d и рассмотрим граф из n вершин (вершины соответствуют точкам), в котором есть ребро между вершинами i и j, если |xi - xj| + |yi - yj| > d. Тогда понятно, что если полученный граф будет двудольным, то исходное множество можно разбить на две части так, что расстояние между парой самых удаленных точек в каждой части будет не больше d. Пусть мы определили минимальное значение d, при котором вышеописанный граф будет оставаться двудольным, тогда подсчет количества разбиений сводится, как несложно видеть, к подсчету количества раскрасок двудольного графа в два цвета. Время работы данного решения составляет O(n2log(n)). Попробуем ускорить данный алгоритм следующим образом. Предположим, что мы отсортировали все попарные расстояния между точками в порядке уменьшения. Данную операцию можно сделать за линейное время от количества пар, т.е. за время O(n2), используя сортировку подсчетом. Теперь для каждой пары точек (i, j) (в отсортированном порядке) будем добавлять ребро в граф между вершинами i и j, до тех пор пока он будет оставаться двудольным. Расстояние между парой точек, на которой мы остановились и будет оптимальным значением d. Остался лишь одни неясный момент, как быстро (за O(1)) проверять остается ли граф двудольным после добавления очередного ребра? Это можно делать используя CНМ. Как известно в двудольном графе нет циклов нечетной длины, а поэтому, нам достаточно модифицировать СНМ так, что бы она не учитывала циклы четной длины, а реагировала лишь на нечетные. Для этого для каждой вершины заведем пометку, которая будет указывать на четность длины пути от вершины до корня ее дерева, которую несложно пересчитывать после изменения СНМ. Реализовав такую структуру данных, мы получим быстрый способ ответа на интересующий нас вопрос. Итого, сложность вышеописанного решения O(n2).На самом деле, при использовании манхетенской метрики, данную задачу можно решать за линейное время, т.е. O(n). Преобразуем систему координат следующим образом:x’ = x - yy’ = x + yТогда задачу можно свести к покрытию всех точек двумя квадратами одинакового размера (возможно пересекающимися) со сторонами параллельными осям новой системы координат. Ответом на задачу будет наименьшая длина стороны квадратов, которыми можно покрыть все точки, а количество способов разбиения равно 2k + 1, где k - число точек, которые принадлежат сразу двум квадратам. Отличную реализацию данного алгоритма можно увидеть в решении участника Sammarize во время раунда.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2896
        },
        {
          "title": "Разбор задачи C из Яндекс.Алгоритм 2011 раунд 1 - Codeforces",
          "content": "Good day!I am an author of the problem C in the first round of Yandex.Algorithm competition and I would like to tell you about the solution of this problem.I hope you enjoyed the problem and regret about the weakness of the test-set. This trouble was mentioned by the user maksay, whose quadratic solution is successfully passed system tests. I did not consider this case when created tests for the problem and random tests with deep trees could not challenge this solution.   So, let remember statement of the problem. We have  the correct binary search tree and the set of request keys. For each request key we consider paths in the tree with one error. These paths are constructed by the search of request key in the tree with one wrong choice of the next vertice. Each wrong choice generate one search path in the tree. At the beginning solve the problem for one request key. Consider the vertex of the path, after which the error occurred. Suppose that correct search at this vertex goes to the left child but we go to the right. This means that request key lies in key range of the left subtree and we go to the right subtree. Therefore further search of request key goes to the vertex of the right subtree with minimum key. Similar, if correct search goes to the right child but we go to the left, then further search goes to the vertex with maximum key in left subtree. Count maximum and minimum keys for each subtree of the all tree. This is done by the depth-first search. If we know minimum and maximum keys for all subtrees, there is easy to count answer for given request key. Execute search of the request key and accumulate values of minimum or maximum keys of subtrees where we go with one error.  Now solve the problem for all request keys. Note that the answer for request key depends of only final vertex of the correct search in the tree. Therefore count answer for all leafs of the tree by one depth-first search. For all request keys we need to find final vertex of the search very fast. Put all keys of all vertices of the tree in ordered array. Note that keys of inner vertices and keys of leafs are alternated in this array. So, for each request key find nearest left and right keys in this array using binary search. One of this keys belongs to the leaf. Answer for this leaf would be answer for given request key. Thus, solution of the problem requires two depth-first searches and k binary searches in array. So, running time is , where n is a number of vertices in the tree and k is a number of request keys.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2021",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2537
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1); // 1-based indexing\n    vector<int64_t> key(n + 1);\n    unordered_set<int64_t> nodeKeys; // For node keys\n\n    // To keep track of children\n    vector<int> leftChild(n + 1, -1);\n    vector<int> rightChild(n + 1, -1);\n\n    int rootCount = 0, root = -1;\n\n    for (int i = 1; i <= n; ++i) {\n        int pi = inf.readInt(-1, n, \"parent\");\n        if (pi == -1) {\n            rootCount++;\n            ensuref(rootCount == 1, \"Multiple roots found\");\n            root = i;\n        } else {\n            ensuref(1 <= pi && pi <= n, \"Invalid parent index for node %d: pi=%d\", i, pi);\n            ensuref(pi != i, \"Node %d cannot be its own parent\", i);\n        }\n\n        inf.readSpace();\n\n        int64_t ki = inf.readLong(1LL, 1000000000LL, \"key\");\n\n        inf.readEoln();\n\n        // Check for duplicate keys\n        ensuref(nodeKeys.find(ki) == nodeKeys.end(), \"Duplicate key found: %lld\", ki);\n        nodeKeys.insert(ki);\n\n        // Store parent and key\n        parent[i] = pi;\n        key[i] = ki;\n    }\n\n    // Ensure that there is exactly one root\n    ensuref(rootCount == 1, \"There must be exactly one root\");\n\n    // Now, assign left and right children\n    for (int i = 1; i <= n; ++i) {\n        int pi = parent[i];\n        if (pi != -1) {\n            int64_t ki = key[i];\n            int64_t kpi = key[pi];\n            if (ki < kpi) {\n                // Left child\n                ensuref(leftChild[pi] == -1, \"Node %d already has a left child\", pi);\n                leftChild[pi] = i;\n            } else if (ki > kpi) {\n                // Right child\n                ensuref(rightChild[pi] == -1, \"Node %d already has a right child\", pi);\n                rightChild[pi] = i;\n            } else {\n                ensuref(false, \"Node %d and its parent %d have the same key %lld\", i, pi, ki);\n            }\n        }\n    }\n\n    // Now check that every node has either 0 or 2 children\n    for (int i = 1; i <= n; ++i) {\n        int numChildren = 0;\n        if (leftChild[i] != -1) numChildren++;\n        if (rightChild[i] != -1) numChildren++;\n        ensuref(numChildren == 0 || numChildren == 2, \"Node %d has %d children, must have 0 or 2\", i, numChildren);\n    }\n\n    // Now, perform DFS to check connectedness, acyclicity, and BST property\n\n    vector<bool> visited(n + 1, false);\n\n    function<void(int, int64_t, int64_t)> dfs = [&](int u, int64_t minKey, int64_t maxKey) {\n        ensuref(!visited[u], \"Node %d visited more than once (cycle detected)\", u);\n        visited[u] = true;\n\n        int64_t ku = key[u];\n        ensuref(minKey < ku && ku < maxKey, \"BST property violated at node %d: key=%lld not in (%lld, %lld)\", u, ku, minKey, maxKey);\n\n        if (leftChild[u] != -1) {\n            dfs(leftChild[u], minKey, ku);\n        }\n        if (rightChild[u] != -1) {\n            dfs(rightChild[u], ku, maxKey);\n        }\n    };\n\n    dfs(root, LLONG_MIN, LLONG_MAX);\n\n    // Check that all nodes are visited\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to the root\", i);\n    }\n\n    // Now read k\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    unordered_set<int64_t> searchKeys;\n    for (int i = 0; i < k; ++i) {\n        int64_t ki = inf.readLong(1LL, 1000000000LL, \"searchKey\");\n        inf.readEoln();\n\n        ensuref(nodeKeys.find(ki) == nodeKeys.end(), \"Search key %lld is in node keys\", ki);\n        ensuref(searchKeys.find(ki) == searchKeys.end(), \"Duplicate search key found: %lld\", ki);\n        searchKeys.insert(ki);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1); // 1-based indexing\n    vector<int64_t> key(n + 1);\n    unordered_set<int64_t> nodeKeys; // For node keys\n\n    // To keep track of children\n    vector<int> leftChild(n + 1, -1);\n    vector<int> rightChild(n + 1, -1);\n\n    int rootCount = 0, root = -1;\n\n    for (int i = 1; i <= n; ++i) {\n        int pi = inf.readInt(-1, n, \"parent\");\n        if (pi == -1) {\n            rootCount++;\n            ensuref(rootCount == 1, \"Multiple roots found\");\n            root = i;\n        } else {\n            ensuref(1 <= pi && pi <= n, \"Invalid parent index for node %d: pi=%d\", i, pi);\n            ensuref(pi != i, \"Node %d cannot be its own parent\", i);\n        }\n\n        inf.readSpace();\n\n        int64_t ki = inf.readLong(1LL, 1000000000LL, \"key\");\n\n        inf.readEoln();\n\n        // Check for duplicate keys\n        ensuref(nodeKeys.find(ki) == nodeKeys.end(), \"Duplicate key found: %lld\", ki);\n        nodeKeys.insert(ki);\n\n        // Store parent and key\n        parent[i] = pi;\n        key[i] = ki;\n    }\n\n    // Ensure that there is exactly one root\n    ensuref(rootCount == 1, \"There must be exactly one root\");\n\n    // Now, assign left and right children\n    for (int i = 1; i <= n; ++i) {\n        int pi = parent[i];\n        if (pi != -1) {\n            int64_t ki = key[i];\n            int64_t kpi = key[pi];\n            if (ki < kpi) {\n                // Left child\n                ensuref(leftChild[pi] == -1, \"Node %d already has a left child\", pi);\n                leftChild[pi] = i;\n            } else if (ki > kpi) {\n                // Right child\n                ensuref(rightChild[pi] == -1, \"Node %d already has a right child\", pi);\n                rightChild[pi] = i;\n            } else {\n                ensuref(false, \"Node %d and its parent %d have the same key %lld\", i, pi, ki);\n            }\n        }\n    }\n\n    // Now check that every node has either 0 or 2 children\n    for (int i = 1; i <= n; ++i) {\n        int numChildren = 0;\n        if (leftChild[i] != -1) numChildren++;\n        if (rightChild[i] != -1) numChildren++;\n        ensuref(numChildren == 0 || numChildren == 2, \"Node %d has %d children, must have 0 or 2\", i, numChildren);\n    }\n\n    // Now, perform DFS to check connectedness, acyclicity, and BST property\n\n    vector<bool> visited(n + 1, false);\n\n    function<void(int, int64_t, int64_t)> dfs = [&](int u, int64_t minKey, int64_t maxKey) {\n        ensuref(!visited[u], \"Node %d visited more than once (cycle detected)\", u);\n        visited[u] = true;\n\n        int64_t ku = key[u];\n        ensuref(minKey < ku && ku < maxKey, \"BST property violated at node %d: key=%lld not in (%lld, %lld)\", u, ku, minKey, maxKey);\n\n        if (leftChild[u] != -1) {\n            dfs(leftChild[u], minKey, ku);\n        }\n        if (rightChild[u] != -1) {\n            dfs(rightChild[u], ku, maxKey);\n        }\n    };\n\n    dfs(root, LLONG_MIN, LLONG_MAX);\n\n    // Check that all nodes are visited\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to the root\", i);\n    }\n\n    // Now read k\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    unordered_set<int64_t> searchKeys;\n    for (int i = 0; i < k; ++i) {\n        int64_t ki = inf.readLong(1LL, 1000000000LL, \"searchKey\");\n        inf.readEoln();\n\n        ensuref(nodeKeys.find(ki) == nodeKeys.end(), \"Search key %lld is in node keys\", ki);\n        ensuref(searchKeys.find(ki) == searchKeys.end(), \"Duplicate search key found: %lld\", ki);\n        searchKeys.insert(ki);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1); // 1-based indexing\n    vector<int64_t> key(n + 1);\n    unordered_set<int64_t> nodeKeys; // For node keys\n\n    // To keep track of children\n    vector<int> leftChild(n + 1, -1);\n    vector<int> rightChild(n + 1, -1);\n\n    int rootCount = 0, root = -1;\n\n    for (int i = 1; i <= n; ++i) {\n        int pi = inf.readInt(-1, n, \"parent\");\n        if (pi == -1) {\n            rootCount++;\n            ensuref(rootCount == 1, \"Multiple roots found\");\n            root = i;\n        } else {\n            ensuref(1 <= pi && pi <= n, \"Invalid parent index for node %d: pi=%d\", i, pi);\n            ensuref(pi != i, \"Node %d cannot be its own parent\", i);\n        }\n\n        inf.readSpace();\n\n        int64_t ki = inf.readLong(1LL, 1000000000LL, \"key\");\n\n        inf.readEoln();\n\n        // Check for duplicate keys\n        ensuref(nodeKeys.find(ki) == nodeKeys.end(), \"Duplicate key found: %lld\", ki);\n        nodeKeys.insert(ki);\n\n        // Store parent and key\n        parent[i] = pi;\n        key[i] = ki;\n    }\n\n    // Ensure that there is exactly one root\n    ensuref(rootCount == 1, \"There must be exactly one root\");\n\n    // Now, assign left and right children\n    for (int i = 1; i <= n; ++i) {\n        int pi = parent[i];\n        if (pi != -1) {\n            int64_t ki = key[i];\n            int64_t kpi = key[pi];\n            if (ki < kpi) {\n                // Left child\n                ensuref(leftChild[pi] == -1, \"Node %d already has a left child\", pi);\n                leftChild[pi] = i;\n            } else if (ki > kpi) {\n                // Right child\n                ensuref(rightChild[pi] == -1, \"Node %d already has a right child\", pi);\n                rightChild[pi] = i;\n            } else {\n                ensuref(false, \"Node %d and its parent %d have the same key %lld\", i, pi, ki);\n            }\n        }\n    }\n\n    // Now check that every node has either 0 or 2 children\n    for (int i = 1; i <= n; ++i) {\n        int numChildren = 0;\n        if (leftChild[i] != -1) numChildren++;\n        if (rightChild[i] != -1) numChildren++;\n        ensuref(numChildren == 0 || numChildren == 2, \"Node %d has %d children, must have 0 or 2\", i, numChildren);\n    }\n\n    // Now, perform DFS to check connectedness, acyclicity, and BST property\n\n    vector<bool> visited(n + 1, false);\n\n    function<void(int, int64_t, int64_t)> dfs = [&](int u, int64_t minKey, int64_t maxKey) {\n        ensuref(!visited[u], \"Node %d visited more than once (cycle detected)\", u);\n        visited[u] = true;\n\n        int64_t ku = key[u];\n        ensuref(minKey < ku && ku < maxKey, \"BST property violated at node %d: key=%lld not in (%lld, %lld)\", u, ku, minKey, maxKey);\n\n        if (leftChild[u] != -1) {\n            dfs(leftChild[u], minKey, ku);\n        }\n        if (rightChild[u] != -1) {\n            dfs(rightChild[u], ku, maxKey);\n        }\n    };\n\n    dfs(root, LLONG_MIN, LLONG_MAX);\n\n    // Check that all nodes are visited\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to the root\", i);\n    }\n\n    // Now read k\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    unordered_set<int64_t> searchKeys;\n    for (int i = 0; i < k; ++i) {\n        int64_t ki = inf.readLong(1LL, 1000000000LL, \"searchKey\");\n        inf.readEoln();\n\n        ensuref(nodeKeys.find(ki) == nodeKeys.end(), \"Search key %lld is in node keys\", ki);\n        ensuref(searchKeys.find(ki) == searchKeys.end(), \"Duplicate search key found: %lld\", ki);\n        searchKeys.insert(ki);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   We need to generate a \"full\" BST (each node has either 0 or 2 children),\n   with n odd (3 <= n < 100000), and then generate k distinct search keys\n   (1 <= k <= 100000), all distinct from the node keys.\n\n   We support three main \"shapes\" of trees:\n   1) Skewed:  a \"chain-like\" structure where each internal node has exactly\n      one child that is a leaf, and the other child is an internal node,\n      until the last internal node has two leaf children. This creates\n      a tall, skewed full BST.\n   2) Balanced: recursively split the set of internal nodes to produce a\n      roughly balanced full BST.\n   3) Random: recursively pick a random split of the internal nodes for\n      the left/right subtrees, generating a random shape (still full).\n\n   Then we assign keys via an in-order traversal so that the BST property\n   is satisfied (left < parent < right). We generate these keys randomly\n   from [1..1e9], ensuring no duplicates. Finally, we output (parent, key)\n   for each node in BFS order (root is index 1, parent can be -1 if root),\n   then output k search keys (distinct from the node keys). \n*/\n\nstruct Node {\n    Node* parent;\n    Node* left;\n    Node* right;\n    int bfsIndex;    // index in BFS order\n    long long key;   // assigned later\n    bool isLeaf;     // true if leaf, false if internal\n    \n    Node(bool leaf) : parent(nullptr), left(nullptr), right(nullptr),\n                      bfsIndex(-1), key(-1), isLeaf(leaf) {}\n};\n\n// We will build a full binary tree (each internal node has 2 children).\n// n is odd: #internalNodes = (n-1)/2, #leaves = (n+1)/2.\n\n// Build a skewed full tree. We create (n-1)/2 internal nodes in a chain:\n//   internal[0] -> left=leaf[0], right=internal[1]\n//   internal[1] -> left=leaf[1], right=internal[2]\n//   ...\n//   internal[iCount-2] -> left=leaf[iCount-2], right=internal[iCount-1]\n//   internal[iCount-1] -> left=leaf[iCount-1], right=leaf[iCount]\n// This yields a chain of internal nodes to the right, with one new leaf\n// added at each step. \nNode* buildSkewedTree(int n) {\n    int iCount = (n - 1) / 2;\n    int lCount = (n + 1) / 2;\n    \n    // Create all internal nodes.\n    vector<Node*> inodes(iCount);\n    for (int i = 0; i < iCount; i++) {\n        inodes[i] = new Node(false);\n    }\n    // Create all leaf nodes.\n    vector<Node*> leaves(lCount);\n    for (int i = 0; i < lCount; i++) {\n        leaves[i] = new Node(true);\n    }\n    \n    // Link them in a chain:\n    for (int i = 0; i < iCount - 1; i++) {\n        inodes[i]->left = leaves[i];\n        leaves[i]->parent = inodes[i];\n        inodes[i]->right = inodes[i + 1];\n        inodes[i + 1]->parent = inodes[i];\n    }\n    // Last internal node has two leaf children.\n    inodes[iCount - 1]->left = leaves[iCount - 1];\n    leaves[iCount - 1]->parent = inodes[iCount - 1];\n    inodes[iCount - 1]->right = leaves[iCount];\n    leaves[iCount]->parent = inodes[iCount - 1];\n    \n    // Root is inodes[0].\n    return inodes[0];\n}\n\n// Build a balanced full tree given iCount = number of internal nodes \n// (each internal node has exactly 2 children), plus the knowledge\n// that total nodes = iCount + (iCount+1) = 2*iCount+1.\nNode* buildBalancedTree(int iCount) {\n    // If no internal nodes left, then we must build a leaf.\n    // Called only if iCount >= 0. If iCount == 0 => leaf.\n    if (iCount == 0) {\n        Node *leaf = new Node(true);\n        return leaf;\n    }\n    // Otherwise, create an internal node, and split iCount-1\n    // among left and right subtrees:\n    Node* root = new Node(false);\n    int leftI = (iCount - 1) / 2; // roughly half\n    int rightI = iCount - 1 - leftI;\n    root->left = buildBalancedTree(leftI);\n    root->left->parent = root;\n    root->right = buildBalancedTree(rightI);\n    root->right->parent = root;\n    return root;\n}\n\n// Build a random full tree with iCount internal nodes. We do a random split\n// of (iCount - 1) between left and right subtrees (both must be >= 0).\nNode* buildRandomTree(int iCount) {\n    if (iCount == 0) {\n        // leaf\n        Node* leaf = new Node(true);\n        return leaf;\n    }\n    Node* root = new Node(false);\n    int leftI = rnd.next(0, iCount - 1); \n    int rightI = iCount - 1 - leftI;\n    root->left = buildRandomTree(leftI);\n    root->left->parent = root;\n    root->right = buildRandomTree(rightI);\n    root->right->parent = root;\n    return root;\n}\n\n// We do a BFS to assign BFS indices in [0..n-1], store them in bfsOrder.\nvoid assignBFSIndices(Node* root, vector<Node*>& bfsOrder) {\n    queue<Node*>q;\n    q.push(root);\n    int idx = 0;\n    while (!q.empty()) {\n        Node* f = q.front(); \n        q.pop();\n        f->bfsIndex = idx++;\n        bfsOrder.push_back(f);\n        if (!f->isLeaf) {\n            q.push(f->left);\n            q.push(f->right);\n        }\n    }\n}\n\n// Collect BFS indices in an in-order traversal, so that we can assign keys\n// in ascending order to ensure BST property. We will store them in \"inList\".\nvoid inOrderTraverse(Node* v, vector<int>& inList) {\n    if (!v) return;\n    if (v->isLeaf) {\n        // leaf => just push\n        inList.push_back(v->bfsIndex);\n        return;\n    }\n    // traverse left, push self, traverse right\n    inOrderTraverse(v->left, inList);\n    inList.push_back(v->bfsIndex);\n    inOrderTraverse(v->right, inList);\n}\n\n// Generate k distinct search keys from [1..maxVal], excluding usedKeys. \n// We'll do a straightforward approach by picking random until we find a\n// candidate not in usedKeys. \nvector<long long> generateSearchKeys(int k, long long maxVal, \n                                     const unordered_set<long long>& usedKeys) {\n    vector<long long> result;\n    result.reserve(k);\n    for (int i = 0; i < k; i++) {\n        while (true) {\n            long long x = rnd.next(1LL, maxVal);\n            if (!usedKeys.count(x)) {\n                result.push_back(x);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters: n (odd, >=3), k, type in {skewed, balanced, random}, \n    // default type = \"random\".\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 5); // default 5 if not provided\n    string shape = opt<string>(\"type\", \"random\");\n\n    // n must be odd, 3 <= n < 100000. k in [1..100000].\n    // We'll just trust the user for valid parameters.\n\n    // Build the full tree structure with (n-1)/2 internal nodes.\n    int iCount = (n - 1) / 2; \n    Node* root = nullptr;\n    if (shape == \"skewed\") {\n        // special chain-like shape\n        root = buildSkewedTree(n);\n    } else if (shape == \"balanced\") {\n        root = buildBalancedTree(iCount);\n    } else {\n        // random\n        root = buildRandomTree(iCount);\n    }\n\n    // BFS to collect all nodes in BFS order\n    vector<Node*> bfsOrder;\n    bfsOrder.reserve(n);\n    assignBFSIndices(root, bfsOrder);\n\n    // In-order to get BFS indices in sorted key order\n    vector<int> inList;\n    inList.reserve(n);\n    inOrderTraverse(root, inList);\n    // inList now is the BFS indices in in-order order.\n\n    // We'll assign n distinct random keys from [1..1e9], all distinct.\n    // We store them in an array \"vals\", sorted, and map them to BFS index\n    // in ascending inList order.\n    // The upper bound for node keys is up to 1e9 (per problem).\n    // We do a quick approach: we'll pick values from [1..1e9 + buffer].\n    // For large n we might be okay. The chance of duplication is small.\n    // We'll store them in a set to avoid collisions.\n    // Then we'll put them into a vector, sort, assign to BFS indices.\n    // This ensures we won't exceed 1e9 by default.\n\n    // Because n < 100000, we can gather them in a set comfortably.\n    unordered_set<long long> used;\n    used.reserve(n * 2);\n\n    // collect distinct node keys\n    vector<long long> nodeKeys;\n    nodeKeys.reserve(n);\n\n    while ((int)nodeKeys.size() < n) {\n        long long x = rnd.next(1LL, 1000000000LL);\n        if (!used.count(x)) {\n            used.insert(x);\n            nodeKeys.push_back(x);\n        }\n    }\n    sort(nodeKeys.begin(), nodeKeys.end());\n\n    // Assign these nodeKeys in ascending order to BFS indices in inList\n    for (int i = 0; i < n; i++) {\n        long long val = nodeKeys[i];\n        int bfsi = inList[i];\n        bfsOrder[bfsi]->key = val;\n    }\n\n    // Now output the data:\n    // 1) print n\n    // 2) for i from 1..n: parent's BFS index + 1 or -1 if root, then key\n    //    The node with BFS index i is stored in bfsOrder[i].\n    //    If parent is null => -1, else parent's BFS index + 1.\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        Node* nd = bfsOrder[i];\n        if (nd->parent == nullptr) {\n            // root\n            printf(\"-1 %lld\\n\", nd->key);\n        } else {\n            printf(\"%d %lld\\n\", nd->parent->bfsIndex + 1, nd->key);\n        }\n    }\n\n    // Now generate k search keys, all distinct from these node keys.\n    // We'll pick from [1..1e9], but skip any that appear in used.\n    // Then print k, then the keys.\n    vector<long long> searchKeys = generateSearchKeys(k, 1000000000LL, used);\n    \n    // Output k, then each search key in its own line\n    printf(\"%d\\n\", k);\n    for (auto &sk : searchKeys) {\n        printf(\"%lld\\n\", sk);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   We need to generate a \"full\" BST (each node has either 0 or 2 children),\n   with n odd (3 <= n < 100000), and then generate k distinct search keys\n   (1 <= k <= 100000), all distinct from the node keys.\n\n   We support three main \"shapes\" of trees:\n   1) Skewed:  a \"chain-like\" structure where each internal node has exactly\n      one child that is a leaf, and the other child is an internal node,\n      until the last internal node has two leaf children. This creates\n      a tall, skewed full BST.\n   2) Balanced: recursively split the set of internal nodes to produce a\n      roughly balanced full BST.\n   3) Random: recursively pick a random split of the internal nodes for\n      the left/right subtrees, generating a random shape (still full).\n\n   Then we assign keys via an in-order traversal so that the BST property\n   is satisfied (left < parent < right). We generate these keys randomly\n   from [1..1e9], ensuring no duplicates. Finally, we output (parent, key)\n   for each node in BFS order (root is index 1, parent can be -1 if root),\n   then output k search keys (distinct from the node keys). \n*/\n\nstruct Node {\n    Node* parent;\n    Node* left;\n    Node* right;\n    int bfsIndex;    // index in BFS order\n    long long key;   // assigned later\n    bool isLeaf;     // true if leaf, false if internal\n    \n    Node(bool leaf) : parent(nullptr), left(nullptr), right(nullptr),\n                      bfsIndex(-1), key(-1), isLeaf(leaf) {}\n};\n\n// We will build a full binary tree (each internal node has 2 children).\n// n is odd: #internalNodes = (n-1)/2, #leaves = (n+1)/2.\n\n// Build a skewed full tree. We create (n-1)/2 internal nodes in a chain:\n//   internal[0] -> left=leaf[0], right=internal[1]\n//   internal[1] -> left=leaf[1], right=internal[2]\n//   ...\n//   internal[iCount-2] -> left=leaf[iCount-2], right=internal[iCount-1]\n//   internal[iCount-1] -> left=leaf[iCount-1], right=leaf[iCount]\n// This yields a chain of internal nodes to the right, with one new leaf\n// added at each step. \nNode* buildSkewedTree(int n) {\n    int iCount = (n - 1) / 2;\n    int lCount = (n + 1) / 2;\n    \n    // Create all internal nodes.\n    vector<Node*> inodes(iCount);\n    for (int i = 0; i < iCount; i++) {\n        inodes[i] = new Node(false);\n    }\n    // Create all leaf nodes.\n    vector<Node*> leaves(lCount);\n    for (int i = 0; i < lCount; i++) {\n        leaves[i] = new Node(true);\n    }\n    \n    // Link them in a chain:\n    for (int i = 0; i < iCount - 1; i++) {\n        inodes[i]->left = leaves[i];\n        leaves[i]->parent = inodes[i];\n        inodes[i]->right = inodes[i + 1];\n        inodes[i + 1]->parent = inodes[i];\n    }\n    // Last internal node has two leaf children.\n    inodes[iCount - 1]->left = leaves[iCount - 1];\n    leaves[iCount - 1]->parent = inodes[iCount - 1];\n    inodes[iCount - 1]->right = leaves[iCount];\n    leaves[iCount]->parent = inodes[iCount - 1];\n    \n    // Root is inodes[0].\n    return inodes[0];\n}\n\n// Build a balanced full tree given iCount = number of internal nodes \n// (each internal node has exactly 2 children), plus the knowledge\n// that total nodes = iCount + (iCount+1) = 2*iCount+1.\nNode* buildBalancedTree(int iCount) {\n    // If no internal nodes left, then we must build a leaf.\n    // Called only if iCount >= 0. If iCount == 0 => leaf.\n    if (iCount == 0) {\n        Node *leaf = new Node(true);\n        return leaf;\n    }\n    // Otherwise, create an internal node, and split iCount-1\n    // among left and right subtrees:\n    Node* root = new Node(false);\n    int leftI = (iCount - 1) / 2; // roughly half\n    int rightI = iCount - 1 - leftI;\n    root->left = buildBalancedTree(leftI);\n    root->left->parent = root;\n    root->right = buildBalancedTree(rightI);\n    root->right->parent = root;\n    return root;\n}\n\n// Build a random full tree with iCount internal nodes. We do a random split\n// of (iCount - 1) between left and right subtrees (both must be >= 0).\nNode* buildRandomTree(int iCount) {\n    if (iCount == 0) {\n        // leaf\n        Node* leaf = new Node(true);\n        return leaf;\n    }\n    Node* root = new Node(false);\n    int leftI = rnd.next(0, iCount - 1); \n    int rightI = iCount - 1 - leftI;\n    root->left = buildRandomTree(leftI);\n    root->left->parent = root;\n    root->right = buildRandomTree(rightI);\n    root->right->parent = root;\n    return root;\n}\n\n// We do a BFS to assign BFS indices in [0..n-1], store them in bfsOrder.\nvoid assignBFSIndices(Node* root, vector<Node*>& bfsOrder) {\n    queue<Node*>q;\n    q.push(root);\n    int idx = 0;\n    while (!q.empty()) {\n        Node* f = q.front(); \n        q.pop();\n        f->bfsIndex = idx++;\n        bfsOrder.push_back(f);\n        if (!f->isLeaf) {\n            q.push(f->left);\n            q.push(f->right);\n        }\n    }\n}\n\n// Collect BFS indices in an in-order traversal, so that we can assign keys\n// in ascending order to ensure BST property. We will store them in \"inList\".\nvoid inOrderTraverse(Node* v, vector<int>& inList) {\n    if (!v) return;\n    if (v->isLeaf) {\n        // leaf => just push\n        inList.push_back(v->bfsIndex);\n        return;\n    }\n    // traverse left, push self, traverse right\n    inOrderTraverse(v->left, inList);\n    inList.push_back(v->bfsIndex);\n    inOrderTraverse(v->right, inList);\n}\n\n// Generate k distinct search keys from [1..maxVal], excluding usedKeys. \n// We'll do a straightforward approach by picking random until we find a\n// candidate not in usedKeys. \nvector<long long> generateSearchKeys(int k, long long maxVal, \n                                     const unordered_set<long long>& usedKeys) {\n    vector<long long> result;\n    result.reserve(k);\n    for (int i = 0; i < k; i++) {\n        while (true) {\n            long long x = rnd.next(1LL, maxVal);\n            if (!usedKeys.count(x)) {\n                result.push_back(x);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters: n (odd, >=3), k, type in {skewed, balanced, random}, \n    // default type = \"random\".\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 5); // default 5 if not provided\n    string shape = opt<string>(\"type\", \"random\");\n\n    // n must be odd, 3 <= n < 100000. k in [1..100000].\n    // We'll just trust the user for valid parameters.\n\n    // Build the full tree structure with (n-1)/2 internal nodes.\n    int iCount = (n - 1) / 2; \n    Node* root = nullptr;\n    if (shape == \"skewed\") {\n        // special chain-like shape\n        root = buildSkewedTree(n);\n    } else if (shape == \"balanced\") {\n        root = buildBalancedTree(iCount);\n    } else {\n        // random\n        root = buildRandomTree(iCount);\n    }\n\n    // BFS to collect all nodes in BFS order\n    vector<Node*> bfsOrder;\n    bfsOrder.reserve(n);\n    assignBFSIndices(root, bfsOrder);\n\n    // In-order to get BFS indices in sorted key order\n    vector<int> inList;\n    inList.reserve(n);\n    inOrderTraverse(root, inList);\n    // inList now is the BFS indices in in-order order.\n\n    // We'll assign n distinct random keys from [1..1e9], all distinct.\n    // We store them in an array \"vals\", sorted, and map them to BFS index\n    // in ascending inList order.\n    // The upper bound for node keys is up to 1e9 (per problem).\n    // We do a quick approach: we'll pick values from [1..1e9 + buffer].\n    // For large n we might be okay. The chance of duplication is small.\n    // We'll store them in a set to avoid collisions.\n    // Then we'll put them into a vector, sort, assign to BFS indices.\n    // This ensures we won't exceed 1e9 by default.\n\n    // Because n < 100000, we can gather them in a set comfortably.\n    unordered_set<long long> used;\n    used.reserve(n * 2);\n\n    // collect distinct node keys\n    vector<long long> nodeKeys;\n    nodeKeys.reserve(n);\n\n    while ((int)nodeKeys.size() < n) {\n        long long x = rnd.next(1LL, 1000000000LL);\n        if (!used.count(x)) {\n            used.insert(x);\n            nodeKeys.push_back(x);\n        }\n    }\n    sort(nodeKeys.begin(), nodeKeys.end());\n\n    // Assign these nodeKeys in ascending order to BFS indices in inList\n    for (int i = 0; i < n; i++) {\n        long long val = nodeKeys[i];\n        int bfsi = inList[i];\n        bfsOrder[bfsi]->key = val;\n    }\n\n    // Now output the data:\n    // 1) print n\n    // 2) for i from 1..n: parent's BFS index + 1 or -1 if root, then key\n    //    The node with BFS index i is stored in bfsOrder[i].\n    //    If parent is null => -1, else parent's BFS index + 1.\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        Node* nd = bfsOrder[i];\n        if (nd->parent == nullptr) {\n            // root\n            printf(\"-1 %lld\\n\", nd->key);\n        } else {\n            printf(\"%d %lld\\n\", nd->parent->bfsIndex + 1, nd->key);\n        }\n    }\n\n    // Now generate k search keys, all distinct from these node keys.\n    // We'll pick from [1..1e9], but skip any that appear in used.\n    // Then print k, then the keys.\n    vector<long long> searchKeys = generateSearchKeys(k, 1000000000LL, used);\n    \n    // Output k, then each search key in its own line\n    printf(\"%d\\n\", k);\n    for (auto &sk : searchKeys) {\n        printf(\"%lld\\n\", sk);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are about 20 sample commands to produce various test cases \n# (no file redirection, just printing to standard output).\n# Each command generates exactly one test file.\n\n# 1) Small n, skewed\n./gen -n 3 -k 1 -type skewed\n\n# 2) Small n, balanced\n./gen -n 3 -k 2 -type balanced\n\n# 3) Small n, random\n./gen -n 3 -k 3 -type random\n\n# 4) Medium n=7, skewed\n./gen -n 7 -k 4 -type skewed\n\n# 5) Medium n=7, balanced\n./gen -n 7 -k 4 -type balanced\n\n# 6) Medium n=7, random\n./gen -n 7 -k 4 -type random\n\n# 7) n=9, skewed\n./gen -n 9 -k 5 -type skewed\n\n# 8) n=9, balanced\n./gen -n 9 -k 5 -type balanced\n\n# 9) n=9, random\n./gen -n 9 -k 5 -type random\n\n# 10) Larger n=15, skewed\n./gen -n 15 -k 6 -type skewed\n\n# 11) Larger n=15, balanced\n./gen -n 15 -k 6 -type balanced\n\n# 12) Larger n=15, random\n./gen -n 15 -k 6 -type random\n\n# 13) n=31, balanced (bigger full tree)\n./gen -n 31 -k 10 -type balanced\n\n# 14) n=31, random\n./gen -n 31 -k 10 -type random\n\n# 15) n=99, skewed\n./gen -n 99 -k 15 -type skewed\n\n# 16) n=99, balanced\n./gen -n 99 -k 15 -type balanced\n\n# 17) n=99, random\n./gen -n 99 -k 15 -type random\n\n# 18) near upper limit, n=99999, skewed\n./gen -n 99999 -k 1 -type skewed\n\n# 19) near upper limit, n=99999, balanced\n./gen -n 99999 -k 1 -type balanced\n\n# 20) near upper limit, n=99999, random\n./gen -n 99999 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:13.200911",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "85/D",
      "title": "D. Сумма медиан",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке задано число n (1 ≤ n ≤ 105) — количество операций, производимых с множеством.Далее в каждой из n строк описана одна из трех операций:   add x — добавить в множество элемент x;  del x — удалить из множества элемент x;  sum — найти сумму медиан множества. Для любой операции add x верно, что элемент x непосредственно перед операцией не входит в множество.Для любой операции del x верно, что элемент x непосредственно перед операцией входит в множество.Все числа во входных данных — положительные целые числа, не превосходящие 109.",
      "output_spec": "Выходные данныеДля каждой операции sum выведите на отдельной строке сумму медиан текущего множества. Если множество пусто, то выведите 0.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout (также вы можете использовать спецификатор %I64d).",
      "sample_tests": "ПримерыВходные данныеСкопировать6add 4add 5add 1add 2add 3sumВыходные данныеСкопировать3Входные данныеСкопировать14add 1add 7add 2add 5sumadd 6add 8add 9add 3add 4add 10sumdel 1sumВыходные данныеСкопировать51113",
      "description": "D. Сумма медиан\n\nограничение по времени на тест3 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано число n (1 ≤ n ≤ 105) — количество операций, производимых с множеством.Далее в каждой из n строк описана одна из трех операций:   add x — добавить в множество элемент x;  del x — удалить из множества элемент x;  sum — найти сумму медиан множества. Для любой операции add x верно, что элемент x непосредственно перед операцией не входит в множество.Для любой операции del x верно, что элемент x непосредственно перед операцией входит в множество.Все числа во входных данных — положительные целые числа, не превосходящие 109.\n\nВходные данные\n\nВыходные данныеДля каждой операции sum выведите на отдельной строке сумму медиан текущего множества. Если множество пусто, то выведите 0.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout (также вы можете использовать спецификатор %I64d).\n\nВыходные данные\n\nВходные данныеСкопировать6add 4add 5add 1add 2add 3sumВыходные данныеСкопировать3Входные данныеСкопировать14add 1add 7add 2add 5sumadd 6add 8add 9add 3add 4add 10sumdel 1sumВыходные данныеСкопировать51113\n\nВходные данныеСкопировать6add 4add 5add 1add 2add 3sum\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать14add 1add 7add 2add 5sumadd 6add 8add 9add 3add 4add 10sumdel 1sum\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать51113\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Яндекс.Алгоритм 2011 - Раунд 1 - Codeforces",
          "content": "Мы рады приветствовать всех участников отборочного этапа “Яндекc.Алгоритм 2011 - Раунд 1”.Авторами сегодняшнего тура являются сразу несколько человек, а именно: Виталий Гольдштейн, Игнат Колесниченко, Станислав Пак и Денис Ярец. Все мы являемся сотрудниками или интернами компании Яндекс. Мы очень признательны Артему Рахову, Марии Беловой и Михаилу Мирзаянову за оказание помощи в подготовке задач. Надеемся, наши задачи окажутся интересными и понравятся вам.Как вы наверное уже знаете, по результатам сегодняшнего отборочного раунда определятся 200 участников, которые продолжат борьбу за право участвовать в финале чемпионата.Обратите внимание, что как и во время предыдущих квалификационных раундов, функциональность Codeforces на время соревнования будет немного урезана. Не беспокойтесь, все вернется на место после окончания раунда.Раунд будет учитываться в рейтинге как для официальных участников отборочного этапа, так и для тех, кто не прошел квалификацию и участвует вне конкурса.Желаем всем удачи и высокого рейтинга!Контест завершен. Всем спасибо за участие! Особые поздравления победителю раунда tourist-у и 200-ке лидеров, вышедшей в следующий тур. Ждем вас на заключительном отборочном раунде послезавтра.Разбор задач:  С, E",
          "author": "frost_nova",
          "url": "https://codeforces.com/blog/entry/2008",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1240
        },
        {
          "title": "Яндекс.Алгоритм 2011 - Раунд 1 (Разбор задачи Е \"Сторожевые башни\") - Codeforces",
          "content": "В задаче нужно было разделить множество точек (мощностью n) на плоскости на два множества так, что бы в каждом множестве расстояние между парой самых удаленных точек было d, которое нужно минимизировать. А затем, уже при найденном минимальном d, посчитать количество способов разбиения с сохранением вышеописанного инварианта.Для начала научимся решать задачу за более медленную асимптотику. Зафиксируем бинарным поиском искомое расстояние d и рассмотрим граф из n вершин (вершины соответствуют точкам), в котором есть ребро между вершинами i и j, если |xi - xj| + |yi - yj| > d. Тогда понятно, что если полученный граф будет двудольным, то исходное множество можно разбить на две части так, что расстояние между парой самых удаленных точек в каждой части будет не больше d. Пусть мы определили минимальное значение d, при котором вышеописанный граф будет оставаться двудольным, тогда подсчет количества разбиений сводится, как несложно видеть, к подсчету количества раскрасок двудольного графа в два цвета. Время работы данного решения составляет O(n2log(n)). Попробуем ускорить данный алгоритм следующим образом. Предположим, что мы отсортировали все попарные расстояния между точками в порядке уменьшения. Данную операцию можно сделать за линейное время от количества пар, т.е. за время O(n2), используя сортировку подсчетом. Теперь для каждой пары точек (i, j) (в отсортированном порядке) будем добавлять ребро в граф между вершинами i и j, до тех пор пока он будет оставаться двудольным. Расстояние между парой точек, на которой мы остановились и будет оптимальным значением d. Остался лишь одни неясный момент, как быстро (за O(1)) проверять остается ли граф двудольным после добавления очередного ребра? Это можно делать используя CНМ. Как известно в двудольном графе нет циклов нечетной длины, а поэтому, нам достаточно модифицировать СНМ так, что бы она не учитывала циклы четной длины, а реагировала лишь на нечетные. Для этого для каждой вершины заведем пометку, которая будет указывать на четность длины пути от вершины до корня ее дерева, которую несложно пересчитывать после изменения СНМ. Реализовав такую структуру данных, мы получим быстрый способ ответа на интересующий нас вопрос. Итого, сложность вышеописанного решения O(n2).На самом деле, при использовании манхетенской метрики, данную задачу можно решать за линейное время, т.е. O(n). Преобразуем систему координат следующим образом:x’ = x - yy’ = x + yТогда задачу можно свести к покрытию всех точек двумя квадратами одинакового размера (возможно пересекающимися) со сторонами параллельными осям новой системы координат. Ответом на задачу будет наименьшая длина стороны квадратов, которыми можно покрыть все точки, а количество способов разбиения равно 2k + 1, где k - число точек, которые принадлежат сразу двум квадратам. Отличную реализацию данного алгоритма можно увидеть в решении участника Sammarize во время раунда.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2896
        },
        {
          "title": "Разбор задачи C из Яндекс.Алгоритм 2011 раунд 1 - Codeforces",
          "content": "Всем доброго дня!Я автор задачи С первого раунда Яндекс.Алгоритма и расскажу её решение.Надеюсь задача вам понравилась. Сразу хочу извиниться, за то, что тесты были не достаточно сильными и квадратичное решение пользователя maksay проходит системные тесты. Когда состовлял простые решения для проверки тестов, забыл предусмотреть такой вариант решения, а случайные тесты с глубокими деревьями не смогли его отловить. Итак, вспомним условие задачи. Дано корректное бинарное дерево поиска и набор ключей-запросов. Для каждого ключа-запроса рассматриваются пути, которые получаются, если поискать этот ключ в дереве и один раз в ходе поиска пойти не в ту вершину. Сначала поймем, как решить задачу для одного ключа-запроса. Рассмотрим вершину в пути,  после которой произошла ошибка. Предположим, что мы согласно ключу должны были пойти в левого сына, а пошли в правого. Это означает, что ключ-запрос лежит в интервале ключей левого поддерева, а мы перешли в правое поддерево. Отсюда сразу следует, что поиск этого ключа в правом поддереве приведет нас в вершину с наименьшим ключом. Аналогично, если мы должны были пойти в правое поддерево, а пошли в левое, то в левом поддереве мы придем к вершине с наибольшм ключом.Посчитаем для каждого поддерева максимальный и минимальный ключи, которые в нем встречаются. Это можно сделать одним обходом в глубину. Теперь для заданного ключа-запроса несложно посчитать ответ задачи. Необходимо выполнить поиск этого ключа в дереве, и в ходе поиска смотреть на поддеревья, в которые мы пошли бы при одной ошибке, брать у них соответсвенно минимальный или максимальный ключ и накапливать ответ.Теперь решим задачу для всех ключей-запросов. Для этого заметим, что ответ задачи для ключа-запроса зависит только от листа, в который мы попадем в ходе поиска по дереву. Поэтому, насчитаем ответ для всех листьев дерева одним обходом в глубину. После этого научимся для каждого ключа-запроса быстро определять в какой лист мы придем при его поиске в дереве. Для этого надо все ключи всех вершин дерева сложить в один отсортированный массив. Заметим, что в этом массиве будут чередоваться ключи листьев и внутренних вершин дерева. Бинарным поиском найдем пару вершин, между которыми лежит ключ-запрос, и выберем из этих двух вершин лист. Ответ для этого листа и будет ответом для данного ключа-запроса.  Таким образом, решение задачи требует двух обходов дерева в глубину и k бинарных поисков по массиву. То есть ассимптотика решения состовляет . Здесь n --- это количество вершин в дереве, а k --- это количество ключей-запросов.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2021",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2558
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n    int n = inf.readInt(1, 100000, \"n\");\r\n    inf.readEoln();\r\n    set<long long> currentSet;\r\n    for(int i = 0; i < n; i++) {\r\n        string line = inf.readLine(\"(sum|(?:add|del) [1-9][0-9]*)\");\r\n        if (line == \"sum\") {\r\n            // Do nothing, 'sum' operation\r\n        } else {\r\n            // 'add x' or 'del x'\r\n            size_t pos = line.find(' ');\r\n            ensuref(pos != string::npos, \"Line should contain space in 'add x' or 'del x' at operation %d\", i+1);\r\n            string op = line.substr(0, pos);\r\n            string x_str = line.substr(pos + 1);\r\n            ensuref(op == \"add\" || op == \"del\", \"Unknown operation '%s' at operation %d\", op.c_str(), i+1);\r\n\r\n            ensuref(!x_str.empty(), \"Missing integer in operation '%s' at operation %d\", op.c_str(), i+1);\r\n            ensuref(x_str.find(' ') == string::npos, \"Extra spaces in line at operation %d\", i+1);\r\n            ensuref(all_of(x_str.begin(), x_str.end(), ::isdigit), \"Invalid character in integer in operation %d\", i+1);\r\n            ensuref(x_str.size() <= 10, \"Integer too large in operation %d\", i+1);\r\n\r\n            ensuref(x_str[0] >= '1' && x_str[0] <= '9', \"Invalid integer in operation %d\", i+1);\r\n            long long x = atoll(x_str.c_str());\r\n            ensuref(x >= 1 && x <= 1000000000LL, \"x = %lld out of bounds in operation %d\", x, i+1);\r\n\r\n            if(op == \"add\") {\r\n                ensuref(currentSet.find(x) == currentSet.end(), \"Element %lld is already in the set at operation %d\", x, i+1);\r\n                currentSet.insert(x);\r\n            } else if(op == \"del\") {\r\n                ensuref(currentSet.find(x) != currentSet.end(), \"Element %lld is not in the set at operation %d\", x, i+1);\r\n                currentSet.erase(x);\r\n            }\r\n        }\r\n    }\r\n    inf.readEof();\r\n    return 0;\r\n}",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n    int n = inf.readInt(1, 100000, \"n\");\r\n    inf.readEoln();\r\n    set<long long> currentSet;\r\n    for(int i = 0; i < n; i++) {\r\n        string line = inf.readLine(\"(sum|(?:add|del) [1-9][0-9]*)\");\r\n        if (line == \"sum\") {\r\n            // Do nothing, 'sum' operation\r\n        } else {\r\n            // 'add x' or 'del x'\r\n            size_t pos = line.find(' ');\r\n            ensuref(pos != string::npos, \"Line should contain space in 'add x' or 'del x' at operation %d\", i+1);\r\n            string op = line.substr(0, pos);\r\n            string x_str = line.substr(pos + 1);\r\n            ensuref(op == \"add\" || op == \"del\", \"Unknown operation '%s' at operation %d\", op.c_str(), i+1);\r\n\r\n            ensuref(!x_str.empty(), \"Missing integer in operation '%s' at operation %d\", op.c_str(), i+1);\r\n            ensuref(x_str.find(' ') == string::npos, \"Extra spaces in line at operation %d\", i+1);\r\n            ensuref(all_of(x_str.begin(), x_str.end(), ::isdigit), \"Invalid character in integer in operation %d\", i+1);\r\n            ensuref(x_str.size() <= 10, \"Integer too large in operation %d\", i+1);\r\n\r\n            ensuref(x_str[0] >= '1' && x_str[0] <= '9', \"Invalid integer in operation %d\", i+1);\r\n            long long x = atoll(x_str.c_str());\r\n            ensuref(x >= 1 && x <= 1000000000LL, \"x = %lld out of bounds in operation %d\", x, i+1);\r\n\r\n            if(op == \"add\") {\r\n                ensuref(currentSet.find(x) == currentSet.end(), \"Element %lld is already in the set at operation %d\", x, i+1);\r\n                currentSet.insert(x);\r\n            } else if(op == \"del\") {\r\n                ensuref(currentSet.find(x) != currentSet.end(), \"Element %lld is not in the set at operation %d\", x, i+1);\r\n                currentSet.erase(x);\r\n            }\r\n        }\r\n    }\r\n    inf.readEof();\r\n    return 0;\r\n}",
            "output_validator": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n    int n = inf.readInt(1, 100000, \"n\");\r\n    inf.readEoln();\r\n    set<long long> currentSet;\r\n    for(int i = 0; i < n; i++) {\r\n        string line = inf.readLine(\"(sum|(?:add|del) [1-9][0-9]*)\");\r\n        if (line == \"sum\") {\r\n            // Do nothing, 'sum' operation\r\n        } else {\r\n            // 'add x' or 'del x'\r\n            size_t pos = line.find(' ');\r\n            ensuref(pos != string::npos, \"Line should contain space in 'add x' or 'del x' at operation %d\", i+1);\r\n            string op = line.substr(0, pos);\r\n            string x_str = line.substr(pos + 1);\r\n            ensuref(op == \"add\" || op == \"del\", \"Unknown operation '%s' at operation %d\", op.c_str(), i+1);\r\n\r\n            ensuref(!x_str.empty(), \"Missing integer in operation '%s' at operation %d\", op.c_str(), i+1);\r\n            ensuref(x_str.find(' ') == string::npos, \"Extra spaces in line at operation %d\", i+1);\r\n            ensuref(all_of(x_str.begin(), x_str.end(), ::isdigit), \"Invalid character in integer in operation %d\", i+1);\r\n            ensuref(x_str.size() <= 10, \"Integer too large in operation %d\", i+1);\r\n\r\n            ensuref(x_str[0] >= '1' && x_str[0] <= '9', \"Invalid integer in operation %d\", i+1);\r\n            long long x = atoll(x_str.c_str());\r\n            ensuref(x >= 1 && x <= 1000000000LL, \"x = %lld out of bounds in operation %d\", x, i+1);\r\n\r\n            if(op == \"add\") {\r\n                ensuref(currentSet.find(x) == currentSet.end(), \"Element %lld is already in the set at operation %d\", x, i+1);\r\n                currentSet.insert(x);\r\n            } else if(op == \"del\") {\r\n                ensuref(currentSet.find(x) != currentSet.end(), \"Element %lld is not in the set at operation %d\", x, i+1);\r\n                currentSet.erase(x);\r\n            }\r\n        }\r\n    }\r\n    inf.readEof();\r\n    return 0;\r\n}",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> operations;\n    set<int> current_set;\n\n    int maxNumbers = n; // maximum number of unique numbers we may need\n\n    vector<int> unused_numbers;\n    for (int i = 0; i < maxNumbers * 2; i++) {\n        // Generate unique numbers from 1 to 1e9\n        int x = rnd.next(1, int(1e9));\n        unused_numbers.push_back(x);\n    }\n    // Remove duplicates in unused_numbers (to ensure uniqueness)\n    sort(unused_numbers.begin(), unused_numbers.end());\n    unused_numbers.erase(unique(unused_numbers.begin(), unused_numbers.end()), unused_numbers.end());\n    // Shuffle unused_numbers\n    shuffle(unused_numbers.begin(), unused_numbers.end());\n    int idx_unused = 0;\n\n    if (type == \"random\") {\n        while ((int)operations.size() < n) {\n            // Decide operation\n            int op = rnd.next(100); // random number between 0 and 99\n            if (op < 40) {\n                // Try to add x\n                if (idx_unused < (int)unused_numbers.size()) {\n                    int x = unused_numbers[idx_unused++];\n                    current_set.insert(x);\n                    operations.push_back(\"add \" + to_string(x));\n                }\n                else {\n                    // Cannot add more numbers, perform sum or delete\n                    if (!current_set.empty()) {\n                        // Perform del or sum\n                        if (rnd.next(2)) {\n                            // del\n                            auto it = current_set.begin();\n                            advance(it, rnd.next(0, (int)current_set.size() - 1));\n                            int x = *it;\n                            current_set.erase(x);\n                            operations.push_back(\"del \" + to_string(x));\n                        } else {\n                            // sum\n                            operations.push_back(\"sum\");\n                        }\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else if (op < 70) {\n                // Try to delete x\n                if (!current_set.empty()) {\n                    // Pick x from current_set\n                    auto it = current_set.begin();\n                    advance(it, rnd.next(0, (int)current_set.size() - 1));\n                    int x = *it;\n                    current_set.erase(x);\n                    operations.push_back(\"del \" + to_string(x));\n                }\n                else {\n                    // Cannot delete, try to add\n                    if (idx_unused < (int)unused_numbers.size()) {\n                        int x = unused_numbers[idx_unused++];\n                        current_set.insert(x);\n                        operations.push_back(\"add \" + to_string(x));\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else {\n                // Sum operation\n                operations.push_back(\"sum\");\n            }\n        }\n    }\n    else if (type == \"max_size\") {\n        // Add maximum possible elements to set\n        while (idx_unused < (int)unused_numbers.size() && (int)operations.size() < n) {\n            int x = unused_numbers[idx_unused++];\n            current_set.insert(x);\n            operations.push_back(\"add \" + to_string(x));\n        }\n        // Perform sum operations until n operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else if (type == \"empty_sums\") {\n        // Perform only sum operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else if (type == \"alternating_add_del\") {\n        // Alternate between adding and deleting the same element\n        int x = unused_numbers[idx_unused++];\n        while ((int)operations.size() + 2 <= n) {\n            current_set.insert(x);\n            operations.push_back(\"add \" + to_string(x));\n            operations.push_back(\"sum\");\n            current_set.erase(x);\n            operations.push_back(\"del \" + to_string(x));\n            operations.push_back(\"sum\");\n        }\n        // If there are remaining operations, add sum operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else if (type == \"worst_case\") {\n        // Create worst-case operations\n        // Generate operations that require contestants to handle large sets and deletions\n        while ((int)operations.size() < n) {\n            if (idx_unused < (int)unused_numbers.size()) {\n                int x = unused_numbers[idx_unused++];\n                current_set.insert(x);\n                operations.push_back(\"add \" + to_string(x));\n            }\n            // Occasionally perform sum and delete\n            if ((int)operations.size() < n && rnd.next(100) < 10) {\n                operations.push_back(\"sum\");\n            }\n            if ((int)operations.size() < n && !current_set.empty() && rnd.next(100) < 10) {\n                // delete an element\n                auto it = current_set.begin();\n                advance(it, rnd.next(0, (int)current_set.size() - 1));\n                int x = *it;\n                current_set.erase(x);\n                operations.push_back(\"del \" + to_string(x));\n            }\n        }\n    }\n    else if (type == \"repeated\") {\n        // Add and delete the same element multiple times\n        int x = unused_numbers[idx_unused++];\n        while ((int)operations.size() + 2 <= n) {\n            current_set.insert(x);\n            operations.push_back(\"add \" + to_string(x));\n            operations.push_back(\"sum\");\n            current_set.erase(x);\n            operations.push_back(\"del \" + to_string(x));\n            operations.push_back(\"sum\");\n        }\n        // If there are remaining operations, add sum operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else {\n        // Default is random\n        while ((int)operations.size() < n) {\n            // Decide operation\n            int op = rnd.next(100); // random number between 0 and 99\n            if (op < 40) {\n                // Try to add x\n                if (idx_unused < (int)unused_numbers.size()) {\n                    int x = unused_numbers[idx_unused++];\n                    current_set.insert(x);\n                    operations.push_back(\"add \" + to_string(x));\n                }\n                else {\n                    // Cannot add more numbers, perform sum or delete\n                    if (!current_set.empty()) {\n                        // Perform del or sum\n                        if (rnd.next(2)) {\n                            // del\n                            auto it = current_set.begin();\n                            advance(it, rnd.next(0, (int)current_set.size() - 1));\n                            int x = *it;\n                            current_set.erase(x);\n                            operations.push_back(\"del \" + to_string(x));\n                        } else {\n                            // sum\n                            operations.push_back(\"sum\");\n                        }\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else if (op < 70) {\n                // Try to delete x\n                if (!current_set.empty()) {\n                    // Pick x from current_set\n                    auto it = current_set.begin();\n                    advance(it, rnd.next(0, (int)current_set.size() - 1));\n                    int x = *it;\n                    current_set.erase(x);\n                    operations.push_back(\"del \" + to_string(x));\n                }\n                else {\n                    // Cannot delete, try to add\n                    if (idx_unused < (int)unused_numbers.size()) {\n                        int x = unused_numbers[idx_unused++];\n                        current_set.insert(x);\n                        operations.push_back(\"add \" + to_string(x));\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else {\n                // Sum operation\n                operations.push_back(\"sum\");\n            }\n        }\n    }\n\n    // Output n\n    cout << operations.size() << endl;\n    // Output operations\n    for (string op : operations) {\n        cout << op << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> operations;\n    set<int> current_set;\n\n    int maxNumbers = n; // maximum number of unique numbers we may need\n\n    vector<int> unused_numbers;\n    for (int i = 0; i < maxNumbers * 2; i++) {\n        // Generate unique numbers from 1 to 1e9\n        int x = rnd.next(1, int(1e9));\n        unused_numbers.push_back(x);\n    }\n    // Remove duplicates in unused_numbers (to ensure uniqueness)\n    sort(unused_numbers.begin(), unused_numbers.end());\n    unused_numbers.erase(unique(unused_numbers.begin(), unused_numbers.end()), unused_numbers.end());\n    // Shuffle unused_numbers\n    shuffle(unused_numbers.begin(), unused_numbers.end());\n    int idx_unused = 0;\n\n    if (type == \"random\") {\n        while ((int)operations.size() < n) {\n            // Decide operation\n            int op = rnd.next(100); // random number between 0 and 99\n            if (op < 40) {\n                // Try to add x\n                if (idx_unused < (int)unused_numbers.size()) {\n                    int x = unused_numbers[idx_unused++];\n                    current_set.insert(x);\n                    operations.push_back(\"add \" + to_string(x));\n                }\n                else {\n                    // Cannot add more numbers, perform sum or delete\n                    if (!current_set.empty()) {\n                        // Perform del or sum\n                        if (rnd.next(2)) {\n                            // del\n                            auto it = current_set.begin();\n                            advance(it, rnd.next(0, (int)current_set.size() - 1));\n                            int x = *it;\n                            current_set.erase(x);\n                            operations.push_back(\"del \" + to_string(x));\n                        } else {\n                            // sum\n                            operations.push_back(\"sum\");\n                        }\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else if (op < 70) {\n                // Try to delete x\n                if (!current_set.empty()) {\n                    // Pick x from current_set\n                    auto it = current_set.begin();\n                    advance(it, rnd.next(0, (int)current_set.size() - 1));\n                    int x = *it;\n                    current_set.erase(x);\n                    operations.push_back(\"del \" + to_string(x));\n                }\n                else {\n                    // Cannot delete, try to add\n                    if (idx_unused < (int)unused_numbers.size()) {\n                        int x = unused_numbers[idx_unused++];\n                        current_set.insert(x);\n                        operations.push_back(\"add \" + to_string(x));\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else {\n                // Sum operation\n                operations.push_back(\"sum\");\n            }\n        }\n    }\n    else if (type == \"max_size\") {\n        // Add maximum possible elements to set\n        while (idx_unused < (int)unused_numbers.size() && (int)operations.size() < n) {\n            int x = unused_numbers[idx_unused++];\n            current_set.insert(x);\n            operations.push_back(\"add \" + to_string(x));\n        }\n        // Perform sum operations until n operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else if (type == \"empty_sums\") {\n        // Perform only sum operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else if (type == \"alternating_add_del\") {\n        // Alternate between adding and deleting the same element\n        int x = unused_numbers[idx_unused++];\n        while ((int)operations.size() + 2 <= n) {\n            current_set.insert(x);\n            operations.push_back(\"add \" + to_string(x));\n            operations.push_back(\"sum\");\n            current_set.erase(x);\n            operations.push_back(\"del \" + to_string(x));\n            operations.push_back(\"sum\");\n        }\n        // If there are remaining operations, add sum operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else if (type == \"worst_case\") {\n        // Create worst-case operations\n        // Generate operations that require contestants to handle large sets and deletions\n        while ((int)operations.size() < n) {\n            if (idx_unused < (int)unused_numbers.size()) {\n                int x = unused_numbers[idx_unused++];\n                current_set.insert(x);\n                operations.push_back(\"add \" + to_string(x));\n            }\n            // Occasionally perform sum and delete\n            if ((int)operations.size() < n && rnd.next(100) < 10) {\n                operations.push_back(\"sum\");\n            }\n            if ((int)operations.size() < n && !current_set.empty() && rnd.next(100) < 10) {\n                // delete an element\n                auto it = current_set.begin();\n                advance(it, rnd.next(0, (int)current_set.size() - 1));\n                int x = *it;\n                current_set.erase(x);\n                operations.push_back(\"del \" + to_string(x));\n            }\n        }\n    }\n    else if (type == \"repeated\") {\n        // Add and delete the same element multiple times\n        int x = unused_numbers[idx_unused++];\n        while ((int)operations.size() + 2 <= n) {\n            current_set.insert(x);\n            operations.push_back(\"add \" + to_string(x));\n            operations.push_back(\"sum\");\n            current_set.erase(x);\n            operations.push_back(\"del \" + to_string(x));\n            operations.push_back(\"sum\");\n        }\n        // If there are remaining operations, add sum operations\n        while ((int)operations.size() < n) {\n            operations.push_back(\"sum\");\n        }\n    }\n    else {\n        // Default is random\n        while ((int)operations.size() < n) {\n            // Decide operation\n            int op = rnd.next(100); // random number between 0 and 99\n            if (op < 40) {\n                // Try to add x\n                if (idx_unused < (int)unused_numbers.size()) {\n                    int x = unused_numbers[idx_unused++];\n                    current_set.insert(x);\n                    operations.push_back(\"add \" + to_string(x));\n                }\n                else {\n                    // Cannot add more numbers, perform sum or delete\n                    if (!current_set.empty()) {\n                        // Perform del or sum\n                        if (rnd.next(2)) {\n                            // del\n                            auto it = current_set.begin();\n                            advance(it, rnd.next(0, (int)current_set.size() - 1));\n                            int x = *it;\n                            current_set.erase(x);\n                            operations.push_back(\"del \" + to_string(x));\n                        } else {\n                            // sum\n                            operations.push_back(\"sum\");\n                        }\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else if (op < 70) {\n                // Try to delete x\n                if (!current_set.empty()) {\n                    // Pick x from current_set\n                    auto it = current_set.begin();\n                    advance(it, rnd.next(0, (int)current_set.size() - 1));\n                    int x = *it;\n                    current_set.erase(x);\n                    operations.push_back(\"del \" + to_string(x));\n                }\n                else {\n                    // Cannot delete, try to add\n                    if (idx_unused < (int)unused_numbers.size()) {\n                        int x = unused_numbers[idx_unused++];\n                        current_set.insert(x);\n                        operations.push_back(\"add \" + to_string(x));\n                    } else {\n                        operations.push_back(\"sum\");\n                    }\n                }\n            }\n            else {\n                // Sum operation\n                operations.push_back(\"sum\");\n            }\n        }\n    }\n\n    // Output n\n    cout << operations.size() << endl;\n    // Output operations\n    for (string op : operations) {\n        cout << op << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type empty_sums\n./gen -n 10 -type alternating_add_del\n./gen -n 100 -type random\n./gen -n 100 -type max_size\n./gen -n 100 -type alternating_add_del\n./gen -n 100 -type worst_case\n./gen -n 500 -type random\n./gen -n 500 -type max_size\n./gen -n 500 -type empty_sums\n./gen -n 500 -type worst_case\n./gen -n 500 -type repeated\n./gen -n 1000 -type random\n./gen -n 1000 -type max_size\n./gen -n 1000 -type empty_sums\n./gen -n 1000 -type worst_case\n./gen -n 1000 -type alternating_add_del\n./gen -n 5000 -type random\n./gen -n 5000 -type max_size\n./gen -n 5000 -type empty_sums\n./gen -n 5000 -type worst_case\n./gen -n 5000 -type repeated\n./gen -n 10000 -type random\n./gen -n 10000 -type max_size\n./gen -n 10000 -type worst_case\n./gen -n 10000 -type alternating_add_del\n./gen -n 100000 -type random\n./gen -n 100000 -type max_size\n./gen -n 100000 -type empty_sums\n./gen -n 100000 -type worst_case\n./gen -n 100000 -type alternating_add_del\n./gen -n 100000 -type repeated\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:15.456200",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "85/E",
      "title": "E. Guard Towers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (2 ≤ n ≤ 5000), n is the number of guard towers. Then follow n lines, each of which contains two integers x, y — the coordinates of the i-th tower (0 ≤ x, y ≤ 5000). No two towers are present at one point.Pretest 6 is one of the maximal tests for this problem.",
      "output_spec": "OutputPrint on the first line the smallest possible amount of money that will be enough to pay fees to the generals. Print on the second line the number of arrangements that can be carried out using the smallest possible fee. This number should be calculated modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy20 01 1OutputCopy02InputCopy40 00 11 01 1OutputCopy14InputCopy30 01000 10005000 5000OutputCopy20002",
      "description": "E. Guard Towers\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (2 ≤ n ≤ 5000), n is the number of guard towers. Then follow n lines, each of which contains two integers x, y — the coordinates of the i-th tower (0 ≤ x, y ≤ 5000). No two towers are present at one point.Pretest 6 is one of the maximal tests for this problem.\n\nOutputPrint on the first line the smallest possible amount of money that will be enough to pay fees to the generals. Print on the second line the number of arrangements that can be carried out using the smallest possible fee. This number should be calculated modulo 1000000007 (109 + 7).\n\nInputCopy20 01 1OutputCopy02InputCopy40 00 11 01 1OutputCopy14InputCopy30 01000 10005000 5000OutputCopy20002\n\nInputCopy20 01 1\n\nOutputCopy02\n\nInputCopy40 00 11 01 1\n\nOutputCopy14\n\nInputCopy30 01000 10005000 5000\n\nOutputCopy20002\n\nNoteIn the first example there are only two towers, the distance between which is equal to 2. If we give both towers to one general, then we well have to pay 2 units of money. If each general receives a tower to manage, to fee will be equal to 0. That is the smallest possible fee. As you can easily see, we can obtain it in two ways.",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round1 - Codeforces",
          "content": "We are glad to welcome all contestants of a qualifying contest \"Yandex.Algorithm 2011 - Round 1\". Today's round authors are Vitaly Goldshteyn, Ignat Kolesnichenko, Stanislav Pak and Denis Yarets. All we are employees or interns of Yandex. We really appreciate Artem Rakhov, Maria Belova and Mike Mirzayanov who helped us to prepare the contest. We hope that our tasks will be quite interesting and you will get much fun solving them. As you may know top 200 contestants after this round will be able to continue fighting for spots in the final round. Please pay attention that as well as during the previous qualifying round Codeforces functionality will be a little cut down for the time of the competition. Do not worry, all will return into place after the end of the round. Round will be rated for the official participants, and for those who failed to qualify and participate out of competition (unofficial).Good luck and high rating for everyone!Tasks analysis: C",
          "author": "frost_nova",
          "url": "https://codeforces.com/blog/entry/2008",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Яндекс.Алгоритм 2011 - Раунд 1 (Разбор задачи Е \"Сторожевые башни\") - Codeforces",
          "content": "В задаче нужно было разделить множество точек (мощностью n) на плоскости на два множества так, что бы в каждом множестве расстояние между парой самых удаленных точек было d, которое нужно минимизировать. А затем, уже при найденном минимальном d, посчитать количество способов разбиения с сохранением вышеописанного инварианта.Для начала научимся решать задачу за более медленную асимптотику. Зафиксируем бинарным поиском искомое расстояние d и рассмотрим граф из n вершин (вершины соответствуют точкам), в котором есть ребро между вершинами i и j, если |xi - xj| + |yi - yj| > d. Тогда понятно, что если полученный граф будет двудольным, то исходное множество можно разбить на две части так, что расстояние между парой самых удаленных точек в каждой части будет не больше d. Пусть мы определили минимальное значение d, при котором вышеописанный граф будет оставаться двудольным, тогда подсчет количества разбиений сводится, как несложно видеть, к подсчету количества раскрасок двудольного графа в два цвета. Время работы данного решения составляет O(n2log(n)). Попробуем ускорить данный алгоритм следующим образом. Предположим, что мы отсортировали все попарные расстояния между точками в порядке уменьшения. Данную операцию можно сделать за линейное время от количества пар, т.е. за время O(n2), используя сортировку подсчетом. Теперь для каждой пары точек (i, j) (в отсортированном порядке) будем добавлять ребро в граф между вершинами i и j, до тех пор пока он будет оставаться двудольным. Расстояние между парой точек, на которой мы остановились и будет оптимальным значением d. Остался лишь одни неясный момент, как быстро (за O(1)) проверять остается ли граф двудольным после добавления очередного ребра? Это можно делать используя CНМ. Как известно в двудольном графе нет циклов нечетной длины, а поэтому, нам достаточно модифицировать СНМ так, что бы она не учитывала циклы четной длины, а реагировала лишь на нечетные. Для этого для каждой вершины заведем пометку, которая будет указывать на четность длины пути от вершины до корня ее дерева, которую несложно пересчитывать после изменения СНМ. Реализовав такую структуру данных, мы получим быстрый способ ответа на интересующий нас вопрос. Итого, сложность вышеописанного решения O(n2).На самом деле, при использовании манхетенской метрики, данную задачу можно решать за линейное время, т.е. O(n). Преобразуем систему координат следующим образом:x’ = x - yy’ = x + yТогда задачу можно свести к покрытию всех точек двумя квадратами одинакового размера (возможно пересекающимися) со сторонами параллельными осям новой системы координат. Ответом на задачу будет наименьшая длина стороны квадратов, которыми можно покрыть все точки, а количество способов разбиения равно 2k + 1, где k - число точек, которые принадлежат сразу двум квадратам. Отличную реализацию данного алгоритма можно увидеть в решении участника Sammarize во время раунда.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2896
        },
        {
          "title": "Разбор задачи C из Яндекс.Алгоритм 2011 раунд 1 - Codeforces",
          "content": "Good day!I am an author of the problem C in the first round of Yandex.Algorithm competition and I would like to tell you about the solution of this problem.I hope you enjoyed the problem and regret about the weakness of the test-set. This trouble was mentioned by the user maksay, whose quadratic solution is successfully passed system tests. I did not consider this case when created tests for the problem and random tests with deep trees could not challenge this solution.   So, let remember statement of the problem. We have  the correct binary search tree and the set of request keys. For each request key we consider paths in the tree with one error. These paths are constructed by the search of request key in the tree with one wrong choice of the next vertice. Each wrong choice generate one search path in the tree. At the beginning solve the problem for one request key. Consider the vertex of the path, after which the error occurred. Suppose that correct search at this vertex goes to the left child but we go to the right. This means that request key lies in key range of the left subtree and we go to the right subtree. Therefore further search of request key goes to the vertex of the right subtree with minimum key. Similar, if correct search goes to the right child but we go to the left, then further search goes to the vertex with maximum key in left subtree. Count maximum and minimum keys for each subtree of the all tree. This is done by the depth-first search. If we know minimum and maximum keys for all subtrees, there is easy to count answer for given request key. Execute search of the request key and accumulate values of minimum or maximum keys of subtrees where we go with one error.  Now solve the problem for all request keys. Note that the answer for request key depends of only final vertex of the correct search in the tree. Therefore count answer for all leafs of the tree by one depth-first search. For all request keys we need to find final vertex of the search very fast. Put all keys of all vertices of the tree in ordered array. Note that keys of inner vertices and keys of leafs are alternated in this array. So, for each request key find nearest left and right keys in this array using binary search. One of this keys belongs to the leaf. Answer for this leaf would be answer for given request key. Thus, solution of the problem requires two depth-first searches and k binary searches in array. So, running time is , where n is a number of vertices in the tree and k is a number of request keys.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2021",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2537
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    // Create a set to store the points\n    set<pair<int, int>> points;\n\n    // For each of the next n lines, read x_i and y_i\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(0, 5000, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(0, 5000, \"y_i\");\n        inf.readEoln();\n\n        // Check for duplicate points\n        pair<int, int> point = make_pair(x_i, y_i);\n        ensuref(points.find(point) == points.end(), \"No two towers are present at one point: duplicate point (%d, %d) found\", x_i, y_i);\n        points.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    // Create a set to store the points\n    set<pair<int, int>> points;\n\n    // For each of the next n lines, read x_i and y_i\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(0, 5000, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(0, 5000, \"y_i\");\n        inf.readEoln();\n\n        // Check for duplicate points\n        pair<int, int> point = make_pair(x_i, y_i);\n        ensuref(points.find(point) == points.end(), \"No two towers are present at one point: duplicate point (%d, %d) found\", x_i, y_i);\n        points.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    // Create a set to store the points\n    set<pair<int, int>> points;\n\n    // For each of the next n lines, read x_i and y_i\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(0, 5000, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(0, 5000, \"y_i\");\n        inf.readEoln();\n\n        // Check for duplicate points\n        pair<int, int> point = make_pair(x_i, y_i);\n        ensuref(points.find(point) == points.end(), \"No two towers are present at one point: duplicate point (%d, %d) found\", x_i, y_i);\n        points.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        set<pair<int, int>> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            int y = rnd.next(0, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"line_horizontal\") {\n        // Generate towers along a horizontal line\n        int y = rnd.next(0, 5000);\n        set<int> used_x;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            if (used_x.count(x) == 0) {\n                used_x.insert(x);\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"line_vertical\") {\n        // Generate towers along a vertical line\n        int x = rnd.next(0, 5000);\n        set<int> used_y;\n        for (int i = 0; i < n; ) {\n            int y = rnd.next(0, 5000);\n            if (used_y.count(y) == 0) {\n                used_y.insert(y);\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"diagonal\") {\n        // Generate towers along a diagonal line x = y\n        set<int> used_x;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            if (used_x.count(x) == 0) {\n                used_x.insert(x);\n                points.push_back({x, x});\n                i++;\n            }\n        }\n    } else if (type == \"grid\") {\n        // Arrange towers in a grid pattern\n        int grid_size = sqrt(n);\n        if (grid_size * grid_size < n) grid_size++;\n        set<pair<int, int>> used;\n        for (int i = 0; i < grid_size && points.size() < n; i++) {\n            for (int j = 0; j < grid_size && points.size() < n; j++) {\n                int x = i * (5000 / max(1, grid_size - 1));\n                int y = j * (5000 / max(1, grid_size - 1));\n                if (used.count({x, y}) == 0) {\n                    used.insert({x, y});\n                    points.push_back({x, y});\n                }\n            }\n        }\n    } else if (type == \"cluster\") {\n        // Divide towers into two clusters\n        int cluster_size = n / 2;\n        set<pair<int, int>> used;\n        // First cluster near (0, 0)\n        for (int i = 0; i < cluster_size; ) {\n            int x = rnd.next(0, 1000);\n            int y = rnd.next(0, 1000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n        // Second cluster near (5000, 5000)\n        for (int i = cluster_size; i < n; ) {\n            int x = rnd.next(4000, 5000);\n            int y = rnd.next(4000, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"max_fee\") {\n        // Place towers to maximize the minimal fee\n        int positions[][2] = {{0,0}, {0,5000}, {5000,0}, {5000,5000}};\n        for (int i = 0; i < min(n, 4); ++i) {\n            points.push_back({positions[i][0], positions[i][1]});\n        }\n        set<pair<int, int>> used(points.begin(), points.end());\n        // Fill the rest with random points\n        for (int i = points.size(); i < n; ) {\n            int x = rnd.next(0, 5000);\n            int y = rnd.next(0, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else {\n        // Default to random\n        set<pair<int, int>> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            int y = rnd.next(0, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto [x, y] : points) {\n        printf(\"%d %d\\n\", x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        set<pair<int, int>> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            int y = rnd.next(0, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"line_horizontal\") {\n        // Generate towers along a horizontal line\n        int y = rnd.next(0, 5000);\n        set<int> used_x;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            if (used_x.count(x) == 0) {\n                used_x.insert(x);\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"line_vertical\") {\n        // Generate towers along a vertical line\n        int x = rnd.next(0, 5000);\n        set<int> used_y;\n        for (int i = 0; i < n; ) {\n            int y = rnd.next(0, 5000);\n            if (used_y.count(y) == 0) {\n                used_y.insert(y);\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"diagonal\") {\n        // Generate towers along a diagonal line x = y\n        set<int> used_x;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            if (used_x.count(x) == 0) {\n                used_x.insert(x);\n                points.push_back({x, x});\n                i++;\n            }\n        }\n    } else if (type == \"grid\") {\n        // Arrange towers in a grid pattern\n        int grid_size = sqrt(n);\n        if (grid_size * grid_size < n) grid_size++;\n        set<pair<int, int>> used;\n        for (int i = 0; i < grid_size && points.size() < n; i++) {\n            for (int j = 0; j < grid_size && points.size() < n; j++) {\n                int x = i * (5000 / max(1, grid_size - 1));\n                int y = j * (5000 / max(1, grid_size - 1));\n                if (used.count({x, y}) == 0) {\n                    used.insert({x, y});\n                    points.push_back({x, y});\n                }\n            }\n        }\n    } else if (type == \"cluster\") {\n        // Divide towers into two clusters\n        int cluster_size = n / 2;\n        set<pair<int, int>> used;\n        // First cluster near (0, 0)\n        for (int i = 0; i < cluster_size; ) {\n            int x = rnd.next(0, 1000);\n            int y = rnd.next(0, 1000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n        // Second cluster near (5000, 5000)\n        for (int i = cluster_size; i < n; ) {\n            int x = rnd.next(4000, 5000);\n            int y = rnd.next(4000, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else if (type == \"max_fee\") {\n        // Place towers to maximize the minimal fee\n        int positions[][2] = {{0,0}, {0,5000}, {5000,0}, {5000,5000}};\n        for (int i = 0; i < min(n, 4); ++i) {\n            points.push_back({positions[i][0], positions[i][1]});\n        }\n        set<pair<int, int>> used(points.begin(), points.end());\n        // Fill the rest with random points\n        for (int i = points.size(); i < n; ) {\n            int x = rnd.next(0, 5000);\n            int y = rnd.next(0, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    } else {\n        // Default to random\n        set<pair<int, int>> used;\n        for (int i = 0; i < n; ) {\n            int x = rnd.next(0, 5000);\n            int y = rnd.next(0, 5000);\n            if (used.count({x, y}) == 0) {\n                used.insert({x, y});\n                points.push_back({x, y});\n                i++;\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto [x, y] : points) {\n        printf(\"%d %d\\n\", x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n\n./gen -n 2 -type line_horizontal\n./gen -n 3 -type line_horizontal\n./gen -n 100 -type line_horizontal\n./gen -n 5000 -type line_horizontal\n\n./gen -n 2 -type line_vertical\n./gen -n 3 -type line_vertical\n./gen -n 100 -type line_vertical\n./gen -n 5000 -type line_vertical\n\n./gen -n 2 -type diagonal\n./gen -n 3 -type diagonal\n./gen -n 100 -type diagonal\n./gen -n 5000 -type diagonal\n\n./gen -n 2 -type grid\n./gen -n 4 -type grid\n./gen -n 100 -type grid\n./gen -n 1000 -type grid\n./gen -n 5000 -type grid\n\n./gen -n 4 -type cluster\n./gen -n 100 -type cluster\n./gen -n 5000 -type cluster\n\n./gen -n 2 -type max_fee\n./gen -n 3 -type max_fee\n./gen -n 10 -type max_fee\n./gen -n 1000 -type max_fee\n./gen -n 5000 -type max_fee\n\n# Additional commands with varying n\n./gen -n 5 -type random\n./gen -n 6 -type random\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 9 -type random\n./gen -n 10 -type random\n./gen -n 4999 -type random\n\n# Commands with minimal n to test small inputs\n./gen -n 2 -type random\n./gen -n 2 -type line_horizontal\n./gen -n 2 -type line_vertical\n./gen -n 2 -type diagonal\n./gen -n 2 -type grid\n./gen -n 2 -type cluster\n./gen -n 2 -type max_fee\n\n# Commands with maximum n to test large inputs\n./gen -n 5000 -type random\n./gen -n 5000 -type line_horizontal\n./gen -n 5000 -type line_vertical\n./gen -n 5000 -type diagonal\n./gen -n 5000 -type grid\n./gen -n 5000 -type cluster\n./gen -n 5000 -type max_fee\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:17.749188",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "850/A",
      "title": "A. Five Dimensional Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 103) — the number of points.The next n lines of input contain five integers ai, bi, ci, di, ei (|ai|, |bi|, |ci|, |di|, |ei| ≤ 103)  — the coordinates of the i-th point. All points are distinct.",
      "output_spec": "OutputFirst, print a single integer k — the number of good points.Then, print k integers, each on their own line — the indices of the good points in ascending order.",
      "sample_tests": "ExamplesInputCopy60 0 0 0 01 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 00 0 0 0 1OutputCopy11InputCopy30 0 1 2 00 0 9 2 00 0 5 9 0OutputCopy0",
      "description": "A. Five Dimensional Points\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 103) — the number of points.The next n lines of input contain five integers ai, bi, ci, di, ei (|ai|, |bi|, |ci|, |di|, |ei| ≤ 103)  — the coordinates of the i-th point. All points are distinct.\n\nOutputFirst, print a single integer k — the number of good points.Then, print k integers, each on their own line — the indices of the good points in ascending order.\n\nInputCopy60 0 0 0 01 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 00 0 0 0 1OutputCopy11InputCopy30 0 1 2 00 0 9 2 00 0 5 9 0OutputCopy0\n\nInputCopy60 0 0 0 01 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 00 0 0 0 1\n\nOutputCopy11\n\nInputCopy30 0 1 2 00 0 9 2 00 0 5 9 0\n\nOutputCopy0\n\nNoteIn the first sample, the first point forms exactly a  angle with all other pairs of points, so it is good.In the second sample, along the cd plane, we can see the points look as follows:We can see that all angles here are acute, so no points are good.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 850\\s*A"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");  // Read n, 1 <= n <= 1000\n    inf.readEoln();  // Read end of line after n\n\n    set<array<int,5>> pointsSet;  // To store unique points\n\n    for (int i = 0; i < n; i++) {\n        vector<int> coord = inf.readInts(5, -1000, 1000, \"coordinate\");  // Read 5 integers per point\n        inf.readEoln();  // Read end of line after each point\n\n        array<int,5> point;\n        for (int j = 0; j < 5; j++) {\n            point[j] = coord[j];\n        }\n\n        // Ensure all points are unique\n        ensuref(pointsSet.insert(point).second, \"Point %d is not unique\", i + 1);\n    }\n\n    inf.readEof();  // Ensure there's no extra input\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");  // Read n, 1 <= n <= 1000\n    inf.readEoln();  // Read end of line after n\n\n    set<array<int,5>> pointsSet;  // To store unique points\n\n    for (int i = 0; i < n; i++) {\n        vector<int> coord = inf.readInts(5, -1000, 1000, \"coordinate\");  // Read 5 integers per point\n        inf.readEoln();  // Read end of line after each point\n\n        array<int,5> point;\n        for (int j = 0; j < 5; j++) {\n            point[j] = coord[j];\n        }\n\n        // Ensure all points are unique\n        ensuref(pointsSet.insert(point).second, \"Point %d is not unique\", i + 1);\n    }\n\n    inf.readEof();  // Ensure there's no extra input\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");  // Read n, 1 <= n <= 1000\n    inf.readEoln();  // Read end of line after n\n\n    set<array<int,5>> pointsSet;  // To store unique points\n\n    for (int i = 0; i < n; i++) {\n        vector<int> coord = inf.readInts(5, -1000, 1000, \"coordinate\");  // Read 5 integers per point\n        inf.readEoln();  // Read end of line after each point\n\n        array<int,5> point;\n        for (int j = 0; j < 5; j++) {\n            point[j] = coord[j];\n        }\n\n        // Ensure all points are unique\n        ensuref(pointsSet.insert(point).second, \"Point %d is not unique\", i + 1);\n    }\n\n    inf.readEof();  // Ensure there's no extra input\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int min_coord = -1000;\n    int max_coord = 1000;\n\n    vector<array<int,5>> points(n);\n\n    if(type == \"random_small\") {\n        // Generate small n random points\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(i > 0 && find(points.begin(), points.begin() + i, p) != points.begin() + i);\n            points[i] = p;\n        }\n    } else if(type == \"random_large\") {\n        // Generate large n random points\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"cluster\") {\n        // Generate points clustered together\n        array<int,5> center;\n        for(int j = 0; j < 5; ++j) {\n            center[j] = rnd.next(min_coord/2, max_coord/2);\n        }\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = center[j] + rnd.next(-10,10);\n                    p[j] = max(min_coord, min(max_coord, p[j]));\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"line\") {\n        // Generate points along a line in 5D space\n        array<int,5> start;\n        array<int,5> dir;\n        // Random start point and direction vector\n        for(int j = 0; j < 5; ++j) {\n            start[j] = rnd.next(min_coord/2, max_coord/2);\n            dir[j] = rnd.next(-max_coord/10, max_coord/10);\n        }\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            for(int j = 0; j < 5; ++j) {\n                p[j] = start[j] + dir[j]*i;\n                p[j] = max(min_coord, min(max_coord, p[j]));\n            }\n            if(point_set.count(vector<int>(p.begin(), p.end()))) continue;\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"plane\") {\n        // Generate points lying in a plane\n        array<int,5> base;\n        array<int,5> dir1;\n        array<int,5> dir2;\n        // Random base point and two direction vectors\n        for(int j = 0; j < 5; ++j) {\n            base[j] = rnd.next(min_coord/2, max_coord/2);\n            dir1[j] = rnd.next(-max_coord/10, max_coord/10);\n            dir2[j] = rnd.next(-max_coord/10, max_coord/10);\n        }\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(-n, n);\n            int b = rnd.next(-n, n);\n            array<int,5> p;\n            for(int j = 0; j < 5; ++j) {\n                p[j] = base[j] + dir1[j]*a + dir2[j]*b;\n                p[j] = max(min_coord, min(max_coord, p[j]));\n            }\n            if(point_set.count(vector<int>(p.begin(), p.end()))) continue;\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"all_good_small\") {\n        // Manually construct small n test case where all points are good\n        // For example, using the sample input\n        if(n > 6) n = 6;\n        points = {{ {0,0,0,0,0}, {1,0,0,0,0}, {0,1,0,0,0}, {0,0,1,0,0}, {0,0,0,1,0}, {0,0,0,0,1} }};\n    } else if (type == \"all_bad_small\") {\n        // Manually construct small n test case where all points are bad.\n        points = {{ {0,0,1,2,0}, {0,0,9,2,0}, {0,0,5,9,0} }};\n        if(n > 3) n = 3;\n    } else if (type == \"max_n_random\") {\n        // n = 1000, random points\n        n = 1000;\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"few_good\") {\n        // Generate a test case where few points are good\n        // For this, we can generate a cluster of points around the origin\n        // And some points at remote positions.\n        set<vector<int>> point_set;\n        // First, generate points close to origin\n        for(int i = 0; i < n-2; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(-10, 10);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n        // Then, add two distant points to potentially be good points\n        points[n-2] = {1000,0,0,0,0};\n        points[n-1] = {-1000,0,0,0,0};\n    } else {\n        // Default: random points\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < 5; ++j) {\n            printf(\"%d%c\", points[i][j], j==4?'\\n':' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int min_coord = -1000;\n    int max_coord = 1000;\n\n    vector<array<int,5>> points(n);\n\n    if(type == \"random_small\") {\n        // Generate small n random points\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(i > 0 && find(points.begin(), points.begin() + i, p) != points.begin() + i);\n            points[i] = p;\n        }\n    } else if(type == \"random_large\") {\n        // Generate large n random points\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"cluster\") {\n        // Generate points clustered together\n        array<int,5> center;\n        for(int j = 0; j < 5; ++j) {\n            center[j] = rnd.next(min_coord/2, max_coord/2);\n        }\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = center[j] + rnd.next(-10,10);\n                    p[j] = max(min_coord, min(max_coord, p[j]));\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"line\") {\n        // Generate points along a line in 5D space\n        array<int,5> start;\n        array<int,5> dir;\n        // Random start point and direction vector\n        for(int j = 0; j < 5; ++j) {\n            start[j] = rnd.next(min_coord/2, max_coord/2);\n            dir[j] = rnd.next(-max_coord/10, max_coord/10);\n        }\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            for(int j = 0; j < 5; ++j) {\n                p[j] = start[j] + dir[j]*i;\n                p[j] = max(min_coord, min(max_coord, p[j]));\n            }\n            if(point_set.count(vector<int>(p.begin(), p.end()))) continue;\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"plane\") {\n        // Generate points lying in a plane\n        array<int,5> base;\n        array<int,5> dir1;\n        array<int,5> dir2;\n        // Random base point and two direction vectors\n        for(int j = 0; j < 5; ++j) {\n            base[j] = rnd.next(min_coord/2, max_coord/2);\n            dir1[j] = rnd.next(-max_coord/10, max_coord/10);\n            dir2[j] = rnd.next(-max_coord/10, max_coord/10);\n        }\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(-n, n);\n            int b = rnd.next(-n, n);\n            array<int,5> p;\n            for(int j = 0; j < 5; ++j) {\n                p[j] = base[j] + dir1[j]*a + dir2[j]*b;\n                p[j] = max(min_coord, min(max_coord, p[j]));\n            }\n            if(point_set.count(vector<int>(p.begin(), p.end()))) continue;\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"all_good_small\") {\n        // Manually construct small n test case where all points are good\n        // For example, using the sample input\n        if(n > 6) n = 6;\n        points = {{ {0,0,0,0,0}, {1,0,0,0,0}, {0,1,0,0,0}, {0,0,1,0,0}, {0,0,0,1,0}, {0,0,0,0,1} }};\n    } else if (type == \"all_bad_small\") {\n        // Manually construct small n test case where all points are bad.\n        points = {{ {0,0,1,2,0}, {0,0,9,2,0}, {0,0,5,9,0} }};\n        if(n > 3) n = 3;\n    } else if (type == \"max_n_random\") {\n        // n = 1000, random points\n        n = 1000;\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    } else if (type == \"few_good\") {\n        // Generate a test case where few points are good\n        // For this, we can generate a cluster of points around the origin\n        // And some points at remote positions.\n        set<vector<int>> point_set;\n        // First, generate points close to origin\n        for(int i = 0; i < n-2; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(-10, 10);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n        // Then, add two distant points to potentially be good points\n        points[n-2] = {1000,0,0,0,0};\n        points[n-1] = {-1000,0,0,0,0};\n    } else {\n        // Default: random points\n        set<vector<int>> point_set;\n        for(int i = 0; i < n; ++i) {\n            array<int,5> p;\n            do {\n                for(int j = 0; j < 5; ++j) {\n                    p[j] = rnd.next(min_coord, max_coord);\n                }\n            } while(point_set.count(vector<int>(p.begin(), p.end())));\n            points[i] = p;\n            point_set.insert(vector<int>(p.begin(), p.end()));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < 5; ++j) {\n            printf(\"%d%c\", points[i][j], j==4?'\\n':' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random_small\n./gen -n 10 -type random_small\n./gen -n 20 -type random_small\n\n./gen -n 100 -type random_large\n./gen -n 500 -type random_large\n./gen -n 1000 -type random_large\n\n./gen -n 1000 -type max_n_random\n\n./gen -n 3 -type all_good_small\n./gen -n 6 -type all_good_small\n\n./gen -n 3 -type all_bad_small\n\n./gen -n 100 -type cluster\n./gen -n 500 -type cluster\n\n./gen -n 50 -type line\n./gen -n 100 -type line\n\n./gen -n 50 -type plane\n./gen -n 100 -type plane\n\n./gen -n 1000 -type cluster\n\n./gen -n 1000 -type few_good\n\n./gen -n 1 -type random_small\n./gen -n 1000 -type random_large\n\n./gen -n 500 -type cluster\n./gen -n 500 -type line\n./gen -n 500 -type plane\n\n./gen -n 2 -type random_small\n./gen -n 2 -type all_good_small\n\n./gen -n 10 -type few_good\n./gen -n 100 -type few_good\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:19.885280",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "850/B",
      "title": "B. Arpa and a list of numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains three integers n, x and y (1 ≤ n ≤ 5·105, 1 ≤ x, y ≤ 109) — the number of elements in the list and the integers x and y.Second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106) — the elements of the list.",
      "output_spec": "OutputPrint a single integer: the minimum possible cost to make the list good.",
      "sample_tests": "ExamplesInputCopy4 23 171 17 17 16OutputCopy40InputCopy10 6 2100 49 71 73 66 96 8 60 41 63OutputCopy10",
      "description": "B. Arpa and a list of numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line contains three integers n, x and y (1 ≤ n ≤ 5·105, 1 ≤ x, y ≤ 109) — the number of elements in the list and the integers x and y.Second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106) — the elements of the list.\n\nOutputPrint a single integer: the minimum possible cost to make the list good.\n\nInputCopy4 23 171 17 17 16OutputCopy40InputCopy10 6 2100 49 71 73 66 96 8 60 41 63OutputCopy10\n\nInputCopy4 23 171 17 17 16\n\nOutputCopy40\n\nInputCopy10 6 2100 49 71 73 66 96 8 60 41 63\n\nOutputCopy10\n\nNoteIn example, number 1 must be deleted (with cost 23) and number 16 must increased by 1 (with cost 17).A gcd (greatest common divisor) of a set of numbers is the maximum integer that divides all integers in the set. Read more about gcd here.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 850\\s*B"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = rnd.next(1, 1000000);\n    }\n}\n\nvoid generate_all_equal(int n, vector<int>& a)\n{\n    int val = rnd.next(1, 1000000);\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = val;\n    }\n}\n\nvoid generate_all_ones(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = 1;\n    }\n}\n\nvoid generate_gcd_is_1(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = rnd.next(1, 1000000);\n    }\n    if (n >= 2)\n    {\n        a[0] = rnd.next(2, 1000000);\n        a[1] = a[0] + 1;\n    }\n}\n\nvoid generate_gcd_is_not_1(int n, vector<int>& a)\n{\n    int g = rnd.next(2, 1000); // GCD between 2 and 1000\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = g * rnd.next(1, 1000);\n    }\n}\n\nvoid generate_large_numbers(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = 1000000 - rnd.next(0, 10);\n    }\n}\n\nvoid generate_powers_of_two(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        int exp = rnd.next(0, 19); // 2^0 to 2^19 is up to 524288\n        a[i] = 1 << exp;\n    }\n}\n\nvoid generate_primes(int n, vector<int>& a)\n{\n    // Sieve up to 1e6\n    const int MAXN = 1000000;\n    static vector<int> primes;\n    if (primes.empty())\n    {\n        vector<bool> is_prime(MAXN + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i * i <= MAXN; ++i)\n        {\n            if(is_prime[i])\n            {\n                for(int j = i * i; j <= MAXN; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for(int i = 2; i <= MAXN; ++i)\n            if(is_prime[i])\n                primes.push_back(i);\n    }\n    for(int i = 0; i < n; ++i)\n    {\n        int idx = rnd.next(0, (int)primes.size() -1);\n        a[i] = primes[idx];\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\")\n        generate_random(n, a);\n    else if (type == \"all_equal\")\n        generate_all_equal(n, a);\n    else if (type == \"all_ones\")\n        generate_all_ones(n, a);\n    else if (type == \"gcd_is_1\")\n        generate_gcd_is_1(n, a);\n    else if (type == \"gcd_is_not_1\")\n        generate_gcd_is_not_1(n, a);\n    else if (type == \"large_numbers\")\n        generate_large_numbers(n, a);\n    else if (type == \"powers_of_two\")\n        generate_powers_of_two(n, a);\n    else if (type == \"primes\")\n        generate_primes(n, a);\n    else\n        generate_random(n, a);\n\n    // Output n, x, y\n    printf(\"%d %d %d\\n\", n, x, y);\n    // Output a_i's\n    for(int i = 0; i < n; ++i)\n    {\n        printf(\"%d%c\", a[i], (i+1 == n ? '\\n' : ' '));\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = rnd.next(1, 1000000);\n    }\n}\n\nvoid generate_all_equal(int n, vector<int>& a)\n{\n    int val = rnd.next(1, 1000000);\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = val;\n    }\n}\n\nvoid generate_all_ones(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = 1;\n    }\n}\n\nvoid generate_gcd_is_1(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = rnd.next(1, 1000000);\n    }\n    if (n >= 2)\n    {\n        a[0] = rnd.next(2, 1000000);\n        a[1] = a[0] + 1;\n    }\n}\n\nvoid generate_gcd_is_not_1(int n, vector<int>& a)\n{\n    int g = rnd.next(2, 1000); // GCD between 2 and 1000\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = g * rnd.next(1, 1000);\n    }\n}\n\nvoid generate_large_numbers(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        a[i] = 1000000 - rnd.next(0, 10);\n    }\n}\n\nvoid generate_powers_of_two(int n, vector<int>& a)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        int exp = rnd.next(0, 19); // 2^0 to 2^19 is up to 524288\n        a[i] = 1 << exp;\n    }\n}\n\nvoid generate_primes(int n, vector<int>& a)\n{\n    // Sieve up to 1e6\n    const int MAXN = 1000000;\n    static vector<int> primes;\n    if (primes.empty())\n    {\n        vector<bool> is_prime(MAXN + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i * i <= MAXN; ++i)\n        {\n            if(is_prime[i])\n            {\n                for(int j = i * i; j <= MAXN; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for(int i = 2; i <= MAXN; ++i)\n            if(is_prime[i])\n                primes.push_back(i);\n    }\n    for(int i = 0; i < n; ++i)\n    {\n        int idx = rnd.next(0, (int)primes.size() -1);\n        a[i] = primes[idx];\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\")\n        generate_random(n, a);\n    else if (type == \"all_equal\")\n        generate_all_equal(n, a);\n    else if (type == \"all_ones\")\n        generate_all_ones(n, a);\n    else if (type == \"gcd_is_1\")\n        generate_gcd_is_1(n, a);\n    else if (type == \"gcd_is_not_1\")\n        generate_gcd_is_not_1(n, a);\n    else if (type == \"large_numbers\")\n        generate_large_numbers(n, a);\n    else if (type == \"powers_of_two\")\n        generate_powers_of_two(n, a);\n    else if (type == \"primes\")\n        generate_primes(n, a);\n    else\n        generate_random(n, a);\n\n    // Output n, x, y\n    printf(\"%d %d %d\\n\", n, x, y);\n    // Output a_i's\n    for(int i = 0; i < n; ++i)\n    {\n        printf(\"%d%c\", a[i], (i+1 == n ? '\\n' : ' '));\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -x 1 -y 1 -type random\n./gen -n 1 -x 1000000 -y 1000000 -type random\n./gen -n 2 -x 1 -y 1 -type gcd_is_1\n./gen -n 2 -x 1 -y 1 -type gcd_is_not_1\n./gen -n 10 -x 10 -y 10 -type all_ones\n./gen -n 10 -x 10 -y 1 -type all_equal\n./gen -n 100 -x 100 -y 1 -type gcd_is_1\n./gen -n 100 -x 1 -y 100 -type gcd_is_not_1\n./gen -n 1000 -x 10 -y 10 -type large_numbers\n./gen -n 1000 -x 1 -y 1000000000 -type all_ones\n./gen -n 100000 -x 1000000000 -y 1 -type random\n./gen -n 500000 -x 1 -y 1 -type powers_of_two\n./gen -n 500000 -x 1 -y 1 -type gcd_is_1\n./gen -n 500000 -x 1 -y 1000000000 -type all_ones\n./gen -n 500000 -x 1000000000 -y 1 -type large_numbers\n./gen -n 500000 -x 1 -y 1 -type gcd_is_not_1\n./gen -n 500000 -x 1000000000 -y 1000000000 -type random\n./gen -n 500000 -x 1 -y 1000000000 -type gcd_is_1\n./gen -n 500000 -x 1 -y 1000000000 -type gcd_is_not_1\n./gen -n 500000 -x 1000000000 -y 1 -type gcd_is_1\n./gen -n 500000 -x 1000000000 -y 1 -type gcd_is_not_1\n./gen -n 500000 -x 500000000 -y 500000000 -type random\n./gen -n 1 -x 1 -y 1 -type all_ones\n./gen -n 500000 -x 1000000000 -y 1000000000 -type all_equal\n./gen -n 500000 -x 1 -y 1 -type all_equal\n./gen -n 2 -x 10 -y 10 -type random\n./gen -n 10 -x 10 -y 10 -type random\n./gen -n 100 -x 10 -y 10 -type random\n./gen -n 1000 -x 10 -y 10 -type random\n./gen -n 10000 -x 10 -y 10 -type random\n./gen -n 100000 -x 10 -y 10 -type random\n./gen -n 500000 -x 1000000000 -y 1 -type primes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:21.534138",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "850/C",
      "title": "C. Arpa and a game with Mojtaba",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of elements in the list.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the list.",
      "output_spec": "OutputIf Mojtaba wins, print \"Mojtaba\", otherwise print \"Arpa\" (without quotes).You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy41 1 1 1OutputCopyArpaInputCopy41 1 17 17OutputCopyMojtabaInputCopy41 1 17 289OutputCopyArpaInputCopy51 2 3 4 5OutputCopyArpa",
      "description": "C. Arpa and a game with Mojtaba\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of elements in the list.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the list.\n\nOutputIf Mojtaba wins, print \"Mojtaba\", otherwise print \"Arpa\" (without quotes).You can print each letter in any case (upper or lower).\n\nInputCopy41 1 1 1OutputCopyArpaInputCopy41 1 17 17OutputCopyMojtabaInputCopy41 1 17 289OutputCopyArpaInputCopy51 2 3 4 5OutputCopyArpa\n\nInputCopy41 1 1 1\n\nOutputCopyArpa\n\nInputCopy41 1 17 17\n\nOutputCopyMojtaba\n\nInputCopy41 1 17 289\n\nOutputCopyArpa\n\nInputCopy51 2 3 4 5\n\nOutputCopyArpa\n\nNoteIn the first sample test, Mojtaba can't move.In the second sample test, Mojtaba chooses p = 17 and k = 1, then the list changes to [1, 1, 1, 1].In the third sample test, if Mojtaba chooses p = 17 and k = 1, then Arpa chooses p = 17 and k = 1 and wins, if Mojtaba chooses p = 17 and k = 2, then Arpa chooses p = 17 and k = 1 and wins.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 850\\s*C"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for(int d = 2; d * d <= n; ++d)\n        if (n % d == 0)\n            return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    \n    vector<long long> a(n);\n    \n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    } else if (type == \"ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"same_prime\") {\n        int p = opt<int>(\"p\", 2); // default prime is 2\n        for(int i = 0; i < n; ++i)\n            a[i] = p;\n    } else if (type == \"power_of_same_prime\") {\n        int p = opt<int>(\"p\", 2); // default prime is 2\n        vector<long long> powers;\n        long long val = p;\n        while (val <= 1e9) {\n            powers.push_back(val);\n            if (val > 1e9 / p) break;\n            val *= p;\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = powers[rnd.next(0, (int)powers.size() - 1)];\n        }\n    } else if (type == \"large_powers\") {\n        // generate numbers with large exponents\n        for(int i = 0; i < n; ++i) {\n            int p = rnd.next(2, 1000); // small primes\n            while (!is_prime(p)) p = rnd.next(2, 1000);\n            long long val = p;\n            int k = rnd.next(1, 30); // exponents up to 30\n            for(int j = 1; j < k; ++j) {\n                if (val > 1e9 / p) break;\n                val *= p;\n            }\n            a[i] = val;\n        }\n    } else if (type == \"max_ai\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = (long long)1e9;\n    } else if (type == \"composite_numbers\") {\n        for(int i = 0; i < n; ++i) {\n            int num_factors = rnd.next(2, 5);\n            long long x = 1;\n            for(int j = 0; j < num_factors; ++j) {\n                int p = rnd.next(2, 100);\n                while (!is_prime(p)) p = rnd.next(2, 100);\n                if (x > 1e9 / p) break;\n                x *= p;\n            }\n            a[i] = x;\n        }\n    } else if (type == \"square_free_numbers\") {\n        for(int i = 0; i < n; ++i) {\n            int num_factors = rnd.next(2, 5);\n            set<int> factors;\n            while ((int)factors.size() < num_factors) {\n                int p = rnd.next(2, 1000);\n                if (is_prime(p)) {\n                    factors.insert(p);\n                }\n            }\n            long long x = 1;\n            for(int p : factors) {\n                if (x > 1e9 / p) {\n                    x = 1e9;\n                    break;\n                }\n                x *= p;\n            }\n            a[i] = x;\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for(int d = 2; d * d <= n; ++d)\n        if (n % d == 0)\n            return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    \n    vector<long long> a(n);\n    \n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    } else if (type == \"ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"same_prime\") {\n        int p = opt<int>(\"p\", 2); // default prime is 2\n        for(int i = 0; i < n; ++i)\n            a[i] = p;\n    } else if (type == \"power_of_same_prime\") {\n        int p = opt<int>(\"p\", 2); // default prime is 2\n        vector<long long> powers;\n        long long val = p;\n        while (val <= 1e9) {\n            powers.push_back(val);\n            if (val > 1e9 / p) break;\n            val *= p;\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = powers[rnd.next(0, (int)powers.size() - 1)];\n        }\n    } else if (type == \"large_powers\") {\n        // generate numbers with large exponents\n        for(int i = 0; i < n; ++i) {\n            int p = rnd.next(2, 1000); // small primes\n            while (!is_prime(p)) p = rnd.next(2, 1000);\n            long long val = p;\n            int k = rnd.next(1, 30); // exponents up to 30\n            for(int j = 1; j < k; ++j) {\n                if (val > 1e9 / p) break;\n                val *= p;\n            }\n            a[i] = val;\n        }\n    } else if (type == \"max_ai\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = (long long)1e9;\n    } else if (type == \"composite_numbers\") {\n        for(int i = 0; i < n; ++i) {\n            int num_factors = rnd.next(2, 5);\n            long long x = 1;\n            for(int j = 0; j < num_factors; ++j) {\n                int p = rnd.next(2, 100);\n                while (!is_prime(p)) p = rnd.next(2, 100);\n                if (x > 1e9 / p) break;\n                x *= p;\n            }\n            a[i] = x;\n        }\n    } else if (type == \"square_free_numbers\") {\n        for(int i = 0; i < n; ++i) {\n            int num_factors = rnd.next(2, 5);\n            set<int> factors;\n            while ((int)factors.size() < num_factors) {\n                int p = rnd.next(2, 1000);\n                if (is_prime(p)) {\n                    factors.insert(p);\n                }\n            }\n            long long x = 1;\n            for(int p : factors) {\n                if (x > 1e9 / p) {\n                    x = 1e9;\n                    break;\n                }\n                x *= p;\n            }\n            a[i] = x;\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 1 -type random\n./gen -n 1 -type max_ai\n./gen -n 2 -type same_prime -p 2\n./gen -n 2 -type same_prime -p 17\n./gen -n 2 -type power_of_same_prime -p 2\n./gen -n 2 -type power_of_same_prime -p 3\n./gen -n 5 -type ones\n./gen -n 5 -type random\n./gen -n 5 -type composite_numbers\n./gen -n 10 -type random\n./gen -n 10 -type power_of_same_prime -p 2\n./gen -n 10 -type same_prime -p 7\n./gen -n 10 -type max_ai\n./gen -n 10 -type composite_numbers\n./gen -n 10 -type square_free_numbers\n./gen -n 50 -type random\n./gen -n 50 -type max_ai\n./gen -n 50 -type ones\n./gen -n 50 -type power_of_same_prime -p 2\n./gen -n 50 -type composite_numbers\n./gen -n 50 -type square_free_numbers\n./gen -n 100 -type random\n./gen -n 100 -type ones\n./gen -n 100 -type max_ai\n./gen -n 100 -type same_prime -p 2\n./gen -n 100 -type same_prime -p 17\n./gen -n 100 -type power_of_same_prime -p 2\n./gen -n 100 -type power_of_same_prime -p 3\n./gen -n 100 -type composite_numbers\n./gen -n 100 -type square_free_numbers\n./gen -n 100 -type large_powers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:23.313570",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "850/D",
      "title": "D. Tournament Construction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains a single integer m (1 ≤ m ≤ 31).The next line contains m distinct integers a1, a2, ..., am (0 ≤ ai ≤ 30) — elements of the set S. It is guaranteed that all elements of the set are distinct.",
      "output_spec": "OutputIf there are no such tournaments, print string \"=(\" (without quotes).Otherwise, print an integer n — the number of vertices in the tournament.Then print n lines with n characters — matrix of the tournament. The j-th element in the i-th row should be 1 if the edge between the i-th and the j-th vertices is oriented towards the j-th vertex, and 0 otherwise. The main diagonal should contain only zeros.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy40011100101000010InputCopy20 3OutputCopy6000111100011110001011001001101000000",
      "description": "D. Tournament Construction\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer m (1 ≤ m ≤ 31).The next line contains m distinct integers a1, a2, ..., am (0 ≤ ai ≤ 30) — elements of the set S. It is guaranteed that all elements of the set are distinct.\n\nOutputIf there are no such tournaments, print string \"=(\" (without quotes).Otherwise, print an integer n — the number of vertices in the tournament.Then print n lines with n characters — matrix of the tournament. The j-th element in the i-th row should be 1 if the edge between the i-th and the j-th vertices is oriented towards the j-th vertex, and 0 otherwise. The main diagonal should contain only zeros.\n\nInputCopy21 2OutputCopy40011100101000010InputCopy20 3OutputCopy6000111100011110001011001001101000000\n\nInputCopy21 2\n\nOutputCopy40011100101000010\n\nInputCopy20 3\n\nOutputCopy6000111100011110001011001001101000000",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 850\\s*D"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 31, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 0, 30, \"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == m, \"All elements of S must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 31, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 0, 30, \"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == m, \"All elements of S must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 31, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 0, 30, \"a_i\");\n    inf.readEoln();\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == m, \"All elements of S must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// This function reads the answer from the stream,\n// checks its correctness, and returns n.\n// If the answer is \"=(\" (no solution), returns -1.\nint readAns(InStream &stream, set<int> &scores) {\n    if (stream.seekEof()) {\n        stream.quitf(_pe, \"Empty output\");\n    }\n    string firstToken = stream.readToken();\n    if (firstToken == \"=(\") {\n        return -1;\n    }\n    // Try to parse firstToken as integer n\n    long long n;\n    if (!(istringstream(firstToken) >> n)) {\n        stream.quitf(_pe, \"Expected integer n or '=(', but found '%s'\", firstToken.c_str());\n    }\n    if (n < 1 || n > 1000) {\n        stream.quitf(_pe, \"Invalid n: %lld\", n);\n    }\n    int N = int(n);\n\n    // Read adjacency matrix\n    vector<vector<int>> adjMat(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        if (stream.seekEof()) {\n            stream.quitf(_pe, \"Expected %d lines of adjacency matrix, but found EOF at line %d\", N, i + 1);\n        }\n        string s = stream.readLine();\n        if ((int)s.size() != N) {\n            stream.quitf(_pe, \"Expected line %d of length %d, but got length %d\", i + 1, N, (int)s.size());\n        }\n        for (int j = 0; j < N; j++) {\n            if (s[j] != '0' && s[j] != '1') {\n                stream.quitf(_pe, \"Invalid character '%c' at line %d position %d, expected '0' or '1'\", s[j], i + 1, j + 1);\n            }\n            adjMat[i][j] = s[j] - '0';\n        }\n    }\n\n    // Validate adjacency matrix\n    for (int i = 0; i < N; i++) {\n        if (adjMat[i][i] != 0) {\n            stream.quitf(_wa, \"Diagonal element at (%d,%d) is not 0\", i + 1, i + 1);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int sum = adjMat[i][j] + adjMat[j][i];\n            if (sum != 1) {\n                stream.quitf(_wa, \"Invalid adjacency between vertices %d and %d\", i + 1, j + 1);\n            }\n        }\n    }\n\n    // Compute scores (out-degrees)\n    vector<int> out_deg(N);\n    for (int i = 0; i < N; i++) {\n        int deg = 0;\n        for (int j = 0; j < N; j++) {\n            deg += adjMat[i][j];\n        }\n        out_deg[i] = deg;\n    }\n\n    // Collect set of scores (after deduplication)\n    scores = set<int>(out_deg.begin(), out_deg.end());\n\n    return N;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read m and S from the input file\n    int m = inf.readInt();\n    set<int> S;\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt();\n        S.insert(a);\n    }\n\n    // Read jury's answer\n    set<int> scores_jury;\n    int ans_n = readAns(ans, scores_jury);\n\n    // Read contestant's answer\n    set<int> scores_contestant;\n    int ouf_n = readAns(ouf, scores_contestant);\n\n    // Compare jury's and contestant's outputs\n    if (ans_n == -1) {\n        // Jury says no solution\n        if (ouf_n == -1) {\n            // Contestant also says no solution\n            quitf(_ok, \"No solution exists and contestant correctly reported it.\");\n        } else {\n            // Contestant found a solution\n            quitf(_fail, \"Participant found a solution, but jury says no solution exists.\");\n        }\n    } else {\n        // Jury says solution exists\n        if (ouf_n == -1) {\n            // Contestant says no solution\n            quitf(_wa, \"Contestant failed to find a solution, but a solution exists.\");\n        } else {\n            // Both outputs are solutions\n            if (ouf_n > ans_n) {\n                quitf(_wa, \"Contestant's n=%d is greater than minimal n=%d\", ouf_n, ans_n);\n            } else if (ouf_n == ans_n) {\n                // Compare scores\n                if (scores_contestant != S) {\n                    quitf(_wa, \"Contestant's set of scores doesn't match the required set.\");\n                } else {\n                    quitf(_ok, \"Solution is correct with n=%d\", ouf_n);\n                }\n            } else {\n                // Contestant found a better solution\n                quitf(_fail, \"Participant found better solution with n=%d, jury's n=%d\", ouf_n, ans_n);\n            }\n        }\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    ensure(1 <= m && m <= 31);\n\n    vector<int> S;\n\n    if (type == \"min\") {\n        // All ai are 0\n        for (int i = 0; i < m; ++i) {\n            S.push_back(0);\n        }\n    } else if (type == \"max\") {\n        // All ai are 30\n        for (int i = 0; i < m; ++i) {\n            S.push_back(30);\n        }\n    } else if (type == \"ascending\") {\n        // ai from 0 upwards, wrapping around at 30\n        int val = 0;\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            s.insert(val++);\n            if (val > 30) val = 0;\n        }\n        S.assign(s.begin(), s.end());\n    } else if (type == \"descending\") {\n        // ai from 30 downwards, wrapping around at 0\n        int val = 30;\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            s.insert(val--);\n            if (val < 0) val = 30;\n        }\n        S.assign(s.begin(), s.end());\n    } else if (type == \"random\") {\n        // Random ai between 0 and 30\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            int ai = rnd.next(0, 30);\n            s.insert(ai);\n        }\n        S.assign(s.begin(), s.end());\n        shuffle(S.begin(), S.end());\n    } else if (type == \"impossible\") {\n        // Generate an impossible set S\n        // For example, degrees that cannot sum to n(n-1)/2\n        if (m >= 3) {\n            S = {0, 0, (m * (m - 1)) / 2}; // Sum too large\n        } else {\n            S = {0, m * (m -1)}; // Sum too large\n        }\n        S.resize(m, 0); // Fill the rest with zeros\n    } else {\n        // Default is random\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            int ai = rnd.next(0, 30);\n            s.insert(ai);\n        }\n        S.assign(s.begin(), s.end());\n        shuffle(S.begin(), S.end());\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output ai\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", S[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    ensure(1 <= m && m <= 31);\n\n    vector<int> S;\n\n    if (type == \"min\") {\n        // All ai are 0\n        for (int i = 0; i < m; ++i) {\n            S.push_back(0);\n        }\n    } else if (type == \"max\") {\n        // All ai are 30\n        for (int i = 0; i < m; ++i) {\n            S.push_back(30);\n        }\n    } else if (type == \"ascending\") {\n        // ai from 0 upwards, wrapping around at 30\n        int val = 0;\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            s.insert(val++);\n            if (val > 30) val = 0;\n        }\n        S.assign(s.begin(), s.end());\n    } else if (type == \"descending\") {\n        // ai from 30 downwards, wrapping around at 0\n        int val = 30;\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            s.insert(val--);\n            if (val < 0) val = 30;\n        }\n        S.assign(s.begin(), s.end());\n    } else if (type == \"random\") {\n        // Random ai between 0 and 30\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            int ai = rnd.next(0, 30);\n            s.insert(ai);\n        }\n        S.assign(s.begin(), s.end());\n        shuffle(S.begin(), S.end());\n    } else if (type == \"impossible\") {\n        // Generate an impossible set S\n        // For example, degrees that cannot sum to n(n-1)/2\n        if (m >= 3) {\n            S = {0, 0, (m * (m - 1)) / 2}; // Sum too large\n        } else {\n            S = {0, m * (m -1)}; // Sum too large\n        }\n        S.resize(m, 0); // Fill the rest with zeros\n    } else {\n        // Default is random\n        set<int> s;\n        while (s.size() < (size_t)m) {\n            int ai = rnd.next(0, 30);\n            s.insert(ai);\n        }\n        S.assign(s.begin(), s.end());\n        shuffle(S.begin(), S.end());\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output ai\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", S[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal m, minimal ai\n./gen -m 1 -type min\n\n# Maximal m, minimal ai\n./gen -m 31 -type min\n\n# Minimal m, maximal ai\n./gen -m 1 -type max\n\n# Maximal m, maximal ai\n./gen -m 31 -type max\n\n# m from small to large, type random\n./gen -m 1 -type random\n./gen -m 2 -type random\n./gen -m 3 -type random\n./gen -m 4 -type random\n./gen -m 5 -type random\n./gen -m 10 -type random\n./gen -m 15 -type random\n./gen -m 20 -type random\n./gen -m 25 -type random\n./gen -m 30 -type random\n./gen -m 31 -type random\n\n# Type ascending\n./gen -m 3 -type ascending\n./gen -m 5 -type ascending\n./gen -m 10 -type ascending\n./gen -m 15 -type ascending\n./gen -m 31 -type ascending\n\n# Type descending\n./gen -m 3 -type descending\n./gen -m 5 -type descending\n./gen -m 10 -type descending\n./gen -m 15 -type descending\n./gen -m 31 -type descending\n\n# Type impossible (should produce cases where the answer is \"=(\")\n./gen -m 2 -type impossible\n./gen -m 3 -type impossible\n./gen -m 5 -type impossible\n./gen -m 10 -type impossible\n./gen -m 31 -type impossible\n\n# Type default (random)\n./gen -m 5\n./gen -m 10\n./gen -m 15\n./gen -m 31\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:25.221013",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "850/E",
      "title": "E. Random Elections",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test1024 megabytes",
      "input_spec": "InputThe first line contains one integer n (1 ≤ n ≤ 20).The next line contains a string of length 2n of zeros and ones, representing function f. Let bk(x) the k-th bit in binary representation of x, i-th (0-based) digit of this string shows the return value of f(b1(i), b2(i), ..., bn(i)).It is guaranteed that f(1 - x1, 1 - x2, ..., 1 - xn) = 1 - f(x1, x2, ..., xn) for any values of x1, x2, ldots, xn.",
      "output_spec": "OutputOutput one integer — answer to the problem.",
      "sample_tests": "ExamplesInputCopy301010101OutputCopy216InputCopy301101001OutputCopy168",
      "description": "E. Random Elections\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test1024 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer n (1 ≤ n ≤ 20).The next line contains a string of length 2n of zeros and ones, representing function f. Let bk(x) the k-th bit in binary representation of x, i-th (0-based) digit of this string shows the return value of f(b1(i), b2(i), ..., bn(i)).It is guaranteed that f(1 - x1, 1 - x2, ..., 1 - xn) = 1 - f(x1, x2, ..., xn) for any values of x1, x2, ldots, xn.\n\nOutputOutput one integer — answer to the problem.\n\nInputCopy301010101OutputCopy216InputCopy301101001OutputCopy168\n\nInputCopy301010101\n\nOutputCopy216\n\nInputCopy301101001\n\nOutputCopy168\n\nNoteIn first sample, result is always fully determined by the first voter. In other words, f(x1, x2, x3) = x1. Thus, any no matter what happens, there will be a candidate who won two rounds (more specifically, the candidate who is at the top of voter 1's preference list), so p = 1, and we print 1·63 = 216.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 850\\s*E"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n\n    // Read s, a string of length 2^n, containing '0's and '1's\n    long long m = 1LL << n;\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    // Check that f(1 - x) = 1 - f(x) for all x in [0, m - 1]\n    for (long long x = 0; x < m; ++x) {\n        long long x_compl = x ^ (m - 1);\n        int f_x = s[x] - '0';\n        int f_x_compl = s[x_compl] - '0';\n        ensuref(f_x_compl + f_x == 1, \"Function f does not satisfy f(1 - x) = 1 - f(x) at x = %lld\", x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n\n    // Read s, a string of length 2^n, containing '0's and '1's\n    long long m = 1LL << n;\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    // Check that f(1 - x) = 1 - f(x) for all x in [0, m - 1]\n    for (long long x = 0; x < m; ++x) {\n        long long x_compl = x ^ (m - 1);\n        int f_x = s[x] - '0';\n        int f_x_compl = s[x_compl] - '0';\n        ensuref(f_x_compl + f_x == 1, \"Function f does not satisfy f(1 - x) = 1 - f(x) at x = %lld\", x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readEoln();\n\n    // Read s, a string of length 2^n, containing '0's and '1's\n    long long m = 1LL << n;\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    // Check that f(1 - x) = 1 - f(x) for all x in [0, m - 1]\n    for (long long x = 0; x < m; ++x) {\n        long long x_compl = x ^ (m - 1);\n        int f_x = s[x] - '0';\n        int f_x_compl = s[x_compl] - '0';\n        ensuref(f_x_compl + f_x == 1, \"Function f does not satisfy f(1 - x) = 1 - f(x) at x = %lld\", x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int l = 1 << n; // l = 2^n\n\n    vector<int> f(l); // f[0..l-1]\n\n    if (type == \"random\") {\n\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = rnd.next(2); // 0 or 1\n            f[l - 1 - k] = 1 - f[k];\n        }\n    } else if (type == \"firstbit\") {\n        for (int k = 0; k < l; ++k) {\n            f[k] = k & 1; // least significant bit\n        }\n    } else if (type == \"mod2\") {\n        for (int k = 0; k < l; ++k) {\n            f[k] = (k % 2);\n        }\n    } else if (type == \"allzero\") {\n        // Cannot set f(x) = 0 for all x, so adjust to satisfy the property\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = 0;\n            f[l - 1 - k] = 1 - f[k]; // So f[l -1 - k] = 1\n        }\n    } else if (type == \"allone\") {\n        // Cannot set f(x) = 1 for all x, so adjust to satisfy the property\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = 1;\n            f[l - 1 - k] = 1 - f[k]; // So f[l -1 - k] = 0\n        }\n    } else {\n        // Default to random if unrecognized type\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = rnd.next(2); // 0 or 1\n            f[l - 1 - k] = 1 - f[k];\n        }\n    }\n\n    // Output n\n    cout << n << '\\n';\n\n    // Output the string representing f\n    for (int k = 0; k < l; ++k) {\n        cout << f[k];\n    }\n    cout << '\\n';\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int l = 1 << n; // l = 2^n\n\n    vector<int> f(l); // f[0..l-1]\n\n    if (type == \"random\") {\n\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = rnd.next(2); // 0 or 1\n            f[l - 1 - k] = 1 - f[k];\n        }\n    } else if (type == \"firstbit\") {\n        for (int k = 0; k < l; ++k) {\n            f[k] = k & 1; // least significant bit\n        }\n    } else if (type == \"mod2\") {\n        for (int k = 0; k < l; ++k) {\n            f[k] = (k % 2);\n        }\n    } else if (type == \"allzero\") {\n        // Cannot set f(x) = 0 for all x, so adjust to satisfy the property\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = 0;\n            f[l - 1 - k] = 1 - f[k]; // So f[l -1 - k] = 1\n        }\n    } else if (type == \"allone\") {\n        // Cannot set f(x) = 1 for all x, so adjust to satisfy the property\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = 1;\n            f[l - 1 - k] = 1 - f[k]; // So f[l -1 - k] = 0\n        }\n    } else {\n        // Default to random if unrecognized type\n        for (int k = 0; k < l / 2; ++k) {\n            f[k] = rnd.next(2); // 0 or 1\n            f[l - 1 - k] = 1 - f[k];\n        }\n    }\n\n    // Output n\n    cout << n << '\\n';\n\n    // Output the string representing f\n    for (int k = 0; k < l; ++k) {\n        cout << f[k];\n    }\n    cout << '\\n';\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type firstbit\n./gen -n 1 -type random\n./gen -n 1 -type mod2\n\n./gen -n 2 -type firstbit\n./gen -n 2 -type random\n./gen -n 2 -type allzero\n./gen -n 2 -type allone\n\n./gen -n 3 -type firstbit\n./gen -n 3 -type random\n\n./gen -n 4 -type firstbit\n./gen -n 4 -type random\n\n./gen -n 5 -type firstbit\n./gen -n 5 -type random\n\n./gen -n 10 -type firstbit\n./gen -n 10 -type random\n\n./gen -n 15 -type firstbit\n./gen -n 15 -type random\n\n./gen -n 20 -type firstbit\n./gen -n 20 -type random\n./gen -n 20 -type random\n./gen -n 20 -type random\n\n./gen -n 5 -type unknown\n\n./gen -n 10 -type mod2\n./gen -n 15 -type mod2\n./gen -n 20 -type mod2\n\n./gen -n 10 -type allzero\n./gen -n 10 -type allone\n\n./gen -n 20 -type allzero\n./gen -n 20 -type allone\n\n./gen -n 17 -type random\n./gen -n 6 -type firstbit\n./gen -n 8 -type random\n\n./gen -n 12 -type firstbit\n./gen -n 12 -type mod2\n./gen -n 12 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:27.352287",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "850/F",
      "title": "F. Rainbow Balls",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain a single integer n (1 ≤ n ≤ 2 500) — the number of colors.The next line of input will contain n space separated integers a1, a2, ..., an (1 ≤ ai ≤ 105) — the number of balls of each color.",
      "output_spec": "OutputPrint a single integer, the answer to the problem.",
      "sample_tests": "ExamplesInputCopy21 1OutputCopy1InputCopy31 2 3OutputCopy750000026",
      "description": "F. Rainbow Balls\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will contain a single integer n (1 ≤ n ≤ 2 500) — the number of colors.The next line of input will contain n space separated integers a1, a2, ..., an (1 ≤ ai ≤ 105) — the number of balls of each color.\n\nOutputPrint a single integer, the answer to the problem.\n\nInputCopy21 1OutputCopy1InputCopy31 2 3OutputCopy750000026\n\nInputCopy21 1\n\nOutputCopy1\n\nInputCopy31 2 3\n\nOutputCopy750000026\n\nNoteIn the first sample, no matter what happens, the balls will become the same color after one step.For the second sample, we have 6 balls. Let’s label the balls from 1 to 6, and without loss of generality, let’s say balls 1,2,3 are initially color 1, balls 4,5 are color 2, and ball 6 are color 3.Here is an example of how these steps can go:   We choose ball 5 and ball 6. Ball 6 then becomes color 2.  We choose ball 4 and ball 5. Ball 5 remains the same color (color 2).  We choose ball 1 and ball 5. Ball 5 becomes color 1.  We choose ball 6 and ball 5. Ball 5 becomes color 2.  We choose ball 3 and ball 4. Ball 4 becomes color 1.  We choose ball 4 and ball 6. Ball 6 becomes color 1.  We choose ball 2 and ball 5. Ball 5 becomes color 1.  At this point, the game ends since all the balls are the same color. This particular sequence took 7 seconds.It can be shown that the answer to this case is .",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 850\\s*F"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2500, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2500, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2500, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a.push_back(rnd.next(1, 100000));\n        }\n    }\n    else if (type == \"equal\") {\n        int ai = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(ai);\n        }\n    }\n    else if (type == \"one_large\") {\n        a.resize(n, 1);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 100000;\n    }\n    else if (type == \"max_ai\") {\n        a.resize(n, 100000);\n    }\n    else if (type == \"min_ai\") {\n        a.resize(n, 1);\n    }\n    else if (type == \"single_color\") {\n        n = 1;\n        a.push_back(rnd.next(1, 100000));\n    }\n    else if (type == \"max_n\") {\n        n = 2500;\n        for (int i = 0; i < n; ++i) {\n            a.push_back(rnd.next(1, 100000));\n        }\n    }\n    else if (type == \"max_n_max_ai\") {\n        n = 2500;\n        a.resize(n, 100000);\n    }\n    else if (type == \"max_n_min_ai\") {\n        n = 2500;\n        a.resize(n, 1);\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a.push_back(rnd.next(1, 100000));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a.push_back(rnd.next(1, 100000));\n        }\n    }\n    else if (type == \"equal\") {\n        int ai = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(ai);\n        }\n    }\n    else if (type == \"one_large\") {\n        a.resize(n, 1);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 100000;\n    }\n    else if (type == \"max_ai\") {\n        a.resize(n, 100000);\n    }\n    else if (type == \"min_ai\") {\n        a.resize(n, 1);\n    }\n    else if (type == \"single_color\") {\n        n = 1;\n        a.push_back(rnd.next(1, 100000));\n    }\n    else if (type == \"max_n\") {\n        n = 2500;\n        for (int i = 0; i < n; ++i) {\n            a.push_back(rnd.next(1, 100000));\n        }\n    }\n    else if (type == \"max_n_max_ai\") {\n        n = 2500;\n        a.resize(n, 100000);\n    }\n    else if (type == \"max_n_min_ai\") {\n        n = 2500;\n        a.resize(n, 1);\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a.push_back(rnd.next(1, 100000));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_color\n./gen -n 2 -type min_ai\n./gen -n 2 -type max_ai\n./gen -n 2 -type one_large\n./gen -n 2 -type random\n\n./gen -n 5 -type random\n./gen -n 5 -type equal\n./gen -n 5 -type one_large\n\n./gen -n 50 -type min_ai\n./gen -n 50 -type max_ai\n./gen -n 50 -type random\n./gen -n 50 -type equal\n\n./gen -n 100 -type min_ai\n./gen -n 100 -type max_ai\n./gen -n 100 -type random\n./gen -n 100 -type equal\n\n./gen -n 2500 -type min_ai\n./gen -n 2500 -type max_ai\n./gen -n 2500 -type random\n./gen -n 2500 -type equal\n./gen -n 2500 -type one_large\n./gen -n 2500 -type max_n_min_ai\n./gen -n 2500 -type max_n_max_ai\n./gen -n 2500 -type one_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:28.965594",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "851/A",
      "title": "A. Arpa and a research in Mexican wave",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, k, t (1 ≤ n ≤ 109, 1 ≤ k ≤ n, 1 ≤ t < n + k).",
      "output_spec": "OutputPrint single integer: how many spectators are standing at time t.",
      "sample_tests": "ExamplesInputCopy10 5 3OutputCopy3InputCopy10 5 7OutputCopy5InputCopy10 5 12OutputCopy3",
      "description": "A. Arpa and a research in Mexican wave\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, k, t (1 ≤ n ≤ 109, 1 ≤ k ≤ n, 1 ≤ t < n + k).\n\nOutputPrint single integer: how many spectators are standing at time t.\n\nInputCopy10 5 3OutputCopy3InputCopy10 5 7OutputCopy5InputCopy10 5 12OutputCopy3\n\nInputCopy10 5 3\n\nOutputCopy3\n\nInputCopy10 5 7\n\nOutputCopy5\n\nInputCopy10 5 12\n\nOutputCopy3\n\nNoteIn the following a sitting spectator is represented as -, a standing spectator is represented as ^.  At t = 0  ----------  number of standing spectators = 0.  At t = 1  ^---------  number of standing spectators = 1.  At t = 2  ^^--------  number of standing spectators = 2.  At t = 3  ^^^-------  number of standing spectators = 3.  At t = 4  ^^^^------  number of standing spectators = 4.  At t = 5  ^^^^^-----  number of standing spectators = 5.  At t = 6  -^^^^^----  number of standing spectators = 5.  At t = 7  --^^^^^---  number of standing spectators = 5.  At t = 8  ---^^^^^--  number of standing spectators = 5.  At t = 9  ----^^^^^-  number of standing spectators = 5.  At t = 10 -----^^^^^  number of standing spectators = 5.  At t = 11 ------^^^^  number of standing spectators = 4.  At t = 12 -------^^^  number of standing spectators = 3.  At t = 13 --------^^  number of standing spectators = 2.  At t = 14 ---------^  number of standing spectators = 1.  At t = 15 ----------  number of standing spectators = 0.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 851\\s*A"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int t = inf.readInt(1, n + k - 1, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int t = inf.readInt(1, n + k - 1, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int t = inf.readInt(1, n + k - 1, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    long long t = opt<long long>(\"t\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        k = 1;\n        t = 1;\n    } else if (type == \"max\") {\n        n = 1000000000LL;\n        k = n;\n        t = n + k - 1;\n    } else if (type == \"k1\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        k = 1;\n        t = rnd.next(1LL, n + k - 1);\n    } else if (type == \"kn\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        k = n;\n        t = rnd.next(1LL, n + k - 1);\n    } else if (type == \"t1\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = 1;\n    } else if (type == \"tmax\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = n + k - 1;\n    } else if (type == \"tk\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = k;\n    } else if (type == \"tn\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = n;\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = rnd.next(1LL, n);\n        t = rnd.next(1LL, n + k - 1);\n    } else {\n        // Default to random values if type is unrecognized\n        n = rnd.next(1LL, 1000000000LL);\n        k = rnd.next(1LL, n);\n        t = rnd.next(1LL, n + k - 1);\n    }\n\n    // If n, k, t are not set, assign random values within constraints\n    if (n == -1) n = rnd.next(1LL, 1000000000LL);\n    if (k == -1) k = rnd.next(1LL, n);\n    if (t == -1) t = rnd.next(1LL, n + k - 1);\n\n    // Validate inputs according to problem constraints\n    ensure(1LL <= n && n <= 1000000000LL);\n    ensure(1LL <= k && k <= n);\n    ensure(1LL <= t && t <= n + k - 1);\n\n    // Output n, k, t\n    printf(\"%lld %lld %lld\\n\", n, k, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    long long t = opt<long long>(\"t\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        k = 1;\n        t = 1;\n    } else if (type == \"max\") {\n        n = 1000000000LL;\n        k = n;\n        t = n + k - 1;\n    } else if (type == \"k1\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        k = 1;\n        t = rnd.next(1LL, n + k - 1);\n    } else if (type == \"kn\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        k = n;\n        t = rnd.next(1LL, n + k - 1);\n    } else if (type == \"t1\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = 1;\n    } else if (type == \"tmax\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = n + k - 1;\n    } else if (type == \"tk\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = k;\n    } else if (type == \"tn\") {\n        if (n == -1) n = rnd.next(1LL, 1000000000LL);\n        if (k == -1) k = rnd.next(1LL, n);\n        t = n;\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = rnd.next(1LL, n);\n        t = rnd.next(1LL, n + k - 1);\n    } else {\n        // Default to random values if type is unrecognized\n        n = rnd.next(1LL, 1000000000LL);\n        k = rnd.next(1LL, n);\n        t = rnd.next(1LL, n + k - 1);\n    }\n\n    // If n, k, t are not set, assign random values within constraints\n    if (n == -1) n = rnd.next(1LL, 1000000000LL);\n    if (k == -1) k = rnd.next(1LL, n);\n    if (t == -1) t = rnd.next(1LL, n + k - 1);\n\n    // Validate inputs according to problem constraints\n    ensure(1LL <= n && n <= 1000000000LL);\n    ensure(1LL <= k && k <= n);\n    ensure(1LL <= t && t <= n + k - 1);\n\n    // Output n, k, t\n    printf(\"%lld %lld %lld\\n\", n, k, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test case\n./gen -type min\n\n# Maximal test case\n./gen -type max\n\n# Test case with k = 1\n./gen -type k1\n\n# Test case with k = n\n./gen -type kn\n\n# Test case with t = 1\n./gen -type t1\n\n# Test case with t = n + k - 1\n./gen -type tmax\n\n# Test case with t = k\n./gen -type tk\n\n# Test case with t = n\n./gen -type tn\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Specific test cases with set values\n./gen -n 1 -k 1 -t 1\n./gen -n 1000000000 -k 1 -t 1\n./gen -n 1000000000 -k 1000000000 -t 1999999999\n./gen -n 1000000000 -k 500000000 -t 1500000000\n./gen -n 1000000 -k 1000000 -t 2000000\n\n# Edge cases\n./gen -n 2 -k 1 -t 1\n./gen -n 2 -k 2 -t 3\n./gen -n 2 -k 2 -t 1\n./gen -n 1 -k 1 -t 1\n./gen -n 1 -k 1 -t 2\n\n# Large n, k, and t near their limits\n./gen -n 999999999 -k 999999999 -t 1999999997\n\n# Random test cases with large n\n./gen -n 1000000000 -k 999999999 -t 1500000000\n./gen -n 1000000000 -k 500000000 -t 1200000000\n\n# Random test cases without specifying any options\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:31.269785",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "851/B",
      "title": "B. Arpa and an exam about geometry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains six integers ax, ay, bx, by, cx, cy (|ax|, |ay|, |bx|, |by|, |cx|, |cy| ≤ 109). It's guaranteed that the points are distinct.",
      "output_spec": "OutputPrint \"Yes\" if the problem has a solution, \"No\" otherwise.You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy0 1 1 1 1 0OutputCopyYesInputCopy1 1 0 0 1000 1000OutputCopyNo",
      "description": "B. Arpa and an exam about geometry\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains six integers ax, ay, bx, by, cx, cy (|ax|, |ay|, |bx|, |by|, |cx|, |cy| ≤ 109). It's guaranteed that the points are distinct.\n\nOutputPrint \"Yes\" if the problem has a solution, \"No\" otherwise.You can print each letter in any case (upper or lower).\n\nInputCopy0 1 1 1 1 0OutputCopyYesInputCopy1 1 0 0 1000 1000OutputCopyNo\n\nInputCopy0 1 1 1 1 0\n\nOutputCopyYes\n\nInputCopy1 1 0 0 1000 1000\n\nOutputCopyNo\n\nNoteIn the first sample test, rotate the page around (0.5, 0.5) by .In the second sample test, you can't find any solution.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 851\\s*B"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int ax = inf.readInt(-1000000000, 1000000000, \"ax\");\n    inf.readSpace();\n    int ay = inf.readInt(-1000000000, 1000000000, \"ay\");\n    inf.readSpace();\n    int bx = inf.readInt(-1000000000, 1000000000, \"bx\");\n    inf.readSpace();\n    int by = inf.readInt(-1000000000, 1000000000, \"by\");\n    inf.readSpace();\n    int cx = inf.readInt(-1000000000, 1000000000, \"cx\");\n    inf.readSpace();\n    int cy = inf.readInt(-1000000000, 1000000000, \"cy\");\n    inf.readEoln();\n\n    pair<int, int> a = make_pair(ax, ay);\n    pair<int, int> b = make_pair(bx, by);\n    pair<int, int> c = make_pair(cx, cy);\n\n    ensuref(a != b, \"Points a and b must be distinct\");\n    ensuref(b != c, \"Points b and c must be distinct\");\n    ensuref(a != c, \"Points a and c must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int ax = inf.readInt(-1000000000, 1000000000, \"ax\");\n    inf.readSpace();\n    int ay = inf.readInt(-1000000000, 1000000000, \"ay\");\n    inf.readSpace();\n    int bx = inf.readInt(-1000000000, 1000000000, \"bx\");\n    inf.readSpace();\n    int by = inf.readInt(-1000000000, 1000000000, \"by\");\n    inf.readSpace();\n    int cx = inf.readInt(-1000000000, 1000000000, \"cx\");\n    inf.readSpace();\n    int cy = inf.readInt(-1000000000, 1000000000, \"cy\");\n    inf.readEoln();\n\n    pair<int, int> a = make_pair(ax, ay);\n    pair<int, int> b = make_pair(bx, by);\n    pair<int, int> c = make_pair(cx, cy);\n\n    ensuref(a != b, \"Points a and b must be distinct\");\n    ensuref(b != c, \"Points b and c must be distinct\");\n    ensuref(a != c, \"Points a and c must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int ax = inf.readInt(-1000000000, 1000000000, \"ax\");\n    inf.readSpace();\n    int ay = inf.readInt(-1000000000, 1000000000, \"ay\");\n    inf.readSpace();\n    int bx = inf.readInt(-1000000000, 1000000000, \"bx\");\n    inf.readSpace();\n    int by = inf.readInt(-1000000000, 1000000000, \"by\");\n    inf.readSpace();\n    int cx = inf.readInt(-1000000000, 1000000000, \"cx\");\n    inf.readSpace();\n    int cy = inf.readInt(-1000000000, 1000000000, \"cy\");\n    inf.readEoln();\n\n    pair<int, int> a = make_pair(ax, ay);\n    pair<int, int> b = make_pair(bx, by);\n    pair<int, int> c = make_pair(cx, cy);\n\n    ensuref(a != b, \"Points a and b must be distinct\");\n    ensuref(b != c, \"Points b and c must be distinct\");\n    ensuref(a != c, \"Points a and c must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int maxc = opt<int>(\"maxc\", 1000000000);\n\n    if (type == \"equally_spaced\") {\n        // Generate center O\n        int ox = rnd.next(-maxc, maxc);\n        int oy = rnd.next(-maxc, maxc);\n\n        int maxr = min({maxc - abs(ox), maxc - abs(oy)});\n        maxr = min(maxr, 1000000); // Limit r to prevent overflow\n        int r = rnd.next(1, maxr);\n\n        // Angles at 0°, 120°, 240°\n        vector<double> angles = {0.0, 2.0 * M_PI / 3.0, 4.0 * M_PI / 3.0};\n\n        vector<pair<int, int>> points;\n        for (int i = 0; i < 3; ++i) {\n            double theta = angles[i];\n            double x = ox + r * cos(theta);\n            double y = oy + r * sin(theta);\n            int xi = round(x);\n            int yi = round(y);\n            points.push_back(make_pair(xi, yi));\n        }\n\n        // Ensure points are distinct\n        set<pair<int, int>> point_set(points.begin(), points.end());\n        if (point_set.size() != 3) {\n            // Adjust r slightly to get distinct points\n            r += 1;\n            points.clear();\n            for (int i = 0; i < 3; ++i) {\n                double theta = angles[i];\n                double x = ox + r * cos(theta);\n                double y = oy + r * sin(theta);\n                int xi = round(x);\n                int yi = round(y);\n                points.push_back(make_pair(xi, yi));\n            }\n        }\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    } else if (type == \"circle_unequal_angles\") {\n        // Generate center O\n        int ox = rnd.next(-maxc, maxc);\n        int oy = rnd.next(-maxc, maxc);\n\n        int maxr = min({maxc - abs(ox), maxc - abs(oy)});\n        maxr = min(maxr, 1000000); // Limit r to prevent overflow\n        int r = rnd.next(1, maxr);\n\n        // Generate three random angles, not equally spaced\n        double theta0 = rnd.next(0.0, 2 * M_PI);\n        double delta1 = rnd.next(0.1, M_PI); // Ensure minimum difference\n        double delta2 = rnd.next(0.1, M_PI);\n\n        vector<double> thetas = {theta0, theta0 + delta1, theta0 + delta1 + delta2};\n\n        vector<pair<int, int>> points;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < 3; ++i) {\n            double angle = thetas[i];\n            double x = ox + r * cos(angle);\n            double y = oy + r * sin(angle);\n            int xi = round(x);\n            int yi = round(y);\n            point_set.insert({xi, yi});\n            points.push_back(make_pair(xi, yi));\n        }\n\n        // Ensure points are distinct\n        if (point_set.size() != 3) {\n            // Try again with different angles\n            return main(argc, argv);\n        }\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    } else if (type == \"colinear\") {\n        // Generate two random points\n        int x1 = rnd.next(-maxc, maxc);\n        int y1 = rnd.next(-maxc, maxc);\n\n        int x2 = rnd.next(-maxc, maxc);\n        int y2 = rnd.next(-maxc, maxc);\n\n        // Ensure x1 != x2 to define slope m\n        while (x1 == x2) x2 = rnd.next(-maxc, maxc);\n\n        double m = double(y2 - y1) / (x2 - x1);\n\n        // Generate a third point along the line\n        int x3 = rnd.next(-maxc, maxc);\n        int y3 = round(y1 + m * (x3 - x1));\n\n        // Ensure points are distinct\n        set<pair<int, int>> point_set = {{x1, y1}, {x2, y2}, {x3, y3}};\n        if (point_set.size() != 3) {\n            // Try again\n            return main(argc, argv);\n        }\n\n        vector<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    } else { // \"random\"\n        // Generate random distinct points\n        set<pair<int, int>> point_set;\n        while (point_set.size() < 3) {\n            int x = rnd.next(-maxc, maxc);\n            int y = rnd.next(-maxc, maxc);\n            point_set.insert({x, y});\n        }\n        vector<pair<int, int>> points(point_set.begin(), point_set.end());\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int maxc = opt<int>(\"maxc\", 1000000000);\n\n    if (type == \"equally_spaced\") {\n        // Generate center O\n        int ox = rnd.next(-maxc, maxc);\n        int oy = rnd.next(-maxc, maxc);\n\n        int maxr = min({maxc - abs(ox), maxc - abs(oy)});\n        maxr = min(maxr, 1000000); // Limit r to prevent overflow\n        int r = rnd.next(1, maxr);\n\n        // Angles at 0°, 120°, 240°\n        vector<double> angles = {0.0, 2.0 * M_PI / 3.0, 4.0 * M_PI / 3.0};\n\n        vector<pair<int, int>> points;\n        for (int i = 0; i < 3; ++i) {\n            double theta = angles[i];\n            double x = ox + r * cos(theta);\n            double y = oy + r * sin(theta);\n            int xi = round(x);\n            int yi = round(y);\n            points.push_back(make_pair(xi, yi));\n        }\n\n        // Ensure points are distinct\n        set<pair<int, int>> point_set(points.begin(), points.end());\n        if (point_set.size() != 3) {\n            // Adjust r slightly to get distinct points\n            r += 1;\n            points.clear();\n            for (int i = 0; i < 3; ++i) {\n                double theta = angles[i];\n                double x = ox + r * cos(theta);\n                double y = oy + r * sin(theta);\n                int xi = round(x);\n                int yi = round(y);\n                points.push_back(make_pair(xi, yi));\n            }\n        }\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    } else if (type == \"circle_unequal_angles\") {\n        // Generate center O\n        int ox = rnd.next(-maxc, maxc);\n        int oy = rnd.next(-maxc, maxc);\n\n        int maxr = min({maxc - abs(ox), maxc - abs(oy)});\n        maxr = min(maxr, 1000000); // Limit r to prevent overflow\n        int r = rnd.next(1, maxr);\n\n        // Generate three random angles, not equally spaced\n        double theta0 = rnd.next(0.0, 2 * M_PI);\n        double delta1 = rnd.next(0.1, M_PI); // Ensure minimum difference\n        double delta2 = rnd.next(0.1, M_PI);\n\n        vector<double> thetas = {theta0, theta0 + delta1, theta0 + delta1 + delta2};\n\n        vector<pair<int, int>> points;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < 3; ++i) {\n            double angle = thetas[i];\n            double x = ox + r * cos(angle);\n            double y = oy + r * sin(angle);\n            int xi = round(x);\n            int yi = round(y);\n            point_set.insert({xi, yi});\n            points.push_back(make_pair(xi, yi));\n        }\n\n        // Ensure points are distinct\n        if (point_set.size() != 3) {\n            // Try again with different angles\n            return main(argc, argv);\n        }\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    } else if (type == \"colinear\") {\n        // Generate two random points\n        int x1 = rnd.next(-maxc, maxc);\n        int y1 = rnd.next(-maxc, maxc);\n\n        int x2 = rnd.next(-maxc, maxc);\n        int y2 = rnd.next(-maxc, maxc);\n\n        // Ensure x1 != x2 to define slope m\n        while (x1 == x2) x2 = rnd.next(-maxc, maxc);\n\n        double m = double(y2 - y1) / (x2 - x1);\n\n        // Generate a third point along the line\n        int x3 = rnd.next(-maxc, maxc);\n        int y3 = round(y1 + m * (x3 - x1));\n\n        // Ensure points are distinct\n        set<pair<int, int>> point_set = {{x1, y1}, {x2, y2}, {x3, y3}};\n        if (point_set.size() != 3) {\n            // Try again\n            return main(argc, argv);\n        }\n\n        vector<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    } else { // \"random\"\n        // Generate random distinct points\n        set<pair<int, int>> point_set;\n        while (point_set.size() < 3) {\n            int x = rnd.next(-maxc, maxc);\n            int y = rnd.next(-maxc, maxc);\n            point_set.insert({x, y});\n        }\n        vector<pair<int, int>> points(point_set.begin(), point_set.end());\n\n        // Output ax, ay, bx, by, cx, cy\n        printf(\"%d %d %d %d %d %d\\n\", points[0].first, points[0].second,\n                                     points[1].first, points[1].second,\n                                     points[2].first, points[2].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type equally_spaced -maxc 1000\n./gen -type equally_spaced -maxc 10000\n./gen -type equally_spaced -maxc 100000\n./gen -type equally_spaced -maxc 1000000000\n\n./gen -type circle_unequal_angles -maxc 1000\n./gen -type circle_unequal_angles -maxc 10000\n./gen -type circle_unequal_angles -maxc 100000\n./gen -type circle_unequal_angles -maxc 1000000000\n\n./gen -type colinear -maxc 1000\n./gen -type colinear -maxc 10000\n./gen -type colinear -maxc 100000\n./gen -type colinear -maxc 1000000000\n\n./gen -type random -maxc 1000\n./gen -type random -maxc 1000\n./gen -type random -maxc 1000\n./gen -type random -maxc 10000\n./gen -type random -maxc 10000\n./gen -type random -maxc 10000\n./gen -type random -maxc 100000\n./gen -type random -maxc 100000\n./gen -type random -maxc 100000\n./gen -type random -maxc 1000000000\n./gen -type random -maxc 1000000000\n./gen -type random -maxc 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:33.228415",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "851/C",
      "title": "C. Five Dimensional Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 103) — the number of points.The next n lines of input contain five integers ai, bi, ci, di, ei (|ai|, |bi|, |ci|, |di|, |ei| ≤ 103)  — the coordinates of the i-th point. All points are distinct.",
      "output_spec": "OutputFirst, print a single integer k — the number of good points.Then, print k integers, each on their own line — the indices of the good points in ascending order.",
      "sample_tests": "ExamplesInputCopy60 0 0 0 01 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 00 0 0 0 1OutputCopy11InputCopy30 0 1 2 00 0 9 2 00 0 5 9 0OutputCopy0",
      "description": "C. Five Dimensional Points\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 103) — the number of points.The next n lines of input contain five integers ai, bi, ci, di, ei (|ai|, |bi|, |ci|, |di|, |ei| ≤ 103)  — the coordinates of the i-th point. All points are distinct.\n\nOutputFirst, print a single integer k — the number of good points.Then, print k integers, each on their own line — the indices of the good points in ascending order.\n\nInputCopy60 0 0 0 01 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 00 0 0 0 1OutputCopy11InputCopy30 0 1 2 00 0 9 2 00 0 5 9 0OutputCopy0\n\nInputCopy60 0 0 0 01 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 00 0 0 0 1\n\nOutputCopy11\n\nInputCopy30 0 1 2 00 0 9 2 00 0 5 9 0\n\nOutputCopy0\n\nNoteIn the first sample, the first point forms exactly a  angle with all other pairs of points, so it is good.In the second sample, along the cd plane, we can see the points look as follows:We can see that all angles here are acute, so no points are good.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 851 和字母"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<array<int, 5>> uniquePoints;\n    for (int i = 0; i < n; i++) {\n        vector<int> coords = inf.readInts(5, -1000, 1000, format(\"coordinates of point %d\", i + 1).c_str());\n        inf.readEoln();\n        array<int, 5> point;\n        for (int j = 0; j < 5; j++) {\n            point[j] = coords[j];\n        }\n        ensuref(uniquePoints.count(point) == 0, \"Points must be distinct, but point at index %d repeats\", i+1);\n        uniquePoints.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<array<int, 5>> uniquePoints;\n    for (int i = 0; i < n; i++) {\n        vector<int> coords = inf.readInts(5, -1000, 1000, format(\"coordinates of point %d\", i + 1).c_str());\n        inf.readEoln();\n        array<int, 5> point;\n        for (int j = 0; j < 5; j++) {\n            point[j] = coords[j];\n        }\n        ensuref(uniquePoints.count(point) == 0, \"Points must be distinct, but point at index %d repeats\", i+1);\n        uniquePoints.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<array<int, 5>> uniquePoints;\n    for (int i = 0; i < n; i++) {\n        vector<int> coords = inf.readInts(5, -1000, 1000, format(\"coordinates of point %d\", i + 1).c_str());\n        inf.readEoln();\n        array<int, 5> point;\n        for (int j = 0; j < 5; j++) {\n            point[j] = coords[j];\n        }\n        ensuref(uniquePoints.count(point) == 0, \"Points must be distinct, but point at index %d repeats\", i+1);\n        uniquePoints.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<tuple<int,int,int,int,int>> points_set;\n    vector<tuple<int,int,int,int,int>> points;\n\n    if (n < 1 || n > 1000) {\n        cerr << \"n must be between 1 and 1000\" << endl;\n        exit(1);\n    }\n\n    if (type == \"random\") {\n        // Generate n random points with coordinates in [-1000, 1000], ensuring uniqueness\n        while ((int)points_set.size() < n) {\n            int a = rnd.next(-1000, 1000);\n            int b = rnd.next(-1000, 1000);\n            int c = rnd.next(-1000, 1000);\n            int d = rnd.next(-1000, 1000);\n            int e = rnd.next(-1000, 1000);\n            auto tup = make_tuple(a,b,c,d,e);\n            if (points_set.count(tup) == 0) {\n                points_set.insert(tup);\n                points.push_back(tup);\n            }\n        }\n    }\n    else if (type == \"max_coordinates\") {\n        // Generate points with coordinates at maximum or minimum values\n        int max_abs = 1000;\n        for (int i = 0; i < n; ++i) {\n            int a = (i % 2 == 0) ? max_abs : -max_abs;\n            int b = ((i / 2) % 2 == 0) ? max_abs : -max_abs;\n            int c = ((i / 4) % 2 == 0) ? max_abs : -max_abs;\n            int d = ((i / 8) % 2 == 0) ? max_abs : -max_abs;\n            int e = ((i / 16) % 2 == 0) ? max_abs : -max_abs;\n            auto tup = make_tuple(a,b,c,d,e);\n            points.push_back(tup);\n        }\n    }\n    else if (type == \"negative_coordinates\") {\n        // Generate n random points with negative coordinates in [-1000, -1], ensuring uniqueness\n        while ((int)points_set.size() < n) {\n            int a = rnd.next(-1000, -1);\n            int b = rnd.next(-1000, -1);\n            int c = rnd.next(-1000, -1);\n            int d = rnd.next(-1000, -1);\n            int e = rnd.next(-1000, -1);\n            auto tup = make_tuple(a,b,c,d,e);\n            if (points_set.count(tup) == 0) {\n                points_set.insert(tup);\n                points.push_back(tup);\n            }\n        }\n    }\n    else if (type == \"edge_n1\") {\n        // n must be 1\n        if (n != 1) {\n            cerr << \"For type edge_n1, n must be 1\" << endl;\n            exit(1);\n        }\n        // Generate one point\n        int a = rnd.next(-1000, 1000);\n        int b = rnd.next(-1000, 1000);\n        int c = rnd.next(-1000, 1000);\n        int d = rnd.next(-1000, 1000);\n        int e = rnd.next(-1000, 1000);\n        auto tup = make_tuple(a,b,c,d,e);\n        points.push_back(tup);\n    }\n    else if (type == \"edge_n2\") {\n        // n must be 2\n        if (n != 2) {\n            cerr << \"For type edge_n2, n must be 2\" << endl;\n            exit(1);\n        }\n        // Generate two points\n        while ((int)points_set.size() < 2) {\n            int a = rnd.next(-1000, 1000);\n            int b = rnd.next(-1000, 1000);\n            int c = rnd.next(-1000, 1000);\n            int d = rnd.next(-1000, 1000);\n            int e = rnd.next(-1000, 1000);\n            auto tup = make_tuple(a,b,c,d,e);\n            if (points_set.count(tup) == 0) {\n                points_set.insert(tup);\n                points.push_back(tup);\n            }\n        }\n    }\n    else if (type == \"integer_overflow\") {\n        // Coordinates designed to cause large dot products\n        for (int i = 0; i < n; ++i) {\n            int a = 1000;\n            int b = 1000;\n            int c = 1000;\n            int d = 1000;\n            int e = 1000 - i; // Ensure uniqueness\n            auto tup = make_tuple(a,b,c,d,e);\n            points.push_back(tup);\n        }\n    }\n    else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the points\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int a,b,c,d,e;\n        tie(a,b,c,d,e) = points[i];\n        printf(\"%d %d %d %d %d\\n\", a,b,c,d,e);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<tuple<int,int,int,int,int>> points_set;\n    vector<tuple<int,int,int,int,int>> points;\n\n    if (n < 1 || n > 1000) {\n        cerr << \"n must be between 1 and 1000\" << endl;\n        exit(1);\n    }\n\n    if (type == \"random\") {\n        // Generate n random points with coordinates in [-1000, 1000], ensuring uniqueness\n        while ((int)points_set.size() < n) {\n            int a = rnd.next(-1000, 1000);\n            int b = rnd.next(-1000, 1000);\n            int c = rnd.next(-1000, 1000);\n            int d = rnd.next(-1000, 1000);\n            int e = rnd.next(-1000, 1000);\n            auto tup = make_tuple(a,b,c,d,e);\n            if (points_set.count(tup) == 0) {\n                points_set.insert(tup);\n                points.push_back(tup);\n            }\n        }\n    }\n    else if (type == \"max_coordinates\") {\n        // Generate points with coordinates at maximum or minimum values\n        int max_abs = 1000;\n        for (int i = 0; i < n; ++i) {\n            int a = (i % 2 == 0) ? max_abs : -max_abs;\n            int b = ((i / 2) % 2 == 0) ? max_abs : -max_abs;\n            int c = ((i / 4) % 2 == 0) ? max_abs : -max_abs;\n            int d = ((i / 8) % 2 == 0) ? max_abs : -max_abs;\n            int e = ((i / 16) % 2 == 0) ? max_abs : -max_abs;\n            auto tup = make_tuple(a,b,c,d,e);\n            points.push_back(tup);\n        }\n    }\n    else if (type == \"negative_coordinates\") {\n        // Generate n random points with negative coordinates in [-1000, -1], ensuring uniqueness\n        while ((int)points_set.size() < n) {\n            int a = rnd.next(-1000, -1);\n            int b = rnd.next(-1000, -1);\n            int c = rnd.next(-1000, -1);\n            int d = rnd.next(-1000, -1);\n            int e = rnd.next(-1000, -1);\n            auto tup = make_tuple(a,b,c,d,e);\n            if (points_set.count(tup) == 0) {\n                points_set.insert(tup);\n                points.push_back(tup);\n            }\n        }\n    }\n    else if (type == \"edge_n1\") {\n        // n must be 1\n        if (n != 1) {\n            cerr << \"For type edge_n1, n must be 1\" << endl;\n            exit(1);\n        }\n        // Generate one point\n        int a = rnd.next(-1000, 1000);\n        int b = rnd.next(-1000, 1000);\n        int c = rnd.next(-1000, 1000);\n        int d = rnd.next(-1000, 1000);\n        int e = rnd.next(-1000, 1000);\n        auto tup = make_tuple(a,b,c,d,e);\n        points.push_back(tup);\n    }\n    else if (type == \"edge_n2\") {\n        // n must be 2\n        if (n != 2) {\n            cerr << \"For type edge_n2, n must be 2\" << endl;\n            exit(1);\n        }\n        // Generate two points\n        while ((int)points_set.size() < 2) {\n            int a = rnd.next(-1000, 1000);\n            int b = rnd.next(-1000, 1000);\n            int c = rnd.next(-1000, 1000);\n            int d = rnd.next(-1000, 1000);\n            int e = rnd.next(-1000, 1000);\n            auto tup = make_tuple(a,b,c,d,e);\n            if (points_set.count(tup) == 0) {\n                points_set.insert(tup);\n                points.push_back(tup);\n            }\n        }\n    }\n    else if (type == \"integer_overflow\") {\n        // Coordinates designed to cause large dot products\n        for (int i = 0; i < n; ++i) {\n            int a = 1000;\n            int b = 1000;\n            int c = 1000;\n            int d = 1000;\n            int e = 1000 - i; // Ensure uniqueness\n            auto tup = make_tuple(a,b,c,d,e);\n            points.push_back(tup);\n        }\n    }\n    else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the points\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int a,b,c,d,e;\n        tie(a,b,c,d,e) = points[i];\n        printf(\"%d %d %d %d %d\\n\", a,b,c,d,e);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type edge_n1\n./gen -n 2 -type edge_n2\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 10 -type negative_coordinates\n./gen -n 10 -type max_coordinates\n./gen -n 20 -type integer_overflow\n./gen -n 50 -type random\n./gen -n 50 -type negative_coordinates\n./gen -n 50 -type max_coordinates\n./gen -n 100 -type random\n./gen -n 100 -type integer_overflow\n./gen -n 200 -type random\n./gen -n 500 -type random\n./gen -n 500 -type negative_coordinates\n./gen -n 500 -type max_coordinates\n./gen -n 999 -type random\n./gen -n 999 -type integer_overflow\n./gen -n 1000 -type random\n./gen -n 1000 -type negative_coordinates\n./gen -n 1000 -type max_coordinates\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:35.243382",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "851/D",
      "title": "D. Arpa and a list of numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains three integers n, x and y (1 ≤ n ≤ 5·105, 1 ≤ x, y ≤ 109) — the number of elements in the list and the integers x and y.Second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106) — the elements of the list.",
      "output_spec": "OutputPrint a single integer: the minimum possible cost to make the list good.",
      "sample_tests": "ExamplesInputCopy4 23 171 17 17 16OutputCopy40InputCopy10 6 2100 49 71 73 66 96 8 60 41 63OutputCopy10",
      "description": "D. Arpa and a list of numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line contains three integers n, x and y (1 ≤ n ≤ 5·105, 1 ≤ x, y ≤ 109) — the number of elements in the list and the integers x and y.Second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106) — the elements of the list.\n\nOutputPrint a single integer: the minimum possible cost to make the list good.\n\nInputCopy4 23 171 17 17 16OutputCopy40InputCopy10 6 2100 49 71 73 66 96 8 60 41 63OutputCopy10\n\nInputCopy4 23 171 17 17 16\n\nOutputCopy40\n\nInputCopy10 6 2100 49 71 73 66 96 8 60 41 63\n\nOutputCopy10\n\nNoteIn example, number 1 must be deleted (with cost 23) and number 16 must increased by 1 (with cost 17).A gcd (greatest common divisor) of a set of numbers is the maximum integer that divides all integers in the set. Read more about gcd here.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 851 和字母"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\"); // Read n between 1 and 5e5\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\"); // Read x between 1 and 1e9\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\"); // Read y between 1 and 1e9\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\"); // Read n integers a_i between 1 and 1e6\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\"); // Read n between 1 and 5e5\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\"); // Read x between 1 and 1e9\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\"); // Read y between 1 and 1e9\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\"); // Read n integers a_i between 1 and 1e6\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\"); // Read n between 1 and 5e5\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\"); // Read x between 1 and 1e9\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\"); // Read y between 1 and 1e9\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\"); // Read n integers a_i between 1 and 1e6\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"all_same\") {\n        int value = opt<int>(\"value\", 2); // Default value is 2\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"even_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500000) * 2;\n        }\n    } else if (type == \"primes\") {\n        // Generate primes up to 1e6 and select random ones\n        const int MAX_PRIME = 1000000;\n        vector<int> primes;\n        vector<bool> is_prime(MAX_PRIME + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_PRIME; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX_PRIME) {\n                    for (int j = i * i; j <= MAX_PRIME; j += i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else if (type == \"alternating_even_odd\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 500000) * 2;\n            } else {\n                a[i] = rnd.next(1, 500000) * 2 - 1;\n            }\n        }\n    } else if (type == \"worst_case_deletion\") {\n        // Generate numbers such that deleting all is optimal\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000 - i % 1000;\n        }\n    } else if (type == \"worst_case_increment\") {\n        // Generate numbers such that incrementing is better than deleting\n        vector<int> small_primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};\n        for (int i = 0; i < n; ++i) {\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            a[i] = rnd.next(1, 1000000 / p) * p - 1;\n            if (a[i] < 1) a[i] += p;\n        }\n    } else if (type == \"already_good\") {\n        int gcd = opt<int>(\"gcd\", 2); // Default gcd is 2\n        for (int i = 0; i < n; ++i) {\n            int offset = rnd.next(0, gcd - 1);\n            a[i] = gcd + offset;\n        }\n    } else if (type == \"gcd_one\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n        // Ensure GCD is 1\n        if (n >= 3) {\n            a[0] = 2;\n            a[1] = 3;\n            a[2] = 5;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output according to problem statement\n    // First line: n x y\n    printf(\"%d %d %d\\n\", n, x, y);\n\n    // Second line: a_1 a_2 ... a_n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"all_same\") {\n        int value = opt<int>(\"value\", 2); // Default value is 2\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"even_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500000) * 2;\n        }\n    } else if (type == \"primes\") {\n        // Generate primes up to 1e6 and select random ones\n        const int MAX_PRIME = 1000000;\n        vector<int> primes;\n        vector<bool> is_prime(MAX_PRIME + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_PRIME; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX_PRIME) {\n                    for (int j = i * i; j <= MAX_PRIME; j += i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else if (type == \"alternating_even_odd\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 500000) * 2;\n            } else {\n                a[i] = rnd.next(1, 500000) * 2 - 1;\n            }\n        }\n    } else if (type == \"worst_case_deletion\") {\n        // Generate numbers such that deleting all is optimal\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000 - i % 1000;\n        }\n    } else if (type == \"worst_case_increment\") {\n        // Generate numbers such that incrementing is better than deleting\n        vector<int> small_primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};\n        for (int i = 0; i < n; ++i) {\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            a[i] = rnd.next(1, 1000000 / p) * p - 1;\n            if (a[i] < 1) a[i] += p;\n        }\n    } else if (type == \"already_good\") {\n        int gcd = opt<int>(\"gcd\", 2); // Default gcd is 2\n        for (int i = 0; i < n; ++i) {\n            int offset = rnd.next(0, gcd - 1);\n            a[i] = gcd + offset;\n        }\n    } else if (type == \"gcd_one\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n        // Ensure GCD is 1\n        if (n >= 3) {\n            a[0] = 2;\n            a[1] = 3;\n            a[2] = 5;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output according to problem statement\n    // First line: n x y\n    printf(\"%d %d %d\\n\", n, x, y);\n\n    // Second line: a_1 a_2 ... a_n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -x 1 -y 1 -type random\n\n./gen -n 2 -x 1 -y 1 -type even_numbers\n\n./gen -n 50 -x 1 -y 1 -type alternating_even_odd\n\n./gen -n 100 -x 10 -y 5 -type all_ones\n\n./gen -n 1000 -x 100 -y 100 -type all_same -value 42\n\n./gen -n 10000 -x 500000000 -y 1 -type worst_case_deletion\n\n./gen -n 10000 -x 1 -y 500000000 -type worst_case_increment\n\n./gen -n 50000 -x 100 -y 1 -type primes\n\n./gen -n 50000 -x 1 -y 100 -type primes\n\n./gen -n 100000 -x 1000000 -y 1000000 -type random\n\n./gen -n 100000 -x 1 -y 1 -type gcd_one\n\n./gen -n 200000 -x 1 -y 1 -type already_good -gcd 1000000\n\n./gen -n 500000 -x 1000000000 -y 1 -type worst_case_deletion\n\n./gen -n 500000 -x 1 -y 1000000000 -type worst_case_increment\n\n./gen -n 500000 -x 1000000000 -y 1000000000 -type random\n\n./gen -n 500000 -x 999999999 -y 999999999 -type all_same -value 1\n\n./gen -n 500000 -x 1 -y 1 -type all_same -value 1\n\n./gen -n 500000 -x 1 -y 1000000000 -type all_same -value 1000000\n\n./gen -n 5 -x 1000000000 -y 1 -type random\n\n./gen -n 5 -x 1 -y 1000000000 -type random\n\n./gen -n 10 -x 1000000 -y 1000000 -type even_numbers\n\n./gen -n 500000 -x 100 -y 1 -type alternating_even_odd\n\n./gen -n 500000 -x 100 -y 1 -type all_same -value 2\n\n./gen -n 5 -x 1 -y 1 -type already_good -gcd 2\n\n./gen -n 500000 -x 1 -y 1 -type random\n\n./gen -n 500000 -x 1 -y 1 -type primes\n\n./gen -n 500000 -x 1 -y 1 -type even_numbers\n\n./gen -n 500000 -x 1 -y 1 -type all_ones\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:37.360180",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "851/E",
      "title": "E. Arpa and a game with Mojtaba",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of elements in the list.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the list.",
      "output_spec": "OutputIf Mojtaba wins, print \"Mojtaba\", otherwise print \"Arpa\" (without quotes).You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy41 1 1 1OutputCopyArpaInputCopy41 1 17 17OutputCopyMojtabaInputCopy41 1 17 289OutputCopyArpaInputCopy51 2 3 4 5OutputCopyArpa",
      "description": "E. Arpa and a game with Mojtaba\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of elements in the list.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the list.\n\nOutputIf Mojtaba wins, print \"Mojtaba\", otherwise print \"Arpa\" (without quotes).You can print each letter in any case (upper or lower).\n\nInputCopy41 1 1 1OutputCopyArpaInputCopy41 1 17 17OutputCopyMojtabaInputCopy41 1 17 289OutputCopyArpaInputCopy51 2 3 4 5OutputCopyArpa\n\nInputCopy41 1 1 1\n\nOutputCopyArpa\n\nInputCopy41 1 17 17\n\nOutputCopyMojtaba\n\nInputCopy41 1 17 289\n\nOutputCopyArpa\n\nInputCopy51 2 3 4 5\n\nOutputCopyArpa\n\nNoteIn the first sample test, Mojtaba can't move.In the second sample test, Mojtaba chooses p = 17 and k = 1, then the list changes to [1, 1, 1, 1].In the third sample test, if Mojtaba chooses p = 17 and k = 1, then Arpa chooses p = 17 and k = 1 and wins, if Mojtaba chooses p = 17 and k = 2, then Arpa chooses p = 17 and k = 1 and wins.",
      "solutions": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces",
          "content": "Hi!I'm honored to invite you to Codeforces Round #432, it will be held on 4th September 14:35 UTC. There will be 5 problems for each division, as usual, you have 2:30 to solve the problems. The contest was prepared by Lewin Lewin Gan, Artsem Arterm Zhuk and me.The IndiaHacks Final Round will be held on 3rd September 12:30. Finalist must not discuss the problems after their contest.The stories of my problems will be about Arpa, although in one problem you'll see Mojtaba moji FayazBakhsh, my great teacher.I'd like to thank Lewin, Artsem and myself (:P) at first, then Konstantin zemen Semenov and WHITE2302 for testing the problems, Nikolay KAN Kalinin for helping us in moving the contest to codeforces and Mike MikeMirzayanov Mirzayanov for the great Codeforces and Polygon platforms.The scoring distribution will be announced later.Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.UPD. There will be 5 problems for div.2 and 6 problems for div.1.UPD2. Scoring Distribution: div.1: 500-1000-1250-1750-2000-2500, div.2: 500-1000-1500-2000-2500.UPD3. Editorial is partially ready. I'll complete it soon.Congratulations to winners:Div.1:1 . BaconLi2 . dreamoon_love_AA3 . sd00614 . W4yneb0t5 . Um_nikDiv.2:1 . miaom2 . fzzzq20023 . lzy9606014 . Lucas97 and Szymanski_w (WoW !!)Official results",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1357
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces",
          "content": "Hi!Thanks to all of you participates, who made this contest possible. And thanks to Lewin and Arterm, also to the great coordinator, Nikolay KAN Kalinin, zemen, WHITE2302, and for sure MikeMirzayanov.Test data and code solutions. It's the original packages from polygon, you can find pretests, tests, generators, validators, etc in it.HintsDiv.2 A: Take a look at notes section.Div.2 B: Create a circle with these points.Div.1 B: Fix the gcd.Div.1 C: Tag: Grundy number.DetailsDiv.1 CI want to thank my grand teacher Mojtaba moji FayazBakhsh here. Who was my teacher not only for coding but also a teacher for my life. Thanks Mojtaba! Thanks to you and all of other good teachers in the world.Solutions 851A - Arpa and a research in Mexican wave If t ≤ k, answer is t. If k ≤ t ≤ n, answer is k. If n ≤ t < n + k, answer is n + k - t. Another solution: just print min(t, k, n + k - t).Author: Arpa 851B - Arpa and an exam about geometryIf a, b, c are on the same line or dis(a, b) ≠ dis(b, c), the problem has not any solution.Author: Arpa 850A - Five Dimensional PointsIt's easier to visualize this in 2D first. Fix a point p. If all other points form angles that are 90 degrees or greater, they must all be in different quadrants, so there can be at most 4 such points. In k dimension, this generalizes to 2*k such points, so for five dimensions, there can only be at most 10 other points. Thus, we can run the naive solution for small n and print 0 otherwise.Author: LewinThanks to Lewin, the writer of this tutorial. 850B - Arpa and a list of numbersLet's define cost(g) the cost if we want gcd of the array becomes g. The answer is min cost(g) for g > 1. Now, let's see how to calculate cost(g). For each number like c, we can delete it with cost x or we can add it till g divides it. So, we must pay . Let's iterate on possible values for .Before entering the main part of the solution, let's define two helper functions:– cnt(l, r): this function returns the number of i's such that l ≤ ai ≤ r.– sum(l, r): this function returns . To implement this function, define an array ps, such that psi keeps the sum of values less than or equal to i. Then sum(l, r) = psr - psl - 1.Now for each multiple of g like k, let's find the cost of numbers in the range (k - g, k], and sum up these values. We must find the best f and divide the range into two segments (k - g, f] and (f, k] and delete the numbers in the first range and add the numbers in second range till they become k. Now to find the best value for f, .So, the total cost for this range is cnt(k - g + 1, k - ⌊ f⌋) × x + (cnt(k - ⌊ f⌋ + 1, k) × k - sum(k - ⌊ f⌋ + 1, k)) × y.Time complexity: .Author: Arpa 850C - Arpa and a game with MojtabaThe problem is separate for each prime, so we will calculate Grundy number for each prime and xor these number to find the answer.Now let's solve the problem for some prime like p. Let's show the game with a mask, i-th bit of mask is true if and only if there is a number in the list such that it is divisible by pi and it isn't divisible by pk + 1.When some player chooses p and some k in his turn, in fact, he converts mask to (mask»k)|(mask&((1«k) - 1)). So, for each k, there is an edge between state (mask»k)|(mask&((1«k) - 1)) and mask. We can caluclate the grundy numbers by this way.Author: Arpa 850D - Tournament ConstructionLet n be the number of players participating in the tournament. First of all, note that n ≤ 61, since the total number of wins must be , and there can be no more than 30 × n, therefore , hence n ≤ 61. Next, we find an appropriate n, based on the criterion of the condition. We will go through all possible n from 1 to 61 and use the dynamic programming method to determine whether there can be a given number of participants, the parameters will be: the current element in the sorted list apos how many participants are already aware of their number of victories the total number of wins for the already known participants From these parameters, we store whether it is possible for the remaining participants to assign any apos, apos + 1... am so that there is a tournament for these participants. Also, do not forget that each of ai should be taken at least once. Further, if we did not find n, then we print  - 1. Otherwise, you can recover from the dynamics how many times we took each ai, it remains to build a correct tournament on these values.To do this, each time we take the player with the smallest number of wins, let this number be x, and we make him win x other players with the least number of wins, and loose to the remaining players. Next, delete this player, recompute for each remaining player how many times they have to win, and continue this process until all of the players are processed. The proof that a correct tournament is always built by this algorithm follows from the criterion.Thus, the first part works in the second part works in .Author: ArtermThanks to WHITE2302, the writer of this tutorial. I translated this tutorial to English. 850E - Random Electionsbk(x) denotes i-th bit of x. denotes number of bits in x.Count number of ways where Alice wins. Suppose Alice wins in first round with mask x and in third round with mask y (so, bi(x) = 1 or bi(y) = 1 if i voter preferred Alice in corresponding round). Necessary condition is f(x) = f(y) = 1. Assume we fixed x and y. In how many ways we can choose orders for voters? If bi(x) = bi(y), we can chose two valid permutations for i-th voter. If , only one permutation. So, total number of permutation is . So, answer to the problem is Denote S = {x|f(x) = 1}. Lets solve more general problem, for each z, how many pairs (x, y) are there such that and ? This is well-known problem. There are multiple O(2nn) solutions. Probably first usage of this problem in competitive programming can be found here https://apps.topcoder.com/wiki/display/tc/SRM+518.If you interesting in understanding this approach more deeply from math perspective, you can start investigate from here https://en.wikipedia.org/wiki/Fourier_transform_on_finite_groups. Sorry for late editorial. Btw, in task D there are always an answer (for any set S), that's called Reid's conjectue and was proven by T.X. Yao in 1988 (and have very difficult proof that I didn't manage to find in English; if somebody succeed in search, please direct it to me). Author: ArtermThanks to Arterm, the writer of this tutorial. 850F - Rainbow BallsFirst, let's fix the final color of the balls.After fixing the final color, we can see the other colors don't matter.Define an \"interesting\" draw as one where we choose a ball of the final color and one of a different color.Once we do an interesting draw, we can see there is an equal probability of increasing or decreasing the number of balls of our final color.So, we can view this as a random walk, with equal probability of going in either direction. Let Xt be the number of balls of the final color at time t. Let T be the first time we hit 0 or S balls.Now, we can write the expected value of time as follows: Let t(r) = E(T|X0 = r, XT = S) (i.e. in words, expected value of time, given we are at r, only counting the events that reach XT = S first).Let p(r) be the probability of an interesting draw, so p(r) = r × (S - r) × 2 / (S × (S - 1)). Then, we can write t(r) = p / 2 × t(r - 1) + p / 2 × t(r + 1) + r / S. Rearranging gives us 2 × t(r) = t(r - 1) + t(r + 1) + (S - 1) / (S - r).So, in particular, t(r) - t(r - 1) = t(r + 1) - t(r) + (S - 1) / (S - r) So, letting g(r) = t(r) - t(r - 1), we get g(r + 1) = g(r) - (S - 1) / (S - r). Doing some more manipulation can get us .So, we just need to print the sum of t(ai).Author: LewinThanks to Lewin, the writer of this tutorial.I’d like to finish the editorial with the below poem by Hatef Esfahani: چه کند کوه کن دلشده با غیرت عشق گر نه بر فرق زند تیشه ز رشک خسرو Translation: What can lover (Farhad) do with the power of love? He has no choice but to hurt himself by ax because he feels jealousy to Khosrow. More information about Khosrow and Shirin story.Good luck and see you soon ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 851 和字母"
          },
          "content_length": 8068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 1",
          "code": "Obviously, if you are interested in if the round is rated or not, ask in comments and get a lot of down votes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 2",
          "code": "4nd September 14:35",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 3",
          "code": "3nd September 12:30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 4",
          "code": "There will be 5 problems for each division, as usual, you have 2:30 to solve the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int LEN = 1000;\nbool isP[LEN];\n\nint n, a[500001];\nll x, y;\nvector<int> pri;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    fill_n(isP, LEN, true);\n    isP[0] = isP[1] = false;\n    for (int i = 2; i*i < LEN; ++i)\n        if (isP[i])\n            for (int j = 2; i*j < LEN; ++j)\n                isP[i*j] = false;\n    for (int i = 0; i < LEN; ++i)\n        if (isP[i])\n            pri.push_back(i);\n    assert(pri.size() == 168);\n    // cout << pri.size() << '\\n';\n    cin >> n >> x >> y;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    ll ans = (1LL<<60);\n    for (int p : pri) {\n        ll z = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = ceil((double)a[i] / p);\n            z += min((p*d - a[i]) * y, x);\n        }\n        ans = min(ans, z);\n    }\n    cout << ans << '\\n';\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 7",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 8",
          "code": "double ax,ay,bx,by,cx,cy;\n    scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n    \n    double dist1=sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay));\n    double dist2=sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by));\n    double dist3=sqrt((cx-ax)*(cx-ax)+(cy-ay)*(cy-ay));\n\n    //pritnf(\"%lf %lf %lf\\n\",dist1,dist2,dist3);\n\n    if(dist1==dist2  && dist1+dist2!=dist3)\n    \tprintf(\"Yes\\n\");\n    else\n    \tprintf(\"No\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 9",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 10",
          "code": "if(n>64) { cout<<0<<endl; return 0; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 11",
          "code": "is acute (i.e. strictly less than 90°)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 12",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 (based on IndiaHacks Final Round 2017) - Codeforces - Code 13",
          "code": "sort(a, a + m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 1",
          "code": "fabs(a - b) <= 1e-9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 2",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 3",
          "code": "int main()\n{\n    multi_dimensional_points< 5, 1000 > problem;\n\n    problem.brute_force();\n\n    problem.write_solution();\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 4",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 5",
          "code": "(g-f)*y=x/y  => f=g-min(g,x/y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 6",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 7",
          "code": "11 11 10\n3 5 7 11 13 17 19 23 29 31 37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 8",
          "code": "n = 470982, x = 1000000000, y = 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #432 editorial - Codeforces - Code 9",
          "code": "3 3 3 3 3 3 5 5 5 5 5 5 7 7 7 7 ... 999983 999983",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string ja = upperCase(ans.readToken()); // Read the judge's answer and convert to uppercase\n    string pa = upperCase(ouf.readToken()); // Read the participant's answer and convert to uppercase\n\n    if (ja == pa) {\n        quitf(_ok, \"Answer is correct: %s\", pa.c_str());\n    } else {\n        quitf(_wa, \"Expected %s, found %s\", ja.c_str(), pa.c_str());\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> primes; // List of primes up to a limit\n\nvoid init_primes(int limit) {\n    vector<bool> is_prime(limit+1,true);\n    is_prime[0]=is_prime[1]=false;\n    for(int i=2;i<=limit;++i){\n        if(is_prime[i]){\n            primes.push_back(i);\n            for(int j=i*2;j<=limit;j+=i)\n                is_prime[j]=false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\",\"random\");\n    ensure(1 <= n && n <= 100);\n    init_primes(100000);\n    \n    vector<int> a(n);\n    \n    if(type==\"ones\"){\n        // All numbers are 1\n        for(int i=0;i<n;++i)\n            a[i]=1;\n    }else if(type==\"single_prime_powers\"){\n        // All numbers are powers of a single prime\n        int p = primes[rnd.next((int)primes.size())];\n        for(int i=0;i<n;++i){\n            int k = rnd.next(1,9); // Exponent up to 9\n            int64_t val = 1;\n            for(int j=0;j<k;++j){\n                val *= p;\n                if(val > 1e9) {\n                    val = 1e9;\n                    break;\n                }\n            }\n            a[i]=(int)val;\n        }\n    }else if(type==\"mixed_primes\"){\n        // Numbers are products of different primes\n        for(int i=0;i<n;++i){\n            int num_primes = rnd.next(1,5);\n            int64_t val = 1;\n            set<int> used_primes;\n            for(int j=0;j<num_primes;++j){\n                int idx = rnd.next(0,(int)primes.size() - 1);\n                int p = primes[idx];\n                if (val * p > 1e9) break;\n                if(used_primes.count(p)) continue;\n                used_primes.insert(p);\n                int k = rnd.next(1,5); // Exponent up to 5\n                for(int l=0;l<k;++l){\n                    if(val > 1e9 / p) {\n                        val = 1e9;\n                        break;\n                    }\n                    val *= p;\n                }\n                if(val >= 1e9) break;\n            }\n            a[i]=(int)val;\n        }\n    }else if(type==\"big_exponents\"){\n        // Numbers are powers of small primes with big exponents\n        int p = primes[rnd.next(0,5)]; // Small prime\n        for(int i=0;i<n;++i){\n            int k = rnd.next(20,30); // Big exponent\n            int64_t val = 1;\n            for(int j=0;j<k;++j){\n                if(val > 1e9 / p) {\n                    val = 1e9;\n                    break;\n                }\n                val *= p;\n            }\n            a[i]=(int)val;\n        }\n    }else if(type==\"max_numbers\"){\n        // All numbers are 1e9\n        for(int i=0;i<n;++i){\n            a[i]=1000000000;\n        }\n    }else if(type==\"random\"){\n        // Random numbers in the range [1,1e9]\n        for(int i=0;i<n;++i){\n            a[i]=rnd.next(1,1000000000);\n        }\n    }else{\n        // Default to random\n        for(int i=0;i<n;++i){\n            a[i]=rnd.next(1,1000000000);\n        }\n    }\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i=0;i<n;++i){\n        printf(\"%d\", a[i]);\n        if(i+1<n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> primes; // List of primes up to a limit\n\nvoid init_primes(int limit) {\n    vector<bool> is_prime(limit+1,true);\n    is_prime[0]=is_prime[1]=false;\n    for(int i=2;i<=limit;++i){\n        if(is_prime[i]){\n            primes.push_back(i);\n            for(int j=i*2;j<=limit;j+=i)\n                is_prime[j]=false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\",\"random\");\n    ensure(1 <= n && n <= 100);\n    init_primes(100000);\n    \n    vector<int> a(n);\n    \n    if(type==\"ones\"){\n        // All numbers are 1\n        for(int i=0;i<n;++i)\n            a[i]=1;\n    }else if(type==\"single_prime_powers\"){\n        // All numbers are powers of a single prime\n        int p = primes[rnd.next((int)primes.size())];\n        for(int i=0;i<n;++i){\n            int k = rnd.next(1,9); // Exponent up to 9\n            int64_t val = 1;\n            for(int j=0;j<k;++j){\n                val *= p;\n                if(val > 1e9) {\n                    val = 1e9;\n                    break;\n                }\n            }\n            a[i]=(int)val;\n        }\n    }else if(type==\"mixed_primes\"){\n        // Numbers are products of different primes\n        for(int i=0;i<n;++i){\n            int num_primes = rnd.next(1,5);\n            int64_t val = 1;\n            set<int> used_primes;\n            for(int j=0;j<num_primes;++j){\n                int idx = rnd.next(0,(int)primes.size() - 1);\n                int p = primes[idx];\n                if (val * p > 1e9) break;\n                if(used_primes.count(p)) continue;\n                used_primes.insert(p);\n                int k = rnd.next(1,5); // Exponent up to 5\n                for(int l=0;l<k;++l){\n                    if(val > 1e9 / p) {\n                        val = 1e9;\n                        break;\n                    }\n                    val *= p;\n                }\n                if(val >= 1e9) break;\n            }\n            a[i]=(int)val;\n        }\n    }else if(type==\"big_exponents\"){\n        // Numbers are powers of small primes with big exponents\n        int p = primes[rnd.next(0,5)]; // Small prime\n        for(int i=0;i<n;++i){\n            int k = rnd.next(20,30); // Big exponent\n            int64_t val = 1;\n            for(int j=0;j<k;++j){\n                if(val > 1e9 / p) {\n                    val = 1e9;\n                    break;\n                }\n                val *= p;\n            }\n            a[i]=(int)val;\n        }\n    }else if(type==\"max_numbers\"){\n        // All numbers are 1e9\n        for(int i=0;i<n;++i){\n            a[i]=1000000000;\n        }\n    }else if(type==\"random\"){\n        // Random numbers in the range [1,1e9]\n        for(int i=0;i<n;++i){\n            a[i]=rnd.next(1,1000000000);\n        }\n    }else{\n        // Default to random\n        for(int i=0;i<n;++i){\n            a[i]=rnd.next(1,1000000000);\n        }\n    }\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i=0;i<n;++i){\n        printf(\"%d\", a[i]);\n        if(i+1<n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 1 -type single_prime_powers\n./gen -n 1 -type mixed_primes\n./gen -n 1 -type big_exponents\n./gen -n 1 -type max_numbers\n./gen -n 1 -type random\n\n./gen -n 2 -type ones\n./gen -n 2 -type single_prime_powers\n./gen -n 2 -type mixed_primes\n./gen -n 2 -type big_exponents\n./gen -n 2 -type max_numbers\n./gen -n 2 -type random\n\n./gen -n 3 -type ones\n./gen -n 3 -type single_prime_powers\n./gen -n 3 -type mixed_primes\n./gen -n 3 -type big_exponents\n./gen -n 3 -type max_numbers\n./gen -n 3 -type random\n\n./gen -n 4 -type ones\n./gen -n 4 -type single_prime_powers\n./gen -n 4 -type mixed_primes\n./gen -n 4 -type big_exponents\n./gen -n 4 -type max_numbers\n./gen -n 4 -type random\n\n./gen -n 10 -type ones\n./gen -n 10 -type single_prime_powers\n./gen -n 10 -type mixed_primes\n./gen -n 10 -type big_exponents\n./gen -n 10 -type max_numbers\n./gen -n 10 -type random\n\n./gen -n 50 -type ones\n./gen -n 50 -type single_prime_powers\n./gen -n 50 -type mixed_primes\n./gen -n 50 -type big_exponents\n./gen -n 50 -type max_numbers\n./gen -n 50 -type random\n\n./gen -n 99 -type ones\n./gen -n 99 -type single_prime_powers\n./gen -n 99 -type mixed_primes\n./gen -n 99 -type big_exponents\n./gen -n 99 -type max_numbers\n./gen -n 99 -type random\n\n./gen -n 100 -type ones\n./gen -n 100 -type single_prime_powers\n./gen -n 100 -type mixed_primes\n./gen -n 100 -type big_exponents\n./gen -n 100 -type max_numbers\n./gen -n 100 -type random\n\n# Edge cases:\n# All ones\n./gen -n 100 -type ones\n# All maximum numbers\n./gen -n 100 -type max_numbers\n\n# Additional test cases with different 'n' values\n./gen -n 5 -type mixed_primes\n./gen -n 6 -type big_exponents\n./gen -n 7 -type random\n./gen -n 8 -type single_prime_powers\n./gen -n 9 -type big_exponents\n\n# Random types with maximum 'n'\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:39.422028",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/A",
      "title": "A. Цифры",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит одно целое число N (1 ≤ N ≤ 200000) — число цифр в A0.Вторая строка содержит целое число A0 из N цифр без лидирующих нулей.",
      "output_spec": "Выходные данныеВыведите ровно три строки. Каждая строка будет шагом, выполненным Джеком. Результатом третьего шага должно быть однозначное число.Каждый шаг должен состоять из цифр и знаков ' + '. Шаги не должны содержать несколько знаков ' + ' подряд, пробелов, а также знаков ' + ' перед первой и после последней цифры. Кроме того, они должны быть арифметически согласованными.Возможно, что решение не единственно. В таком случае, выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать11Выходные данныеСкопировать111Входные данныеСкопировать45806Выходные данныеСкопировать5+8+0+61+91+0",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит одно целое число N (1 ≤ N ≤ 200000) — число цифр в A0.Вторая строка содержит целое число A0 из N цифр без лидирующих нулей.\n\nВходные данные\n\nВыходные данныеВыведите ровно три строки. Каждая строка будет шагом, выполненным Джеком. Результатом третьего шага должно быть однозначное число.Каждый шаг должен состоять из цифр и знаков ' + '. Шаги не должны содержать несколько знаков ' + ' подряд, пробелов, а также знаков ' + ' перед первой и после последней цифры. Кроме того, они должны быть арифметически согласованными.Возможно, что решение не единственно. В таком случае, выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать11Выходные данныеСкопировать111Входные данныеСкопировать45806Выходные данныеСкопировать5+8+0+61+91+0\n\nВходные данныеСкопировать11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать111\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать45806\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5+8+0+61+91+0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Джек не может нигде поставить знак ' + ', поэтому он просто пишет 1 в каждой из строк и решает задачу. В этом случае решение единственно.Во втором примере Джек сначала пишет знаки ' + ' между каждой парой последовательных цифр, получая результат 5 + 8 + 0 + 6 = 19. Он делает то же на втором шаге, получая 1 + 9 = 10. Затем он пишет 1 + 0 = 1, поэтому после трех шагов результат равен 1 и его решение корректно.",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 200000, \"N\");\n    inf.readEoln();\n    string A0 = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(A0.length()) == N, \"Length of A0 is not equal to N\");\n\n    ensuref(A0[0] >= '1' && A0[0] <= '9', \"A0 has leading zero\");\n\n    for (char c : A0) {\n        ensuref(c >= '0' && c <= '9', \"A0 contains non-digit character\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 200000, \"N\");\n    inf.readEoln();\n    string A0 = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(A0.length()) == N, \"Length of A0 is not equal to N\");\n\n    ensuref(A0[0] >= '1' && A0[0] <= '9', \"A0 has leading zero\");\n\n    for (char c : A0) {\n        ensuref(c >= '0' && c <= '9', \"A0 contains non-digit character\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 200000, \"N\");\n    inf.readEoln();\n    string A0 = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(A0.length()) == N, \"Length of A0 is not equal to N\");\n\n    ensuref(A0[0] >= '1' && A0[0] <= '9', \"A0 has leading zero\");\n\n    for (char c : A0) {\n        ensuref(c >= '0' && c <= '9', \"A0 contains non-digit character\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <string>\n#include <cstring> // for memcpy, strlen\n#include <cstdio>  // for sprintf\n\nstatic char current[200001]; \nstatic int currentLen;\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // 1) Include <string> so std::string is recognized properly.\n    // 2) Read N, then read the big integer A0 as a std::string (without a pattern).\n    int N = inf.readInt(1, 200000, \"N\");\n    std::string A0 = inf.readToken(); // read the next token (the big integer A0)\n\n    // Copy A0 into 'current'.\n    currentLen = (int)A0.size();\n    if(currentLen < 1 || currentLen > 200000) {\n        quitf(_fail, \"Invalid length of A0\");\n    }\n    memcpy(current, A0.data(), currentLen);\n    current[currentLen] = '\\0';\n\n    // We expect exactly 3 lines from the contestant's output.\n    // After 3 steps, 'current' must be exactly 1 digit.\n    for(int step = 1; step <= 3; step++){\n        if(ouf.eof()){\n            ouf.quitf(_wa, \"Expected 3 lines, got only %d\", step - 1);\n        }\n\n        // Read one full line of output as a std::string.\n        std::string expr = ouf.readLine();\n        int len = (int)expr.size();\n        if(len == 0){\n            ouf.quitf(_wa, \"Empty expression (step %d)\", step);\n        }\n        // Must not start or end with '+'\n        if(expr[0] == '+' || expr[len - 1] == '+'){\n            ouf.quitf(_wa, \"Expression starts/ends with '+' (step %d): \\\"%s\\\"\", step, expr.c_str());\n        }\n\n        // We'll parse tokens separated by '+', summing them, and collect digits for comparison.\n        static char digitsBuf[200001];\n        int dPos = 0;\n        long long total = 0;\n        long long tokenVal = 0;\n        bool haveToken = false;\n\n        // Single pass parse. At the end (i == len), treat it as '+'.\n        for(int i = 0; /*no condition*/; i++){\n            bool atEnd = (i == len);\n            char c = atEnd ? '+' : expr[i];\n            if(c == '+'){\n                if(!haveToken){\n                    ouf.quitf(_wa, \"Empty token found (step %d)\", step);\n                }\n                total += tokenVal;\n                tokenVal = 0;\n                haveToken = false;\n                if(atEnd) break; \n            } else {\n                // Must be a digit\n                if(c < '0' || c > '9'){\n                    ouf.quitf(_wa, \"Non-digit '%c' in expression (step %d): \\\"%s\\\"\", c, step, expr.c_str());\n                }\n                if(!haveToken){\n                    haveToken = true;\n                    tokenVal = 0;\n                }\n                tokenVal = tokenVal * 10 + (c - '0');\n                digitsBuf[dPos++] = c;\n            }\n        }\n\n        // Compare collected digits to old 'current'.\n        if(dPos != currentLen){\n            ouf.quitf(_wa,\n                \"Digit-count mismatch after removing '+' (step %d). Got %d, expected %d\",\n                step, dPos, currentLen);\n        }\n        for(int i = 0; i < dPos; i++){\n            if(digitsBuf[i] != current[i]){\n                ouf.quitf(_wa,\n                    \"Digits differ from old number after removing '+' (step %d)\", step);\n            }\n        }\n\n        // Convert total to string\n        static char sumBuf[32];\n        std::sprintf(sumBuf, \"%lld\", total);\n        int sumLen = (int)std::strlen(sumBuf);\n\n        // If sumLen > 1 and starts with '0', it's a leading zero error.\n        if(sumLen > 1 && sumBuf[0] == '0'){\n            ouf.quitf(_wa, \"Leading zero in intermediate result (step %d)\", step);\n        }\n\n        // Update 'current'\n        memcpy(current, sumBuf, sumLen + 1);\n        currentLen = sumLen;\n    }\n\n    // After 3 steps, 'current' must be exactly 1 digit.\n    if(currentLen != 1){\n        quitf(_wa, \"Final result \\\"%s\\\" is not a single digit\", current);\n    }\n\n    // Everything is correct.\n    quitf(_ok, \"Correct. Final digit: %s\", current);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string a0;\n\n    if (type == \"random\") {\n        // First digit cannot be zero.\n        a0 += '1' + rnd.next(9);\n        for (int i = 1; i < n; ++i) {\n            a0 += '0' + rnd.next(10);  // digits from '0' to '9'\n        }\n    } else if (type == \"maxsum\") {\n        // All digits are '9'\n        a0 = string(n, '9');\n    } else if (type == \"minsum\") {\n        // First digit '1', rest zeros\n        a0 = '1' + string(n - 1, '0');\n    } else if (type == \"ones\") {\n        // All digits are '1'\n        a0 = string(n, '1');\n    } else if (type == \"zerosandones\") {\n        // Alternate '0's and '1's, starting with '1'\n        a0 = '1';\n        for (int i = 1; i < n; ++i) {\n            a0 += (i % 2 == 1) ? '0' : '1';\n        }\n    } else if (type == \"palindrome\") {\n        // Build a palindrome number\n        string half = \"\";\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char digit = '0' + rnd.next(10);\n            if (i == 0 && digit == '0') digit = '1' + rnd.next(9);  // ensure first digit is non-zero\n            half += digit;\n        }\n        string rev_half = half;\n        if (n % 2 == 1) rev_half.pop_back();\n        reverse(rev_half.begin(), rev_half.end());\n        a0 = half + rev_half;\n    } else if (type == \"zerosinmiddle\") {\n        // First and last digit '1', middle zeros\n        if (n == 1) {\n            a0 = \"1\";\n        } else {\n            a0 = '1' + string(n - 2, '0') + '1';\n        }\n    } else if (type == \"manyzeros\") {\n        // Higher chance of zeros in the number\n        a0 += '1' + rnd.next(9);\n        for (int i = 1; i < n; ++i) {\n            int rand_val = rnd.next(10);\n            if (rand_val < 7) a0 += '0';  // 70% chance to be '0'\n            else a0 += '0' + rnd.next(10);  // digits from '0' to '9'\n        }\n    } else {\n        // Default to random\n        a0 += '1' + rnd.next(9);\n        for (int i = 1; i < n; ++i) {\n            a0 += '0' + rnd.next(10);  // digits from '0' to '9'\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", a0.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string a0;\n\n    if (type == \"random\") {\n        // First digit cannot be zero.\n        a0 += '1' + rnd.next(9);\n        for (int i = 1; i < n; ++i) {\n            a0 += '0' + rnd.next(10);  // digits from '0' to '9'\n        }\n    } else if (type == \"maxsum\") {\n        // All digits are '9'\n        a0 = string(n, '9');\n    } else if (type == \"minsum\") {\n        // First digit '1', rest zeros\n        a0 = '1' + string(n - 1, '0');\n    } else if (type == \"ones\") {\n        // All digits are '1'\n        a0 = string(n, '1');\n    } else if (type == \"zerosandones\") {\n        // Alternate '0's and '1's, starting with '1'\n        a0 = '1';\n        for (int i = 1; i < n; ++i) {\n            a0 += (i % 2 == 1) ? '0' : '1';\n        }\n    } else if (type == \"palindrome\") {\n        // Build a palindrome number\n        string half = \"\";\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char digit = '0' + rnd.next(10);\n            if (i == 0 && digit == '0') digit = '1' + rnd.next(9);  // ensure first digit is non-zero\n            half += digit;\n        }\n        string rev_half = half;\n        if (n % 2 == 1) rev_half.pop_back();\n        reverse(rev_half.begin(), rev_half.end());\n        a0 = half + rev_half;\n    } else if (type == \"zerosinmiddle\") {\n        // First and last digit '1', middle zeros\n        if (n == 1) {\n            a0 = \"1\";\n        } else {\n            a0 = '1' + string(n - 2, '0') + '1';\n        }\n    } else if (type == \"manyzeros\") {\n        // Higher chance of zeros in the number\n        a0 += '1' + rnd.next(9);\n        for (int i = 1; i < n; ++i) {\n            int rand_val = rnd.next(10);\n            if (rand_val < 7) a0 += '0';  // 70% chance to be '0'\n            else a0 += '0' + rnd.next(10);  // digits from '0' to '9'\n        }\n    } else {\n        // Default to random\n        a0 += '1' + rnd.next(9);\n        for (int i = 1; i < n; ++i) {\n            a0 += '0' + rnd.next(10);  // digits from '0' to '9'\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", a0.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type minsum\n./gen -n 1 -type maxsum\n./gen -n 1 -type ones\n./gen -n 1 -type zerosinmiddle\n./gen -n 1 -type palindrome\n\n./gen -n 2 -type random\n./gen -n 2 -type minsum\n./gen -n 2 -type zerosandones\n./gen -n 2 -type zerosinmiddle\n./gen -n 2 -type palindrome\n./gen -n 2 -type manyzeros\n./gen -n 2 -type ones\n\n./gen -n 10 -type random\n./gen -n 10 -type palindrome\n./gen -n 10 -type manyzeros\n./gen -n 10 -type zerosandones\n./gen -n 10 -type zerosinmiddle\n./gen -n 10 -type ones\n\n./gen -n 100 -type random\n./gen -n 100 -type maxsum\n./gen -n 100 -type ones\n./gen -n 100 -type zerosandones\n./gen -n 100 -type zerosinmiddle\n\n./gen -n 1000 -type zerosinmiddle\n./gen -n 1000 -type minsum\n./gen -n 1000 -type zerosandones\n./gen -n 1000 -type palindrome\n./gen -n 1000 -type manyzeros\n\n./gen -n 10000 -type random\n./gen -n 10000 -type palindrome\n\n./gen -n 100000 -type manyzeros\n./gen -n 100000 -type zerosandones\n\n./gen -n 200000 -type random\n./gen -n 200000 -type maxsum\n./gen -n 200000 -type ones\n./gen -n 200000 -type zerosinmiddle\n./gen -n 200000 -type manyzeros\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:41.557763",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/B",
      "title": "B. Neural Network country",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains N (1 ≤ N ≤ 106), L (2 ≤ L ≤ 105) and M (2 ≤ M ≤ 100), the number of cities in each layer, the number of layers and the number that travelling cost should be divisible by, respectively.Second, third and fourth line contain N integers each denoting costs 0 ≤ cost ≤ M from entry point to the first layer, costs between adjacent layers as described above, and costs from the last layer to the exit point.",
      "output_spec": "OutputOutput a single integer, the number of paths Doctor G. can take which have total cost divisible by M, modulo 109 + 7.",
      "sample_tests": "ExampleInputCopy2 3 134 62 13 4OutputCopy2",
      "description": "B. Neural Network country\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains N (1 ≤ N ≤ 106), L (2 ≤ L ≤ 105) and M (2 ≤ M ≤ 100), the number of cities in each layer, the number of layers and the number that travelling cost should be divisible by, respectively.Second, third and fourth line contain N integers each denoting costs 0 ≤ cost ≤ M from entry point to the first layer, costs between adjacent layers as described above, and costs from the last layer to the exit point.\n\nOutputOutput a single integer, the number of paths Doctor G. can take which have total cost divisible by M, modulo 109 + 7.\n\nInputCopy2 3 134 62 13 4OutputCopy2\n\nInputCopy2 3 134 62 13 4\n\nOutputCopy2\n\nNoteThis is a country with 3 layers, each layer having 2 cities. Paths , and  are the only paths having total cost divisible by 13. Notice that input edges for layer cities have the same cost, and that they are same for all layers.",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readSpace();\n    int L = inf.readInt(2, 100000, \"L\");\n    inf.readSpace();\n    int M = inf.readInt(2, 100, \"M\");\n    inf.readEoln();\n    \n    vector<int> costs1 = inf.readInts(N, 0, M, \"costs1\");\n    inf.readEoln();\n\n    vector<int> costs2 = inf.readInts(N, 0, M, \"costs2\");\n    inf.readEoln();\n\n    vector<int> costs3 = inf.readInts(N, 0, M, \"costs3\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readSpace();\n    int L = inf.readInt(2, 100000, \"L\");\n    inf.readSpace();\n    int M = inf.readInt(2, 100, \"M\");\n    inf.readEoln();\n    \n    vector<int> costs1 = inf.readInts(N, 0, M, \"costs1\");\n    inf.readEoln();\n\n    vector<int> costs2 = inf.readInts(N, 0, M, \"costs2\");\n    inf.readEoln();\n\n    vector<int> costs3 = inf.readInts(N, 0, M, \"costs3\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readSpace();\n    int L = inf.readInt(2, 100000, \"L\");\n    inf.readSpace();\n    int M = inf.readInt(2, 100, \"M\");\n    inf.readEoln();\n    \n    vector<int> costs1 = inf.readInts(N, 0, M, \"costs1\");\n    inf.readEoln();\n\n    vector<int> costs2 = inf.readInts(N, 0, M, \"costs2\");\n    inf.readEoln();\n\n    vector<int> costs3 = inf.readInts(N, 0, M, \"costs3\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"N\"); // number of cities in each layer\n    int L = opt<int>(\"L\"); // number of layers\n    int M = opt<int>(\"M\"); // the modulo\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> entry_costs(N);\n    vector<int> inter_layer_costs(N);\n    vector<int> exit_costs(N);\n\n    // Now, depending on type, we can generate different test cases.\n\n    if(type == \"zero_cost\") {\n        // All costs are zero\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = 0;\n            inter_layer_costs[i] = 0;\n            exit_costs[i] = 0;\n        }\n    }\n    else if(type == \"max_cost\") {\n        // All costs are M\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = M;\n            inter_layer_costs[i] = M;\n            exit_costs[i] = M;\n        }\n    }\n    else if(type == \"fixed_cost\") {\n        int cost = opt<int>(\"cost\", 0); // Use provided cost, default is 0\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = cost % (M+1);\n            inter_layer_costs[i] = cost % (M+1);\n            exit_costs[i] = cost % (M+1);\n        }\n    }\n    else if(type == \"pattern\") {\n        // Generate costs in a pattern to test specific cases\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = i % (M+1);\n            inter_layer_costs[i] = (N - i - 1) % (M+1);\n            exit_costs[i] = (i * 2) % (M+1);\n        }\n    }\n    else if(type == \"alternating\") {\n        // Alternate between 0 and M\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = (i % 2 == 0) ? 0 : M;\n            inter_layer_costs[i] = (i % 2 == 0) ? M : 0;\n            exit_costs[i] = ((i + 1) % 2 == 0) ? 0 : M;\n        }\n    }\n    else { // default is \"random\"\n        // Generate random costs between 0 and M\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = rnd.next(0, M);\n            inter_layer_costs[i] = rnd.next(0, M);\n            exit_costs[i] = rnd.next(0, M);\n        }\n    }\n\n    // Output N L M\n    printf(\"%d %d %d\\n\", N, L, M);\n    // Output entry costs\n    for(int i=0; i<N; ++i) {\n        printf(\"%d%c\", entry_costs[i], i==N-1 ? '\\n' : ' ');\n    }\n    // Output inter-layer costs\n    for(int i=0; i<N; ++i) {\n        printf(\"%d%c\", inter_layer_costs[i], i==N-1 ? '\\n' : ' ');\n    }\n    // Output exit costs\n    for(int i=0; i<N; ++i) {\n        printf(\"%d%c\", exit_costs[i], i==N-1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"N\"); // number of cities in each layer\n    int L = opt<int>(\"L\"); // number of layers\n    int M = opt<int>(\"M\"); // the modulo\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> entry_costs(N);\n    vector<int> inter_layer_costs(N);\n    vector<int> exit_costs(N);\n\n    // Now, depending on type, we can generate different test cases.\n\n    if(type == \"zero_cost\") {\n        // All costs are zero\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = 0;\n            inter_layer_costs[i] = 0;\n            exit_costs[i] = 0;\n        }\n    }\n    else if(type == \"max_cost\") {\n        // All costs are M\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = M;\n            inter_layer_costs[i] = M;\n            exit_costs[i] = M;\n        }\n    }\n    else if(type == \"fixed_cost\") {\n        int cost = opt<int>(\"cost\", 0); // Use provided cost, default is 0\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = cost % (M+1);\n            inter_layer_costs[i] = cost % (M+1);\n            exit_costs[i] = cost % (M+1);\n        }\n    }\n    else if(type == \"pattern\") {\n        // Generate costs in a pattern to test specific cases\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = i % (M+1);\n            inter_layer_costs[i] = (N - i - 1) % (M+1);\n            exit_costs[i] = (i * 2) % (M+1);\n        }\n    }\n    else if(type == \"alternating\") {\n        // Alternate between 0 and M\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = (i % 2 == 0) ? 0 : M;\n            inter_layer_costs[i] = (i % 2 == 0) ? M : 0;\n            exit_costs[i] = ((i + 1) % 2 == 0) ? 0 : M;\n        }\n    }\n    else { // default is \"random\"\n        // Generate random costs between 0 and M\n        for(int i=0; i<N; ++i) {\n            entry_costs[i] = rnd.next(0, M);\n            inter_layer_costs[i] = rnd.next(0, M);\n            exit_costs[i] = rnd.next(0, M);\n        }\n    }\n\n    // Output N L M\n    printf(\"%d %d %d\\n\", N, L, M);\n    // Output entry costs\n    for(int i=0; i<N; ++i) {\n        printf(\"%d%c\", entry_costs[i], i==N-1 ? '\\n' : ' ');\n    }\n    // Output inter-layer costs\n    for(int i=0; i<N; ++i) {\n        printf(\"%d%c\", inter_layer_costs[i], i==N-1 ? '\\n' : ' ');\n    }\n    // Output exit costs\n    for(int i=0; i<N; ++i) {\n        printf(\"%d%c\", exit_costs[i], i==N-1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal N=1, L=2, M=2\n./gen -N 1 -L 2 -M 2 -type zero_cost\n./gen -N 1 -L 2 -M 2 -type max_cost\n./gen -N 1 -L 2 -M 2 -type random\n\n# Maximal N=1e6, L=1e5, M=100\n./gen -N 1000000 -L 100000 -M 100 -type zero_cost\n./gen -N 1000000 -L 100000 -M 100 -type max_cost\n./gen -N 1000000 -L 100000 -M 100 -type random\n\n# Vary M at boundaries\n./gen -N 500000 -L 50000 -M 2 -type random\n./gen -N 500000 -L 50000 -M 100 -type random\n\n# Fixed cost tests\n./gen -N 1000000 -L 100000 -M 50 -type fixed_cost -cost 25\n./gen -N 1000000 -L 100000 -M 50 -type fixed_cost -cost 0\n./gen -N 1000000 -L 100000 -M 50 -type fixed_cost -cost 50\n\n# Pattern cost tests\n./gen -N 100000 -L 10000 -M 99 -type pattern\n./gen -N 1 -L 100000 -M 100 -type pattern\n./gen -N 1000000 -L 2 -M 100 -type pattern\n\n# Alternating costs\n./gen -N 1000000 -L 100000 -M 100 -type alternating\n\n# Random tests with varying N and L\n./gen -N 123456 -L 65432 -M 45 -type random\n./gen -N 999999 -L 88888 -M 2 -type random\n./gen -N 10 -L 2 -M 100 -type random\n\n# Edge case where M=2 and costs are zero\n./gen -N 1000000 -L 100000 -M 2 -type zero_cost\n\n# Edge case where M=100 and costs are maximum\n./gen -N 1000000 -L 100000 -M 100 -type max_cost\n\n# Test with N=1 and large L\n./gen -N 1 -L 100000 -M 50 -type random\n\n# Test with L=2 and large N\n./gen -N 1000000 -L 2 -M 50 -type random\n\n# Tiny test case similar to sample input\n./gen -N 2 -L 3 -M 13 -type fixed_cost -cost 4\n\n# Random tests with small N and L\n./gen -N 5 -L 5 -M 7 -type random\n./gen -N 10 -L 10 -M 2 -type random\n\n# Random test with M=99\n./gen -N 1000000 -L 100000 -M 99 -type random\n\n# Random test with M in the middle\n./gen -N 1000000 -L 100000 -M 50 -type random\n\n# Test with M=2 and alternating costs\n./gen -N 100000 -L 100000 -M 2 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:43.428049",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/C",
      "title": "C. Property",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer number n (2 ≤ n ≤ 50000), representing number of edges of 2n-sided polygon.The second line contains n distinct integer numbers B2k (0 ≤ B2k ≤ n - 1,  k = 0... n - 1) separated by a single space, representing points the court chose. If B2k = i, the court chose point Pi on side A2k A2k + 1.",
      "output_spec": "OutputOutput contains n distinct integers separated by a single space representing points B1, B3, ..., B2n - 1 Bill should choose in order to maximize the property area. If there are multiple solutions that maximize the area, return any of them.",
      "sample_tests": "ExampleInputCopy30 1 2OutputCopy0 2 1",
      "description": "C. Property\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer number n (2 ≤ n ≤ 50000), representing number of edges of 2n-sided polygon.The second line contains n distinct integer numbers B2k (0 ≤ B2k ≤ n - 1,  k = 0... n - 1) separated by a single space, representing points the court chose. If B2k = i, the court chose point Pi on side A2k A2k + 1.\n\nOutputOutput contains n distinct integers separated by a single space representing points B1, B3, ..., B2n - 1 Bill should choose in order to maximize the property area. If there are multiple solutions that maximize the area, return any of them.\n\nInputCopy30 1 2OutputCopy0 2 1\n\nInputCopy30 1 2\n\nOutputCopy0 2 1\n\nNoteTo maximize area Bill should choose points: B1 = P0, B3 = P2, B5 = P1",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readEoln();\n\n    vector<int> B = inf.readInts(n, 0, n - 1);\n    inf.readEoln();\n\n    set<int> s(B.begin(), B.end());\n    ensuref((int)s.size() == n, \"The numbers B2k must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readEoln();\n\n    vector<int> B = inf.readInts(n, 0, n - 1);\n    inf.readEoln();\n\n    set<int> s(B.begin(), B.end());\n    ensuref((int)s.size() == n, \"The numbers B2k must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readEoln();\n\n    vector<int> B = inf.readInts(n, 0, n - 1);\n    inf.readEoln();\n\n    set<int> s(B.begin(), B.end());\n    ensuref((int)s.size() == n, \"The numbers B2k must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    inf.readEoln();\n    std::vector<int> court_choices = inf.readInts(n, 0, n - 1);\n\n    // Read Bill's choices from the contestant's output\n    std::vector<int> bill_choices = ouf.readInts(n, 0, n - 1, \"Bill's choices\");\n\n    // Check if all Bill's choices are distinct\n    std::set<int> unique_choices(bill_choices.begin(), bill_choices.end());\n    if (unique_choices.size() != n) {\n        quitf(_wa, \"Bill's choices are not distinct\");\n    }\n\n    // If all checks pass, the output is accepted\n    quitf(_ok, \"Bill's choices are valid\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> B_even(n);\n\n    if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i) {\n            B_even[i] = i;\n        }\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i) {\n            B_even[i] = n - 1 - i;\n        }\n    } else if (type == \"alternate\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                B_even[i] = i / 2;\n            else\n                B_even[i] = n - 1 - i / 2;\n        }\n    } else if (type == \"evenfirst\") {\n        vector<int> even_indices;\n        vector<int> odd_indices;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                even_indices.push_back(i);\n            else\n                odd_indices.push_back(i);\n        }\n        int idx = 0;\n        for(int x : even_indices)\n            B_even[idx++] = x;\n        for(int x : odd_indices)\n            B_even[idx++] = x;\n    } else if (type == \"oddfirst\") {\n        vector<int> even_indices;\n        vector<int> odd_indices;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                even_indices.push_back(i);\n            else\n                odd_indices.push_back(i);\n        }\n        int idx = 0;\n        for(int x : odd_indices)\n            B_even[idx++] = x;\n        for(int x : even_indices)\n            B_even[idx++] = x;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            B_even[i] = i;\n        shuffle(B_even.begin(), B_even.end());\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            B_even[i] = i;\n        shuffle(B_even.begin(), B_even.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", B_even[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> B_even(n);\n\n    if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i) {\n            B_even[i] = i;\n        }\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i) {\n            B_even[i] = n - 1 - i;\n        }\n    } else if (type == \"alternate\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                B_even[i] = i / 2;\n            else\n                B_even[i] = n - 1 - i / 2;\n        }\n    } else if (type == \"evenfirst\") {\n        vector<int> even_indices;\n        vector<int> odd_indices;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                even_indices.push_back(i);\n            else\n                odd_indices.push_back(i);\n        }\n        int idx = 0;\n        for(int x : even_indices)\n            B_even[idx++] = x;\n        for(int x : odd_indices)\n            B_even[idx++] = x;\n    } else if (type == \"oddfirst\") {\n        vector<int> even_indices;\n        vector<int> odd_indices;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                even_indices.push_back(i);\n            else\n                odd_indices.push_back(i);\n        }\n        int idx = 0;\n        for(int x : odd_indices)\n            B_even[idx++] = x;\n        for(int x : even_indices)\n            B_even[idx++] = x;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            B_even[i] = i;\n        shuffle(B_even.begin(), B_even.end());\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            B_even[i] = i;\n        shuffle(B_even.begin(), B_even.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", B_even[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type alternate\n\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type evenfirst\n./gen -n 5 -type oddfirst\n./gen -n 5 -type random\n\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type evenfirst\n./gen -n 10 -type oddfirst\n./gen -n 10 -type random\n\n./gen -n 50 -type increasing\n./gen -n 50 -type decreasing\n./gen -n 50 -type alternate\n./gen -n 50 -type random\n\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n./gen -n 10000 -type random\n\n./gen -n 50000 -type increasing\n./gen -n 50000 -type decreasing\n./gen -n 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:45.124626",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/D",
      "title": "D. Exploration plan",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers: V, E, N and K (1 ≤  V  ≤  600,  1  ≤  E  ≤  20000,  1  ≤  N  ≤  min(V, 200),  1  ≤  K  ≤  N), number of cities, number of roads, number of teams and the smallest number of different cities they need to end up in, respectively.The second line contains N integers, the cities where the teams start their journey.Next E lines contain information about the roads in following format: Ai Bi Ti (1 ≤ Ai, Bi ≤ V,  1 ≤ Ti ≤ 10000), which means that there is a road connecting cities Ai and Bi, and you need Ti minutes to cross that road.",
      "output_spec": "OutputOutput a single integer that represents the minimal time the teams can move for, such that they end up in at least K different cities or output -1 if there is no solution.If the solution exists, result will be no greater than 1731311.",
      "sample_tests": "ExampleInputCopy6 7 5 45 5 2 2 51 3 31 5 21 6 52 5 42 6 73 4 113 5 3OutputCopy3",
      "description": "D. Exploration plan\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers: V, E, N and K (1 ≤  V  ≤  600,  1  ≤  E  ≤  20000,  1  ≤  N  ≤  min(V, 200),  1  ≤  K  ≤  N), number of cities, number of roads, number of teams and the smallest number of different cities they need to end up in, respectively.The second line contains N integers, the cities where the teams start their journey.Next E lines contain information about the roads in following format: Ai Bi Ti (1 ≤ Ai, Bi ≤ V,  1 ≤ Ti ≤ 10000), which means that there is a road connecting cities Ai and Bi, and you need Ti minutes to cross that road.\n\nOutputOutput a single integer that represents the minimal time the teams can move for, such that they end up in at least K different cities or output -1 if there is no solution.If the solution exists, result will be no greater than 1731311.\n\nInputCopy6 7 5 45 5 2 2 51 3 31 5 21 6 52 5 42 6 73 4 113 5 3OutputCopy3\n\nInputCopy6 7 5 45 5 2 2 51 3 31 5 21 6 52 5 42 6 73 4 113 5 3\n\nOutputCopy3\n\nNoteThree teams start from city 5, and two teams start from city 2. If they agree to move for 3 minutes, one possible situation would be the following: Two teams in city 2, one team in city 5, one team in city 3 , and one team in city 1. And we see that there are four different cities the teams end their journey at.",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int V = inf.readInt(1, 600, \"V\");\n    inf.readSpace();\n    int E = inf.readInt(1, 20000, \"E\");\n    inf.readSpace();\n    int N = inf.readInt(1, min(V,200), \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, N, \"K\");\n    inf.readEoln();\n    \n    vector<int> starting_cities = inf.readInts(N, 1, V);\n    inf.readEoln();\n\n    for (int i = 0; i < E; i++) {\n        int Ai = inf.readInt(1, V, \"Ai[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int Bi = inf.readInt(1, V, \"Bi[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int Ti = inf.readInt(1, 10000, \"Ti[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int V = inf.readInt(1, 600, \"V\");\n    inf.readSpace();\n    int E = inf.readInt(1, 20000, \"E\");\n    inf.readSpace();\n    int N = inf.readInt(1, min(V,200), \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, N, \"K\");\n    inf.readEoln();\n    \n    vector<int> starting_cities = inf.readInts(N, 1, V);\n    inf.readEoln();\n\n    for (int i = 0; i < E; i++) {\n        int Ai = inf.readInt(1, V, \"Ai[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int Bi = inf.readInt(1, V, \"Bi[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int Ti = inf.readInt(1, 10000, \"Ti[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int V = inf.readInt(1, 600, \"V\");\n    inf.readSpace();\n    int E = inf.readInt(1, 20000, \"E\");\n    inf.readSpace();\n    int N = inf.readInt(1, min(V,200), \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, N, \"K\");\n    inf.readEoln();\n    \n    vector<int> starting_cities = inf.readInts(N, 1, V);\n    inf.readEoln();\n\n    for (int i = 0; i < E; i++) {\n        int Ai = inf.readInt(1, V, \"Ai[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int Bi = inf.readInt(1, V, \"Bi[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int Ti = inf.readInt(1, 10000, \"Ti[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int V = opt<int>(\"v\");\n    int E = opt<int>(\"e\", -1);\n    int N = opt<int>(\"n\");\n    int K = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints\n    V = min(max(1, V), 600);\n    N = min(max(1, N), min(V, 200));\n    if (N > V) N = V; // Adjust N if necessary\n    K = min(max(1, K), N);\n\n    int maxE = min(20000, V * (V - 1) / 2);\n    if (E == -1) {\n        if (type == \"sparse\")\n            E = V - 1;\n        else if (type == \"dense\")\n            E = maxE;\n        else\n            E = rnd.next(V - 1, maxE);\n    } else {\n        E = min(max(V - 1, E), 20000);\n    }\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edgeSet;\n\n    // Generate edges based on type\n    if (type == \"random\" || type == \"sparse\" || type == \"dense\") {\n        // Generate a connected graph\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        // Create a random spanning tree\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n            edgeSet.insert({min(u, v), max(u, v)});\n        }\n\n        // Add extra edges to reach E edges\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            pair<int, int> edge = {min(u, v), max(u, v)};\n            if (edgeSet.count(edge) == 0 || rnd.next(0, 1)) {\n                edges.push_back({u, v});\n                if (edgeSet.size() < V * (V - 1) / 2)\n                    edgeSet.insert(edge);\n            }\n        }\n    } else if (type == \"disconnected\") {\n        // Generate a disconnected graph\n        // Split the graph into two components\n        int V1 = V / 2;\n        int V2 = V - V1;\n\n        // Component 1\n        vector<int> comp1(V1);\n        for (int i = 0; i < V1; ++i) comp1[i] = i;\n        for (int i = 1; i < V1; ++i) {\n            int u = comp1[i];\n            int v = comp1[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n        // Component 2\n        vector<int> comp2(V2);\n        for (int i = 0; i < V2; ++i) comp2[i] = V1 + i;\n        for (int i = 1; i < V2; ++i) {\n            int u = comp2[i];\n            int v = comp2[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n        // Add extra edges randomly within components\n        while ((int)edges.size() < E) {\n            int comp = rnd.next(0, 1);\n            int u, v;\n            if (comp == 0) {\n                u = comp1[rnd.next(0, V1 - 1)];\n                v = comp1[rnd.next(0, V1 - 1)];\n            } else {\n                u = comp2[rnd.next(0, V2 - 1)];\n                v = comp2[rnd.next(0, V2 - 1)];\n            }\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"multiple_edges\") {\n        // Generate a connected graph with multiple edges\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        // Create a random spanning tree\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n\n        // Add random extra edges, including multiple edges\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"impossible\") {\n        // Generate a case where it's impossible to achieve required K\n        // For example, all teams start at the same city and cannot reach others\n        N = K;\n        K = K;\n        V = N;\n        E = 0;\n        edges.clear();\n    } else if (type == \"same_start\") {\n        // Generate a connected graph, all teams start at the same city\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"diff_start\") {\n        // Generate a connected graph, all teams start at different cities\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    }\n\n    // Generate starting positions\n    vector<int> starting_positions;\n    if (type == \"impossible\") {\n        starting_positions.assign(N, 0);\n    } else if (type == \"same_start\") {\n        int start_city = rnd.next(0, V - 1);\n        starting_positions.assign(N, start_city);\n    } else if (type == \"diff_start\") {\n        N = min(N, V);\n        for (int i = 0; i < N; ++i) starting_positions.push_back(i);\n        shuffle(starting_positions.begin(), starting_positions.end());\n    } else {\n        for (int i = 0; i < N; ++i) starting_positions.push_back(rnd.next(0, V - 1));\n    }\n\n    // Generate weights\n    vector<int> weights;\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int Ti = rnd.next(1, 10000);\n        weights.push_back(Ti);\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", V, (int)edges.size(), N, K);\n\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d%c\", starting_positions[i] + 1, (i == N - 1) ? '\\n' : ' ');\n    }\n\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int Ai = edges[i].first + 1;\n        int Bi = edges[i].second + 1;\n        int Ti = weights[i];\n        printf(\"%d %d %d\\n\", Ai, Bi, Ti);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int V = opt<int>(\"v\");\n    int E = opt<int>(\"e\", -1);\n    int N = opt<int>(\"n\");\n    int K = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints\n    V = min(max(1, V), 600);\n    N = min(max(1, N), min(V, 200));\n    if (N > V) N = V; // Adjust N if necessary\n    K = min(max(1, K), N);\n\n    int maxE = min(20000, V * (V - 1) / 2);\n    if (E == -1) {\n        if (type == \"sparse\")\n            E = V - 1;\n        else if (type == \"dense\")\n            E = maxE;\n        else\n            E = rnd.next(V - 1, maxE);\n    } else {\n        E = min(max(V - 1, E), 20000);\n    }\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edgeSet;\n\n    // Generate edges based on type\n    if (type == \"random\" || type == \"sparse\" || type == \"dense\") {\n        // Generate a connected graph\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        // Create a random spanning tree\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n            edgeSet.insert({min(u, v), max(u, v)});\n        }\n\n        // Add extra edges to reach E edges\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            pair<int, int> edge = {min(u, v), max(u, v)};\n            if (edgeSet.count(edge) == 0 || rnd.next(0, 1)) {\n                edges.push_back({u, v});\n                if (edgeSet.size() < V * (V - 1) / 2)\n                    edgeSet.insert(edge);\n            }\n        }\n    } else if (type == \"disconnected\") {\n        // Generate a disconnected graph\n        // Split the graph into two components\n        int V1 = V / 2;\n        int V2 = V - V1;\n\n        // Component 1\n        vector<int> comp1(V1);\n        for (int i = 0; i < V1; ++i) comp1[i] = i;\n        for (int i = 1; i < V1; ++i) {\n            int u = comp1[i];\n            int v = comp1[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n        // Component 2\n        vector<int> comp2(V2);\n        for (int i = 0; i < V2; ++i) comp2[i] = V1 + i;\n        for (int i = 1; i < V2; ++i) {\n            int u = comp2[i];\n            int v = comp2[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n        // Add extra edges randomly within components\n        while ((int)edges.size() < E) {\n            int comp = rnd.next(0, 1);\n            int u, v;\n            if (comp == 0) {\n                u = comp1[rnd.next(0, V1 - 1)];\n                v = comp1[rnd.next(0, V1 - 1)];\n            } else {\n                u = comp2[rnd.next(0, V2 - 1)];\n                v = comp2[rnd.next(0, V2 - 1)];\n            }\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"multiple_edges\") {\n        // Generate a connected graph with multiple edges\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        // Create a random spanning tree\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n\n        // Add random extra edges, including multiple edges\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"impossible\") {\n        // Generate a case where it's impossible to achieve required K\n        // For example, all teams start at the same city and cannot reach others\n        N = K;\n        K = K;\n        V = N;\n        E = 0;\n        edges.clear();\n    } else if (type == \"same_start\") {\n        // Generate a connected graph, all teams start at the same city\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"diff_start\") {\n        // Generate a connected graph, all teams start at different cities\n        vector<int> perm(V);\n        for (int i = 0; i < V; ++i) perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 1; i < V; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n\n        while ((int)edges.size() < E) {\n            int u = rnd.next(0, V - 1);\n            int v = rnd.next(0, V - 1);\n            if (u == v) continue;\n            edges.push_back({u, v});\n        }\n    }\n\n    // Generate starting positions\n    vector<int> starting_positions;\n    if (type == \"impossible\") {\n        starting_positions.assign(N, 0);\n    } else if (type == \"same_start\") {\n        int start_city = rnd.next(0, V - 1);\n        starting_positions.assign(N, start_city);\n    } else if (type == \"diff_start\") {\n        N = min(N, V);\n        for (int i = 0; i < N; ++i) starting_positions.push_back(i);\n        shuffle(starting_positions.begin(), starting_positions.end());\n    } else {\n        for (int i = 0; i < N; ++i) starting_positions.push_back(rnd.next(0, V - 1));\n    }\n\n    // Generate weights\n    vector<int> weights;\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int Ti = rnd.next(1, 10000);\n        weights.push_back(Ti);\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", V, (int)edges.size(), N, K);\n\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d%c\", starting_positions[i] + 1, (i == N - 1) ? '\\n' : ' ');\n    }\n\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int Ai = edges[i].first + 1;\n        int Bi = edges[i].second + 1;\n        int Ti = weights[i];\n        printf(\"%d %d %d\\n\", Ai, Bi, Ti);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -v 1 -n 1 -k 1 -type random\n\n# Small random connected graphs\n./gen -v 5 -n 3 -k 2 -type random\n./gen -v 10 -n 5 -k 3 -type random\n\n# Sparse graphs\n./gen -v 50 -n 10 -k 5 -type sparse\n./gen -v 100 -n 20 -k 10 -type sparse\n\n# Dense graphs\n./gen -v 50 -n 10 -k 5 -type dense\n./gen -v 100 -n 20 -k 10 -type dense\n\n# Graph with multiple edges\n./gen -v 50 -n 15 -k 10 -type multiple_edges\n./gen -v 100 -n 20 -k 15 -type multiple_edges\n\n# Disconnected graphs\n./gen -v 50 -n 10 -k 5 -type disconnected\n./gen -v 100 -n 20 -k 10 -type disconnected\n\n# All teams start at the same city\n./gen -v 50 -n 15 -k 10 -type same_start\n./gen -v 100 -n 20 -k 15 -type same_start\n\n# All teams start at different cities\n./gen -v 50 -n 15 -k 10 -type diff_start\n./gen -v 100 -n 20 -k 20 -type diff_start\n\n# Impossible cases\n./gen -v 10 -n 5 -k 6 -type impossible\n./gen -v 20 -n 10 -k 15 -type impossible\n\n# Maximum input sizes\n./gen -v 600 -n 200 -k 200 -type random\n./gen -v 600 -n 200 -k 100 -type random\n./gen -v 600 -n 200 -k 200 -type dense\n./gen -v 600 -n 200 -k 200 -type multiple_edges\n\n# Random graphs with various sizes\n./gen -v 200 -n 100 -k 50 -type random\n./gen -v 300 -n 150 -k 100 -type random\n\n# Edge cases with K equal to N\n./gen -v 50 -n 30 -k 30 -type random\n./gen -v 100 -n 50 -k 50 -type random\n\n# Edge cases with K equal to 1\n./gen -v 50 -n 30 -k 1 -type random\n./gen -v 100 -n 50 -k 1 -type random\n\n# Edge cases with minimal E\n./gen -v 100 -e 99 -n 50 -k 25 -type random\n./gen -v 200 -e 199 -n 100 -k 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:47.225655",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/E",
      "title": "E. Casinos and travel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line, a positive integer N (1 ≤ N ≤ 100000), the number of cities. In the next N - 1 lines, two numbers a,  b (1 ≤ a, b ≤ N) separated by a single space meaning that cities a and b are connected by a bidirectional road.",
      "output_spec": "OutputOutput one number, the answer to the problem modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy4InputCopy31 22 3OutputCopy10",
      "description": "E. Casinos and travel\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputIn the first line, a positive integer N (1 ≤ N ≤ 100000), the number of cities. In the next N - 1 lines, two numbers a,  b (1 ≤ a, b ≤ N) separated by a single space meaning that cities a and b are connected by a bidirectional road.\n\nOutputOutput one number, the answer to the problem modulo 109 + 7.\n\nInputCopy21 2OutputCopy4InputCopy31 22 3OutputCopy10\n\nInputCopy21 2\n\nOutputCopy4\n\nInputCopy31 22 3\n\nOutputCopy10\n\nNoteExample 1: If Jack selects city 1 as John's starting city, he can either build 0 casinos, so John will be happy all the time, or build a casino in both cities, so John would visit a casino in city 1, become unhappy, then go to city 2, visit a casino there and become happy and his journey ends there because he can't go back to city 1. If Jack selects city 2 for start, everything is symmetrical, so the answer is 4.Example 2: If Jack tells John to start from city 1, he can either build casinos in 0 or 2 cities (total 4 possibilities). If he tells him to start from city 2, then John's journey will either contain cities 2 and 1 or 2 and 3. Therefore, Jack will either have to build no casinos, or build them in all three cities. With other options, he risks John ending his journey unhappy. Starting from 3 is symmetric to starting from 1, so in total we have 4 + 2 + 4 = 10 options.",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a != b)\n        parent[a] = b;\n    else\n        ensuref(false, \"Cycle detected when processing edge between %d and %d\", a, b);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    for (int i = 1; i <= N; ++i)\n        parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a = inf.readInt(1, N, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, N, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected at line %d\", i + 2);\n\n        if (a > b) swap(a, b); // To ensure that (a,b) and (b,a) are considered the same edge\n\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between node %d and node %d\", a, b);\n\n        edges.insert({a, b});\n\n        union_sets(a, b);\n    }\n\n    ensuref(edges.size() == N - 1, \"Number of unique edges is not N - 1\");\n\n    set<int> components;\n    for (int i = 1; i <= N; ++i) {\n        components.insert(find(i));\n    }\n\n    ensuref(components.size() == 1, \"Graph is not connected, found %d components\", (int)components.size());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a != b)\n        parent[a] = b;\n    else\n        ensuref(false, \"Cycle detected when processing edge between %d and %d\", a, b);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    for (int i = 1; i <= N; ++i)\n        parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a = inf.readInt(1, N, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, N, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected at line %d\", i + 2);\n\n        if (a > b) swap(a, b); // To ensure that (a,b) and (b,a) are considered the same edge\n\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between node %d and node %d\", a, b);\n\n        edges.insert({a, b});\n\n        union_sets(a, b);\n    }\n\n    ensuref(edges.size() == N - 1, \"Number of unique edges is not N - 1\");\n\n    set<int> components;\n    for (int i = 1; i <= N; ++i) {\n        components.insert(find(i));\n    }\n\n    ensuref(components.size() == 1, \"Graph is not connected, found %d components\", (int)components.size());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a != b)\n        parent[a] = b;\n    else\n        ensuref(false, \"Cycle detected when processing edge between %d and %d\", a, b);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    for (int i = 1; i <= N; ++i)\n        parent[i] = i;\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a = inf.readInt(1, N, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, N, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected at line %d\", i + 2);\n\n        if (a > b) swap(a, b); // To ensure that (a,b) and (b,a) are considered the same edge\n\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between node %d and node %d\", a, b);\n\n        edges.insert({a, b});\n\n        union_sets(a, b);\n    }\n\n    ensuref(edges.size() == N - 1, \"Number of unique edges is not N - 1\");\n\n    set<int> components;\n    for (int i = 1; i <= N; ++i) {\n        components.insert(find(i));\n    }\n\n    ensuref(components.size() == 1, \"Graph is not connected, found %d components\", (int)components.size());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output_tree(int n, vector<int>& p) {\n    // permute the vertex labels\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Build edges\n    vector<pair<int,int> > edges;\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i];\n        int v = perm[p[i]];\n        // Randomly swap u and v\n        if (rnd.next(0, 1))\n            swap(u, v);\n        edges.push_back({u, v});\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"chain\") {\n        // Chain tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = i - 1;\n        }\n    }\n    else if (type == \"star\") {\n        // Star tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = 0;\n        }\n    }\n    else if (type == \"binary\") {\n        // Complete binary tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = (i - 1) / 2;\n        }\n    }\n    else if (type == \"skewed\") {\n        // Skewed tree\n        int curr = 0;\n        for (int i = 1; i < n; ++i) {\n            p[i] = curr;\n            curr = i;\n        }\n    }\n    else {\n        // Random tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n        }\n    }\n\n    output_tree(n, p);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output_tree(int n, vector<int>& p) {\n    // permute the vertex labels\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Build edges\n    vector<pair<int,int> > edges;\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i];\n        int v = perm[p[i]];\n        // Randomly swap u and v\n        if (rnd.next(0, 1))\n            swap(u, v);\n        edges.push_back({u, v});\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"chain\") {\n        // Chain tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = i - 1;\n        }\n    }\n    else if (type == \"star\") {\n        // Star tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = 0;\n        }\n    }\n    else if (type == \"binary\") {\n        // Complete binary tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = (i - 1) / 2;\n        }\n    }\n    else if (type == \"skewed\") {\n        // Skewed tree\n        int curr = 0;\n        for (int i = 1; i < n; ++i) {\n            p[i] = curr;\n            curr = i;\n        }\n    }\n    else {\n        // Random tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n        }\n    }\n\n    output_tree(n, p);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type binary\n./gen -n 1 -type skewed\n./gen -n 1 -type random\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type skewed\n./gen -n 2 -type random\n\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type binary\n./gen -n 5 -type skewed\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type skewed\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type skewed\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type skewed\n./gen -n 1000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type skewed\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:49.164377",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/F",
      "title": "F. Product transformation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and only line of input contains four integers N, M, a, Q (7 ≤ Q ≤ 109 + 123, 2 ≤ a ≤ 106 + 123, ,  is prime), where  is the multiplicative order of the integer a modulo Q, see notes for definition.",
      "output_spec": "OutputYou should output the array A from left to right.",
      "sample_tests": "ExampleInputCopy2 2 2 7OutputCopy1 2",
      "description": "F. Product transformation\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and only line of input contains four integers N, M, a, Q (7 ≤ Q ≤ 109 + 123, 2 ≤ a ≤ 106 + 123, ,  is prime), where  is the multiplicative order of the integer a modulo Q, see notes for definition.\n\nOutputYou should output the array A from left to right.\n\nInputCopy2 2 2 7OutputCopy1 2\n\nInputCopy2 2 2 7\n\nOutputCopy1 2\n\nNoteThe multiplicative order of a number a modulo Q , is the smallest natural number x such that ax mod Q = 1. For example, .",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A simple function to check primality of a number up to about 1e9+.\n// This is enough for Q ≤ 10^9+123.\nbool isPrime(long long x) {\n    if (x < 2) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    for (long long i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    // Read N (at least 1), M (at least 0). \n    // We do not have an explicit upper bound for them in the statement, so we allow any 64-bit range that makes sense.\n    long long N = inf.readLong(1, LLONG_MAX, \"N\");\n    inf.readSpace();\n    \n    long long M = inf.readLong(0, LLONG_MAX, \"M\");\n    inf.readSpace();\n\n    // a in [2, 10^6+123]\n    long long a = inf.readLong(2, 1000000LL + 123, \"a\");\n    inf.readSpace();\n\n    // Q in [7, 10^9+123], Q must be prime\n    long long Q = inf.readLong(7, 1000000000LL + 123, \"Q\");\n    inf.readEoln();\n\n    // Check if Q is prime\n    ensuref(isPrime(Q), \"Q must be prime\");\n\n    // Ensure gcd(a, Q) == 1 for the multiplicative order of a modulo Q to be well-defined\n    // Since Q is prime, this is equivalent to ensuring a is not a multiple of Q.\n    ensuref(std::gcd(a, Q) == 1, \"gcd(a, Q) must be 1, otherwise no well-defined multiplicative order\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A simple function to check primality of a number up to about 1e9+.\n// This is enough for Q ≤ 10^9+123.\nbool isPrime(long long x) {\n    if (x < 2) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    for (long long i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    // Read N (at least 1), M (at least 0). \n    // We do not have an explicit upper bound for them in the statement, so we allow any 64-bit range that makes sense.\n    long long N = inf.readLong(1, LLONG_MAX, \"N\");\n    inf.readSpace();\n    \n    long long M = inf.readLong(0, LLONG_MAX, \"M\");\n    inf.readSpace();\n\n    // a in [2, 10^6+123]\n    long long a = inf.readLong(2, 1000000LL + 123, \"a\");\n    inf.readSpace();\n\n    // Q in [7, 10^9+123], Q must be prime\n    long long Q = inf.readLong(7, 1000000000LL + 123, \"Q\");\n    inf.readEoln();\n\n    // Check if Q is prime\n    ensuref(isPrime(Q), \"Q must be prime\");\n\n    // Ensure gcd(a, Q) == 1 for the multiplicative order of a modulo Q to be well-defined\n    // Since Q is prime, this is equivalent to ensuring a is not a multiple of Q.\n    ensuref(std::gcd(a, Q) == 1, \"gcd(a, Q) must be 1, otherwise no well-defined multiplicative order\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A simple function to check primality of a number up to about 1e9+.\n// This is enough for Q ≤ 10^9+123.\nbool isPrime(long long x) {\n    if (x < 2) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    for (long long i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    // Read N (at least 1), M (at least 0). \n    // We do not have an explicit upper bound for them in the statement, so we allow any 64-bit range that makes sense.\n    long long N = inf.readLong(1, LLONG_MAX, \"N\");\n    inf.readSpace();\n    \n    long long M = inf.readLong(0, LLONG_MAX, \"M\");\n    inf.readSpace();\n\n    // a in [2, 10^6+123]\n    long long a = inf.readLong(2, 1000000LL + 123, \"a\");\n    inf.readSpace();\n\n    // Q in [7, 10^9+123], Q must be prime\n    long long Q = inf.readLong(7, 1000000000LL + 123, \"Q\");\n    inf.readEoln();\n\n    // Check if Q is prime\n    ensuref(isPrime(Q), \"Q must be prime\");\n\n    // Ensure gcd(a, Q) == 1 for the multiplicative order of a modulo Q to be well-defined\n    // Since Q is prime, this is equivalent to ensuring a is not a multiple of Q.\n    ensuref(std::gcd(a, Q) == 1, \"gcd(a, Q) must be 1, otherwise no well-defined multiplicative order\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a SINGLE TEST CASE each time it is run.\n  To get multiple test cases, you should run it multiple times with different arguments.\n\n  Usage examples:\n    ./gen -n 10 -m 5 -a 2 -q 7\n    ./gen -type small\n    ./gen -type random\n    ./gen -type largeN\n    ./gen -type largeM\n    ./gen -type bothLarge\n    ./gen -type nearQ\n    ./gen -type manual -n 999 -m 100000 -a 124 -q 999983\n*/\n\nstatic vector<long long> candidatePrimes = {\n    7, 31, 131, 1013, 10007, 100003, 999983,\n    1000003, 999999937, 999999929, 1000000007\n};\n\nint main(int argc, char* argv[]) {\n    // Register generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters (if not provided, use default sentinel values)\n    int n = opt<int>(\"n\", -1);\n    long long m = opt<long long>(\"m\", -1);\n    long long a = opt<long long>(\"a\", -1);\n    long long q = opt<long long>(\"q\", -1);\n    string type = opt<string>(\"type\", \"manual\");\n\n    // Helper lambda: pick a random prime from candidatePrimes\n    auto pickRandomPrime = [&]() {\n        return candidatePrimes[rnd.next((int)candidatePrimes.size())];\n    };\n\n    // If the user wants a special type, ignore the manual parameters (unless \"manual\").\n    if (type == \"small\") {\n        // Very small corner\n        // N=2, M=2, a=2, Q=7\n        n = 2;\n        m = 2;\n        a = 2;\n        q = 7;\n    }\n    else if (type == \"random\") {\n        // A random moderate test\n        // n in [2..10000], m in [0..10000],\n        // q from candidatePrimes, a in [2..q-1]\n        // ensuring gcd(a,q)=1 is trivial since q is prime and a < q.\n        if (n < 0)  n = rnd.next(2, 10000);\n        if (m < 0)  m = rnd.next(0LL, 10000LL);\n        if (q < 0)  q = pickRandomPrime();\n        // Now pick a in [2..q-1]\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"largeN\") {\n        // Large N, moderate M\n        if (n < 0)  n = 100000;\n        if (m < 0)  m = rnd.next(0LL, 1000LL);\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"largeM\") {\n        // Moderate N, large M\n        if (n < 0)  n = rnd.next(2, 2000);\n        if (m < 0)  m = 100000;  // or up to ~1e5\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"bothLarge\") {\n        // Large N and M\n        if (n < 0)  n = 100000;\n        if (m < 0)  m = 100000;\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"nearQ\") {\n        // a close to q\n        // pick a prime q, pick a = q-1\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = q - 1; // guaranteed gcd(a,q)=1 since q prime\n        if (n < 0)  n = rnd.next(2, 1000);\n        if (m < 0)  m = rnd.next(0LL, 1000LL);\n    }\n    else if (type == \"manual\") {\n        // Use user-supplied or pick random defaults if not provided.\n        // For safety, if any param is still -1, pick random.\n        if (n < 0)  n = rnd.next(2, 1000);\n        if (m < 0)  m = rnd.next(0LL, 1000LL);\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else {\n        // Fallback if unknown type\n        // Just pick a small random test\n        if (n < 0)  n = rnd.next(2, 10);\n        if (m < 0)  m = rnd.next(0LL, 10LL);\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n\n    // Final sanity checks:\n    // Ensure n >= 2\n    // The problem example used N=2. We'll keep N >= 2 to have a meaningful scenario.\n    if (n < 2) n = 2;\n\n    // Ensure q >= 7. (We only pick from candidatePrimes, which are >=7.)\n    // Ensure gcd(a, q) = 1 if q is prime and 2 <= a < q.\n    // If somehow a >= q, adjust it:\n    if (a >= q) {\n        a = (a % (q - 1)) + 1;  // ensure 1 < a < q\n        if (a < 2) a = 2;\n        if (a >= q) a = q - 1;\n    }\n\n    // Output a single test: \"N M a Q\"\n    // The problem statement wants them on one line\n    cout << n << \" \" << m << \" \" << a << \" \" << q << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a SINGLE TEST CASE each time it is run.\n  To get multiple test cases, you should run it multiple times with different arguments.\n\n  Usage examples:\n    ./gen -n 10 -m 5 -a 2 -q 7\n    ./gen -type small\n    ./gen -type random\n    ./gen -type largeN\n    ./gen -type largeM\n    ./gen -type bothLarge\n    ./gen -type nearQ\n    ./gen -type manual -n 999 -m 100000 -a 124 -q 999983\n*/\n\nstatic vector<long long> candidatePrimes = {\n    7, 31, 131, 1013, 10007, 100003, 999983,\n    1000003, 999999937, 999999929, 1000000007\n};\n\nint main(int argc, char* argv[]) {\n    // Register generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters (if not provided, use default sentinel values)\n    int n = opt<int>(\"n\", -1);\n    long long m = opt<long long>(\"m\", -1);\n    long long a = opt<long long>(\"a\", -1);\n    long long q = opt<long long>(\"q\", -1);\n    string type = opt<string>(\"type\", \"manual\");\n\n    // Helper lambda: pick a random prime from candidatePrimes\n    auto pickRandomPrime = [&]() {\n        return candidatePrimes[rnd.next((int)candidatePrimes.size())];\n    };\n\n    // If the user wants a special type, ignore the manual parameters (unless \"manual\").\n    if (type == \"small\") {\n        // Very small corner\n        // N=2, M=2, a=2, Q=7\n        n = 2;\n        m = 2;\n        a = 2;\n        q = 7;\n    }\n    else if (type == \"random\") {\n        // A random moderate test\n        // n in [2..10000], m in [0..10000],\n        // q from candidatePrimes, a in [2..q-1]\n        // ensuring gcd(a,q)=1 is trivial since q is prime and a < q.\n        if (n < 0)  n = rnd.next(2, 10000);\n        if (m < 0)  m = rnd.next(0LL, 10000LL);\n        if (q < 0)  q = pickRandomPrime();\n        // Now pick a in [2..q-1]\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"largeN\") {\n        // Large N, moderate M\n        if (n < 0)  n = 100000;\n        if (m < 0)  m = rnd.next(0LL, 1000LL);\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"largeM\") {\n        // Moderate N, large M\n        if (n < 0)  n = rnd.next(2, 2000);\n        if (m < 0)  m = 100000;  // or up to ~1e5\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"bothLarge\") {\n        // Large N and M\n        if (n < 0)  n = 100000;\n        if (m < 0)  m = 100000;\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else if (type == \"nearQ\") {\n        // a close to q\n        // pick a prime q, pick a = q-1\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = q - 1; // guaranteed gcd(a,q)=1 since q prime\n        if (n < 0)  n = rnd.next(2, 1000);\n        if (m < 0)  m = rnd.next(0LL, 1000LL);\n    }\n    else if (type == \"manual\") {\n        // Use user-supplied or pick random defaults if not provided.\n        // For safety, if any param is still -1, pick random.\n        if (n < 0)  n = rnd.next(2, 1000);\n        if (m < 0)  m = rnd.next(0LL, 1000LL);\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n    else {\n        // Fallback if unknown type\n        // Just pick a small random test\n        if (n < 0)  n = rnd.next(2, 10);\n        if (m < 0)  m = rnd.next(0LL, 10LL);\n        if (q < 0)  q = pickRandomPrime();\n        if (a < 0)  a = rnd.next(2LL, q - 1);\n    }\n\n    // Final sanity checks:\n    // Ensure n >= 2\n    // The problem example used N=2. We'll keep N >= 2 to have a meaningful scenario.\n    if (n < 2) n = 2;\n\n    // Ensure q >= 7. (We only pick from candidatePrimes, which are >=7.)\n    // Ensure gcd(a, q) = 1 if q is prime and 2 <= a < q.\n    // If somehow a >= q, adjust it:\n    if (a >= q) {\n        a = (a % (q - 1)) + 1;  // ensure 1 < a < q\n        if (a < 2) a = 2;\n        if (a >= q) a = q - 1;\n    }\n\n    // Output a single test: \"N M a Q\"\n    // The problem statement wants them on one line\n    cout << n << \" \" << m << \" \" << a << \" \" << q << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct commands showing how to run the generator\n# to produce various test cases. Each command prints exactly one test case to stdout.\n\n# 1) Small corner case\n./gen -type small\n\n# 2) Random moderate test (may vary on re-runs)\n./gen -type random\n\n# 3) Large N, moderate M\n./gen -type largeN\n\n# 4) Large M, moderate N\n./gen -type largeM\n\n# 5) Both large N and M\n./gen -type bothLarge\n\n# 6) a close to Q\n./gen -type nearQ\n\n# 7) Manually specify everything\n./gen -type manual -n 2 -m 2 -a 2 -q 7\n\n# 8) Manually specify: larger N, moderate M, prime Q\n./gen -type manual -n 1000 -m 50 -a 999 -q 100003\n\n# 9) Manually specify: bigger M\n./gen -type manual -n 10 -m 99999 -a 12 -q 999983\n\n# 10) Just rely on defaults for \"manual\" (will pick random values)\n./gen -type manual\n\n# 11) Another random test\n./gen -type random\n\n# 12) Another small random test\n./gen -type manual -n 5 -m 4 -q 31 -a 2\n\n# 13) Large prime Q from list, random N, M\n./gen -type random -n -1 -m -1 -q 999999929\n\n# 14) Very large N with nearQ type\n./gen -type nearQ -n 100000\n\n# 15) Both large with nearQ\n./gen -type nearQ -n 100000 -m 100000\n\n# 16) Manual with Q=7 but random N, M, a\n./gen -type manual -q 7\n\n# 17) LargeM with given prime\n./gen -type largeM -q 999999937\n\n# 18) largeN with given prime\n./gen -type largeN -q 999983\n\n# 19) bothLarge with a moderately large prime\n./gen -type bothLarge -q 100003\n\n# 20) random (fully random again for variety)\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:50.902430",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/G",
      "title": "G. Bathroom terminal",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers N and M (1 ≤ N ≤  100 000, 1 ≤ M ≤  5000), representing the number of words and patterns respectively.The next N lines represent each word, and after those N lines, following M lines represent each pattern. Each word and each pattern has a maximum length L (1 ≤ L ≤ 50). Each pattern has no more that three characters '?'. All other characters in words and patters are lowercase English letters from 'a' to 'e'.",
      "output_spec": "OutputOutput contains M lines and each line consists of one integer, representing the number of words that match the corresponding pattern.",
      "sample_tests": "ExampleInputCopy3 1abcaecaca?cOutputCopy3",
      "description": "G. Bathroom terminal\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers N and M (1 ≤ N ≤  100 000, 1 ≤ M ≤  5000), representing the number of words and patterns respectively.The next N lines represent each word, and after those N lines, following M lines represent each pattern. Each word and each pattern has a maximum length L (1 ≤ L ≤ 50). Each pattern has no more that three characters '?'. All other characters in words and patters are lowercase English letters from 'a' to 'e'.\n\nOutputOutput contains M lines and each line consists of one integer, representing the number of words that match the corresponding pattern.\n\nInputCopy3 1abcaecaca?cOutputCopy3\n\nInputCopy3 1abcaecaca?c\n\nOutputCopy3\n\nNoteIf we switch '?' with 'b', 'e' and with empty character, we get 'abc', 'aec' and 'ac' respectively.",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 5000, \"M\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        string word = inf.readToken(\"[a-e]{1,50}\", \"word\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < M; ++i) {\n        string pattern = inf.readToken(\"[a-e?]{1,50}\", \"pattern\");\n        int num_q = count(pattern.begin(), pattern.end(), '?');\n        ensuref(num_q <= 3, \"Pattern number %d contains more than 3 '?'\", i+1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 5000, \"M\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        string word = inf.readToken(\"[a-e]{1,50}\", \"word\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < M; ++i) {\n        string pattern = inf.readToken(\"[a-e?]{1,50}\", \"pattern\");\n        int num_q = count(pattern.begin(), pattern.end(), '?');\n        ensuref(num_q <= 3, \"Pattern number %d contains more than 3 '?'\", i+1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int M = inf.readInt(1, 5000, \"M\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        string word = inf.readToken(\"[a-e]{1,50}\", \"word\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < M; ++i) {\n        string pattern = inf.readToken(\"[a-e?]{1,50}\", \"pattern\");\n        int num_q = count(pattern.begin(), pattern.end(), '?');\n        ensuref(num_q <= 3, \"Pattern number %d contains more than 3 '?'\", i+1);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring letters = \"abcde\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int l = opt<int>(\"l\", 50);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words(n);\n    vector<string> patterns(m);\n\n    if (type == \"random\") {\n        // Generate random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate random patterns\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = rnd.next(0, min(len, 3));\n            // Random positions for '?'\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"max_words\") {\n        // n is maximum, generate maximum length words\n        // Generate words of length l\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < l; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate random patterns\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = rnd.next(0, min(len, 3));\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"max_patterns\") {\n        // m is maximum\n        // Generate random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate patterns of maximum size\n        for(int i = 0; i < m; ++i) {\n            int len = l;\n            int num_q = min(3, len);\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"many_matches\") {\n        // Generate words and patterns such that patterns match many words\n        // Generate words of length l\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < l; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate patterns with lots of '?'s\n        for(int i = 0; i < m; ++i) {\n            string p;\n            int len = l;\n            int num_q = min(3, len);\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"few_matches\") {\n        // Generate words and patterns such that patterns match few words\n        // Generate words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate patterns unlikely to match words\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            string p;\n            for(int j = 0; j < len; ++j) {\n                p += letters[rnd.next(5)];\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"all_question_marks\") {\n        // Generate patterns with all '?'\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = min(3, len);\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"stress\") {\n        // Max n, m, l\n        n = 100000;\n        m = 5000;\n        l = 50;\n        words.resize(n);\n        patterns.resize(m);\n        // Words of length l\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < l; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Patterns with 3 '?'s\n        for(int i = 0; i < m; ++i) {\n            int len = l;\n            int num_q = 3;\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else {\n        // Default to random\n        // Generate random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate random patterns\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = rnd.next(0, min(len, 3));\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output words\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", words[i].c_str());\n    }\n    // Output patterns\n    for(int i = 0; i < m; ++i) {\n        printf(\"%s\\n\", patterns[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring letters = \"abcde\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int l = opt<int>(\"l\", 50);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words(n);\n    vector<string> patterns(m);\n\n    if (type == \"random\") {\n        // Generate random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate random patterns\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = rnd.next(0, min(len, 3));\n            // Random positions for '?'\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"max_words\") {\n        // n is maximum, generate maximum length words\n        // Generate words of length l\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < l; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate random patterns\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = rnd.next(0, min(len, 3));\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"max_patterns\") {\n        // m is maximum\n        // Generate random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate patterns of maximum size\n        for(int i = 0; i < m; ++i) {\n            int len = l;\n            int num_q = min(3, len);\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"many_matches\") {\n        // Generate words and patterns such that patterns match many words\n        // Generate words of length l\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < l; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate patterns with lots of '?'s\n        for(int i = 0; i < m; ++i) {\n            string p;\n            int len = l;\n            int num_q = min(3, len);\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"few_matches\") {\n        // Generate words and patterns such that patterns match few words\n        // Generate words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate patterns unlikely to match words\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            string p;\n            for(int j = 0; j < len; ++j) {\n                p += letters[rnd.next(5)];\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"all_question_marks\") {\n        // Generate patterns with all '?'\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = min(3, len);\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else if (type == \"stress\") {\n        // Max n, m, l\n        n = 100000;\n        m = 5000;\n        l = 50;\n        words.resize(n);\n        patterns.resize(m);\n        // Words of length l\n        for(int i = 0; i < n; ++i) {\n            string s;\n            for(int j = 0; j < l; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Patterns with 3 '?'s\n        for(int i = 0; i < m; ++i) {\n            int len = l;\n            int num_q = 3;\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    } else {\n        // Default to random\n        // Generate random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, l);\n            string s;\n            for(int j = 0; j < len; ++j) {\n                s += letters[rnd.next(5)];\n            }\n            words[i] = s;\n        }\n        // Generate random patterns\n        for(int i = 0; i < m; ++i) {\n            int len = rnd.next(1, l);\n            int num_q = rnd.next(0, min(len, 3));\n            set<int> q_positions;\n            while((int)q_positions.size() < num_q) {\n                q_positions.insert(rnd.next(0, len-1));\n            }\n            string p;\n            for(int j = 0; j < len; ++j) {\n                if(q_positions.count(j)) {\n                    p += '?';\n                } else {\n                    p += letters[rnd.next(5)];\n                }\n            }\n            patterns[i] = p;\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output words\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", words[i].c_str());\n    }\n    // Output patterns\n    for(int i = 0; i < m; ++i) {\n        printf(\"%s\\n\", patterns[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -l 1 -type random\n./gen -n 10 -m 5 -l 5 -type random\n./gen -n 100 -m 50 -l 10 -type random\n./gen -n 1000 -m 100 -l 20 -type random\n./gen -n 5000 -m 500 -l 30 -type random\n./gen -n 10000 -m 1000 -l 40 -type random\n./gen -n 50000 -m 2500 -l 50 -type random\n./gen -n 100000 -m 5000 -l 50 -type random\n\n./gen -n 100000 -m 5000 -l 50 -type max_words\n./gen -n 50000 -m 5000 -l 50 -type max_patterns\n./gen -n 100000 -m 5000 -l 50 -type many_matches\n./gen -n 100000 -m 5000 -l 50 -type few_matches\n./gen -n 100000 -m 5000 -l 50 -type all_question_marks\n./gen -n 100000 -m 5000 -l 50 -type stress\n\n./gen -n 1000 -m 500 -l 50 -type random\n./gen -n 1000 -m 500 -l 1 -type random\n./gen -n 1000 -m 500 -l 1 -type all_question_marks\n./gen -n 1000 -m 500 -l 1 -type few_matches\n\n./gen -n 1 -m 1 -l 50 -type random\n./gen -n 50000 -m 2500 -l 25 -type random\n./gen -n 100000 -m 5000 -l 50 -type random\n\n./gen -n 50000 -m 5000 -l 50 -type many_matches\n./gen -n 100000 -m 5000 -l 50 -type many_matches\n./gen -n 100000 -m 1 -l 50 -type many_matches\n\n./gen -n 100000 -m 5000 -l 50 -type few_matches\n./gen -n 100000 -m 5000 -l 50 -type all_question_marks\n\n./gen -n 100000 -m 5000 -l 50 -type stress\n./gen -n 10000 -m 500 -l 10 -type random\n./gen -n 100000 -m 5000 -l 1 -type random\n./gen -n 100000 -m 5000 -l 50 -type max_words\n./gen -n 100000 -m 5000 -l 50 -type max_patterns\n./gen -n 100000 -m 5000 -l 50 -type all_question_marks\n./gen -n 100000 -m 5000 -l 50 -type stress\n./gen -n 50000 -m 5000 -l 25 -type random\n./gen -n 100000 -m 5000 -l 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:52.849254",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/H",
      "title": "H. Bob and stages",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers N (3 ≤ N ≤ 200) and K (3 ≤ K ≤ min(N, 50)), separated with one empty space, representing number of stages and number of singers, respectively.Each of the next N lines contains two integers Xi and Yi (0 ≤ Xi, Yi ≤ 106) representing the coordinates of the stages. There are no three or more collinear stages.",
      "output_spec": "OutputOutput contains only one line with one number, rounded to exactly two decimal places: the maximal festival area. Rounding is performed so that 0.5 and more rounds up and everything else rounds down.",
      "sample_tests": "ExampleInputCopy5 40 03 02 14 41 5OutputCopy10.00",
      "description": "H. Bob and stages\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers N (3 ≤ N ≤ 200) and K (3 ≤ K ≤ min(N, 50)), separated with one empty space, representing number of stages and number of singers, respectively.Each of the next N lines contains two integers Xi and Yi (0 ≤ Xi, Yi ≤ 106) representing the coordinates of the stages. There are no three or more collinear stages.\n\nOutputOutput contains only one line with one number, rounded to exactly two decimal places: the maximal festival area. Rounding is performed so that 0.5 and more rounds up and everything else rounds down.\n\nInputCopy5 40 03 02 14 41 5OutputCopy10.00\n\nInputCopy5 40 03 02 14 41 5\n\nOutputCopy10.00\n\nNoteExample explanation: From all possible convex polygon with 4 vertices and no other vertex inside, the largest is one with points (0, 0), (2, 1), (4, 4) and (1, 5).",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(3, 200, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(3, min(N,50), \"K\");\n    inf.readEoln();\n\n    vector<pair<int,int>> points(N);\n    for (int i = 0; i < N; ++i) {\n        int Xi = inf.readInt(0, 1000000, \"Xi\");\n        inf.readSpace();\n        int Yi = inf.readInt(0, 1000000, \"Yi\");\n        inf.readEoln();\n        points[i] = make_pair(Xi, Yi);\n    }\n\n    // Check that no three or more points are colinear.\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int x1 = points[j].first - points[i].first;\n                int y1 = points[j].second - points[i].second;\n                int x2 = points[k].first - points[i].first;\n                int y2 = points[k].second - points[i].second;\n                long long cross = (long long)x1 * y2 - (long long)x2 * y1;\n                ensuref(cross != 0, \"Three points are colinear: (%d,%d), (%d,%d), (%d,%d)\", \n                      points[i].first, points[i].second,\n                      points[j].first, points[j].second,\n                      points[k].first, points[k].second);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(3, 200, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(3, min(N,50), \"K\");\n    inf.readEoln();\n\n    vector<pair<int,int>> points(N);\n    for (int i = 0; i < N; ++i) {\n        int Xi = inf.readInt(0, 1000000, \"Xi\");\n        inf.readSpace();\n        int Yi = inf.readInt(0, 1000000, \"Yi\");\n        inf.readEoln();\n        points[i] = make_pair(Xi, Yi);\n    }\n\n    // Check that no three or more points are colinear.\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int x1 = points[j].first - points[i].first;\n                int y1 = points[j].second - points[i].second;\n                int x2 = points[k].first - points[i].first;\n                int y2 = points[k].second - points[i].second;\n                long long cross = (long long)x1 * y2 - (long long)x2 * y1;\n                ensuref(cross != 0, \"Three points are colinear: (%d,%d), (%d,%d), (%d,%d)\", \n                      points[i].first, points[i].second,\n                      points[j].first, points[j].second,\n                      points[k].first, points[k].second);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(3, 200, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(3, min(N,50), \"K\");\n    inf.readEoln();\n\n    vector<pair<int,int>> points(N);\n    for (int i = 0; i < N; ++i) {\n        int Xi = inf.readInt(0, 1000000, \"Xi\");\n        inf.readSpace();\n        int Yi = inf.readInt(0, 1000000, \"Yi\");\n        inf.readEoln();\n        points[i] = make_pair(Xi, Yi);\n    }\n\n    // Check that no three or more points are colinear.\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int x1 = points[j].first - points[i].first;\n                int y1 = points[j].second - points[i].second;\n                int x2 = points[k].first - points[i].first;\n                int y2 = points[k].second - points[i].second;\n                long long cross = (long long)x1 * y2 - (long long)x2 * y1;\n                ensuref(cross != 0, \"Three points are colinear: (%d,%d), (%d,%d), (%d,%d)\", \n                      points[i].first, points[i].second,\n                      points[j].first, points[j].second,\n                      points[k].first, points[k].second);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the judge's area\n    double juryArea = ans.readDouble();\n\n    // Read the contestant's output as a string to verify format\n    string partStr = ouf.readLine();\n\n    // Verify that the output is a number rounded to exactly two decimal places\n    regex decimalFormat(\"^\\\\d+\\\\.\\\\d{2}$\");\n    if (!regex_match(partStr, decimalFormat)) {\n        quitf(_wa, \"Output is not a number rounded to exactly two decimal places\");\n    }\n\n    // Parse the contestant's area\n    double partArea = atof(partStr.c_str());\n\n    // Check if the contestant's area is acceptable\n    const double eps = 1e-6;\n    if (partArea + eps < juryArea) {\n        quitf(_wa, \"Contestant's area is less than the jury's area\");\n    } else if (partArea > juryArea + eps) {\n        quitf(_fail, \"Contestant's area is greater than the jury's area\");\n    }\n\n    // Function to perform rounding as per problem statement\n    auto roundAsPerProblem = [](double x) {\n        x *= 100.0;\n        double frac = x - floor(x);\n        if (frac >= 0.5) {\n            x = floor(x) + 1.0;\n        } else {\n            x = floor(x);\n        }\n        return x / 100.0;\n    };\n\n    // Check that the contestant's area is correctly rounded\n    double expectedRoundedArea = roundAsPerProblem(partArea);\n    if (fabs(expectedRoundedArea - partArea) > eps) {\n        quitf(_wa, \"Area is not correctly rounded to two decimal places\");\n    }\n\n    // Verify that the printed area matches the correctly rounded area\n    char expectedOutput[20];\n    sprintf(expectedOutput, \"%.2f\", expectedRoundedArea);\n    if (partStr != expectedOutput) {\n        quitf(_wa, \"Printed area does not match the correctly rounded area\");\n    }\n\n    // Round the jury's area for comparison\n    double roundedJuryArea = roundAsPerProblem(juryArea);\n\n    // Compare the contestant's rounded area with the jury's rounded area\n    if (fabs(expectedRoundedArea - roundedJuryArea) > eps) {\n        if (expectedRoundedArea + eps < roundedJuryArea) {\n            quitf(_wa, \"Contestant's area is less than the maximum possible area\");\n        } else {\n            quitf(_fail, \"Contestant's area is greater than the maximum possible area\");\n        }\n    }\n\n    quitf(_ok, \"Correct area: %.2f\", expectedRoundedArea);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nbool colinear(Point a, Point b, Point c) {\n    return (long long)(b.y - a.y)*(c.x - b.x) == (long long)(c.y - b.y)*(b.x - a.x);\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    int N = opt<int>(\"N\");\n    int K = opt<int>(\"K\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<Point> points;\n    set<pair<int, int>> s; // To ensure uniqueness\n    \n    if (type == \"convex\") {\n        /* Generate N points around a circle */\n        double R = 1e6 / 3; // Max Coordinate is 1e6\n        double cx = R*1.5, cy = R*1.5; // Center of circle\n        vector<double> angles;\n        for (int i = 0; i < N; ++i) {\n            angles.push_back(rnd.next(0.0, 2*M_PI));\n        }\n        sort(angles.begin(), angles.end());\n        for (double angle : angles) {\n            int x = (int)(cx + R * cos(angle));\n            int y = (int)(cy + R * sin(angle));\n            if (x < 0 || x > 1e6 || y < 0 || y > 1e6) {\n                x = min(max(x, 0), (int)1e6);\n                y = min(max(y, 0), (int)1e6);\n            }\n            if (s.count({x, y})) {\n                x += rnd.next(-5, 5);\n                y += rnd.next(-5, 5);\n            }\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else if (type == \"random\") {\n        /* Generate random points, ensuring that no three are colinear */\n        while ((int)points.size() < N) {\n            int x = rnd.next(0, (int)1e6);\n            int y = rnd.next(0, (int)1e6);\n            if (s.count({x, y})) continue;\n            bool is_colinear = false;\n            for (int i = 0; i < (int)points.size() && !is_colinear; ++i) {\n                for (int j = i+1; j < (int)points.size() && !is_colinear; ++j) {\n                    if (colinear(points[i], points[j], {x, y})) {\n                        is_colinear = true;\n                    }\n                }\n            }\n            if (is_colinear) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else if (type == \"impossible\") {\n        /* Generate a test case where it's impossible to select K points forming a convex polygon with no points inside */\n        if (N < K + 1) {\n            fprintf(stderr, \"Impossible to generate 'impossible' test case with N=%d K=%d\\n\", N, K);\n            exit(1);\n        }\n        N = K + 1;\n        double R = 1e6 / 3; // Max Coordinate is 1e6\n        double cx = R*1.5, cy = R*1.5; // Center of circle\n        vector<double> angles;\n        for (int i = 0; i < K; ++i) {\n            angles.push_back(2 * M_PI * i / K);\n        }\n        for (double angle : angles) {\n            int x = (int)(cx + R * cos(angle));\n            int y = (int)(cy + R * sin(angle));\n            if (x < 0 || x > 1e6 || y < 0 || y > 1e6) {\n                x = min(max(x, 0), (int)1e6);\n                y = min(max(y, 0), (int)1e6);\n            }\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n        points.push_back({(int)cx, (int)cy});\n    } else if (type == \"maximized_area\") {\n        /* Create a test where the maximal area convex K-gon is non-obvious */\n        int cluster_size = N - K + 3;\n        while ((int)points.size() < cluster_size) {\n            int x = rnd.next(0, (int)(1e5));\n            int y = rnd.next(0, (int)(1e5));\n            if (s.count({x, y})) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n        while ((int)points.size() < N) {\n            int x = rnd.next((int)(5e5), (int)(1e6));\n            int y = rnd.next((int)(5e5), (int)(1e6));\n            if (s.count({x, y})) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else if (type == \"small\") {\n        /* N and K are small */\n        N = max(N, 3);\n        K = max(K, 3);\n        while ((int)points.size() < N) {\n            int x = rnd.next(0, (int)1e6);\n            int y = rnd.next(0, (int)1e6);\n            if (s.count({x, y})) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    printf(\"%d %d\\n\", N, K);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d %d\\n\", points[i].x, points[i].y);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nbool colinear(Point a, Point b, Point c) {\n    return (long long)(b.y - a.y)*(c.x - b.x) == (long long)(c.y - b.y)*(b.x - a.x);\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    int N = opt<int>(\"N\");\n    int K = opt<int>(\"K\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<Point> points;\n    set<pair<int, int>> s; // To ensure uniqueness\n    \n    if (type == \"convex\") {\n        /* Generate N points around a circle */\n        double R = 1e6 / 3; // Max Coordinate is 1e6\n        double cx = R*1.5, cy = R*1.5; // Center of circle\n        vector<double> angles;\n        for (int i = 0; i < N; ++i) {\n            angles.push_back(rnd.next(0.0, 2*M_PI));\n        }\n        sort(angles.begin(), angles.end());\n        for (double angle : angles) {\n            int x = (int)(cx + R * cos(angle));\n            int y = (int)(cy + R * sin(angle));\n            if (x < 0 || x > 1e6 || y < 0 || y > 1e6) {\n                x = min(max(x, 0), (int)1e6);\n                y = min(max(y, 0), (int)1e6);\n            }\n            if (s.count({x, y})) {\n                x += rnd.next(-5, 5);\n                y += rnd.next(-5, 5);\n            }\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else if (type == \"random\") {\n        /* Generate random points, ensuring that no three are colinear */\n        while ((int)points.size() < N) {\n            int x = rnd.next(0, (int)1e6);\n            int y = rnd.next(0, (int)1e6);\n            if (s.count({x, y})) continue;\n            bool is_colinear = false;\n            for (int i = 0; i < (int)points.size() && !is_colinear; ++i) {\n                for (int j = i+1; j < (int)points.size() && !is_colinear; ++j) {\n                    if (colinear(points[i], points[j], {x, y})) {\n                        is_colinear = true;\n                    }\n                }\n            }\n            if (is_colinear) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else if (type == \"impossible\") {\n        /* Generate a test case where it's impossible to select K points forming a convex polygon with no points inside */\n        if (N < K + 1) {\n            fprintf(stderr, \"Impossible to generate 'impossible' test case with N=%d K=%d\\n\", N, K);\n            exit(1);\n        }\n        N = K + 1;\n        double R = 1e6 / 3; // Max Coordinate is 1e6\n        double cx = R*1.5, cy = R*1.5; // Center of circle\n        vector<double> angles;\n        for (int i = 0; i < K; ++i) {\n            angles.push_back(2 * M_PI * i / K);\n        }\n        for (double angle : angles) {\n            int x = (int)(cx + R * cos(angle));\n            int y = (int)(cy + R * sin(angle));\n            if (x < 0 || x > 1e6 || y < 0 || y > 1e6) {\n                x = min(max(x, 0), (int)1e6);\n                y = min(max(y, 0), (int)1e6);\n            }\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n        points.push_back({(int)cx, (int)cy});\n    } else if (type == \"maximized_area\") {\n        /* Create a test where the maximal area convex K-gon is non-obvious */\n        int cluster_size = N - K + 3;\n        while ((int)points.size() < cluster_size) {\n            int x = rnd.next(0, (int)(1e5));\n            int y = rnd.next(0, (int)(1e5));\n            if (s.count({x, y})) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n        while ((int)points.size() < N) {\n            int x = rnd.next((int)(5e5), (int)(1e6));\n            int y = rnd.next((int)(5e5), (int)(1e6));\n            if (s.count({x, y})) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else if (type == \"small\") {\n        /* N and K are small */\n        N = max(N, 3);\n        K = max(K, 3);\n        while ((int)points.size() < N) {\n            int x = rnd.next(0, (int)1e6);\n            int y = rnd.next(0, (int)1e6);\n            if (s.count({x, y})) continue;\n            s.insert({x, y});\n            points.push_back({x, y});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    printf(\"%d %d\\n\", N, K);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d %d\\n\", points[i].x, points[i].y);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -N 3 -K 3 -type small\n./gen -N 4 -K 3 -type small\n./gen -N 10 -K 4 -type small\n\n# Convex test cases\n./gen -N 10 -K 3 -type convex\n./gen -N 50 -K 3 -type convex\n./gen -N 100 -K 50 -type convex\n./gen -N 200 -K 50 -type convex\n\n# Random test cases\n./gen -N 10 -K 4 -type random\n./gen -N 50 -K 25 -type random\n./gen -N 100 -K 50 -type random\n./gen -N 200 -K 50 -type random\n\n# Impossible test cases\n./gen -N 4 -K 3 -type impossible\n./gen -N 5 -K 4 -type impossible\n./gen -N 50 -K 25 -type impossible\n./gen -N 100 -K 50 -type impossible\n\n# Maximized area test cases\n./gen -N 50 -K 25 -type maximized_area\n./gen -N 100 -K 50 -type maximized_area\n./gen -N 200 -K 50 -type maximized_area\n\n# Edge cases\n./gen -N 200 -K 3 -type convex\n./gen -N 200 -K 3 -type random\n./gen -N 200 -K 3 -type impossible\n\n# Some more random test cases\n./gen -N 199 -K 50 -type random\n./gen -N 50 -K 50 -type random\n./gen -N 150 -K 50 -type random\n\n# Random K\n./gen -N 200 -K 49 -type random\n./gen -N 200 -K 50 -type random\n\n# Random N\n./gen -N 100 -K 3 -type random\n./gen -N 50 -K 3 -type random\n./gen -N 10 -K 10 -type random\n\n# Additional test cases\n./gen -N 200 -K 50 -type small\n./gen -N 200 -K 3 -type small\n./gen -N 200 -K 50 -type maximized_area\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:54.857559",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "852/I",
      "title": "I. Dating",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105), the number of houses in the town.The second line contains n integers, where the i-th number is 1 if a boy lives in the i-th house or 0 if a girl lives in i-th house.The third line contains n integers, where the i-th number represents the favorite number fi (1 ≤ fi ≤ 109) of the girl or boy that lives in the i-th house.The next n - 1 lines contain information about the roads and the i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ n) which means that there exists road between those two houses. It is guaranteed that it's possible to reach any house from any other.The following line contains an integer q (1 ≤ q ≤ 105), the number of queries.Each of the following q lines represents a question and consists of two integers a and b (1 ≤ a, b ≤ n).",
      "output_spec": "OutputFor each of the q questions output a single number, the answer to the citizens question.",
      "sample_tests": "ExampleInputCopy71 0 0 1 0 1 09 2 9 2 2 9 92 61 24 26 53 67 421 37 5OutputCopy23",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105), the number of houses in the town.The second line contains n integers, where the i-th number is 1 if a boy lives in the i-th house or 0 if a girl lives in i-th house.The third line contains n integers, where the i-th number represents the favorite number fi (1 ≤ fi ≤ 109) of the girl or boy that lives in the i-th house.The next n - 1 lines contain information about the roads and the i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ n) which means that there exists road between those two houses. It is guaranteed that it's possible to reach any house from any other.The following line contains an integer q (1 ≤ q ≤ 105), the number of queries.Each of the following q lines represents a question and consists of two integers a and b (1 ≤ a, b ≤ n).\n\nOutputFor each of the q questions output a single number, the answer to the citizens question.\n\nInputCopy71 0 0 1 0 1 09 2 9 2 2 9 92 61 24 26 53 67 421 37 5OutputCopy23\n\nInputCopy71 0 0 1 0 1 09 2 9 2 2 9 92 61 24 26 53 67 421 37 5\n\nOutputCopy23\n\nNoteIn the first question from house 1 to house 3, the potential couples are (1, 3) and (6, 3).In the second question from house 7 to house 5, the potential couples are (7, 6), (4, 2) and (4, 5).",
      "solutions": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces",
          "content": "Hi Codeforces!It's our pleasure to announce the 10th edition of Bubble Cup. Bubble Cup is a programing competition organized by Microsoft Development Center Serbia (MDCS), and will be held this weekend. Contest will take place on Saturday, 2nd of September at 09:30 UTC, in Belgrade, Serbia. Live results will be available on the official Bubble Cup website (results will be frozen during the last hour of the competition). Winners will be announced at the closing ceremony.Just like the two previous editions, this final will be followed by an online mirror competition on Codeforces. Mirror will take place on Sunday, 3rd of September at 10:00 UTC. Contest will last for 5 hours and ACM ICPC rules will be applied. It will be a competition for teams of 1-3 members. There will be at least eight problems.We kindly ask participants of the onsite final to hold off discussing problems publicly until the mirror is over.Contest was mainly prepared by employees of MDCS. We give our thanks to Nikolay Kalinin (KAN) for the round coordination, Mike Mirzayanov (MikeMirzayanov) and the team behind Codeforces and Polygon platforms. Special thanks goes to knightL for helping out with problem testing.The contest will be unrated. The reason for this is because rules of this contest are not common for Codeforces. Also, it is only a mirror of an onsite competition.Editorial will be available in the booklets section on the Bubble Cup website a few hours after the online mirror ends.EDIT:Here you can find mirror contests from the previous two finals:Bubble Cup 8 — Finals [Online Mirror]Bubble Cup 9 — Finals [Online Mirror]EDIT #2:The contest has started. You can see the live results on the Bubble Cup website.EDIT #3:Here are the results of the onsite finals. The top three winning teams of the online mirror contest:1. tourist, VArtem2. zigui, molamola., dotorya3. Um_nik, KroneckerComplete rankings are listed on this link.Congrats to all winners!You can find contest editorial here.EDIT #4:Thank you for your comments. While our official and ainta's solution matched on the test cases provided we found out from the comments here that there are some edge cases we didn't handle correctly and don't know how to handle properly given the constraints. Because of that we decided to remove the problem from the set and reset all penalties people received from the incorrect submissions. Sincere apologies to everyone affected by this.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2433
        }
      ],
      "code_examples": [
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 1",
          "code": "add_edge(i, j + n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 2",
          "code": "add_edge(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 3",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 4",
          "code": "5 5 9\n1 3\n2 3\n4 3\n5 3\n2 2\n3 2\n4 2\n1 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 5",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 6",
          "code": "5 5 5\n1 2\n2 2\n4 2\n5 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 7",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 8",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 9",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        },
        {
          "title": "Mirror of Bubble Cup X Finals on Codeforces - Codeforces - Code 10",
          "code": "5 5 3\n1 1\n3 1\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read gender array (1 for boy, 0 for girl)\n    vector<int> gender = inf.readInts(n, 0, 1, \"gender\");\n    inf.readEoln();\n\n    // Read favorite numbers f_i\n    vector<int> f = inf.readInts(n, 1, 1000000000, \"f\");\n    inf.readEoln();\n\n    // Prepare for Union-Find to check connectivity and acyclicity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            quitf(_fail, \"The graph is not a tree, cycle detected between nodes %d and %d\", x, y);\n        }\n        parent[x] = y;\n        return true;\n    };\n\n    // Read n - 1 edges\n    for (int i = 0; i < n - 1; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        unite(a_i, b_i);\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find(i) != root) {\n            quitf(_fail, \"The graph is not connected\");\n        }\n    }\n\n    // Read q\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    // Read q queries\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read gender array (1 for boy, 0 for girl)\n    vector<int> gender = inf.readInts(n, 0, 1, \"gender\");\n    inf.readEoln();\n\n    // Read favorite numbers f_i\n    vector<int> f = inf.readInts(n, 1, 1000000000, \"f\");\n    inf.readEoln();\n\n    // Prepare for Union-Find to check connectivity and acyclicity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            quitf(_fail, \"The graph is not a tree, cycle detected between nodes %d and %d\", x, y);\n        }\n        parent[x] = y;\n        return true;\n    };\n\n    // Read n - 1 edges\n    for (int i = 0; i < n - 1; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        unite(a_i, b_i);\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find(i) != root) {\n            quitf(_fail, \"The graph is not connected\");\n        }\n    }\n\n    // Read q\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    // Read q queries\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read gender array (1 for boy, 0 for girl)\n    vector<int> gender = inf.readInts(n, 0, 1, \"gender\");\n    inf.readEoln();\n\n    // Read favorite numbers f_i\n    vector<int> f = inf.readInts(n, 1, 1000000000, \"f\");\n    inf.readEoln();\n\n    // Prepare for Union-Find to check connectivity and acyclicity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            quitf(_fail, \"The graph is not a tree, cycle detected between nodes %d and %d\", x, y);\n        }\n        parent[x] = y;\n        return true;\n    };\n\n    // Read n - 1 edges\n    for (int i = 0; i < n - 1; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        unite(a_i, b_i);\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find(i) != root) {\n            quitf(_fail, \"The graph is not connected\");\n        }\n    }\n\n    // Read q\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    // Read q queries\n    for (int i = 0; i < q; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string genderType = opt<string>(\"genderType\", \"random\");\n    string favNumType = opt<string>(\"favNumType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> genders(n + 1);\n    vector<int> favNums(n + 1);\n\n    // Generate tree\n    if (treeType == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (treeType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (treeType == \"binary\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle nodes to randomize the tree structure\n    vector<int> nodes(n);\n    for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n    shuffle(nodes.begin(), nodes.end());\n    map<int, int> nodeMapping;\n    for (int i = 0; i < n; ++i) nodeMapping[i + 1] = nodes[i];\n    for (auto &edge : edges) {\n        edge.first = nodeMapping[edge.first];\n        edge.second = nodeMapping[edge.second];\n    }\n    shuffle(edges.begin(), edges.end());\n\n    // Assign genders\n    if (genderType == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = rnd.next(0, 1);\n        }\n    } else if (genderType == \"all_boy\") {\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = 1;\n        }\n    } else if (genderType == \"all_girl\") {\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = 0;\n        }\n    } else if (genderType == \"half\") {\n        int numBoys = n / 2;\n        int numGirls = n - numBoys;\n        vector<int> temp(n, 0);\n        for (int i = 0; i < numBoys; ++i) temp[i] = 1;\n        shuffle(temp.begin(), temp.end());\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = temp[i - 1];\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = rnd.next(0, 1);\n        }\n    }\n\n    // Assign favorite numbers\n    if (favNumType == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = rnd.next(1, 1000000000);\n        }\n    } else if (favNumType == \"same\") {\n        int num = rnd.next(1, 1000000000);\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = num;\n        }\n    } else if (favNumType == \"perNode\") {\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = i;\n        }\n        shuffle(favNums.begin() + 1, favNums.end());\n    } else if (favNumType == \"few\") {\n        int k = 5;\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = rnd.next(1, k);\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Generate queries\n    vector<pair<int, int>> queries;\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    } else if (queryType == \"fixed\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else if (queryType == \"same\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", genders[i], (i == n) ? '\\n' : ' ');\n    }\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", favNums[i], (i == n) ? '\\n' : ' ');\n    }\n    for (auto &edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    printf(\"%d\\n\", q);\n    for (auto &query : queries) {\n        printf(\"%d %d\\n\", query.first, query.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string genderType = opt<string>(\"genderType\", \"random\");\n    string favNumType = opt<string>(\"favNumType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> genders(n + 1);\n    vector<int> favNums(n + 1);\n\n    // Generate tree\n    if (treeType == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (treeType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (treeType == \"binary\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle nodes to randomize the tree structure\n    vector<int> nodes(n);\n    for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n    shuffle(nodes.begin(), nodes.end());\n    map<int, int> nodeMapping;\n    for (int i = 0; i < n; ++i) nodeMapping[i + 1] = nodes[i];\n    for (auto &edge : edges) {\n        edge.first = nodeMapping[edge.first];\n        edge.second = nodeMapping[edge.second];\n    }\n    shuffle(edges.begin(), edges.end());\n\n    // Assign genders\n    if (genderType == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = rnd.next(0, 1);\n        }\n    } else if (genderType == \"all_boy\") {\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = 1;\n        }\n    } else if (genderType == \"all_girl\") {\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = 0;\n        }\n    } else if (genderType == \"half\") {\n        int numBoys = n / 2;\n        int numGirls = n - numBoys;\n        vector<int> temp(n, 0);\n        for (int i = 0; i < numBoys; ++i) temp[i] = 1;\n        shuffle(temp.begin(), temp.end());\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = temp[i - 1];\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            genders[i] = rnd.next(0, 1);\n        }\n    }\n\n    // Assign favorite numbers\n    if (favNumType == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = rnd.next(1, 1000000000);\n        }\n    } else if (favNumType == \"same\") {\n        int num = rnd.next(1, 1000000000);\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = num;\n        }\n    } else if (favNumType == \"perNode\") {\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = i;\n        }\n        shuffle(favNums.begin() + 1, favNums.end());\n    } else if (favNumType == \"few\") {\n        int k = 5;\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = rnd.next(1, k);\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            favNums[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Generate queries\n    vector<pair<int, int>> queries;\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    } else if (queryType == \"fixed\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else if (queryType == \"same\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({a, b});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", genders[i], (i == n) ? '\\n' : ' ');\n    }\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", favNums[i], (i == n) ? '\\n' : ' ');\n    }\n    for (auto &edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    printf(\"%d\\n\", q);\n    for (auto &query : queries) {\n        printf(\"%d %d\\n\", query.first, query.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: n=1, minimal tree, all boys, same favorite number, fixed query\n./gen -n 1 -q 1 -treeType chain -genderType all_boy -favNumType same -queryType fixed\n\n# Test case 2: n=2, minimal tree, all girls, same favorite number, fixed query\n./gen -n 2 -q 1 -treeType chain -genderType all_girl -favNumType same -queryType fixed\n\n# Test case 3: n=5, chain, half boys/girls, perNode favorite numbers, random queries\n./gen -n 5 -q 5 -treeType chain -genderType half -favNumType perNode -queryType random\n\n# Test case 4: n=10, star, random genders, few favorite numbers, random queries\n./gen -n 10 -q 10 -treeType star -genderType random -favNumType few -queryType random\n\n# Test case 5: n=1000, random tree, random genders, random favorite numbers, random queries\n./gen -n 1000 -q 1000 -treeType random -genderType random -favNumType random -queryType random\n\n# Test case 6: n=1000, chain, half boys/girls, same favorite number, random queries\n./gen -n 1000 -q 1000 -treeType chain -genderType half -favNumType same -queryType random\n\n# Test case 7: n=100000, star, random genders, same favorite number, random queries\n./gen -n 100000 -q 100000 -treeType star -genderType random -favNumType same -queryType random\n\n# Test case 8: n=100000, random tree, random genders, perNode favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType random -genderType random -favNumType perNode -queryType random\n\n# Test case 9: n=100000, binary tree, all boys, few favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType binary -genderType all_boy -favNumType few -queryType random\n\n# Test case 10: n=100000, chain, all girls, random favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType chain -genderType all_girl -favNumType random -queryType random\n\n# Test case 11: n=99999, random tree, half boys/girls, same favorite number, fixed queries\n./gen -n 99999 -q 100000 -treeType random -genderType half -favNumType same -queryType fixed\n\n# Test case 12: n=100000, q=50000, random tree, random genders, few favorite numbers, fixed queries\n./gen -n 100000 -q 50000 -treeType random -genderType random -favNumType few -queryType fixed\n\n# Test case 13: n=100000, chain, half boys/girls, few favorite numbers, same query\n./gen -n 100000 -q 100000 -treeType chain -genderType half -favNumType few -queryType same\n\n# Test case 14: n=100000, random tree, random genders, random favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType random -genderType random -favNumType random -queryType random\n\n# Test case 15: n=100000, random tree, all boys, random favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType random -genderType all_boy -favNumType random -queryType random\n\n# Test case 16: n=100000, random tree, random genders, same favorite number, random queries\n./gen -n 100000 -q 100000 -treeType random -genderType random -favNumType same -queryType random\n\n# Test case 17: n=100000, star, all girls, perNode favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType star -genderType all_girl -favNumType perNode -queryType random\n\n# Test case 18: n=100000, binary tree, random genders, few favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType binary -genderType random -favNumType few -queryType random\n\n# Test case 19: n=100000, chain, random genders, random favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType chain -genderType random -favNumType random -queryType random\n\n# Test case 20: n=100000, random tree, random genders, perNode favorite numbers, fixed queries\n./gen -n 100000 -q 100000 -treeType random -genderType random -favNumType perNode -queryType fixed\n\n# Test case 21: n=100000, random tree, half boys/girls, same favorite number, same query\n./gen -n 100000 -q 100000 -treeType random -genderType half -favNumType same -queryType same\n\n# Test case 22: n=100000, random tree, half boys/girls, few favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType random -genderType half -favNumType few -queryType random\n\n# Test case 23: n=100000, random tree, random genders, favorite numbers from limited range\n./gen -n 100000 -q 100000 -treeType random -genderType random -favNumType few -queryType random\n\n# Test case 24: n=100000, chain, random genders, favorite numbers all the same, random queries\n./gen -n 100000 -q 100000 -treeType chain -genderType random -favNumType same -queryType random\n\n# Test case 25: n=100000, chain, half boys/girls, perNode favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType chain -genderType half -favNumType perNode -queryType random\n\n# Test case 26: n=100000, star, random genders, random favorite numbers, random queries\n./gen -n 100000 -q 100000 -treeType star -genderType random -favNumType random -queryType random\n\n# Test case 27: n=100000, binary tree, random genders, same favorite number, random queries\n./gen -n 100000 -q 100000 -treeType binary -genderType random -favNumType same -queryType random\n\n# Test case 28: n=100000, star, all girls, same favorite number, same query\n./gen -n 100000 -q 100000 -treeType star -genderType all_girl -favNumType same -queryType same\n\n# Test case 29: n=100000, random tree, random genders, same favorite number, random queries\n./gen -n 100000 -q 100000 -treeType random -genderType random -favNumType same -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:56.865707",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "853/A",
      "title": "A. Planning",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 300 000), here n is the number of flights, and k is the number of minutes in the beginning of the day that the flights did not depart.The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 107), here ci is the cost of delaying the i-th flight for one minute.",
      "output_spec": "OutputThe first line must contain the minimum possible total cost of delaying the flights.The second line must contain n different integers t1, t2, ..., tn (k + 1 ≤ ti ≤ k + n), here ti is the minute when the i-th flight must depart. If there are several optimal schedules, print any of them.",
      "sample_tests": "ExampleInputCopy5 24 2 1 10 2OutputCopy203 6 7 4 5",
      "description": "A. Planning\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 300 000), here n is the number of flights, and k is the number of minutes in the beginning of the day that the flights did not depart.The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 107), here ci is the cost of delaying the i-th flight for one minute.\n\nOutputThe first line must contain the minimum possible total cost of delaying the flights.The second line must contain n different integers t1, t2, ..., tn (k + 1 ≤ ti ≤ k + n), here ti is the minute when the i-th flight must depart. If there are several optimal schedules, print any of them.\n\nInputCopy5 24 2 1 10 2OutputCopy203 6 7 4 5\n\nInputCopy5 24 2 1 10 2\n\nOutputCopy203 6 7 4 5\n\nNoteLet us consider sample test. If Helen just moves all flights 2 minutes later preserving the order, the total cost of delaying the flights would be (3 - 1)·4 + (4 - 2)·2 + (5 - 3)·1 + (6 - 4)·10 + (7 - 5)·2 = 38 burles. However, the better schedule is shown in the sample answer, its cost is (3 - 1)·4 + (6 - 2)·2 + (7 - 3)·1 + (4 - 4)·10 + (5 - 5)·2 = 20 burles.",
      "solutions": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces",
          "content": "Hi everybody!These days Moscow is conducting the 2nd International Olympiad of Metropolises that is an international competition for high school students from biggest cities and capitals all around the world. One of the disciplines of the competition is informatics. Rounds of the competition were prepared by the jury members invited from St. Petersburg, Minsk, Almaty and Moscow olympiad scientific committee which you may know by Moscow team Olympiad, Open Olympiad in Informatics and Moscow Olympiad for young students (rounds 327, 342, 345, 376, 401).We are very grateful to MikeMirzayanov for Polygon system that made it possible to conveniently hold a simultaneous statement translation process into lots of languages. As a good friends of Codeforces platform, we conduct a parallel rated Div. 1 + Div. 2 round on the competition problemset.Round will happen on September 6th at 12:55 UTC and it will last for two hours. There will be 5 problems for each division, scoring will be announced later.Scientific Committee of the olympiad consists of: andrewzta, GlebsHP, Endagorion, meshanya, Chmel_Tolstiy, Zlobober, Helen Andreeva and Bakhyt Matkarymov. Problems were prepared by timgaripov, mingaleg, halin.george, vintage_Vlad_Makeev, malcolm, LHiC coordinated by your humble servant.Codeforces coordinator KAN helped us to choose problems for a round.Good luck and high ratings for everybody!PS We kindly ask everybody who knows problems of an on-site event not to participate in a round and not to discuss them in public, as this may be a subject for disqualification.Congratulations to the winners!In div. 1 they are: Um_nik fateice KADR dotorya FallDream In div. 2 they are: jiangIy xolm YxqK lixolas Rawnd The analysis is published. Thanks to all for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54350",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1777
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces",
          "content": "(Idea — Sender , developing — timgaripov) 854A - FractionIt's possible to look over all possible values of the numerator . For the current value of a we have to compute denominator as b = n - a, check that there are no common divisors (except 1) of a and b (it also could be done by a linear search of possible common divisors 2 ≤ d ≤ a). The answer is the maximal fraction that was considered during the iteration over all possible values of the numerator and passed the irreducibility test. Pseudocode of the described solution is presented below: This solution have time complexity.However, we can find answer to the problem analytically in the following way: (Idea — Chmel_Tolstiy, developing — mingaleg) 854B - Maxim Buys an ApartmentMinimum number of good apartments is almost always 1, since rooms with indices from 1 to k could be inhabited. Exceptions are cases in which k = 0 and k = n, in these cases both minimum and maximum number of good rooms is 0 since there is no inhabitant or vacant apartments.Maximum number of good apartments could be reached, for example, as follows. Assume apartments with indices 2, 5, 8 and so on are occupied as much as possible. Each of these apartments produces 2 good rooms except from, if it exists, the one with index n (that apartment produces 1 good apartment). If number of inhabitant apartments is less than k occupy any of rest rooms to reach that number, every such occupation will decrease number of good apartments by one). Simulate this process, than count the number of good rooms to find maximum possible number. Expected complexity: O(n2) or O(n).Instead of simulating the above process calculate number of apartments with indices 2, 5, 8 and so on excluding the one with index n if it exists. Number of that apartments is equal to , and if k ≤ x you can occupy some of these apartments to reach maximum number of good rooms equal to 2·k. Otherwise, if k > x, assume that apartments with indices 2, 5, 8 and so on are occupied, so any room has at least one inhabited room adjacent to it. Therefore number of good apartments is equal to number of vacant apartments and is equal to n - k. Implementation of these formulas with keeping in mind cases in which k = 0 and k = n will be scored as full solution of problem. Expected complexity: O(1).(Idea — Zlobober, developing — halin.george) 853A - PlanningWe will show that following greedy is correct: let's for each moment of time use a plane, which can depart in this moment of time (and didn't depart earlier, of course) with minimal cost of delay. Proof is quite simple: it's required to minimize . You can notice that is constant, so we just need to minimize . Consider the optimal solution when plane i departs at moment bi and solution by greedy algorithm in which plane i departs at moment ai. Let x be plane with minimal cx, such ax ≠ bx. At any moment greedy algorithm takes avaliable plane with lowest cx, so ax < bx. Let y be a plane, such that by = ax. But cy >  = by, so bx·cx + by·cy >  = bx·cy + by·cx and it's possible to swap bx and by in optimal solution without loosing of optimality. By performing this operation many times it's possible to make bi = ai for each i and it means that greedy solution is optimal.To make this solution work fast you need to use some data structures to find optimal plane faster for each moment. This data structure should be able to add number into set, give value of minimal element in set and erase minimal number from set. For this purpose you can use heap (or someting like std::set or std::priority_queue in C++). (Idea — GlebsHP, developing — mingaleg) 853B - Jury MeetingObviously, each member of the jury needs to buy exactly two tickets — to the capital and back. Sort all flights by the day of departure. Now go through flights to the capital (forward flights) and one by one assume it is the last forward flight in answer (let's say it is scheduled on day d). Thus you are assuming that all forward flights are contained in some fixed prefix of flights. Make sure that there is at least one forward flight for every jury member in this prefix and find the cheapest forward flight among them for every person. All return flights we are interested in are contained in the suffix of flights list such that every flight's departure date is at least d + k + 1. Take similar steps: make sure that there is at least one return flight for every jury member in this suffix and find the cheapest return flight among them for every person as well. Select minimal cost among these variants or find out that the problem has no solution. Expected complexity: O(nm2) or O(m2 + n).Just as the boundary of considered prefix moves right, the boundary of considered suffix moves right as well. This suggests that the problem could be solved by the two pointers method. Assume you are storing minimum forward flight's cost on current prefix (infinity if no flight exists) for every person, and you are storing multiset (ordered by cost) of all return flights on current suffix for each person as well. To proceed next prefix and conforming suffix do the following: Move prefix boundary to the next forward flight. If its cost ci is less than minimum forward flight's cost fwdfi from that city, then you could improve total cost: decrease it by ci - fwdfi and set fwdfi to ci since it's new minimal cost. Move suffix boundary to the next backward flight until there is such flight exists and it departure date difference with prefix boundary departure date is under k + 1. While moving suffix boundary, keep return flights multisets consistent: remove boundary flight right before moving that boundary to the next flight. Also check out if you are removing cheapest flight from multiset. If it is so, minimal flight cost for that city changed as well as total cost: it increases by difference between old minimal cost and new minimal cost. Keep in mind that if you are removing last flight from multiset, then there is no more appropriate return flight for this city and you should terminate the process. Proceed these steps moving boundaries to the right until the process terminates. In this way you've reviewed the same prefixes and corresponding suffixes as in slower solution described above. Expected complexity: .(Idea — glebushka98, developing — vintage_Vlad_Makeev) 853C - BoredomWe can't iterate over all interesting rectangles. Let's count number of rectangles that are not intersecting our rectangle. To do it let's calculate number of rectangles to the left, right, up and down of rectangle in query. It can be easily done in O(1) time: suppose we have rectangle with corners (i;pi) and (j;pj). We have min(i, j) - 1 points to the left of rectangle, n - max(i, j) to the right, min(pi, pj) - 1 to the down, etc. If we have x points in some area, there are rectangles in that area. But now we calculated twice rectangles that are simultaneously to the left and up of our rectangle, left and down, etc. To find number of such rectangles we can iterate over all points and find points which are in these areas and find number of rectangles in area using formula . The complexity is O(q·n).To solve the problem we need to find number of points in some areas faster. It's quite easy to notice that we just have many queries of finding number of points in some subrectangle. It's classical problem that can be solved with some 2d tree in O(q·log2) solution. But it can be too slow and can not fit into time limit in case of inaccurate implementation. However, you can notice that all queries are offline and find number of points in subrectangle in O(q·logn) time. It's fast enough to pass all tests.(Idea — Elena Andreeva, developing — vintage_Vlad_Makeev) 853D - Michael and Charging StationsBefore solving problem one observation is required: suppose at day i we have xi bonuses. Then exists optimal solution, which spends 0 or min(ai, xi) bonuses every day. It's quite easy to proof: suppose we have some optimal solution and i is a first day, when neither 0 nor min(ai, xi) bonuses were spent. If i is a last day on which non-zero amount of bonuses was spent, we can notice that solution spending min(ai, xi) bonuses that day is more optimal, so first solution was optimal. So let's consider next day after i, when non-zero amount of bonuses was spent, say j, and amount of bonuses spent at day j is sj (Also, amount of bonuses spent on day i is si). Let's look at solution that spends si + min(si - min(ai, xi), sj) bonuses at day i and sj - min(si - min(ai, xi), sj). That solution is still correct and still optimal, but it spends min(ai, xi) at day i or 0 at day j. Anyway this operation increases first day i when neither i nor min(ai, xi) bonuses were spent or first day j after it, when non-zero amount of burles were spent. But we can't increase i or j infinitely, so, after some iterations of such transformation, solution, spending 0 or min(ai, xi) bonuses in each day.To make an O(n2) solution it's possible to consider dynamic programming approach: let dpi, j be minimum amount of money that is possible to spend at first i days to pay for all chargings and have 100·j bonuses on card. At first, dp0, 0 = 0 and dpi, j = ∞. Then we can easy calculate all states going through all states with something like this code:for (int i = 0; i < n; i++) { for (int j = 0; j <= 2 * n; j++) { dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]); dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)], dp[i][j] + a[i] - 100 * min(j, a[i] / 100)); } }Of course, j can be up to 2·n, because at each day it's possible to earn at most 2 bonuses.To make this solution faster let's consider the following observation: there exists an optimal solution, which never has more 3000 bonuses on bonus card. To proof it let's first proof following lemma:Lemma 1: There exists an optimal solution which spends only 0 or ai bonuses at day i if there are at least 3000 bonuses at card at the beginning of day i. Lemma 1 proof: Let's introduce some designations. Let xi be amount of bonuses at the beginning of day i and si be amount of bonuses spent at day i. Also let's call day i \"fractional\" if si ≠ 0 and si ≠ ai, and call day i \"interesting\" if si ≠ 0. Let's proof lemma2 and lemma3 at first:Lemma 2: Assume xi ≥ 3000 and j — next after i interesting day and k — next after j interesting day. Then there exists an optimal solution in which k is not a fractional day or j is not a fractional day. Lemma2 proof: Suppose is some optimal solution j and k are fractional days. Let's consider a solution spending sj + min(sk, aj - s{j}) bonuses at day j and sk - min(sk, aj - s{j}) at day k. This solution is still correct, because xi ≥ 3000, so for days j and k there is enough bonuses and still optimal. Lemma2 is proved.Lemma 3: Assume xi ≥ 3000 and j — next after i interesting day. Then there exists an optimal solution is which j is not a fractional day.Lemma 3 proof: Consider some optimal solution with fractional day j. At first let's proof that j is not last interesting day. Suppose, j is last interesting day in solution. But we can make a solution that spends ai bonuses at day i (because ai ≤ 3000) and it will be more optimal. Contradiction. So there exists next after j interesting day. Let's call it k. Let's consider 2 cases:Case 1 (aj = 1000): Let's spend consider solution spending 1000 bonuses at day j and ak - (1000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2 (aj = 2000): There are two subcases:Case 2.1 (ak = 2000): Let's spend consider solution spending 2000 bonuses at day j and ak - (2000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2.2 (ak = 1000): Let's proof, k is not last interesting day. Assume k is last interesting day. Consider a solution spending 2000 bonuses at day j and 1000 bonuses at day k. It's correct but more optimal that initial solution. Conrtadiction. Now let p be next after k interesting day (k is not a fractional day by lemma2). If 2000 - aj ≤ 1000 we can consider solution which spends 2000 bonuses at day j, 1000 - (2000 - ak) bonuses at day k and sp bonuses at day p. If 2000 - sj > 1000 let's consider a solution which spends sj + 1000 bonuses at day j, 0 bonuses at day k and sp at day p. But by lemma2 sp = ap, so we can consider solution that spends 2000 bonuses at day j 0 bonuses at day k and ap - (2000 - sj - ak) at day k. All of these solutions are correct and optimal.Lemma 1 proof (end): At first, of course there is at least one interesting day after i (Otherwise, it's more optimal to charge at day i using bounses, but in initial solution si = 0 because xi - 1 ≤ 3000 and xi > 3000). Let's call that day j and by lemma3 j is not fractional day. Let's consider 4 cases now:Case 1: (ai = 1000, aj = 1000). Let's consider a solution with si = 1000 and sj = 0. It's correct and still optimal, but xi ≤ 3000.Case 2: (ai = 2000, aj = 2000). Same as case1.Case 3: (ai = 2000, aj = 1000). Let's consider 2 subcases:Case 3.1: j is not last interesting day. Let k be next interesting day. It ak = 1000 consider a solution spending 2000 bonuses at day i, 0 bonuses at days j and k. It's still correct and optimal, but xi ≤ 3000. If ak = 2000 consider a solution a spending 2000 bonuses at day i, 1000 bonuses at day j and 0 bonuses at day k. It's correct and optimal too, and xi ≤ 3000 too.Case 3.2: j is last interesting day. Let's construct solution this way. At first let's set si = 1000 and sj = 0. Then let's iterate over all ineteresting days after j, say k, in order in increasing time and set si = si + min(2000 - si, sk), sk = sk - min(2000 - si, sk). If after this process we still have some bonus left just add it to si. At the end, si will be equal 2000 because we spent all bonuses, solution will still be correct and optimal, but xi ≤ 3000.Case 4: (ai = 1000, aj = 2000). Let p be last day before i with sp ≠ 0. If ap = 1000 consider a solution with sp = 0, si = 0, sj = 2000. It's correct, optimal and xt ≤ 3000 for each t ≤ i. If ap = 2000, consider a solution with sp = 2000, si = 0, sj = 0. It's correct, optimal and xt ≤ 3000 for each t ≤ i, too.So for all cases we can make correct and optimal solution such there is no xi ≤ 3000 for all i, or number of first day with xi > 3000 increases, but it can't increase forever, so after some amount of opereations solution with xi ≤ 3000 for all i will be constructed.Because of this fact we can consider dynamic programming approach described before but notice, that we should consider only states with j ≤ 30. It will have O(n) complexity. Moreover, looking at states with j = 30 is required. It's possible to make a test on which solution, that looks at states with j ≤ 29 will be incorrect.(Idea — Zlobober, developing — malcolm) 853E - Lada MalinaIn the original contest there were subtasks for this problem and it's more convinient to understand the editorial going through these subtasks, so we will leave them here.The key part of a solution is to understand what are the locations that may be accessed from the origin in T seconds. First observation is that we should investigate it only in case when T = 1 because T is simply a scale factor. Let’s denote this set for T = 1 as P.Group #1. For the first group it’s easy to see that P is a square with vertices in points ( ± 2, 0), (0,  ± 2). So, the first group may be solved with a straightforward O(qn) approach: we iterate through all the factories and check if it's possible to get for cars from i-th factories to the car exposition. We can rotate the plane by 45 degrees (this may be done by the transformation x' = x + y, y' = x - y), after this each query region looks like a square. Therefore, it's necessary to check if point lies inside a square:Group #2. In the second group propeller velocities are two arbitrary vectors. It can be shown that P will always be a parallelogram centered in the origin, built on vectors 2v1 and 2v2 as sides. Thus, this group is a matter of the same O(qn) approach with a bit more complicated predicate: one should be able to check that an integer point belongs to an integer parallelogram. The key observation is that we may find an appropriate transformation of a plane that transforms this set into a rectangle. Indeed, there always exists an affine transformation performing what we want. As an additional requirement, we want to transform coordinates in such way that they are still integral and not much larger than the original coordinates. The transformation looks like following:The first expression is a signed distance to the line parallel to the vector v1, and the second one is the signed distance from the line parallel to the vector v2. Easy to see that belonging to some query parallelogram can be formulated in terms of x' and y' independendly belonging to some ranges. Group #3. Second group should be a hint for the third group. One can find that the set P = {w1v1 + ... + wkvk||wi| ≤ 1} is always a central-symmetric polygon with the center in the origin. Actually, this Polygon is a Minkowski sum of k segments [ - vi, vi]. Minkowski sum of sets A1, A2, ..., Ak is by definition the following set: . It can be built in time, although in this problem k is very small, so one may use any inefficient approach that comes into his head, like building a convex hull of all points { ± v1 ± v2... ± vk}.After we found out a form of P, it’s possible to solve the third group of tests in O(qnk) by checking if each possible factory location belongs into a query polygon in O(k) time.Following groups are exactly the same, but the constraints are higher, they require using some geometric data structure to deal with range queries.Groups #4 and #5. Fourth group and fifth group are very similar to first and second group correspondingly, but we need to process the requests faster. After the transformation of the plane, the request can be reformulated as \"find sum of all factories inside a square\", so any 2d data structure may be applied, like a segment tree of segment trees. Another approach is to use a sweeping line algorithm with a segment tree or an appropriate binary search tree, achieving a time complexity or .Group #6. To solve the sixth group we need to use a trapezoidal polygon area calculation algorithm applied to our problem. Calculate the sum of points in each of 2k trapezoid areas below each of the sides of a polygon, and then take them with appropriate signs to achieve a result. Such trapezoid area can be seen as a set of points satisfying the inequalities l ≤ x ≤ r and y ≤ kx + b. Under transformation x' = x, y' = y - kx, this area becomes a rectangle, leading us to an time solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 853\\s*A"
          },
          "content_length": 18717
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 1",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 2",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 3",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 4",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 5",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 6",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 7",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 8",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 9",
          "code": "The number of comparisons performed is logarithmic in the distance between first and last (At most log 2(last - first) + O(1) comparisons). However, for non-RandomAccessIterators, the number of iterator increments is linear.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 10",
          "code": "dpr[i]=dpr[i]-prev+sumright[num];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++) {    for (int j = 0; j <= 2 * n; j++) {         dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]);         dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)],                                                  dp[i][j] + a[i] - 100 * min(j, a[i] / 100));     } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and k\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    // Read c1, c2, ..., cn\n    vector<int> c = inf.readInts(n, 1, 10000000, \"c_i\");\n    inf.readEoln();\n    \n    // End of file\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and k\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    // Read c1, c2, ..., cn\n    vector<int> c = inf.readInts(n, 1, 10000000, \"c_i\");\n    inf.readEoln();\n    \n    // End of file\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and k\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    // Read c1, c2, ..., cn\n    vector<int> c = inf.readInts(n, 1, 10000000, \"c_i\");\n    inf.readEoln();\n    \n    // End of file\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from the input file\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    // Read the costs ci from the input file\n    vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        c[i] = inf.readInt();\n    }\n\n    // Read the contestant's total cost\n    long long contestant_cost = ouf.readLong();\n\n    // Read the ti's (departure times) from the contestant's output\n    vector<int> ti(n);\n    set<int> used_ti;\n    for (int i = 0; i < n; i++) {\n        ti[i] = ouf.readInt();\n        // Validate ti in [k+1, k+n]\n        if (ti[i] < k + 1 || ti[i] > k + n) {\n            quitf(_wa, \"Invalid ti[%d] = %d, should be between %d and %d\", i + 1, ti[i], k + 1, k + n);\n        }\n        // Check uniqueness\n        if (used_ti.count(ti[i])) {\n            quitf(_wa, \"Duplicate departure time ti = %d\", ti[i]);\n        }\n        used_ti.insert(ti[i]);\n        // Validate ti >= max(k+1, i+1)\n        int earliest_ti = max(k + 1, i + 1);\n        if (ti[i] < earliest_ti) {\n            quitf(_wa, \"ti[%d] = %d < earliest possible time %d\", i + 1, ti[i], earliest_ti);\n        }\n    }\n\n    // Compute the contestant's total cost based on ti's\n    long long calculated_cost = 0;\n    for (int i = 0; i < n; i++) {\n        int delay = ti[i] - (i + 1);\n        calculated_cost += 1LL * c[i] * delay;\n    }\n\n    // Validate that the contestant's reported cost matches the calculated cost\n    if (contestant_cost != calculated_cost) {\n        quitf(_wa, \"Contestant's total cost %lld does not match calculated cost %lld\", contestant_cost, calculated_cost);\n    }\n\n    // Now compute the minimal total cost using a greedy algorithm\n    vector<int> flight_indices(n);\n    for (int i = 0; i < n; i++) {\n        flight_indices[i] = i;\n    }\n\n    // For each flight, compute earliest possible departure time\n    vector<int> earliest_ti(n);\n    for (int i = 0; i < n; i++) {\n        earliest_ti[i] = max(k + 1, i + 1);\n    }\n\n    // Sort the flights in decreasing order of ci (to prioritize higher costs)\n    sort(flight_indices.begin(), flight_indices.end(), [&](int a, int b) {\n        return c[a] > c[b];\n    });\n\n    // Initialize a set of available times\n    set<int> available_ti;\n    for (int t = k + 1; t <= k + n; t++) {\n        available_ti.insert(t);\n    }\n\n    vector<int> assigned_ti(n, -1);\n    for (int idx : flight_indices) {\n        int e_ti = earliest_ti[idx];\n        auto it = available_ti.lower_bound(e_ti);\n        if (it == available_ti.end()) {\n            quitf(_fail, \"Cannot assign departure time for flight %d\", idx + 1);\n        }\n        assigned_ti[idx] = *it;\n        available_ti.erase(it);\n    }\n\n    // Compute the minimal total cost based on the assigned times\n    long long minimal_total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        int delay = assigned_ti[i] - (i + 1);\n        minimal_total_cost += 1LL * c[i] * delay;\n    }\n\n    // Compare the contestant's total cost with the minimal total cost\n    if (contestant_cost > minimal_total_cost) {\n        quitf(_wa, \"Contestant's total cost %lld is greater than minimal total cost %lld\", contestant_cost, minimal_total_cost);\n    } else if (contestant_cost == minimal_total_cost) {\n        quitf(_ok, \"Correct. Total cost = %lld\", contestant_cost);\n    } else {\n        quitf(_fail, \"Contestant's total cost %lld is less than minimal total cost %lld\", contestant_cost, minimal_total_cost);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(k >= 1 && k <= n);\n    ensure(n >= 1 && n <= 300000);\n\n    // Generate ci\n    vector<int> c(n);\n\n    if (type == \"all_ones\") {\n        fill(c.begin(), c.end(), 1);\n    } else if (type == \"all_max\") {\n        fill(c.begin(), c.end(), 10000000); // 1e7\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = n - i;\n        }\n    } else if (type == \"equal_random\") {\n        int val = rnd.next(1, 10000000);\n        fill(c.begin(), c.end(), val);\n    } else if (type == \"small_random\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 100);\n        }\n    } else { // Random\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output ci values\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 != n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(k >= 1 && k <= n);\n    ensure(n >= 1 && n <= 300000);\n\n    // Generate ci\n    vector<int> c(n);\n\n    if (type == \"all_ones\") {\n        fill(c.begin(), c.end(), 1);\n    } else if (type == \"all_max\") {\n        fill(c.begin(), c.end(), 10000000); // 1e7\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = n - i;\n        }\n    } else if (type == \"equal_random\") {\n        int val = rnd.next(1, 10000000);\n        fill(c.begin(), c.end(), val);\n    } else if (type == \"small_random\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 100);\n        }\n    } else { // Random\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output ci values\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 != n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type all_ones\n./gen -n 1 -k 1 -type all_max\n./gen -n 1 -k 1 -type random\n\n./gen -n 1 -k 1 -type increasing\n./gen -n 1 -k 1 -type decreasing\n\n./gen -n 2 -k 1 -type all_ones\n./gen -n 2 -k 1 -type random\n\n./gen -n 2 -k 2 -type all_ones\n./gen -n 2 -k 2 -type random\n\n./gen -n 2 -k 1 -type increasing\n./gen -n 2 -k 1 -type decreasing\n\n./gen -n 5 -k 2 -type random\n\n./gen -n 1000 -k 1 -type all_ones\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1000 -type all_ones\n./gen -n 1000 -k 1000 -type random\n\n./gen -n 100000 -k 1 -type all_ones\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 50000 -type increasing\n./gen -n 100000 -k 50000 -type decreasing\n\n./gen -n 100000 -k 99999 -type all_ones\n./gen -n 100000 -k 99999 -type random\n\n./gen -n 300000 -k 1 -type random\n./gen -n 300000 -k 1 -type all_ones\n./gen -n 300000 -k 150000 -type random\n./gen -n 300000 -k 300000 -type all_max\n\n./gen -n 300000 -k 300000 -type small_random\n./gen -n 300000 -k 1 -type equal_random\n\n./gen -n 300000 -k 1 -type increasing\n./gen -n 300000 -k 1 -type decreasing\n\n./gen -n 300000 -k 299999 -type random\n\n./gen -n 300000 -k 1 -type small_random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:39:59.264772",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "853/B",
      "title": "B. Jury Meeting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains three integers n, m and k (1 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106). The i-th of the following m lines contains the description of the i-th flight defined by four integers di, fi, ti and ci (1 ≤ di ≤ 106, 0 ≤ fi ≤ n, 0 ≤ ti ≤ n, 1 ≤ ci ≤ 106, exactly one of fi and ti equals zero), the day of departure (and arrival), the departure city, the arrival city and the ticket cost.",
      "output_spec": "OutputOutput the only integer that is the minimum cost of gathering all jury members in city 0 for k days and then sending them back to their home cities.If it is impossible to gather everybody in Metropolis for k days and then send them back to their home cities, output \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy2 6 51 1 0 50003 2 0 55002 2 0 600015 0 2 90009 0 1 70008 0 2 6500OutputCopy24500InputCopy2 4 51 2 0 50002 1 0 45002 1 0 30008 0 1 6000OutputCopy-1",
      "description": "B. Jury Meeting\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers n, m and k (1 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106). The i-th of the following m lines contains the description of the i-th flight defined by four integers di, fi, ti and ci (1 ≤ di ≤ 106, 0 ≤ fi ≤ n, 0 ≤ ti ≤ n, 1 ≤ ci ≤ 106, exactly one of fi and ti equals zero), the day of departure (and arrival), the departure city, the arrival city and the ticket cost.\n\nOutputOutput the only integer that is the minimum cost of gathering all jury members in city 0 for k days and then sending them back to their home cities.If it is impossible to gather everybody in Metropolis for k days and then send them back to their home cities, output \"-1\" (without the quotes).\n\nInputCopy2 6 51 1 0 50003 2 0 55002 2 0 600015 0 2 90009 0 1 70008 0 2 6500OutputCopy24500InputCopy2 4 51 2 0 50002 1 0 45002 1 0 30008 0 1 6000OutputCopy-1\n\nInputCopy2 6 51 1 0 50003 2 0 55002 2 0 600015 0 2 90009 0 1 70008 0 2 6500\n\nOutputCopy24500\n\nInputCopy2 4 51 2 0 50002 1 0 45002 1 0 30008 0 1 6000\n\nOutputCopy-1\n\nNoteThe optimal way to gather everybody in Metropolis in the first sample test is to use flights that take place on days 1, 2, 8 and 9. The only alternative option is to send jury member from second city back home on day 15, that would cost 2500 more.In the second sample it is impossible to send jury member from city 2 back home from Metropolis.",
      "solutions": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces",
          "content": "Hi everybody!These days Moscow is conducting the 2nd International Olympiad of Metropolises that is an international competition for high school students from biggest cities and capitals all around the world. One of the disciplines of the competition is informatics. Rounds of the competition were prepared by the jury members invited from St. Petersburg, Minsk, Almaty and Moscow olympiad scientific committee which you may know by Moscow team Olympiad, Open Olympiad in Informatics and Moscow Olympiad for young students (rounds 327, 342, 345, 376, 401).We are very grateful to MikeMirzayanov for Polygon system that made it possible to conveniently hold a simultaneous statement translation process into lots of languages. As a good friends of Codeforces platform, we conduct a parallel rated Div. 1 + Div. 2 round on the competition problemset.Round will happen on September 6th at 12:55 UTC and it will last for two hours. There will be 5 problems for each division, scoring will be announced later.Scientific Committee of the olympiad consists of: andrewzta, GlebsHP, Endagorion, meshanya, Chmel_Tolstiy, Zlobober, Helen Andreeva and Bakhyt Matkarymov. Problems were prepared by timgaripov, mingaleg, halin.george, vintage_Vlad_Makeev, malcolm, LHiC coordinated by your humble servant.Codeforces coordinator KAN helped us to choose problems for a round.Good luck and high ratings for everybody!PS We kindly ask everybody who knows problems of an on-site event not to participate in a round and not to discuss them in public, as this may be a subject for disqualification.Congratulations to the winners!In div. 1 they are: Um_nik fateice KADR dotorya FallDream In div. 2 they are: jiangIy xolm YxqK lixolas Rawnd The analysis is published. Thanks to all for participating!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54350",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1777
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces",
          "content": "(Idea — Sender , developing — timgaripov) 854A - FractionIt's possible to look over all possible values of the numerator . For the current value of a we have to compute denominator as b = n - a, check that there are no common divisors (except 1) of a and b (it also could be done by a linear search of possible common divisors 2 ≤ d ≤ a). The answer is the maximal fraction that was considered during the iteration over all possible values of the numerator and passed the irreducibility test. Pseudocode of the described solution is presented below: This solution have time complexity.However, we can find answer to the problem analytically in the following way: (Idea — Chmel_Tolstiy, developing — mingaleg) 854B - Maxim Buys an ApartmentMinimum number of good apartments is almost always 1, since rooms with indices from 1 to k could be inhabited. Exceptions are cases in which k = 0 and k = n, in these cases both minimum and maximum number of good rooms is 0 since there is no inhabitant or vacant apartments.Maximum number of good apartments could be reached, for example, as follows. Assume apartments with indices 2, 5, 8 and so on are occupied as much as possible. Each of these apartments produces 2 good rooms except from, if it exists, the one with index n (that apartment produces 1 good apartment). If number of inhabitant apartments is less than k occupy any of rest rooms to reach that number, every such occupation will decrease number of good apartments by one). Simulate this process, than count the number of good rooms to find maximum possible number. Expected complexity: O(n2) or O(n).Instead of simulating the above process calculate number of apartments with indices 2, 5, 8 and so on excluding the one with index n if it exists. Number of that apartments is equal to , and if k ≤ x you can occupy some of these apartments to reach maximum number of good rooms equal to 2·k. Otherwise, if k > x, assume that apartments with indices 2, 5, 8 and so on are occupied, so any room has at least one inhabited room adjacent to it. Therefore number of good apartments is equal to number of vacant apartments and is equal to n - k. Implementation of these formulas with keeping in mind cases in which k = 0 and k = n will be scored as full solution of problem. Expected complexity: O(1).(Idea — Zlobober, developing — halin.george) 853A - PlanningWe will show that following greedy is correct: let's for each moment of time use a plane, which can depart in this moment of time (and didn't depart earlier, of course) with minimal cost of delay. Proof is quite simple: it's required to minimize . You can notice that is constant, so we just need to minimize . Consider the optimal solution when plane i departs at moment bi and solution by greedy algorithm in which plane i departs at moment ai. Let x be plane with minimal cx, such ax ≠ bx. At any moment greedy algorithm takes avaliable plane with lowest cx, so ax < bx. Let y be a plane, such that by = ax. But cy >  = by, so bx·cx + by·cy >  = bx·cy + by·cx and it's possible to swap bx and by in optimal solution without loosing of optimality. By performing this operation many times it's possible to make bi = ai for each i and it means that greedy solution is optimal.To make this solution work fast you need to use some data structures to find optimal plane faster for each moment. This data structure should be able to add number into set, give value of minimal element in set and erase minimal number from set. For this purpose you can use heap (or someting like std::set or std::priority_queue in C++). (Idea — GlebsHP, developing — mingaleg) 853B - Jury MeetingObviously, each member of the jury needs to buy exactly two tickets — to the capital and back. Sort all flights by the day of departure. Now go through flights to the capital (forward flights) and one by one assume it is the last forward flight in answer (let's say it is scheduled on day d). Thus you are assuming that all forward flights are contained in some fixed prefix of flights. Make sure that there is at least one forward flight for every jury member in this prefix and find the cheapest forward flight among them for every person. All return flights we are interested in are contained in the suffix of flights list such that every flight's departure date is at least d + k + 1. Take similar steps: make sure that there is at least one return flight for every jury member in this suffix and find the cheapest return flight among them for every person as well. Select minimal cost among these variants or find out that the problem has no solution. Expected complexity: O(nm2) or O(m2 + n).Just as the boundary of considered prefix moves right, the boundary of considered suffix moves right as well. This suggests that the problem could be solved by the two pointers method. Assume you are storing minimum forward flight's cost on current prefix (infinity if no flight exists) for every person, and you are storing multiset (ordered by cost) of all return flights on current suffix for each person as well. To proceed next prefix and conforming suffix do the following: Move prefix boundary to the next forward flight. If its cost ci is less than minimum forward flight's cost fwdfi from that city, then you could improve total cost: decrease it by ci - fwdfi and set fwdfi to ci since it's new minimal cost. Move suffix boundary to the next backward flight until there is such flight exists and it departure date difference with prefix boundary departure date is under k + 1. While moving suffix boundary, keep return flights multisets consistent: remove boundary flight right before moving that boundary to the next flight. Also check out if you are removing cheapest flight from multiset. If it is so, minimal flight cost for that city changed as well as total cost: it increases by difference between old minimal cost and new minimal cost. Keep in mind that if you are removing last flight from multiset, then there is no more appropriate return flight for this city and you should terminate the process. Proceed these steps moving boundaries to the right until the process terminates. In this way you've reviewed the same prefixes and corresponding suffixes as in slower solution described above. Expected complexity: .(Idea — glebushka98, developing — vintage_Vlad_Makeev) 853C - BoredomWe can't iterate over all interesting rectangles. Let's count number of rectangles that are not intersecting our rectangle. To do it let's calculate number of rectangles to the left, right, up and down of rectangle in query. It can be easily done in O(1) time: suppose we have rectangle with corners (i;pi) and (j;pj). We have min(i, j) - 1 points to the left of rectangle, n - max(i, j) to the right, min(pi, pj) - 1 to the down, etc. If we have x points in some area, there are rectangles in that area. But now we calculated twice rectangles that are simultaneously to the left and up of our rectangle, left and down, etc. To find number of such rectangles we can iterate over all points and find points which are in these areas and find number of rectangles in area using formula . The complexity is O(q·n).To solve the problem we need to find number of points in some areas faster. It's quite easy to notice that we just have many queries of finding number of points in some subrectangle. It's classical problem that can be solved with some 2d tree in O(q·log2) solution. But it can be too slow and can not fit into time limit in case of inaccurate implementation. However, you can notice that all queries are offline and find number of points in subrectangle in O(q·logn) time. It's fast enough to pass all tests.(Idea — Elena Andreeva, developing — vintage_Vlad_Makeev) 853D - Michael and Charging StationsBefore solving problem one observation is required: suppose at day i we have xi bonuses. Then exists optimal solution, which spends 0 or min(ai, xi) bonuses every day. It's quite easy to proof: suppose we have some optimal solution and i is a first day, when neither 0 nor min(ai, xi) bonuses were spent. If i is a last day on which non-zero amount of bonuses was spent, we can notice that solution spending min(ai, xi) bonuses that day is more optimal, so first solution was optimal. So let's consider next day after i, when non-zero amount of bonuses was spent, say j, and amount of bonuses spent at day j is sj (Also, amount of bonuses spent on day i is si). Let's look at solution that spends si + min(si - min(ai, xi), sj) bonuses at day i and sj - min(si - min(ai, xi), sj). That solution is still correct and still optimal, but it spends min(ai, xi) at day i or 0 at day j. Anyway this operation increases first day i when neither i nor min(ai, xi) bonuses were spent or first day j after it, when non-zero amount of burles were spent. But we can't increase i or j infinitely, so, after some iterations of such transformation, solution, spending 0 or min(ai, xi) bonuses in each day.To make an O(n2) solution it's possible to consider dynamic programming approach: let dpi, j be minimum amount of money that is possible to spend at first i days to pay for all chargings and have 100·j bonuses on card. At first, dp0, 0 = 0 and dpi, j = ∞. Then we can easy calculate all states going through all states with something like this code:for (int i = 0; i < n; i++) { for (int j = 0; j <= 2 * n; j++) { dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]); dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)], dp[i][j] + a[i] - 100 * min(j, a[i] / 100)); } }Of course, j can be up to 2·n, because at each day it's possible to earn at most 2 bonuses.To make this solution faster let's consider the following observation: there exists an optimal solution, which never has more 3000 bonuses on bonus card. To proof it let's first proof following lemma:Lemma 1: There exists an optimal solution which spends only 0 or ai bonuses at day i if there are at least 3000 bonuses at card at the beginning of day i. Lemma 1 proof: Let's introduce some designations. Let xi be amount of bonuses at the beginning of day i and si be amount of bonuses spent at day i. Also let's call day i \"fractional\" if si ≠ 0 and si ≠ ai, and call day i \"interesting\" if si ≠ 0. Let's proof lemma2 and lemma3 at first:Lemma 2: Assume xi ≥ 3000 and j — next after i interesting day and k — next after j interesting day. Then there exists an optimal solution in which k is not a fractional day or j is not a fractional day. Lemma2 proof: Suppose is some optimal solution j and k are fractional days. Let's consider a solution spending sj + min(sk, aj - s{j}) bonuses at day j and sk - min(sk, aj - s{j}) at day k. This solution is still correct, because xi ≥ 3000, so for days j and k there is enough bonuses and still optimal. Lemma2 is proved.Lemma 3: Assume xi ≥ 3000 and j — next after i interesting day. Then there exists an optimal solution is which j is not a fractional day.Lemma 3 proof: Consider some optimal solution with fractional day j. At first let's proof that j is not last interesting day. Suppose, j is last interesting day in solution. But we can make a solution that spends ai bonuses at day i (because ai ≤ 3000) and it will be more optimal. Contradiction. So there exists next after j interesting day. Let's call it k. Let's consider 2 cases:Case 1 (aj = 1000): Let's spend consider solution spending 1000 bonuses at day j and ak - (1000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2 (aj = 2000): There are two subcases:Case 2.1 (ak = 2000): Let's spend consider solution spending 2000 bonuses at day j and ak - (2000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2.2 (ak = 1000): Let's proof, k is not last interesting day. Assume k is last interesting day. Consider a solution spending 2000 bonuses at day j and 1000 bonuses at day k. It's correct but more optimal that initial solution. Conrtadiction. Now let p be next after k interesting day (k is not a fractional day by lemma2). If 2000 - aj ≤ 1000 we can consider solution which spends 2000 bonuses at day j, 1000 - (2000 - ak) bonuses at day k and sp bonuses at day p. If 2000 - sj > 1000 let's consider a solution which spends sj + 1000 bonuses at day j, 0 bonuses at day k and sp at day p. But by lemma2 sp = ap, so we can consider solution that spends 2000 bonuses at day j 0 bonuses at day k and ap - (2000 - sj - ak) at day k. All of these solutions are correct and optimal.Lemma 1 proof (end): At first, of course there is at least one interesting day after i (Otherwise, it's more optimal to charge at day i using bounses, but in initial solution si = 0 because xi - 1 ≤ 3000 and xi > 3000). Let's call that day j and by lemma3 j is not fractional day. Let's consider 4 cases now:Case 1: (ai = 1000, aj = 1000). Let's consider a solution with si = 1000 and sj = 0. It's correct and still optimal, but xi ≤ 3000.Case 2: (ai = 2000, aj = 2000). Same as case1.Case 3: (ai = 2000, aj = 1000). Let's consider 2 subcases:Case 3.1: j is not last interesting day. Let k be next interesting day. It ak = 1000 consider a solution spending 2000 bonuses at day i, 0 bonuses at days j and k. It's still correct and optimal, but xi ≤ 3000. If ak = 2000 consider a solution a spending 2000 bonuses at day i, 1000 bonuses at day j and 0 bonuses at day k. It's correct and optimal too, and xi ≤ 3000 too.Case 3.2: j is last interesting day. Let's construct solution this way. At first let's set si = 1000 and sj = 0. Then let's iterate over all ineteresting days after j, say k, in order in increasing time and set si = si + min(2000 - si, sk), sk = sk - min(2000 - si, sk). If after this process we still have some bonus left just add it to si. At the end, si will be equal 2000 because we spent all bonuses, solution will still be correct and optimal, but xi ≤ 3000.Case 4: (ai = 1000, aj = 2000). Let p be last day before i with sp ≠ 0. If ap = 1000 consider a solution with sp = 0, si = 0, sj = 2000. It's correct, optimal and xt ≤ 3000 for each t ≤ i. If ap = 2000, consider a solution with sp = 2000, si = 0, sj = 0. It's correct, optimal and xt ≤ 3000 for each t ≤ i, too.So for all cases we can make correct and optimal solution such there is no xi ≤ 3000 for all i, or number of first day with xi > 3000 increases, but it can't increase forever, so after some amount of opereations solution with xi ≤ 3000 for all i will be constructed.Because of this fact we can consider dynamic programming approach described before but notice, that we should consider only states with j ≤ 30. It will have O(n) complexity. Moreover, looking at states with j = 30 is required. It's possible to make a test on which solution, that looks at states with j ≤ 29 will be incorrect.(Idea — Zlobober, developing — malcolm) 853E - Lada MalinaIn the original contest there were subtasks for this problem and it's more convinient to understand the editorial going through these subtasks, so we will leave them here.The key part of a solution is to understand what are the locations that may be accessed from the origin in T seconds. First observation is that we should investigate it only in case when T = 1 because T is simply a scale factor. Let’s denote this set for T = 1 as P.Group #1. For the first group it’s easy to see that P is a square with vertices in points ( ± 2, 0), (0,  ± 2). So, the first group may be solved with a straightforward O(qn) approach: we iterate through all the factories and check if it's possible to get for cars from i-th factories to the car exposition. We can rotate the plane by 45 degrees (this may be done by the transformation x' = x + y, y' = x - y), after this each query region looks like a square. Therefore, it's necessary to check if point lies inside a square:Group #2. In the second group propeller velocities are two arbitrary vectors. It can be shown that P will always be a parallelogram centered in the origin, built on vectors 2v1 and 2v2 as sides. Thus, this group is a matter of the same O(qn) approach with a bit more complicated predicate: one should be able to check that an integer point belongs to an integer parallelogram. The key observation is that we may find an appropriate transformation of a plane that transforms this set into a rectangle. Indeed, there always exists an affine transformation performing what we want. As an additional requirement, we want to transform coordinates in such way that they are still integral and not much larger than the original coordinates. The transformation looks like following:The first expression is a signed distance to the line parallel to the vector v1, and the second one is the signed distance from the line parallel to the vector v2. Easy to see that belonging to some query parallelogram can be formulated in terms of x' and y' independendly belonging to some ranges. Group #3. Second group should be a hint for the third group. One can find that the set P = {w1v1 + ... + wkvk||wi| ≤ 1} is always a central-symmetric polygon with the center in the origin. Actually, this Polygon is a Minkowski sum of k segments [ - vi, vi]. Minkowski sum of sets A1, A2, ..., Ak is by definition the following set: . It can be built in time, although in this problem k is very small, so one may use any inefficient approach that comes into his head, like building a convex hull of all points { ± v1 ± v2... ± vk}.After we found out a form of P, it’s possible to solve the third group of tests in O(qnk) by checking if each possible factory location belongs into a query polygon in O(k) time.Following groups are exactly the same, but the constraints are higher, they require using some geometric data structure to deal with range queries.Groups #4 and #5. Fourth group and fifth group are very similar to first and second group correspondingly, but we need to process the requests faster. After the transformation of the plane, the request can be reformulated as \"find sum of all factories inside a square\", so any 2d data structure may be applied, like a segment tree of segment trees. Another approach is to use a sweeping line algorithm with a segment tree or an appropriate binary search tree, achieving a time complexity or .Group #6. To solve the sixth group we need to use a trapezoidal polygon area calculation algorithm applied to our problem. Calculate the sum of points in each of 2k trapezoid areas below each of the sides of a polygon, and then take them with appropriate signs to achieve a result. Such trapezoid area can be seen as a set of points satisfying the inequalities l ≤ x ≤ r and y ≤ kx + b. Under transformation x' = x, y' = y - kx, this area becomes a rectangle, leading us to an time solution.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 853\\s*B"
          },
          "content_length": 18717
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 1",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 2",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 3",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 4",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 5",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 6",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 7",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 8",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 9",
          "code": "The number of comparisons performed is logarithmic in the distance between first and last (At most log 2(last - first) + O(1) comparisons). However, for non-RandomAccessIterators, the number of iterator increments is linear.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 10",
          "code": "dpr[i]=dpr[i]-prev+sumright[num];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++) {    for (int j = 0; j <= 2 * n; j++) {         dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]);         dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)],                                                  dp[i][j] + a[i] - 100 * min(j, a[i] / 100));     } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54368",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = (int)1e5;\n    const int MAX_M = (int)1e5;\n    const int MAX_K = (int)1e6;\n    const int MAX_D = (int)1e6;\n    const int MAX_C = (int)1e6;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, MAX_M, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, MAX_K, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int di = inf.readInt(1, MAX_D, \"di\");\n        inf.readSpace();\n        int fi = inf.readInt(0, n, \"fi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, n, \"ti\");\n        inf.readSpace();\n        int ci = inf.readInt(1, MAX_C, \"ci\");\n        inf.readEoln();\n\n        // Exactly one of fi and ti must be zero, and not both\n        ensuref((fi == 0) != (ti == 0), \"Exactly one of fi and ti must be zero; fi=%d, ti=%d\", fi, ti);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = (int)1e5;\n    const int MAX_M = (int)1e5;\n    const int MAX_K = (int)1e6;\n    const int MAX_D = (int)1e6;\n    const int MAX_C = (int)1e6;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, MAX_M, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, MAX_K, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int di = inf.readInt(1, MAX_D, \"di\");\n        inf.readSpace();\n        int fi = inf.readInt(0, n, \"fi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, n, \"ti\");\n        inf.readSpace();\n        int ci = inf.readInt(1, MAX_C, \"ci\");\n        inf.readEoln();\n\n        // Exactly one of fi and ti must be zero, and not both\n        ensuref((fi == 0) != (ti == 0), \"Exactly one of fi and ti must be zero; fi=%d, ti=%d\", fi, ti);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = (int)1e5;\n    const int MAX_M = (int)1e5;\n    const int MAX_K = (int)1e6;\n    const int MAX_D = (int)1e6;\n    const int MAX_C = (int)1e6;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, MAX_M, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, MAX_K, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int di = inf.readInt(1, MAX_D, \"di\");\n        inf.readSpace();\n        int fi = inf.readInt(0, n, \"fi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, n, \"ti\");\n        inf.readSpace();\n        int ci = inf.readInt(1, MAX_C, \"ci\");\n        inf.readEoln();\n\n        // Exactly one of fi and ti must be zero, and not both\n        ensuref((fi == 0) != (ti == 0), \"Exactly one of fi and ti must be zero; fi=%d, ti=%d\", fi, ti);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<tuple<int,int,int,int>>> flights_by_day;\n    int m = 0; // Number of flights\n\n    if (type == \"impossible_no_incoming\") {\n        // At least one jury member has no flight to Metropolis\n        int missing_member = rnd.next(1, n);\n\n        // Generate flights for all others\n        vector<int> members(n);\n        iota(members.begin(), members.end(), 1);\n\n        // Remove missing_member from list\n        members.erase(members.begin() + missing_member - 1);\n\n        m = 2 * ((int)members.size());\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        // For each other member, generate incoming and outgoing flights\n        for (int member : members) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"impossible_no_outgoing\") {\n        // At least one jury member has no flight from Metropolis\n        int stuck_member = rnd.next(1, n);\n\n        // Generate flights for all others\n        vector<int> members(n);\n        iota(members.begin(), members.end(), 1);\n\n        // Remove stuck_member from list\n        members.erase(members.begin() + stuck_member - 1);\n\n        m = 2 * ((int)members.size()) + 1; // Additional incoming flight for stuck_member\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        // For each other member, generate incoming and outgoing flights\n        for (int member : members) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n\n        // For stuck_member, only an incoming flight\n        int arrival_day = rnd.next(1, 500000);\n\n        int ci = rnd.next(1, 1000000);\n\n        // Flight from member's city to Metropolis\n        printf(\"%d %d %d %d\\n\", arrival_day, stuck_member, 0, ci);\n\n        // No outgoing flight for stuck_member\n    } else if (type == \"impossible_no_flights\") {\n        // m=0, so impossible to schedule flights\n        m = 0;\n        printf(\"%d %d %d\\n\", n, m, k);\n        // No flights\n    } else if (type == \"possible_exact\") {\n        // For each jury member, generate flights that exactly allow them to work for k days\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = 1;\n            int departure_day = arrival_day + k + 1; // Arrival and departure days are not working days\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"possible_extra_days\") {\n        // For each jury member, generate flights that force them to stay extra days in Metropolis\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = 1;\n            int extra_days = rnd.next(1, 1000);\n            int departure_day = arrival_day + k + extra_days + 1; // Arrival and departure days are non-working\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"maximal\") {\n        // Max values for n, m, k\n        n = 100000;\n        k = 1000000;\n        m = 100000;\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int i = 0; i < m; ++i) {\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n\n            if (rnd.next(0,1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n\n            int ci = rnd.next(1, 1000000);\n\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    } else if (type == \"minimal\") {\n        // Minimal values for n, m, k\n        n = 1;\n        m = 2;\n        k = 1;\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        int arrival_day = 2;\n        int departure_day = arrival_day + k + 1;\n\n        int ci = 1;\n\n        // Flight from member's city to Metropolis\n        printf(\"%d %d %d %d\\n\", arrival_day, 1, 0, ci);\n\n        // Flight from Metropolis to member's city\n        printf(\"%d %d %d %d\\n\", departure_day, 0, 1, ci);\n    } else if (type == \"overlapping_flights\") {\n        // Flights that overlap with working days\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k; // Departure day is last working day\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"edge_dates\") {\n        // Flights on earliest and latest possible days\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 2); // Early days\n            int departure_day = 1000000 - rnd.next(0, 10);\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"expensive_case\") {\n        // Flights are very expensive\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        int ci = 1000000; // Maximum cost\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"cheap_case\") {\n        // Flights are very cheap\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        int ci = 1; // Minimum cost\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else {\n        // Random data\n        m = opt<int>(\"m\", n * 2);\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int i = 0; i < m; ++i) {\n            int fi, ti;\n            if (rnd.next(0, 1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n\n            int di = rnd.next(1, 1000000);\n            int ci = rnd.next(1, 1000000);\n\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<tuple<int,int,int,int>>> flights_by_day;\n    int m = 0; // Number of flights\n\n    if (type == \"impossible_no_incoming\") {\n        // At least one jury member has no flight to Metropolis\n        int missing_member = rnd.next(1, n);\n\n        // Generate flights for all others\n        vector<int> members(n);\n        iota(members.begin(), members.end(), 1);\n\n        // Remove missing_member from list\n        members.erase(members.begin() + missing_member - 1);\n\n        m = 2 * ((int)members.size());\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        // For each other member, generate incoming and outgoing flights\n        for (int member : members) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"impossible_no_outgoing\") {\n        // At least one jury member has no flight from Metropolis\n        int stuck_member = rnd.next(1, n);\n\n        // Generate flights for all others\n        vector<int> members(n);\n        iota(members.begin(), members.end(), 1);\n\n        // Remove stuck_member from list\n        members.erase(members.begin() + stuck_member - 1);\n\n        m = 2 * ((int)members.size()) + 1; // Additional incoming flight for stuck_member\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        // For each other member, generate incoming and outgoing flights\n        for (int member : members) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n\n        // For stuck_member, only an incoming flight\n        int arrival_day = rnd.next(1, 500000);\n\n        int ci = rnd.next(1, 1000000);\n\n        // Flight from member's city to Metropolis\n        printf(\"%d %d %d %d\\n\", arrival_day, stuck_member, 0, ci);\n\n        // No outgoing flight for stuck_member\n    } else if (type == \"impossible_no_flights\") {\n        // m=0, so impossible to schedule flights\n        m = 0;\n        printf(\"%d %d %d\\n\", n, m, k);\n        // No flights\n    } else if (type == \"possible_exact\") {\n        // For each jury member, generate flights that exactly allow them to work for k days\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = 1;\n            int departure_day = arrival_day + k + 1; // Arrival and departure days are not working days\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"possible_extra_days\") {\n        // For each jury member, generate flights that force them to stay extra days in Metropolis\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = 1;\n            int extra_days = rnd.next(1, 1000);\n            int departure_day = arrival_day + k + extra_days + 1; // Arrival and departure days are non-working\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"maximal\") {\n        // Max values for n, m, k\n        n = 100000;\n        k = 1000000;\n        m = 100000;\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int i = 0; i < m; ++i) {\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n\n            if (rnd.next(0,1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n\n            int ci = rnd.next(1, 1000000);\n\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    } else if (type == \"minimal\") {\n        // Minimal values for n, m, k\n        n = 1;\n        m = 2;\n        k = 1;\n\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        int arrival_day = 2;\n        int departure_day = arrival_day + k + 1;\n\n        int ci = 1;\n\n        // Flight from member's city to Metropolis\n        printf(\"%d %d %d %d\\n\", arrival_day, 1, 0, ci);\n\n        // Flight from Metropolis to member's city\n        printf(\"%d %d %d %d\\n\", departure_day, 0, 1, ci);\n    } else if (type == \"overlapping_flights\") {\n        // Flights that overlap with working days\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k; // Departure day is last working day\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"edge_dates\") {\n        // Flights on earliest and latest possible days\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 2); // Early days\n            int departure_day = 1000000 - rnd.next(0, 10);\n\n            int ci = rnd.next(1, 1000000);\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"expensive_case\") {\n        // Flights are very expensive\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        int ci = 1000000; // Maximum cost\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else if (type == \"cheap_case\") {\n        // Flights are very cheap\n        m = 2 * n;\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        int ci = 1; // Minimum cost\n\n        for (int member = 1; member <= n; ++member) {\n            int arrival_day = rnd.next(1, 500000);\n            int departure_day = arrival_day + k + 1;\n\n            // Flight from member's city to Metropolis\n            printf(\"%d %d %d %d\\n\", arrival_day, member, 0, ci);\n\n            // Flight from Metropolis to member's city\n            printf(\"%d %d %d %d\\n\", departure_day, 0, member, ci);\n        }\n    } else {\n        // Random data\n        m = opt<int>(\"m\", n * 2);\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        for (int i = 0; i < m; ++i) {\n            int fi, ti;\n            if (rnd.next(0, 1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n\n            int di = rnd.next(1, 1000000);\n            int ci = rnd.next(1, 1000000);\n\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type minimal\n./gen -n 2 -k 5 -type minimal\n./gen -n 1 -k 1 -type possible_exact\n./gen -n 5 -k 10 -type possible_exact\n./gen -n 10 -k 100 -type possible_exact\n\n./gen -n 100 -k 1000 -type possible_extra_days\n./gen -n 1000 -k 10000 -type possible_extra_days\n./gen -n 10000 -k 100000 -type possible_extra_days\n\n./gen -n 5 -k 10 -type impossible_no_incoming\n./gen -n 10 -k 20 -type impossible_no_incoming\n./gen -n 100 -k 100 -type impossible_no_incoming\n\n./gen -n 5 -k 10 -type impossible_no_outgoing\n./gen -n 10 -k 20 -type impossible_no_outgoing\n./gen -n 100 -k 100 -type impossible_no_outgoing\n\n./gen -n 5 -k 10 -type impossible_no_flights\n./gen -n 10 -k 20 -type impossible_no_flights\n\n./gen -n 100000 -k 1000000 -type maximal\n\n./gen -n 1000 -k 50000 -type overlapping_flights\n./gen -n 10000 -k 100000 -type overlapping_flights\n\n./gen -n 5 -k 1 -type edge_dates\n./gen -n 10 -k 1 -type edge_dates\n./gen -n 10000 -k 500000 -type edge_dates\n\n./gen -n 1000 -k 10000 -type expensive_case\n./gen -n 1000 -k 10000 -type cheap_case\n\n./gen -n 1000 -k 10000 -type random -m 10000\n./gen -n 10000 -k 100000 -type random -m 50000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:01.507922",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "853/C",
      "title": "C. Boredom",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and q (2 ≤ n ≤ 200 000, 1 ≤ q ≤ 200 000) — the size of the grid and the number of query rectangles.The second line contains n integers p1, p2, ..., pn, separated by spaces (1 ≤ pi ≤ n, all pi are different), they specify grid squares marked by Ilya: in column i he has marked a square at row pi, rows are numbered from 1 to n, bottom to top, columns are numbered from 1 to n, left to right.The following q lines describe query rectangles. Each rectangle is described by four integers: l, d, r, u (1 ≤ l ≤ r ≤ n, 1 ≤ d ≤ u ≤ n), here l and r are the leftmost and the rightmost columns of the rectangle, d and u the bottommost and the topmost rows of the rectangle.",
      "output_spec": "OutputFor each query rectangle output its beauty degree on a separate line.",
      "sample_tests": "ExamplesInputCopy2 31 21 1 1 11 1 1 21 1 2 2OutputCopy111InputCopy4 21 3 2 44 1 4 41 1 2 3OutputCopy35",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers n and q (2 ≤ n ≤ 200 000, 1 ≤ q ≤ 200 000) — the size of the grid and the number of query rectangles.The second line contains n integers p1, p2, ..., pn, separated by spaces (1 ≤ pi ≤ n, all pi are different), they specify grid squares marked by Ilya: in column i he has marked a square at row pi, rows are numbered from 1 to n, bottom to top, columns are numbered from 1 to n, left to right.The following q lines describe query rectangles. Each rectangle is described by four integers: l, d, r, u (1 ≤ l ≤ r ≤ n, 1 ≤ d ≤ u ≤ n), here l and r are the leftmost and the rightmost columns of the rectangle, d and u the bottommost and the topmost rows of the rectangle.\n\nOutputFor each query rectangle output its beauty degree on a separate line.\n\nInputCopy2 31 21 1 1 11 1 1 21 1 2 2OutputCopy111InputCopy4 21 3 2 44 1 4 41 1 2 3OutputCopy35\n\nInputCopy2 31 21 1 1 11 1 1 21 1 2 2\n\nOutputCopy111\n\nInputCopy4 21 3 2 44 1 4 41 1 2 3\n\nOutputCopy35\n\nNoteThe first sample test has one beautiful rectangle that occupies the whole grid, therefore the answer to any query is 1.In the second sample test the first query rectangle intersects 3 beautiful rectangles, as shown on the picture below:  There are 5 beautiful rectangles that intersect the second query rectangle, as shown on the following picture:",
      "solutions": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces",
          "content": "Hi everybody!These days Moscow is conducting the 2nd International Olympiad of Metropolises that is an international competition for high school students from biggest cities and capitals all around the world. One of the disciplines of the competition is informatics. Rounds of the competition were prepared by the jury members invited from St. Petersburg, Minsk, Almaty and Moscow olympiad scientific committee which you may know by Moscow team Olympiad, Open Olympiad in Informatics and Moscow Olympiad for young students (rounds 327, 342, 345, 376, 401).We are very grateful to MikeMirzayanov for Polygon system that made it possible to conveniently hold a simultaneous statement translation process into lots of languages. As a good friends of Codeforces platform, we conduct a parallel rated Div. 1 + Div. 2 round on the competition problemset.Round will happen on September 6th at 12:55 UTC and it will last for two hours. There will be 5 problems for each division, scoring will be announced later.Scientific Committee of the olympiad consists of: andrewzta, GlebsHP, Endagorion, meshanya, Chmel_Tolstiy, Zlobober, Helen Andreeva and Bakhyt Matkarymov. Problems were prepared by timgaripov, mingaleg, halin.george, vintage_Vlad_Makeev, malcolm, LHiC coordinated by your humble servant.Codeforces coordinator KAN helped us to choose problems for a round.Good luck and high ratings for everybody!PS We kindly ask everybody who knows problems of an on-site event not to participate in a round and not to discuss them in public, as this may be a subject for disqualification.Congratulations to the winners!In div. 1 they are: Um_nik fateice KADR dotorya FallDream In div. 2 they are: jiangIy xolm YxqK lixolas Rawnd The analysis is published. Thanks to all for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54350",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1777
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces",
          "content": "(Idea — Sender , developing — timgaripov) 854A - FractionIt's possible to look over all possible values of the numerator . For the current value of a we have to compute denominator as b = n - a, check that there are no common divisors (except 1) of a and b (it also could be done by a linear search of possible common divisors 2 ≤ d ≤ a). The answer is the maximal fraction that was considered during the iteration over all possible values of the numerator and passed the irreducibility test. Pseudocode of the described solution is presented below: This solution have time complexity.However, we can find answer to the problem analytically in the following way: (Idea — Chmel_Tolstiy, developing — mingaleg) 854B - Maxim Buys an ApartmentMinimum number of good apartments is almost always 1, since rooms with indices from 1 to k could be inhabited. Exceptions are cases in which k = 0 and k = n, in these cases both minimum and maximum number of good rooms is 0 since there is no inhabitant or vacant apartments.Maximum number of good apartments could be reached, for example, as follows. Assume apartments with indices 2, 5, 8 and so on are occupied as much as possible. Each of these apartments produces 2 good rooms except from, if it exists, the one with index n (that apartment produces 1 good apartment). If number of inhabitant apartments is less than k occupy any of rest rooms to reach that number, every such occupation will decrease number of good apartments by one). Simulate this process, than count the number of good rooms to find maximum possible number. Expected complexity: O(n2) or O(n).Instead of simulating the above process calculate number of apartments with indices 2, 5, 8 and so on excluding the one with index n if it exists. Number of that apartments is equal to , and if k ≤ x you can occupy some of these apartments to reach maximum number of good rooms equal to 2·k. Otherwise, if k > x, assume that apartments with indices 2, 5, 8 and so on are occupied, so any room has at least one inhabited room adjacent to it. Therefore number of good apartments is equal to number of vacant apartments and is equal to n - k. Implementation of these formulas with keeping in mind cases in which k = 0 and k = n will be scored as full solution of problem. Expected complexity: O(1).(Idea — Zlobober, developing — halin.george) 853A - PlanningWe will show that following greedy is correct: let's for each moment of time use a plane, which can depart in this moment of time (and didn't depart earlier, of course) with minimal cost of delay. Proof is quite simple: it's required to minimize . You can notice that is constant, so we just need to minimize . Consider the optimal solution when plane i departs at moment bi and solution by greedy algorithm in which plane i departs at moment ai. Let x be plane with minimal cx, such ax ≠ bx. At any moment greedy algorithm takes avaliable plane with lowest cx, so ax < bx. Let y be a plane, such that by = ax. But cy >  = by, so bx·cx + by·cy >  = bx·cy + by·cx and it's possible to swap bx and by in optimal solution without loosing of optimality. By performing this operation many times it's possible to make bi = ai for each i and it means that greedy solution is optimal.To make this solution work fast you need to use some data structures to find optimal plane faster for each moment. This data structure should be able to add number into set, give value of minimal element in set and erase minimal number from set. For this purpose you can use heap (or someting like std::set or std::priority_queue in C++). (Idea — GlebsHP, developing — mingaleg) 853B - Jury MeetingObviously, each member of the jury needs to buy exactly two tickets — to the capital and back. Sort all flights by the day of departure. Now go through flights to the capital (forward flights) and one by one assume it is the last forward flight in answer (let's say it is scheduled on day d). Thus you are assuming that all forward flights are contained in some fixed prefix of flights. Make sure that there is at least one forward flight for every jury member in this prefix and find the cheapest forward flight among them for every person. All return flights we are interested in are contained in the suffix of flights list such that every flight's departure date is at least d + k + 1. Take similar steps: make sure that there is at least one return flight for every jury member in this suffix and find the cheapest return flight among them for every person as well. Select minimal cost among these variants or find out that the problem has no solution. Expected complexity: O(nm2) or O(m2 + n).Just as the boundary of considered prefix moves right, the boundary of considered suffix moves right as well. This suggests that the problem could be solved by the two pointers method. Assume you are storing minimum forward flight's cost on current prefix (infinity if no flight exists) for every person, and you are storing multiset (ordered by cost) of all return flights on current suffix for each person as well. To proceed next prefix and conforming suffix do the following: Move prefix boundary to the next forward flight. If its cost ci is less than minimum forward flight's cost fwdfi from that city, then you could improve total cost: decrease it by ci - fwdfi and set fwdfi to ci since it's new minimal cost. Move suffix boundary to the next backward flight until there is such flight exists and it departure date difference with prefix boundary departure date is under k + 1. While moving suffix boundary, keep return flights multisets consistent: remove boundary flight right before moving that boundary to the next flight. Also check out if you are removing cheapest flight from multiset. If it is so, minimal flight cost for that city changed as well as total cost: it increases by difference between old minimal cost and new minimal cost. Keep in mind that if you are removing last flight from multiset, then there is no more appropriate return flight for this city and you should terminate the process. Proceed these steps moving boundaries to the right until the process terminates. In this way you've reviewed the same prefixes and corresponding suffixes as in slower solution described above. Expected complexity: .(Idea — glebushka98, developing — vintage_Vlad_Makeev) 853C - BoredomWe can't iterate over all interesting rectangles. Let's count number of rectangles that are not intersecting our rectangle. To do it let's calculate number of rectangles to the left, right, up and down of rectangle in query. It can be easily done in O(1) time: suppose we have rectangle with corners (i;pi) and (j;pj). We have min(i, j) - 1 points to the left of rectangle, n - max(i, j) to the right, min(pi, pj) - 1 to the down, etc. If we have x points in some area, there are rectangles in that area. But now we calculated twice rectangles that are simultaneously to the left and up of our rectangle, left and down, etc. To find number of such rectangles we can iterate over all points and find points which are in these areas and find number of rectangles in area using formula . The complexity is O(q·n).To solve the problem we need to find number of points in some areas faster. It's quite easy to notice that we just have many queries of finding number of points in some subrectangle. It's classical problem that can be solved with some 2d tree in O(q·log2) solution. But it can be too slow and can not fit into time limit in case of inaccurate implementation. However, you can notice that all queries are offline and find number of points in subrectangle in O(q·logn) time. It's fast enough to pass all tests.(Idea — Elena Andreeva, developing — vintage_Vlad_Makeev) 853D - Michael and Charging StationsBefore solving problem one observation is required: suppose at day i we have xi bonuses. Then exists optimal solution, which spends 0 or min(ai, xi) bonuses every day. It's quite easy to proof: suppose we have some optimal solution and i is a first day, when neither 0 nor min(ai, xi) bonuses were spent. If i is a last day on which non-zero amount of bonuses was spent, we can notice that solution spending min(ai, xi) bonuses that day is more optimal, so first solution was optimal. So let's consider next day after i, when non-zero amount of bonuses was spent, say j, and amount of bonuses spent at day j is sj (Also, amount of bonuses spent on day i is si). Let's look at solution that spends si + min(si - min(ai, xi), sj) bonuses at day i and sj - min(si - min(ai, xi), sj). That solution is still correct and still optimal, but it spends min(ai, xi) at day i or 0 at day j. Anyway this operation increases first day i when neither i nor min(ai, xi) bonuses were spent or first day j after it, when non-zero amount of burles were spent. But we can't increase i or j infinitely, so, after some iterations of such transformation, solution, spending 0 or min(ai, xi) bonuses in each day.To make an O(n2) solution it's possible to consider dynamic programming approach: let dpi, j be minimum amount of money that is possible to spend at first i days to pay for all chargings and have 100·j bonuses on card. At first, dp0, 0 = 0 and dpi, j = ∞. Then we can easy calculate all states going through all states with something like this code:for (int i = 0; i < n; i++) { for (int j = 0; j <= 2 * n; j++) { dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]); dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)], dp[i][j] + a[i] - 100 * min(j, a[i] / 100)); } }Of course, j can be up to 2·n, because at each day it's possible to earn at most 2 bonuses.To make this solution faster let's consider the following observation: there exists an optimal solution, which never has more 3000 bonuses on bonus card. To proof it let's first proof following lemma:Lemma 1: There exists an optimal solution which spends only 0 or ai bonuses at day i if there are at least 3000 bonuses at card at the beginning of day i. Lemma 1 proof: Let's introduce some designations. Let xi be amount of bonuses at the beginning of day i and si be amount of bonuses spent at day i. Also let's call day i \"fractional\" if si ≠ 0 and si ≠ ai, and call day i \"interesting\" if si ≠ 0. Let's proof lemma2 and lemma3 at first:Lemma 2: Assume xi ≥ 3000 and j — next after i interesting day and k — next after j interesting day. Then there exists an optimal solution in which k is not a fractional day or j is not a fractional day. Lemma2 proof: Suppose is some optimal solution j and k are fractional days. Let's consider a solution spending sj + min(sk, aj - s{j}) bonuses at day j and sk - min(sk, aj - s{j}) at day k. This solution is still correct, because xi ≥ 3000, so for days j and k there is enough bonuses and still optimal. Lemma2 is proved.Lemma 3: Assume xi ≥ 3000 and j — next after i interesting day. Then there exists an optimal solution is which j is not a fractional day.Lemma 3 proof: Consider some optimal solution with fractional day j. At first let's proof that j is not last interesting day. Suppose, j is last interesting day in solution. But we can make a solution that spends ai bonuses at day i (because ai ≤ 3000) and it will be more optimal. Contradiction. So there exists next after j interesting day. Let's call it k. Let's consider 2 cases:Case 1 (aj = 1000): Let's spend consider solution spending 1000 bonuses at day j and ak - (1000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2 (aj = 2000): There are two subcases:Case 2.1 (ak = 2000): Let's spend consider solution spending 2000 bonuses at day j and ak - (2000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2.2 (ak = 1000): Let's proof, k is not last interesting day. Assume k is last interesting day. Consider a solution spending 2000 bonuses at day j and 1000 bonuses at day k. It's correct but more optimal that initial solution. Conrtadiction. Now let p be next after k interesting day (k is not a fractional day by lemma2). If 2000 - aj ≤ 1000 we can consider solution which spends 2000 bonuses at day j, 1000 - (2000 - ak) bonuses at day k and sp bonuses at day p. If 2000 - sj > 1000 let's consider a solution which spends sj + 1000 bonuses at day j, 0 bonuses at day k and sp at day p. But by lemma2 sp = ap, so we can consider solution that spends 2000 bonuses at day j 0 bonuses at day k and ap - (2000 - sj - ak) at day k. All of these solutions are correct and optimal.Lemma 1 proof (end): At first, of course there is at least one interesting day after i (Otherwise, it's more optimal to charge at day i using bounses, but in initial solution si = 0 because xi - 1 ≤ 3000 and xi > 3000). Let's call that day j and by lemma3 j is not fractional day. Let's consider 4 cases now:Case 1: (ai = 1000, aj = 1000). Let's consider a solution with si = 1000 and sj = 0. It's correct and still optimal, but xi ≤ 3000.Case 2: (ai = 2000, aj = 2000). Same as case1.Case 3: (ai = 2000, aj = 1000). Let's consider 2 subcases:Case 3.1: j is not last interesting day. Let k be next interesting day. It ak = 1000 consider a solution spending 2000 bonuses at day i, 0 bonuses at days j and k. It's still correct and optimal, but xi ≤ 3000. If ak = 2000 consider a solution a spending 2000 bonuses at day i, 1000 bonuses at day j and 0 bonuses at day k. It's correct and optimal too, and xi ≤ 3000 too.Case 3.2: j is last interesting day. Let's construct solution this way. At first let's set si = 1000 and sj = 0. Then let's iterate over all ineteresting days after j, say k, in order in increasing time and set si = si + min(2000 - si, sk), sk = sk - min(2000 - si, sk). If after this process we still have some bonus left just add it to si. At the end, si will be equal 2000 because we spent all bonuses, solution will still be correct and optimal, but xi ≤ 3000.Case 4: (ai = 1000, aj = 2000). Let p be last day before i with sp ≠ 0. If ap = 1000 consider a solution with sp = 0, si = 0, sj = 2000. It's correct, optimal and xt ≤ 3000 for each t ≤ i. If ap = 2000, consider a solution with sp = 2000, si = 0, sj = 0. It's correct, optimal and xt ≤ 3000 for each t ≤ i, too.So for all cases we can make correct and optimal solution such there is no xi ≤ 3000 for all i, or number of first day with xi > 3000 increases, but it can't increase forever, so after some amount of opereations solution with xi ≤ 3000 for all i will be constructed.Because of this fact we can consider dynamic programming approach described before but notice, that we should consider only states with j ≤ 30. It will have O(n) complexity. Moreover, looking at states with j = 30 is required. It's possible to make a test on which solution, that looks at states with j ≤ 29 will be incorrect.(Idea — Zlobober, developing — malcolm) 853E - Lada MalinaIn the original contest there were subtasks for this problem and it's more convinient to understand the editorial going through these subtasks, so we will leave them here.The key part of a solution is to understand what are the locations that may be accessed from the origin in T seconds. First observation is that we should investigate it only in case when T = 1 because T is simply a scale factor. Let’s denote this set for T = 1 as P.Group #1. For the first group it’s easy to see that P is a square with vertices in points ( ± 2, 0), (0,  ± 2). So, the first group may be solved with a straightforward O(qn) approach: we iterate through all the factories and check if it's possible to get for cars from i-th factories to the car exposition. We can rotate the plane by 45 degrees (this may be done by the transformation x' = x + y, y' = x - y), after this each query region looks like a square. Therefore, it's necessary to check if point lies inside a square:Group #2. In the second group propeller velocities are two arbitrary vectors. It can be shown that P will always be a parallelogram centered in the origin, built on vectors 2v1 and 2v2 as sides. Thus, this group is a matter of the same O(qn) approach with a bit more complicated predicate: one should be able to check that an integer point belongs to an integer parallelogram. The key observation is that we may find an appropriate transformation of a plane that transforms this set into a rectangle. Indeed, there always exists an affine transformation performing what we want. As an additional requirement, we want to transform coordinates in such way that they are still integral and not much larger than the original coordinates. The transformation looks like following:The first expression is a signed distance to the line parallel to the vector v1, and the second one is the signed distance from the line parallel to the vector v2. Easy to see that belonging to some query parallelogram can be formulated in terms of x' and y' independendly belonging to some ranges. Group #3. Second group should be a hint for the third group. One can find that the set P = {w1v1 + ... + wkvk||wi| ≤ 1} is always a central-symmetric polygon with the center in the origin. Actually, this Polygon is a Minkowski sum of k segments [ - vi, vi]. Minkowski sum of sets A1, A2, ..., Ak is by definition the following set: . It can be built in time, although in this problem k is very small, so one may use any inefficient approach that comes into his head, like building a convex hull of all points { ± v1 ± v2... ± vk}.After we found out a form of P, it’s possible to solve the third group of tests in O(qnk) by checking if each possible factory location belongs into a query polygon in O(k) time.Following groups are exactly the same, but the constraints are higher, they require using some geometric data structure to deal with range queries.Groups #4 and #5. Fourth group and fifth group are very similar to first and second group correspondingly, but we need to process the requests faster. After the transformation of the plane, the request can be reformulated as \"find sum of all factories inside a square\", so any 2d data structure may be applied, like a segment tree of segment trees. Another approach is to use a sweeping line algorithm with a segment tree or an appropriate binary search tree, achieving a time complexity or .Group #6. To solve the sixth group we need to use a trapezoidal polygon area calculation algorithm applied to our problem. Calculate the sum of points in each of 2k trapezoid areas below each of the sides of a polygon, and then take them with appropriate signs to achieve a result. Such trapezoid area can be seen as a set of points satisfying the inequalities l ≤ x ≤ r and y ≤ kx + b. Under transformation x' = x, y' = y - kx, this area becomes a rectangle, leading us to an time solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 853\\s*C"
          },
          "content_length": 18717
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 1",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 2",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 3",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 4",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 5",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 6",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 7",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 8",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 9",
          "code": "The number of comparisons performed is logarithmic in the distance between first and last (At most log 2(last - first) + O(1) comparisons). However, for non-RandomAccessIterators, the number of iterator increments is linear.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 10",
          "code": "dpr[i]=dpr[i]-prev+sumright[num];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++) {    for (int j = 0; j <= 2 * n; j++) {         dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]);         dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)],                                                  dp[i][j] + a[i] - 100 * min(j, a[i] / 100));     } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    {\n        vector<int> tmp = p;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < n; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"All pi must be distinct, but found duplicate pi=%d\", tmp[i]);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\"); // l ≤ r ≤ n\n        inf.readSpace();\n        int u = inf.readInt(d, n, \"u\"); // d ≤ u ≤ n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    {\n        vector<int> tmp = p;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < n; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"All pi must be distinct, but found duplicate pi=%d\", tmp[i]);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\"); // l ≤ r ≤ n\n        inf.readSpace();\n        int u = inf.readInt(d, n, \"u\"); // d ≤ u ≤ n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    {\n        vector<int> tmp = p;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < n; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"All pi must be distinct, but found duplicate pi=%d\", tmp[i]);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\"); // l ≤ r ≤ n\n        inf.readSpace();\n        int u = inf.readInt(d, n, \"u\"); // d ≤ u ≤ n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n\n    string perm_type = opt<string>(\"perm_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1; // initial permutation 1..n\n\n    if (perm_type == \"random\") {\n        shuffle(p.begin(), p.end());\n    }\n    else if (perm_type == \"sorted\") {\n        // do nothing, already sorted\n    }\n    else if (perm_type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    }\n    else if (perm_type == \"almost_sorted\") {\n        int swaps = min(n, opt<int>(\"swaps\", 10));\n        for (int i = 0; i < swaps; ++i) {\n            int a = rnd.next(n);\n            int b = rnd.next(n);\n            swap(p[a], p[b]);\n        }\n    }\n    else if (perm_type == \"identity\") {\n        // same as sorted\n    }\n    else if (perm_type == \"anti_identity\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    }\n    // other perm_types can be added here\n\n    // Generate queries\n    vector<tuple<int, int, int, int>> queries;\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"single_cell\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.emplace_back(x, y, x, y);\n        }\n    }\n    else if (query_type == \"full_grid\") {\n        for (int i = 0; i < q; ++i) {\n            queries.emplace_back(1, 1, n, n);\n        }\n    }\n    else if (query_type == \"edges\") {\n        for (int i = 0; i < q; ++i) {\n            int l = 1;\n            int r = n;\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"corners\") {\n        queries.emplace_back(1, 1, 1, 1);\n        queries.emplace_back(n, 1, n, 1);\n        queries.emplace_back(1, n, 1, n);\n        queries.emplace_back(n, n, n, n);\n        while ((int)queries.size() < q) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(n / 2 + 1, n);\n            int d = rnd.next(1, n / 2);\n            int u = rnd.next(n / 2 + 1, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"small\") {\n        for (int i = 0; i < q; ++i) {\n            int sz = rnd.next(1, 2);\n            int l = rnd.next(1, n - sz + 1);\n            int r = l + sz - 1;\n            int d = rnd.next(1, n - sz + 1);\n            int u = d + sz - 1;\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"line\") {\n        for (int i = 0; i < q; ++i) {\n            int axis = rnd.next(0,1); // 0 for vertical line, 1 for horizontal line\n            if (axis == 0) {\n                int x = rnd.next(1, n);\n                queries.emplace_back(x, 1, x, n);\n            } else {\n                int y = rnd.next(1, n);\n                queries.emplace_back(1, y, n, y);\n            }\n        }\n    }\n    else if (query_type == \"diagonal\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = l + rnd.next(0, n / 2);\n            int d = l;\n            int u = r;\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    // other query_types can be added here\n\n    // Ensure we have exactly q queries\n    while ((int)queries.size() < q) {\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int d = rnd.next(1, n);\n        int u = rnd.next(d, n);\n        queries.emplace_back(l, d, r, u);\n    }\n\n    // Print the data\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < q; ++i) {\n        int l, d, r, u;\n        tie(l, d, r, u) = queries[i];\n        printf(\"%d %d %d %d\\n\", l, d, r, u);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n\n    string perm_type = opt<string>(\"perm_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1; // initial permutation 1..n\n\n    if (perm_type == \"random\") {\n        shuffle(p.begin(), p.end());\n    }\n    else if (perm_type == \"sorted\") {\n        // do nothing, already sorted\n    }\n    else if (perm_type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    }\n    else if (perm_type == \"almost_sorted\") {\n        int swaps = min(n, opt<int>(\"swaps\", 10));\n        for (int i = 0; i < swaps; ++i) {\n            int a = rnd.next(n);\n            int b = rnd.next(n);\n            swap(p[a], p[b]);\n        }\n    }\n    else if (perm_type == \"identity\") {\n        // same as sorted\n    }\n    else if (perm_type == \"anti_identity\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    }\n    // other perm_types can be added here\n\n    // Generate queries\n    vector<tuple<int, int, int, int>> queries;\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"single_cell\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.emplace_back(x, y, x, y);\n        }\n    }\n    else if (query_type == \"full_grid\") {\n        for (int i = 0; i < q; ++i) {\n            queries.emplace_back(1, 1, n, n);\n        }\n    }\n    else if (query_type == \"edges\") {\n        for (int i = 0; i < q; ++i) {\n            int l = 1;\n            int r = n;\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"corners\") {\n        queries.emplace_back(1, 1, 1, 1);\n        queries.emplace_back(n, 1, n, 1);\n        queries.emplace_back(1, n, 1, n);\n        queries.emplace_back(n, n, n, n);\n        while ((int)queries.size() < q) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(n / 2 + 1, n);\n            int d = rnd.next(1, n / 2);\n            int u = rnd.next(n / 2 + 1, n);\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"small\") {\n        for (int i = 0; i < q; ++i) {\n            int sz = rnd.next(1, 2);\n            int l = rnd.next(1, n - sz + 1);\n            int r = l + sz - 1;\n            int d = rnd.next(1, n - sz + 1);\n            int u = d + sz - 1;\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    else if (query_type == \"line\") {\n        for (int i = 0; i < q; ++i) {\n            int axis = rnd.next(0,1); // 0 for vertical line, 1 for horizontal line\n            if (axis == 0) {\n                int x = rnd.next(1, n);\n                queries.emplace_back(x, 1, x, n);\n            } else {\n                int y = rnd.next(1, n);\n                queries.emplace_back(1, y, n, y);\n            }\n        }\n    }\n    else if (query_type == \"diagonal\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = l + rnd.next(0, n / 2);\n            int d = l;\n            int u = r;\n            queries.emplace_back(l, d, r, u);\n        }\n    }\n    // other query_types can be added here\n\n    // Ensure we have exactly q queries\n    while ((int)queries.size() < q) {\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int d = rnd.next(1, n);\n        int u = rnd.next(d, n);\n        queries.emplace_back(l, d, r, u);\n    }\n\n    // Print the data\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < q; ++i) {\n        int l, d, r, u;\n        tie(l, d, r, u) = queries[i];\n        printf(\"%d %d %d %d\\n\", l, d, r, u);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -q 3 -perm_type sorted -query_type single_cell\n./gen -n 4 -q 2 -perm_type random -query_type random\n./gen -n 10 -q 5 -perm_type reversed -query_type full_grid\n\n./gen -n 100 -q 1000 -perm_type random -query_type random\n./gen -n 10 -q 50 -perm_type random -query_type small\n\n./gen -n 200000 -q 200000 -perm_type random -query_type random\n\n./gen -n 200000 -q 200000 -perm_type random -query_type single_cell\n./gen -n 200000 -q 200000 -perm_type random -query_type full_grid\n./gen -n 200000 -q 200000 -perm_type random -query_type small\n./gen -n 200000 -q 200000 -perm_type random -query_type large\n./gen -n 200000 -q 200000 -perm_type random -query_type line\n./gen -n 200000 -q 200000 -perm_type random -query_type diagonal\n\n./gen -n 200000 -q 200000 -perm_type sorted -query_type random\n./gen -n 200000 -q 200000 -perm_type reversed -query_type random\n./gen -n 200000 -q 200000 -perm_type almost_sorted -swaps 10 -query_type random\n./gen -n 200000 -q 200000 -perm_type almost_sorted -swaps 1000 -query_type random\n\n./gen -n 200000 -q 200000 -perm_type identity -query_type random\n./gen -n 200000 -q 200000 -perm_type anti_identity -query_type random\n\n./gen -n 200000 -q 1 -perm_type random -query_type random\n./gen -n 200000 -q 1 -perm_type random -query_type full_grid\n\n./gen -n 200000 -q 200000 -perm_type random -query_type edges\n./gen -n 200000 -q 200000 -perm_type random -query_type corners\n\n./gen -n 100000 -q 100000 -perm_type reversed -query_type single_cell\n./gen -n 100000 -q 100000 -perm_type sorted -query_type line\n\n./gen -n 2 -q 1 -perm_type sorted -query_type full_grid\n./gen -n 2 -q 1 -perm_type reversed -query_type single_cell\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:03.350857",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "853/D",
      "title": "D. Michael and Charging Stations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 300 000), the number of days Michael has planned.Next line contains n integers a1, a2, ..., an (ai = 1000 or ai = 2000) with ai denoting the charging cost at the day i.",
      "output_spec": "OutputOutput the minimum amount of burles Michael has to spend.",
      "sample_tests": "ExamplesInputCopy31000 2000 1000OutputCopy3700InputCopy62000 2000 2000 2000 2000 1000OutputCopy10000",
      "description": "D. Michael and Charging Stations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 300 000), the number of days Michael has planned.Next line contains n integers a1, a2, ..., an (ai = 1000 or ai = 2000) with ai denoting the charging cost at the day i.\n\nOutputOutput the minimum amount of burles Michael has to spend.\n\nInputCopy31000 2000 1000OutputCopy3700InputCopy62000 2000 2000 2000 2000 1000OutputCopy10000\n\nInputCopy31000 2000 1000\n\nOutputCopy3700\n\nInputCopy62000 2000 2000 2000 2000 1000\n\nOutputCopy10000\n\nNoteIn the first sample case the most optimal way for Michael is to pay for the first two days spending 3000 burles and get 300 bonus burles as return. After that he is able to pay only 700 burles for the third days, covering the rest of the price with bonus burles.In the second sample case the most optimal way for Michael is to pay the whole price for the first five days, getting 1000 bonus burles as return and being able to use them on the last day without paying anything in cash.",
      "solutions": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces",
          "content": "Hi everybody!These days Moscow is conducting the 2nd International Olympiad of Metropolises that is an international competition for high school students from biggest cities and capitals all around the world. One of the disciplines of the competition is informatics. Rounds of the competition were prepared by the jury members invited from St. Petersburg, Minsk, Almaty and Moscow olympiad scientific committee which you may know by Moscow team Olympiad, Open Olympiad in Informatics and Moscow Olympiad for young students (rounds 327, 342, 345, 376, 401).We are very grateful to MikeMirzayanov for Polygon system that made it possible to conveniently hold a simultaneous statement translation process into lots of languages. As a good friends of Codeforces platform, we conduct a parallel rated Div. 1 + Div. 2 round on the competition problemset.Round will happen on September 6th at 12:55 UTC and it will last for two hours. There will be 5 problems for each division, scoring will be announced later.Scientific Committee of the olympiad consists of: andrewzta, GlebsHP, Endagorion, meshanya, Chmel_Tolstiy, Zlobober, Helen Andreeva and Bakhyt Matkarymov. Problems were prepared by timgaripov, mingaleg, halin.george, vintage_Vlad_Makeev, malcolm, LHiC coordinated by your humble servant.Codeforces coordinator KAN helped us to choose problems for a round.Good luck and high ratings for everybody!PS We kindly ask everybody who knows problems of an on-site event not to participate in a round and not to discuss them in public, as this may be a subject for disqualification.Congratulations to the winners!In div. 1 they are: Um_nik fateice KADR dotorya FallDream In div. 2 they are: jiangIy xolm YxqK lixolas Rawnd The analysis is published. Thanks to all for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54350",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1777
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces",
          "content": "(Idea — Sender , developing — timgaripov) 854A - FractionIt's possible to look over all possible values of the numerator . For the current value of a we have to compute denominator as b = n - a, check that there are no common divisors (except 1) of a and b (it also could be done by a linear search of possible common divisors 2 ≤ d ≤ a). The answer is the maximal fraction that was considered during the iteration over all possible values of the numerator and passed the irreducibility test. Pseudocode of the described solution is presented below: This solution have time complexity.However, we can find answer to the problem analytically in the following way: (Idea — Chmel_Tolstiy, developing — mingaleg) 854B - Maxim Buys an ApartmentMinimum number of good apartments is almost always 1, since rooms with indices from 1 to k could be inhabited. Exceptions are cases in which k = 0 and k = n, in these cases both minimum and maximum number of good rooms is 0 since there is no inhabitant or vacant apartments.Maximum number of good apartments could be reached, for example, as follows. Assume apartments with indices 2, 5, 8 and so on are occupied as much as possible. Each of these apartments produces 2 good rooms except from, if it exists, the one with index n (that apartment produces 1 good apartment). If number of inhabitant apartments is less than k occupy any of rest rooms to reach that number, every such occupation will decrease number of good apartments by one). Simulate this process, than count the number of good rooms to find maximum possible number. Expected complexity: O(n2) or O(n).Instead of simulating the above process calculate number of apartments with indices 2, 5, 8 and so on excluding the one with index n if it exists. Number of that apartments is equal to , and if k ≤ x you can occupy some of these apartments to reach maximum number of good rooms equal to 2·k. Otherwise, if k > x, assume that apartments with indices 2, 5, 8 and so on are occupied, so any room has at least one inhabited room adjacent to it. Therefore number of good apartments is equal to number of vacant apartments and is equal to n - k. Implementation of these formulas with keeping in mind cases in which k = 0 and k = n will be scored as full solution of problem. Expected complexity: O(1).(Idea — Zlobober, developing — halin.george) 853A - PlanningWe will show that following greedy is correct: let's for each moment of time use a plane, which can depart in this moment of time (and didn't depart earlier, of course) with minimal cost of delay. Proof is quite simple: it's required to minimize . You can notice that is constant, so we just need to minimize . Consider the optimal solution when plane i departs at moment bi and solution by greedy algorithm in which plane i departs at moment ai. Let x be plane with minimal cx, such ax ≠ bx. At any moment greedy algorithm takes avaliable plane with lowest cx, so ax < bx. Let y be a plane, such that by = ax. But cy >  = by, so bx·cx + by·cy >  = bx·cy + by·cx and it's possible to swap bx and by in optimal solution without loosing of optimality. By performing this operation many times it's possible to make bi = ai for each i and it means that greedy solution is optimal.To make this solution work fast you need to use some data structures to find optimal plane faster for each moment. This data structure should be able to add number into set, give value of minimal element in set and erase minimal number from set. For this purpose you can use heap (or someting like std::set or std::priority_queue in C++). (Idea — GlebsHP, developing — mingaleg) 853B - Jury MeetingObviously, each member of the jury needs to buy exactly two tickets — to the capital and back. Sort all flights by the day of departure. Now go through flights to the capital (forward flights) and one by one assume it is the last forward flight in answer (let's say it is scheduled on day d). Thus you are assuming that all forward flights are contained in some fixed prefix of flights. Make sure that there is at least one forward flight for every jury member in this prefix and find the cheapest forward flight among them for every person. All return flights we are interested in are contained in the suffix of flights list such that every flight's departure date is at least d + k + 1. Take similar steps: make sure that there is at least one return flight for every jury member in this suffix and find the cheapest return flight among them for every person as well. Select minimal cost among these variants or find out that the problem has no solution. Expected complexity: O(nm2) or O(m2 + n).Just as the boundary of considered prefix moves right, the boundary of considered suffix moves right as well. This suggests that the problem could be solved by the two pointers method. Assume you are storing minimum forward flight's cost on current prefix (infinity if no flight exists) for every person, and you are storing multiset (ordered by cost) of all return flights on current suffix for each person as well. To proceed next prefix and conforming suffix do the following: Move prefix boundary to the next forward flight. If its cost ci is less than minimum forward flight's cost fwdfi from that city, then you could improve total cost: decrease it by ci - fwdfi and set fwdfi to ci since it's new minimal cost. Move suffix boundary to the next backward flight until there is such flight exists and it departure date difference with prefix boundary departure date is under k + 1. While moving suffix boundary, keep return flights multisets consistent: remove boundary flight right before moving that boundary to the next flight. Also check out if you are removing cheapest flight from multiset. If it is so, minimal flight cost for that city changed as well as total cost: it increases by difference between old minimal cost and new minimal cost. Keep in mind that if you are removing last flight from multiset, then there is no more appropriate return flight for this city and you should terminate the process. Proceed these steps moving boundaries to the right until the process terminates. In this way you've reviewed the same prefixes and corresponding suffixes as in slower solution described above. Expected complexity: .(Idea — glebushka98, developing — vintage_Vlad_Makeev) 853C - BoredomWe can't iterate over all interesting rectangles. Let's count number of rectangles that are not intersecting our rectangle. To do it let's calculate number of rectangles to the left, right, up and down of rectangle in query. It can be easily done in O(1) time: suppose we have rectangle with corners (i;pi) and (j;pj). We have min(i, j) - 1 points to the left of rectangle, n - max(i, j) to the right, min(pi, pj) - 1 to the down, etc. If we have x points in some area, there are rectangles in that area. But now we calculated twice rectangles that are simultaneously to the left and up of our rectangle, left and down, etc. To find number of such rectangles we can iterate over all points and find points which are in these areas and find number of rectangles in area using formula . The complexity is O(q·n).To solve the problem we need to find number of points in some areas faster. It's quite easy to notice that we just have many queries of finding number of points in some subrectangle. It's classical problem that can be solved with some 2d tree in O(q·log2) solution. But it can be too slow and can not fit into time limit in case of inaccurate implementation. However, you can notice that all queries are offline and find number of points in subrectangle in O(q·logn) time. It's fast enough to pass all tests.(Idea — Elena Andreeva, developing — vintage_Vlad_Makeev) 853D - Michael and Charging StationsBefore solving problem one observation is required: suppose at day i we have xi bonuses. Then exists optimal solution, which spends 0 or min(ai, xi) bonuses every day. It's quite easy to proof: suppose we have some optimal solution and i is a first day, when neither 0 nor min(ai, xi) bonuses were spent. If i is a last day on which non-zero amount of bonuses was spent, we can notice that solution spending min(ai, xi) bonuses that day is more optimal, so first solution was optimal. So let's consider next day after i, when non-zero amount of bonuses was spent, say j, and amount of bonuses spent at day j is sj (Also, amount of bonuses spent on day i is si). Let's look at solution that spends si + min(si - min(ai, xi), sj) bonuses at day i and sj - min(si - min(ai, xi), sj). That solution is still correct and still optimal, but it spends min(ai, xi) at day i or 0 at day j. Anyway this operation increases first day i when neither i nor min(ai, xi) bonuses were spent or first day j after it, when non-zero amount of burles were spent. But we can't increase i or j infinitely, so, after some iterations of such transformation, solution, spending 0 or min(ai, xi) bonuses in each day.To make an O(n2) solution it's possible to consider dynamic programming approach: let dpi, j be minimum amount of money that is possible to spend at first i days to pay for all chargings and have 100·j bonuses on card. At first, dp0, 0 = 0 and dpi, j = ∞. Then we can easy calculate all states going through all states with something like this code:for (int i = 0; i < n; i++) { for (int j = 0; j <= 2 * n; j++) { dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]); dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)], dp[i][j] + a[i] - 100 * min(j, a[i] / 100)); } }Of course, j can be up to 2·n, because at each day it's possible to earn at most 2 bonuses.To make this solution faster let's consider the following observation: there exists an optimal solution, which never has more 3000 bonuses on bonus card. To proof it let's first proof following lemma:Lemma 1: There exists an optimal solution which spends only 0 or ai bonuses at day i if there are at least 3000 bonuses at card at the beginning of day i. Lemma 1 proof: Let's introduce some designations. Let xi be amount of bonuses at the beginning of day i and si be amount of bonuses spent at day i. Also let's call day i \"fractional\" if si ≠ 0 and si ≠ ai, and call day i \"interesting\" if si ≠ 0. Let's proof lemma2 and lemma3 at first:Lemma 2: Assume xi ≥ 3000 and j — next after i interesting day and k — next after j interesting day. Then there exists an optimal solution in which k is not a fractional day or j is not a fractional day. Lemma2 proof: Suppose is some optimal solution j and k are fractional days. Let's consider a solution spending sj + min(sk, aj - s{j}) bonuses at day j and sk - min(sk, aj - s{j}) at day k. This solution is still correct, because xi ≥ 3000, so for days j and k there is enough bonuses and still optimal. Lemma2 is proved.Lemma 3: Assume xi ≥ 3000 and j — next after i interesting day. Then there exists an optimal solution is which j is not a fractional day.Lemma 3 proof: Consider some optimal solution with fractional day j. At first let's proof that j is not last interesting day. Suppose, j is last interesting day in solution. But we can make a solution that spends ai bonuses at day i (because ai ≤ 3000) and it will be more optimal. Contradiction. So there exists next after j interesting day. Let's call it k. Let's consider 2 cases:Case 1 (aj = 1000): Let's spend consider solution spending 1000 bonuses at day j and ak - (1000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2 (aj = 2000): There are two subcases:Case 2.1 (ak = 2000): Let's spend consider solution spending 2000 bonuses at day j and ak - (2000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2.2 (ak = 1000): Let's proof, k is not last interesting day. Assume k is last interesting day. Consider a solution spending 2000 bonuses at day j and 1000 bonuses at day k. It's correct but more optimal that initial solution. Conrtadiction. Now let p be next after k interesting day (k is not a fractional day by lemma2). If 2000 - aj ≤ 1000 we can consider solution which spends 2000 bonuses at day j, 1000 - (2000 - ak) bonuses at day k and sp bonuses at day p. If 2000 - sj > 1000 let's consider a solution which spends sj + 1000 bonuses at day j, 0 bonuses at day k and sp at day p. But by lemma2 sp = ap, so we can consider solution that spends 2000 bonuses at day j 0 bonuses at day k and ap - (2000 - sj - ak) at day k. All of these solutions are correct and optimal.Lemma 1 proof (end): At first, of course there is at least one interesting day after i (Otherwise, it's more optimal to charge at day i using bounses, but in initial solution si = 0 because xi - 1 ≤ 3000 and xi > 3000). Let's call that day j and by lemma3 j is not fractional day. Let's consider 4 cases now:Case 1: (ai = 1000, aj = 1000). Let's consider a solution with si = 1000 and sj = 0. It's correct and still optimal, but xi ≤ 3000.Case 2: (ai = 2000, aj = 2000). Same as case1.Case 3: (ai = 2000, aj = 1000). Let's consider 2 subcases:Case 3.1: j is not last interesting day. Let k be next interesting day. It ak = 1000 consider a solution spending 2000 bonuses at day i, 0 bonuses at days j and k. It's still correct and optimal, but xi ≤ 3000. If ak = 2000 consider a solution a spending 2000 bonuses at day i, 1000 bonuses at day j and 0 bonuses at day k. It's correct and optimal too, and xi ≤ 3000 too.Case 3.2: j is last interesting day. Let's construct solution this way. At first let's set si = 1000 and sj = 0. Then let's iterate over all ineteresting days after j, say k, in order in increasing time and set si = si + min(2000 - si, sk), sk = sk - min(2000 - si, sk). If after this process we still have some bonus left just add it to si. At the end, si will be equal 2000 because we spent all bonuses, solution will still be correct and optimal, but xi ≤ 3000.Case 4: (ai = 1000, aj = 2000). Let p be last day before i with sp ≠ 0. If ap = 1000 consider a solution with sp = 0, si = 0, sj = 2000. It's correct, optimal and xt ≤ 3000 for each t ≤ i. If ap = 2000, consider a solution with sp = 2000, si = 0, sj = 0. It's correct, optimal and xt ≤ 3000 for each t ≤ i, too.So for all cases we can make correct and optimal solution such there is no xi ≤ 3000 for all i, or number of first day with xi > 3000 increases, but it can't increase forever, so after some amount of opereations solution with xi ≤ 3000 for all i will be constructed.Because of this fact we can consider dynamic programming approach described before but notice, that we should consider only states with j ≤ 30. It will have O(n) complexity. Moreover, looking at states with j = 30 is required. It's possible to make a test on which solution, that looks at states with j ≤ 29 will be incorrect.(Idea — Zlobober, developing — malcolm) 853E - Lada MalinaIn the original contest there were subtasks for this problem and it's more convinient to understand the editorial going through these subtasks, so we will leave them here.The key part of a solution is to understand what are the locations that may be accessed from the origin in T seconds. First observation is that we should investigate it only in case when T = 1 because T is simply a scale factor. Let’s denote this set for T = 1 as P.Group #1. For the first group it’s easy to see that P is a square with vertices in points ( ± 2, 0), (0,  ± 2). So, the first group may be solved with a straightforward O(qn) approach: we iterate through all the factories and check if it's possible to get for cars from i-th factories to the car exposition. We can rotate the plane by 45 degrees (this may be done by the transformation x' = x + y, y' = x - y), after this each query region looks like a square. Therefore, it's necessary to check if point lies inside a square:Group #2. In the second group propeller velocities are two arbitrary vectors. It can be shown that P will always be a parallelogram centered in the origin, built on vectors 2v1 and 2v2 as sides. Thus, this group is a matter of the same O(qn) approach with a bit more complicated predicate: one should be able to check that an integer point belongs to an integer parallelogram. The key observation is that we may find an appropriate transformation of a plane that transforms this set into a rectangle. Indeed, there always exists an affine transformation performing what we want. As an additional requirement, we want to transform coordinates in such way that they are still integral and not much larger than the original coordinates. The transformation looks like following:The first expression is a signed distance to the line parallel to the vector v1, and the second one is the signed distance from the line parallel to the vector v2. Easy to see that belonging to some query parallelogram can be formulated in terms of x' and y' independendly belonging to some ranges. Group #3. Second group should be a hint for the third group. One can find that the set P = {w1v1 + ... + wkvk||wi| ≤ 1} is always a central-symmetric polygon with the center in the origin. Actually, this Polygon is a Minkowski sum of k segments [ - vi, vi]. Minkowski sum of sets A1, A2, ..., Ak is by definition the following set: . It can be built in time, although in this problem k is very small, so one may use any inefficient approach that comes into his head, like building a convex hull of all points { ± v1 ± v2... ± vk}.After we found out a form of P, it’s possible to solve the third group of tests in O(qnk) by checking if each possible factory location belongs into a query polygon in O(k) time.Following groups are exactly the same, but the constraints are higher, they require using some geometric data structure to deal with range queries.Groups #4 and #5. Fourth group and fifth group are very similar to first and second group correspondingly, but we need to process the requests faster. After the transformation of the plane, the request can be reformulated as \"find sum of all factories inside a square\", so any 2d data structure may be applied, like a segment tree of segment trees. Another approach is to use a sweeping line algorithm with a segment tree or an appropriate binary search tree, achieving a time complexity or .Group #6. To solve the sixth group we need to use a trapezoidal polygon area calculation algorithm applied to our problem. Calculate the sum of points in each of 2k trapezoid areas below each of the sides of a polygon, and then take them with appropriate signs to achieve a result. Such trapezoid area can be seen as a set of points satisfying the inequalities l ≤ x ≤ r and y ≤ kx + b. Under transformation x' = x, y' = y - kx, this area becomes a rectangle, leading us to an time solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 853\\s*D"
          },
          "content_length": 18717
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 1",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 2",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 3",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 4",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 5",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 6",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 7",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 8",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 9",
          "code": "The number of comparisons performed is logarithmic in the distance between first and last (At most log 2(last - first) + O(1) comparisons). However, for non-RandomAccessIterators, the number of iterator increments is linear.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 10",
          "code": "dpr[i]=dpr[i]-prev+sumright[num];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++) {    for (int j = 0; j <= 2 * n; j++) {         dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]);         dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)],                                                  dp[i][j] + a[i] - 100 * min(j, a[i] / 100));     } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1000, 2000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = a[i];\n        ensuref(ai == 1000 || ai == 2000, \"a[%d] must be 1000 or 2000, but found %d\", i+1, ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1000, 2000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = a[i];\n        ensuref(ai == 1000 || ai == 2000, \"a[%d] must be 1000 or 2000, but found %d\", i+1, ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1000, 2000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = a[i];\n        ensuref(ai == 1000 || ai == 2000, \"a[%d] must be 1000 or 2000, but found %d\", i+1, ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_1000\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000;\n        }\n    } else if (type == \"all_2000\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2000;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1000 : 2000;\n        }\n    } else if (type == \"first_k_1000_rest_2000\") {\n        int k = opt<int>(\"k\", n/2);\n        for (int i = 0; i < n; ++i) {\n            if (i < k) {\n                a[i] = 1000;\n            } else {\n                a[i] = 2000;\n            }\n        }\n    } else if (type == \"last_day_bonus_spend\") {\n        // All days are 2000 except last day is 1000\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 2000;\n        }\n        a[n - 1] = 1000;\n    } else if (type == \"large_bonus_before_small_cost\") {\n        // Generate days such that bonus accumulates to more than 1000 before a day with 1000 cost\n        int num_2000 = opt<int>(\"k\", n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i < num_2000) {\n                a[i] = 2000;\n            } else {\n                a[i] = 1000;\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(2) == 0) ? 1000 : 2000;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(2) == 0) ? 1000 : 2000;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_1000\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000;\n        }\n    } else if (type == \"all_2000\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2000;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1000 : 2000;\n        }\n    } else if (type == \"first_k_1000_rest_2000\") {\n        int k = opt<int>(\"k\", n/2);\n        for (int i = 0; i < n; ++i) {\n            if (i < k) {\n                a[i] = 1000;\n            } else {\n                a[i] = 2000;\n            }\n        }\n    } else if (type == \"last_day_bonus_spend\") {\n        // All days are 2000 except last day is 1000\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 2000;\n        }\n        a[n - 1] = 1000;\n    } else if (type == \"large_bonus_before_small_cost\") {\n        // Generate days such that bonus accumulates to more than 1000 before a day with 1000 cost\n        int num_2000 = opt<int>(\"k\", n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i < num_2000) {\n                a[i] = 2000;\n            } else {\n                a[i] = 1000;\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(2) == 0) ? 1000 : 2000;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(2) == 0) ? 1000 : 2000;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_1000\n./gen -n 1 -type all_2000\n./gen -n 1 -type random\n\n./gen -n 2 -type alternating\n./gen -n 2 -type random\n\n./gen -n 10 -type all_1000\n./gen -n 10 -type all_2000\n./gen -n 10 -type alternating\n./gen -n 10 -type random\n\n./gen -n 50 -type first_k_1000_rest_2000 -k 25\n./gen -n 50 -type first_k_1000_rest_2000 -k 0\n./gen -n 50 -type first_k_1000_rest_2000 -k 50\n\n./gen -n 100 -type last_day_bonus_spend\n./gen -n 100 -type large_bonus_before_small_cost -k 99\n\n./gen -n 1000 -type random\n./gen -n 1000 -type alternating\n\n./gen -n 10000 -type all_1000\n./gen -n 10000 -type all_2000\n./gen -n 10000 -type random\n\n./gen -n 50000 -type first_k_1000_rest_2000 -k 25000\n\n./gen -n 100000 -type last_day_bonus_spend\n./gen -n 100000 -type large_bonus_before_small_cost -k 99999\n\n./gen -n 300000 -type all_1000\n./gen -n 300000 -type all_2000\n./gen -n 300000 -type alternating\n./gen -n 300000 -type random\n\n./gen -n 300000 -type first_k_1000_rest_2000 -k 150000\n./gen -n 300000 -type first_k_1000_rest_2000 -k 0\n./gen -n 300000 -type first_k_1000_rest_2000 -k 300000\n\n./gen -n 300000 -type last_day_bonus_spend\n./gen -n 300000 -type large_bonus_before_small_cost -k 299999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:05.628217",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "853/E",
      "title": "E. Lada Malina",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers k, n, q (2 ≤ k ≤ 10, 1 ≤ n ≤ 105, 1 ≤ q ≤ 105), the number of engines of «Lada Malina», number of factories producing «Lada Malina» and number of options of an exposition time and location respectively.The following k lines contain the descriptions of «Lada Malina» engines. The i-th of them contains two integers vxi, vyi ( - 1000 ≤ vxi, vyi ≤ 1000) defining the velocity vector of the i-th engine. Velocity vector can't be zero, i.e. at least one of vxi and vyi is not equal to zero. It is guaranteed that no two velosity vectors are collinear (parallel).Next n lines contain the descriptions of factories. The i-th of them contains two integers fxi, fyi, ai ( - 109 ≤ fxi, fyi ≤ 109, 1 ≤ ai ≤ 109) defining the coordinates of the i-th factory location and the number of cars that are located there.The following q lines contain the descriptions of the car exposition. The i-th of them contains three integers pxi, pyi, ti ( - 109 ≤ pxi, pyi ≤ 109, 1 ≤ ti ≤ 105) defining the coordinates of the exposition location and the number of days till the exposition start in the i-th option.",
      "output_spec": "OutputFor each possible option of the exposition output the number of cars that will be able to get to the exposition location by the moment of its beginning.",
      "sample_tests": "ExamplesInputCopy2 4 11 1-1 12 3 12 -2 1-2 1 1-2 -2 10 0 2OutputCopy3InputCopy3 4 32 0-1 1-1 -2-3 0 61 -2 1-3 -7 33 2 2-1 -4 10 4 26 0 1OutputCopy490",
      "description": "E. Lada Malina\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers k, n, q (2 ≤ k ≤ 10, 1 ≤ n ≤ 105, 1 ≤ q ≤ 105), the number of engines of «Lada Malina», number of factories producing «Lada Malina» and number of options of an exposition time and location respectively.The following k lines contain the descriptions of «Lada Malina» engines. The i-th of them contains two integers vxi, vyi ( - 1000 ≤ vxi, vyi ≤ 1000) defining the velocity vector of the i-th engine. Velocity vector can't be zero, i.e. at least one of vxi and vyi is not equal to zero. It is guaranteed that no two velosity vectors are collinear (parallel).Next n lines contain the descriptions of factories. The i-th of them contains two integers fxi, fyi, ai ( - 109 ≤ fxi, fyi ≤ 109, 1 ≤ ai ≤ 109) defining the coordinates of the i-th factory location and the number of cars that are located there.The following q lines contain the descriptions of the car exposition. The i-th of them contains three integers pxi, pyi, ti ( - 109 ≤ pxi, pyi ≤ 109, 1 ≤ ti ≤ 105) defining the coordinates of the exposition location and the number of days till the exposition start in the i-th option.\n\nOutputFor each possible option of the exposition output the number of cars that will be able to get to the exposition location by the moment of its beginning.\n\nInputCopy2 4 11 1-1 12 3 12 -2 1-2 1 1-2 -2 10 0 2OutputCopy3InputCopy3 4 32 0-1 1-1 -2-3 0 61 -2 1-3 -7 33 2 2-1 -4 10 4 26 0 1OutputCopy490\n\nInputCopy2 4 11 1-1 12 3 12 -2 1-2 1 1-2 -2 10 0 2\n\nOutputCopy3\n\nInputCopy3 4 32 0-1 1-1 -2-3 0 61 -2 1-3 -7 33 2 2-1 -4 10 4 26 0 1\n\nOutputCopy490\n\nNoteImages describing sample tests are given below. Exposition options are denoted with crosses, factories are denoted with points. Each factory is labeled with a number of cars that it has.First sample test explanation:  Car from the first factory is not able to get to the exposition location in time.  Car from the second factory can get to the exposition in time if we set w1 = 0, w2 = 1.  Car from the third factory can get to the exposition in time if we set , .  Car from the fourth factory can get to the exposition in time if we set w1 = 1, w2 = 0.",
      "solutions": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces",
          "content": "Hi everybody!These days Moscow is conducting the 2nd International Olympiad of Metropolises that is an international competition for high school students from biggest cities and capitals all around the world. One of the disciplines of the competition is informatics. Rounds of the competition were prepared by the jury members invited from St. Petersburg, Minsk, Almaty and Moscow olympiad scientific committee which you may know by Moscow team Olympiad, Open Olympiad in Informatics and Moscow Olympiad for young students (rounds 327, 342, 345, 376, 401).We are very grateful to MikeMirzayanov for Polygon system that made it possible to conveniently hold a simultaneous statement translation process into lots of languages. As a good friends of Codeforces platform, we conduct a parallel rated Div. 1 + Div. 2 round on the competition problemset.Round will happen on September 6th at 12:55 UTC and it will last for two hours. There will be 5 problems for each division, scoring will be announced later.Scientific Committee of the olympiad consists of: andrewzta, GlebsHP, Endagorion, meshanya, Chmel_Tolstiy, Zlobober, Helen Andreeva and Bakhyt Matkarymov. Problems were prepared by timgaripov, mingaleg, halin.george, vintage_Vlad_Makeev, malcolm, LHiC coordinated by your humble servant.Codeforces coordinator KAN helped us to choose problems for a round.Good luck and high ratings for everybody!PS We kindly ask everybody who knows problems of an on-site event not to participate in a round and not to discuss them in public, as this may be a subject for disqualification.Congratulations to the winners!In div. 1 they are: Um_nik fateice KADR dotorya FallDream In div. 2 they are: jiangIy xolm YxqK lixolas Rawnd The analysis is published. Thanks to all for participating!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54350",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1777
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces",
          "content": "(Idea — Sender , developing — timgaripov) 854A - FractionIt's possible to look over all possible values of the numerator . For the current value of a we have to compute denominator as b = n - a, check that there are no common divisors (except 1) of a and b (it also could be done by a linear search of possible common divisors 2 ≤ d ≤ a). The answer is the maximal fraction that was considered during the iteration over all possible values of the numerator and passed the irreducibility test. Pseudocode of the described solution is presented below: This solution have time complexity.However, we can find answer to the problem analytically in the following way: (Idea — Chmel_Tolstiy, developing — mingaleg) 854B - Maxim Buys an ApartmentMinimum number of good apartments is almost always 1, since rooms with indices from 1 to k could be inhabited. Exceptions are cases in which k = 0 and k = n, in these cases both minimum and maximum number of good rooms is 0 since there is no inhabitant or vacant apartments.Maximum number of good apartments could be reached, for example, as follows. Assume apartments with indices 2, 5, 8 and so on are occupied as much as possible. Each of these apartments produces 2 good rooms except from, if it exists, the one with index n (that apartment produces 1 good apartment). If number of inhabitant apartments is less than k occupy any of rest rooms to reach that number, every such occupation will decrease number of good apartments by one). Simulate this process, than count the number of good rooms to find maximum possible number. Expected complexity: O(n2) or O(n).Instead of simulating the above process calculate number of apartments with indices 2, 5, 8 and so on excluding the one with index n if it exists. Number of that apartments is equal to , and if k ≤ x you can occupy some of these apartments to reach maximum number of good rooms equal to 2·k. Otherwise, if k > x, assume that apartments with indices 2, 5, 8 and so on are occupied, so any room has at least one inhabited room adjacent to it. Therefore number of good apartments is equal to number of vacant apartments and is equal to n - k. Implementation of these formulas with keeping in mind cases in which k = 0 and k = n will be scored as full solution of problem. Expected complexity: O(1).(Idea — Zlobober, developing — halin.george) 853A - PlanningWe will show that following greedy is correct: let's for each moment of time use a plane, which can depart in this moment of time (and didn't depart earlier, of course) with minimal cost of delay. Proof is quite simple: it's required to minimize . You can notice that is constant, so we just need to minimize . Consider the optimal solution when plane i departs at moment bi and solution by greedy algorithm in which plane i departs at moment ai. Let x be plane with minimal cx, such ax ≠ bx. At any moment greedy algorithm takes avaliable plane with lowest cx, so ax < bx. Let y be a plane, such that by = ax. But cy >  = by, so bx·cx + by·cy >  = bx·cy + by·cx and it's possible to swap bx and by in optimal solution without loosing of optimality. By performing this operation many times it's possible to make bi = ai for each i and it means that greedy solution is optimal.To make this solution work fast you need to use some data structures to find optimal plane faster for each moment. This data structure should be able to add number into set, give value of minimal element in set and erase minimal number from set. For this purpose you can use heap (or someting like std::set or std::priority_queue in C++). (Idea — GlebsHP, developing — mingaleg) 853B - Jury MeetingObviously, each member of the jury needs to buy exactly two tickets — to the capital and back. Sort all flights by the day of departure. Now go through flights to the capital (forward flights) and one by one assume it is the last forward flight in answer (let's say it is scheduled on day d). Thus you are assuming that all forward flights are contained in some fixed prefix of flights. Make sure that there is at least one forward flight for every jury member in this prefix and find the cheapest forward flight among them for every person. All return flights we are interested in are contained in the suffix of flights list such that every flight's departure date is at least d + k + 1. Take similar steps: make sure that there is at least one return flight for every jury member in this suffix and find the cheapest return flight among them for every person as well. Select minimal cost among these variants or find out that the problem has no solution. Expected complexity: O(nm2) or O(m2 + n).Just as the boundary of considered prefix moves right, the boundary of considered suffix moves right as well. This suggests that the problem could be solved by the two pointers method. Assume you are storing minimum forward flight's cost on current prefix (infinity if no flight exists) for every person, and you are storing multiset (ordered by cost) of all return flights on current suffix for each person as well. To proceed next prefix and conforming suffix do the following: Move prefix boundary to the next forward flight. If its cost ci is less than minimum forward flight's cost fwdfi from that city, then you could improve total cost: decrease it by ci - fwdfi and set fwdfi to ci since it's new minimal cost. Move suffix boundary to the next backward flight until there is such flight exists and it departure date difference with prefix boundary departure date is under k + 1. While moving suffix boundary, keep return flights multisets consistent: remove boundary flight right before moving that boundary to the next flight. Also check out if you are removing cheapest flight from multiset. If it is so, minimal flight cost for that city changed as well as total cost: it increases by difference between old minimal cost and new minimal cost. Keep in mind that if you are removing last flight from multiset, then there is no more appropriate return flight for this city and you should terminate the process. Proceed these steps moving boundaries to the right until the process terminates. In this way you've reviewed the same prefixes and corresponding suffixes as in slower solution described above. Expected complexity: .(Idea — glebushka98, developing — vintage_Vlad_Makeev) 853C - BoredomWe can't iterate over all interesting rectangles. Let's count number of rectangles that are not intersecting our rectangle. To do it let's calculate number of rectangles to the left, right, up and down of rectangle in query. It can be easily done in O(1) time: suppose we have rectangle with corners (i;pi) and (j;pj). We have min(i, j) - 1 points to the left of rectangle, n - max(i, j) to the right, min(pi, pj) - 1 to the down, etc. If we have x points in some area, there are rectangles in that area. But now we calculated twice rectangles that are simultaneously to the left and up of our rectangle, left and down, etc. To find number of such rectangles we can iterate over all points and find points which are in these areas and find number of rectangles in area using formula . The complexity is O(q·n).To solve the problem we need to find number of points in some areas faster. It's quite easy to notice that we just have many queries of finding number of points in some subrectangle. It's classical problem that can be solved with some 2d tree in O(q·log2) solution. But it can be too slow and can not fit into time limit in case of inaccurate implementation. However, you can notice that all queries are offline and find number of points in subrectangle in O(q·logn) time. It's fast enough to pass all tests.(Idea — Elena Andreeva, developing — vintage_Vlad_Makeev) 853D - Michael and Charging StationsBefore solving problem one observation is required: suppose at day i we have xi bonuses. Then exists optimal solution, which spends 0 or min(ai, xi) bonuses every day. It's quite easy to proof: suppose we have some optimal solution and i is a first day, when neither 0 nor min(ai, xi) bonuses were spent. If i is a last day on which non-zero amount of bonuses was spent, we can notice that solution spending min(ai, xi) bonuses that day is more optimal, so first solution was optimal. So let's consider next day after i, when non-zero amount of bonuses was spent, say j, and amount of bonuses spent at day j is sj (Also, amount of bonuses spent on day i is si). Let's look at solution that spends si + min(si - min(ai, xi), sj) bonuses at day i and sj - min(si - min(ai, xi), sj). That solution is still correct and still optimal, but it spends min(ai, xi) at day i or 0 at day j. Anyway this operation increases first day i when neither i nor min(ai, xi) bonuses were spent or first day j after it, when non-zero amount of burles were spent. But we can't increase i or j infinitely, so, after some iterations of such transformation, solution, spending 0 or min(ai, xi) bonuses in each day.To make an O(n2) solution it's possible to consider dynamic programming approach: let dpi, j be minimum amount of money that is possible to spend at first i days to pay for all chargings and have 100·j bonuses on card. At first, dp0, 0 = 0 and dpi, j = ∞. Then we can easy calculate all states going through all states with something like this code:for (int i = 0; i < n; i++) { for (int j = 0; j <= 2 * n; j++) { dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]); dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)], dp[i][j] + a[i] - 100 * min(j, a[i] / 100)); } }Of course, j can be up to 2·n, because at each day it's possible to earn at most 2 bonuses.To make this solution faster let's consider the following observation: there exists an optimal solution, which never has more 3000 bonuses on bonus card. To proof it let's first proof following lemma:Lemma 1: There exists an optimal solution which spends only 0 or ai bonuses at day i if there are at least 3000 bonuses at card at the beginning of day i. Lemma 1 proof: Let's introduce some designations. Let xi be amount of bonuses at the beginning of day i and si be amount of bonuses spent at day i. Also let's call day i \"fractional\" if si ≠ 0 and si ≠ ai, and call day i \"interesting\" if si ≠ 0. Let's proof lemma2 and lemma3 at first:Lemma 2: Assume xi ≥ 3000 and j — next after i interesting day and k — next after j interesting day. Then there exists an optimal solution in which k is not a fractional day or j is not a fractional day. Lemma2 proof: Suppose is some optimal solution j and k are fractional days. Let's consider a solution spending sj + min(sk, aj - s{j}) bonuses at day j and sk - min(sk, aj - s{j}) at day k. This solution is still correct, because xi ≥ 3000, so for days j and k there is enough bonuses and still optimal. Lemma2 is proved.Lemma 3: Assume xi ≥ 3000 and j — next after i interesting day. Then there exists an optimal solution is which j is not a fractional day.Lemma 3 proof: Consider some optimal solution with fractional day j. At first let's proof that j is not last interesting day. Suppose, j is last interesting day in solution. But we can make a solution that spends ai bonuses at day i (because ai ≤ 3000) and it will be more optimal. Contradiction. So there exists next after j interesting day. Let's call it k. Let's consider 2 cases:Case 1 (aj = 1000): Let's spend consider solution spending 1000 bonuses at day j and ak - (1000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2 (aj = 2000): There are two subcases:Case 2.1 (ak = 2000): Let's spend consider solution spending 2000 bonuses at day j and ak - (2000 - sj)) at day k. It's still correct and optimal but j is not a fractional day.Case 2.2 (ak = 1000): Let's proof, k is not last interesting day. Assume k is last interesting day. Consider a solution spending 2000 bonuses at day j and 1000 bonuses at day k. It's correct but more optimal that initial solution. Conrtadiction. Now let p be next after k interesting day (k is not a fractional day by lemma2). If 2000 - aj ≤ 1000 we can consider solution which spends 2000 bonuses at day j, 1000 - (2000 - ak) bonuses at day k and sp bonuses at day p. If 2000 - sj > 1000 let's consider a solution which spends sj + 1000 bonuses at day j, 0 bonuses at day k and sp at day p. But by lemma2 sp = ap, so we can consider solution that spends 2000 bonuses at day j 0 bonuses at day k and ap - (2000 - sj - ak) at day k. All of these solutions are correct and optimal.Lemma 1 proof (end): At first, of course there is at least one interesting day after i (Otherwise, it's more optimal to charge at day i using bounses, but in initial solution si = 0 because xi - 1 ≤ 3000 and xi > 3000). Let's call that day j and by lemma3 j is not fractional day. Let's consider 4 cases now:Case 1: (ai = 1000, aj = 1000). Let's consider a solution with si = 1000 and sj = 0. It's correct and still optimal, but xi ≤ 3000.Case 2: (ai = 2000, aj = 2000). Same as case1.Case 3: (ai = 2000, aj = 1000). Let's consider 2 subcases:Case 3.1: j is not last interesting day. Let k be next interesting day. It ak = 1000 consider a solution spending 2000 bonuses at day i, 0 bonuses at days j and k. It's still correct and optimal, but xi ≤ 3000. If ak = 2000 consider a solution a spending 2000 bonuses at day i, 1000 bonuses at day j and 0 bonuses at day k. It's correct and optimal too, and xi ≤ 3000 too.Case 3.2: j is last interesting day. Let's construct solution this way. At first let's set si = 1000 and sj = 0. Then let's iterate over all ineteresting days after j, say k, in order in increasing time and set si = si + min(2000 - si, sk), sk = sk - min(2000 - si, sk). If after this process we still have some bonus left just add it to si. At the end, si will be equal 2000 because we spent all bonuses, solution will still be correct and optimal, but xi ≤ 3000.Case 4: (ai = 1000, aj = 2000). Let p be last day before i with sp ≠ 0. If ap = 1000 consider a solution with sp = 0, si = 0, sj = 2000. It's correct, optimal and xt ≤ 3000 for each t ≤ i. If ap = 2000, consider a solution with sp = 2000, si = 0, sj = 0. It's correct, optimal and xt ≤ 3000 for each t ≤ i, too.So for all cases we can make correct and optimal solution such there is no xi ≤ 3000 for all i, or number of first day with xi > 3000 increases, but it can't increase forever, so after some amount of opereations solution with xi ≤ 3000 for all i will be constructed.Because of this fact we can consider dynamic programming approach described before but notice, that we should consider only states with j ≤ 30. It will have O(n) complexity. Moreover, looking at states with j = 30 is required. It's possible to make a test on which solution, that looks at states with j ≤ 29 will be incorrect.(Idea — Zlobober, developing — malcolm) 853E - Lada MalinaIn the original contest there were subtasks for this problem and it's more convinient to understand the editorial going through these subtasks, so we will leave them here.The key part of a solution is to understand what are the locations that may be accessed from the origin in T seconds. First observation is that we should investigate it only in case when T = 1 because T is simply a scale factor. Let’s denote this set for T = 1 as P.Group #1. For the first group it’s easy to see that P is a square with vertices in points ( ± 2, 0), (0,  ± 2). So, the first group may be solved with a straightforward O(qn) approach: we iterate through all the factories and check if it's possible to get for cars from i-th factories to the car exposition. We can rotate the plane by 45 degrees (this may be done by the transformation x' = x + y, y' = x - y), after this each query region looks like a square. Therefore, it's necessary to check if point lies inside a square:Group #2. In the second group propeller velocities are two arbitrary vectors. It can be shown that P will always be a parallelogram centered in the origin, built on vectors 2v1 and 2v2 as sides. Thus, this group is a matter of the same O(qn) approach with a bit more complicated predicate: one should be able to check that an integer point belongs to an integer parallelogram. The key observation is that we may find an appropriate transformation of a plane that transforms this set into a rectangle. Indeed, there always exists an affine transformation performing what we want. As an additional requirement, we want to transform coordinates in such way that they are still integral and not much larger than the original coordinates. The transformation looks like following:The first expression is a signed distance to the line parallel to the vector v1, and the second one is the signed distance from the line parallel to the vector v2. Easy to see that belonging to some query parallelogram can be formulated in terms of x' and y' independendly belonging to some ranges. Group #3. Second group should be a hint for the third group. One can find that the set P = {w1v1 + ... + wkvk||wi| ≤ 1} is always a central-symmetric polygon with the center in the origin. Actually, this Polygon is a Minkowski sum of k segments [ - vi, vi]. Minkowski sum of sets A1, A2, ..., Ak is by definition the following set: . It can be built in time, although in this problem k is very small, so one may use any inefficient approach that comes into his head, like building a convex hull of all points { ± v1 ± v2... ± vk}.After we found out a form of P, it’s possible to solve the third group of tests in O(qnk) by checking if each possible factory location belongs into a query polygon in O(k) time.Following groups are exactly the same, but the constraints are higher, they require using some geometric data structure to deal with range queries.Groups #4 and #5. Fourth group and fifth group are very similar to first and second group correspondingly, but we need to process the requests faster. After the transformation of the plane, the request can be reformulated as \"find sum of all factories inside a square\", so any 2d data structure may be applied, like a segment tree of segment trees. Another approach is to use a sweeping line algorithm with a segment tree or an appropriate binary search tree, achieving a time complexity or .Group #6. To solve the sixth group we need to use a trapezoidal polygon area calculation algorithm applied to our problem. Calculate the sum of points in each of 2k trapezoid areas below each of the sides of a polygon, and then take them with appropriate signs to achieve a result. Such trapezoid area can be seen as a set of points satisfying the inequalities l ≤ x ≤ r and y ≤ kx + b. Under transformation x' = x, y' = y - kx, this area becomes a rectangle, leading us to an time solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 853\\s*E"
          },
          "content_length": 18717
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 1",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 2",
          "code": "#define MAXN\t500005\n#define MAXP\t18200095",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 3",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 4",
          "code": "int n; //Size of array P\nPersistentIT t;\n\nll Solve(int l, int r, int d, int u) {\n    ...\n    int n = (r-l+1);\n    int nu = t.query(l, r, u+1, n);\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 5",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 6",
          "code": "cout << 1 << ' ' << min(n - k, 2 * k);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 7",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 8",
          "code": "13\n2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 9",
          "code": "The number of comparisons performed is logarithmic in the distance between first and last (At most log 2(last - first) + O(1) comparisons). However, for non-RandomAccessIterators, the number of iterator increments is linear.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 (based on Olympiad of Metropolises) - Codeforces - Code 10",
          "code": "dpr[i]=dpr[i]-prev+sumright[num];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54350",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #433 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++) {    for (int j = 0; j <= 2 * n; j++) {         dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000], dp[i][j] + a[i]);         dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j - min(j, a[i] / 100)],                                                  dp[i][j] + a[i] - 100 * min(j, a[i] / 100));     } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(2, 10, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<pair<int, int>> engines(k);\n    for (int i = 0; i < k; i++) {\n        string vx_name = \"vx[\" + to_string(i+1) + \"]\";\n        string vy_name = \"vy[\" + to_string(i+1) + \"]\";\n\n        int vx = inf.readInt(-1000, 1000, vx_name);\n        inf.readSpace();\n        int vy = inf.readInt(-1000, 1000, vy_name);\n        inf.readEoln();\n\n        ensuref(!(vx == 0 && vy == 0), \"Engine %d: Velocity vector cannot be zero\", i+1);\n\n        engines[i] = {vx, vy};\n    }\n\n    // Check that no two velocity vectors are colinear\n    for (int i = 0; i < k; i++) {\n        int a = engines[i].first;\n        int b = engines[i].second;\n        for (int j = i+1; j < k; j++) {\n            int c = engines[j].first;\n            int d = engines[j].second;\n            long long cross = 1LL*a*d - 1LL*b*c;\n            ensuref(cross != 0, \"Velocity vectors %d and %d are colinear\", i+1, j+1);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        string fx_name = \"fx[\" + to_string(i+1) + \"]\";\n        string fy_name = \"fy[\" + to_string(i+1) + \"]\";\n        string a_name  = \"a[\" + to_string(i+1) + \"]\";\n\n        long long fx = inf.readLong(-1000000000LL, 1000000000LL, fx_name);\n        inf.readSpace();\n        long long fy = inf.readLong(-1000000000LL, 1000000000LL, fy_name);\n        inf.readSpace();\n        long long a  = inf.readLong(1LL, 1000000000LL, a_name);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; i++) {\n        string px_name = \"px[\" + to_string(i+1) + \"]\";\n        string py_name = \"py[\" + to_string(i+1) + \"]\";\n        string t_name  = \"t[\" + to_string(i+1) + \"]\";\n\n        long long px = inf.readLong(-1000000000LL, 1000000000LL, px_name);\n        inf.readSpace();\n        long long py = inf.readLong(-1000000000LL, 1000000000LL, py_name);\n        inf.readSpace();\n        int t  = inf.readInt(1, 100000, t_name);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(2, 10, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<pair<int, int>> engines(k);\n    for (int i = 0; i < k; i++) {\n        string vx_name = \"vx[\" + to_string(i+1) + \"]\";\n        string vy_name = \"vy[\" + to_string(i+1) + \"]\";\n\n        int vx = inf.readInt(-1000, 1000, vx_name);\n        inf.readSpace();\n        int vy = inf.readInt(-1000, 1000, vy_name);\n        inf.readEoln();\n\n        ensuref(!(vx == 0 && vy == 0), \"Engine %d: Velocity vector cannot be zero\", i+1);\n\n        engines[i] = {vx, vy};\n    }\n\n    // Check that no two velocity vectors are colinear\n    for (int i = 0; i < k; i++) {\n        int a = engines[i].first;\n        int b = engines[i].second;\n        for (int j = i+1; j < k; j++) {\n            int c = engines[j].first;\n            int d = engines[j].second;\n            long long cross = 1LL*a*d - 1LL*b*c;\n            ensuref(cross != 0, \"Velocity vectors %d and %d are colinear\", i+1, j+1);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        string fx_name = \"fx[\" + to_string(i+1) + \"]\";\n        string fy_name = \"fy[\" + to_string(i+1) + \"]\";\n        string a_name  = \"a[\" + to_string(i+1) + \"]\";\n\n        long long fx = inf.readLong(-1000000000LL, 1000000000LL, fx_name);\n        inf.readSpace();\n        long long fy = inf.readLong(-1000000000LL, 1000000000LL, fy_name);\n        inf.readSpace();\n        long long a  = inf.readLong(1LL, 1000000000LL, a_name);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; i++) {\n        string px_name = \"px[\" + to_string(i+1) + \"]\";\n        string py_name = \"py[\" + to_string(i+1) + \"]\";\n        string t_name  = \"t[\" + to_string(i+1) + \"]\";\n\n        long long px = inf.readLong(-1000000000LL, 1000000000LL, px_name);\n        inf.readSpace();\n        long long py = inf.readLong(-1000000000LL, 1000000000LL, py_name);\n        inf.readSpace();\n        int t  = inf.readInt(1, 100000, t_name);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(2, 10, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<pair<int, int>> engines(k);\n    for (int i = 0; i < k; i++) {\n        string vx_name = \"vx[\" + to_string(i+1) + \"]\";\n        string vy_name = \"vy[\" + to_string(i+1) + \"]\";\n\n        int vx = inf.readInt(-1000, 1000, vx_name);\n        inf.readSpace();\n        int vy = inf.readInt(-1000, 1000, vy_name);\n        inf.readEoln();\n\n        ensuref(!(vx == 0 && vy == 0), \"Engine %d: Velocity vector cannot be zero\", i+1);\n\n        engines[i] = {vx, vy};\n    }\n\n    // Check that no two velocity vectors are colinear\n    for (int i = 0; i < k; i++) {\n        int a = engines[i].first;\n        int b = engines[i].second;\n        for (int j = i+1; j < k; j++) {\n            int c = engines[j].first;\n            int d = engines[j].second;\n            long long cross = 1LL*a*d - 1LL*b*c;\n            ensuref(cross != 0, \"Velocity vectors %d and %d are colinear\", i+1, j+1);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        string fx_name = \"fx[\" + to_string(i+1) + \"]\";\n        string fy_name = \"fy[\" + to_string(i+1) + \"]\";\n        string a_name  = \"a[\" + to_string(i+1) + \"]\";\n\n        long long fx = inf.readLong(-1000000000LL, 1000000000LL, fx_name);\n        inf.readSpace();\n        long long fy = inf.readLong(-1000000000LL, 1000000000LL, fy_name);\n        inf.readSpace();\n        long long a  = inf.readLong(1LL, 1000000000LL, a_name);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; i++) {\n        string px_name = \"px[\" + to_string(i+1) + \"]\";\n        string py_name = \"py[\" + to_string(i+1) + \"]\";\n        string t_name  = \"t[\" + to_string(i+1) + \"]\";\n\n        long long px = inf.readLong(-1000000000LL, 1000000000LL, px_name);\n        inf.readSpace();\n        long long py = inf.readLong(-1000000000LL, 1000000000LL, py_name);\n        inf.readSpace();\n        int t  = inf.readInt(1, 100000, t_name);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool are_collinear(int ax, int ay, int bx, int by) {\n    return 1LL * ax * by == 1LL * ay * bx;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> engines(k);\n\n    if (type == \"random\") {\n        // Generate random velocities\n        for(int i = 0; i < k; ) {\n            int vx = rnd.next(-1000,1000);\n            int vy = rnd.next(-1000,1000);\n            if (vx == 0 && vy == 0)\n                continue; // Velocity vector can't be zero\n            bool collinear = false;\n            for(int j = 0; j < i; ++j) {\n                if (are_collinear(vx, vy, engines[j].first, engines[j].second)) {\n                    collinear = true;\n                    break;\n                }\n            }\n            if (collinear)\n                continue; // Velocity vectors can't be collinear\n            engines[i] = make_pair(vx, vy);\n            ++i;\n        }\n    } else if (type == \"boundary\") {\n        // Generate velocities that allow us to create boundary test cases\n        k = 2;\n        engines.resize(k);\n        engines[0] = make_pair(1000, 0);\n        engines[1] = make_pair(0, 1000);\n    } else if (type == \"negative_wi\") {\n        // Generate velocities that require negative wi\n        k = 2;\n        engines.resize(k);\n        engines[0] = make_pair(1000, 0);\n        engines[1] = make_pair(0, 1000);\n    } else if (type == \"impossible\") {\n        // Generate velocities that make it impossible to reach the exposition\n        k = 2;\n        engines.resize(k);\n        engines[0] = make_pair(1000, 0);\n        engines[1] = make_pair(0, 1000);\n    } else {\n        // Default to random\n        for(int i = 0; i < k; ) {\n            int vx = rnd.next(-1000,1000);\n            int vy = rnd.next(-1000,1000);\n            if (vx == 0 && vy == 0)\n                continue; // Velocity vector can't be zero\n            bool collinear = false;\n            for(int j = 0; j < i; ++j) {\n                if (are_collinear(vx, vy, engines[j].first, engines[j].second)) {\n                    collinear = true;\n                    break;\n                }\n            }\n            if (collinear)\n                continue; // Velocity vectors can't be collinear\n            engines[i] = make_pair(vx, vy);\n            ++i;\n        }\n    }\n\n    // Output k, n, q\n    printf(\"%d %d %d\\n\", k, n, q);\n\n    // Output k lines of engines\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", engines[i].first, engines[i].second);\n    }\n\n    vector<tuple<int64_t,int64_t,int64_t>> factories(n);\n\n    if (type == \"boundary\") {\n        // Set factories at (0,0), ai = 1\n        for(int i = 0; i < n; ++i) {\n            factories[i] = make_tuple(0LL, 0LL, 1LL);\n        }\n        // Generate expositions at positions that require wi = -1 or +1\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int ti = rnd.next(1, 100000);\n            int mode = i % 4;\n            int64_t pxi = 0, pyi = 0;\n            // Mode 0: require w1 = +1, w2 arbitrary\n            if (mode == 0) {\n                pxi = 1000LL * ti; // Requires w1 = +1\n                pyi = rnd.next(-1000LL * ti, +1000LL * ti);\n            } else if (mode == 1) {\n                pxi = -1000LL * ti; // Requires w1 = -1\n                pyi = rnd.next(-1000LL * ti, +1000LL * ti);\n            } else if (mode == 2) {\n                pxi = rnd.next(-1000LL * ti, +1000LL * ti);\n                pyi = 1000LL * ti; // Requires w2 = +1\n            } else if (mode == 3) {\n                pxi = rnd.next(-1000LL * ti, +1000LL * ti);\n                pyi = -1000LL * ti; // Requires w2 = -1\n            }\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    } else if (type == \"negative_wi\") {\n        // Set factories at (0,0), ai = 1\n        for(int i = 0; i < n; ++i) {\n            factories[i] = make_tuple(0LL, 0LL, 1LL);\n        }\n        // Generate expositions that require negative wi\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int ti = rnd.next(1, 100000);\n            int mode = i % 2;\n            int64_t pxi = 0, pyi = 0;\n            if (mode == 0) {\n                pxi = -500LL * ti; // Requires w1 negative\n                pyi = +700LL * ti;\n            } else {\n                pxi = +700LL * ti;\n                pyi = -500LL * ti; // Requires w2 negative\n            }\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    } else if (type == \"impossible\") {\n        // Set factories at (0,0), ai = 1\n        for(int i = 0; i < n; ++i) {\n            factories[i] = make_tuple(0LL, 0LL, 1LL);\n        }\n        // Generate expositions that cannot be reached\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int ti = rnd.next(1, 100000);\n            int64_t pxi = rnd.next(2000LL * ti, 3000LL * ti); // Out of attainable range\n            int64_t pyi = rnd.next(2000LL * ti, 3000LL * ti);\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    } else {\n        // Random type\n        // Generate factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t fyi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t ai = rnd.next(1LL, 1000000000LL);\n            factories[i] = make_tuple(fxi, fyi, ai);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Generate expositions\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t pyi = rnd.next(-1000000000LL, 1000000000LL);\n            int ti = rnd.next(1, 100000);\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool are_collinear(int ax, int ay, int bx, int by) {\n    return 1LL * ax * by == 1LL * ay * bx;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> engines(k);\n\n    if (type == \"random\") {\n        // Generate random velocities\n        for(int i = 0; i < k; ) {\n            int vx = rnd.next(-1000,1000);\n            int vy = rnd.next(-1000,1000);\n            if (vx == 0 && vy == 0)\n                continue; // Velocity vector can't be zero\n            bool collinear = false;\n            for(int j = 0; j < i; ++j) {\n                if (are_collinear(vx, vy, engines[j].first, engines[j].second)) {\n                    collinear = true;\n                    break;\n                }\n            }\n            if (collinear)\n                continue; // Velocity vectors can't be collinear\n            engines[i] = make_pair(vx, vy);\n            ++i;\n        }\n    } else if (type == \"boundary\") {\n        // Generate velocities that allow us to create boundary test cases\n        k = 2;\n        engines.resize(k);\n        engines[0] = make_pair(1000, 0);\n        engines[1] = make_pair(0, 1000);\n    } else if (type == \"negative_wi\") {\n        // Generate velocities that require negative wi\n        k = 2;\n        engines.resize(k);\n        engines[0] = make_pair(1000, 0);\n        engines[1] = make_pair(0, 1000);\n    } else if (type == \"impossible\") {\n        // Generate velocities that make it impossible to reach the exposition\n        k = 2;\n        engines.resize(k);\n        engines[0] = make_pair(1000, 0);\n        engines[1] = make_pair(0, 1000);\n    } else {\n        // Default to random\n        for(int i = 0; i < k; ) {\n            int vx = rnd.next(-1000,1000);\n            int vy = rnd.next(-1000,1000);\n            if (vx == 0 && vy == 0)\n                continue; // Velocity vector can't be zero\n            bool collinear = false;\n            for(int j = 0; j < i; ++j) {\n                if (are_collinear(vx, vy, engines[j].first, engines[j].second)) {\n                    collinear = true;\n                    break;\n                }\n            }\n            if (collinear)\n                continue; // Velocity vectors can't be collinear\n            engines[i] = make_pair(vx, vy);\n            ++i;\n        }\n    }\n\n    // Output k, n, q\n    printf(\"%d %d %d\\n\", k, n, q);\n\n    // Output k lines of engines\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", engines[i].first, engines[i].second);\n    }\n\n    vector<tuple<int64_t,int64_t,int64_t>> factories(n);\n\n    if (type == \"boundary\") {\n        // Set factories at (0,0), ai = 1\n        for(int i = 0; i < n; ++i) {\n            factories[i] = make_tuple(0LL, 0LL, 1LL);\n        }\n        // Generate expositions at positions that require wi = -1 or +1\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int ti = rnd.next(1, 100000);\n            int mode = i % 4;\n            int64_t pxi = 0, pyi = 0;\n            // Mode 0: require w1 = +1, w2 arbitrary\n            if (mode == 0) {\n                pxi = 1000LL * ti; // Requires w1 = +1\n                pyi = rnd.next(-1000LL * ti, +1000LL * ti);\n            } else if (mode == 1) {\n                pxi = -1000LL * ti; // Requires w1 = -1\n                pyi = rnd.next(-1000LL * ti, +1000LL * ti);\n            } else if (mode == 2) {\n                pxi = rnd.next(-1000LL * ti, +1000LL * ti);\n                pyi = 1000LL * ti; // Requires w2 = +1\n            } else if (mode == 3) {\n                pxi = rnd.next(-1000LL * ti, +1000LL * ti);\n                pyi = -1000LL * ti; // Requires w2 = -1\n            }\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    } else if (type == \"negative_wi\") {\n        // Set factories at (0,0), ai = 1\n        for(int i = 0; i < n; ++i) {\n            factories[i] = make_tuple(0LL, 0LL, 1LL);\n        }\n        // Generate expositions that require negative wi\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int ti = rnd.next(1, 100000);\n            int mode = i % 2;\n            int64_t pxi = 0, pyi = 0;\n            if (mode == 0) {\n                pxi = -500LL * ti; // Requires w1 negative\n                pyi = +700LL * ti;\n            } else {\n                pxi = +700LL * ti;\n                pyi = -500LL * ti; // Requires w2 negative\n            }\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    } else if (type == \"impossible\") {\n        // Set factories at (0,0), ai = 1\n        for(int i = 0; i < n; ++i) {\n            factories[i] = make_tuple(0LL, 0LL, 1LL);\n        }\n        // Generate expositions that cannot be reached\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int ti = rnd.next(1, 100000);\n            int64_t pxi = rnd.next(2000LL * ti, 3000LL * ti); // Out of attainable range\n            int64_t pyi = rnd.next(2000LL * ti, 3000LL * ti);\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    } else {\n        // Random type\n        // Generate factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t fyi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t ai = rnd.next(1LL, 1000000000LL);\n            factories[i] = make_tuple(fxi, fyi, ai);\n        }\n        // Output factories\n        for(int i = 0; i < n; ++i) {\n            int64_t fxi, fyi, ai;\n            tie(fxi, fyi, ai) = factories[i];\n            printf(\"%lld %lld %lld\\n\", fxi, fyi, ai);\n        }\n        // Generate expositions\n        vector<tuple<int64_t, int64_t, int>> expositions(q);\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi = rnd.next(-1000000000LL, 1000000000LL);\n            int64_t pyi = rnd.next(-1000000000LL, 1000000000LL);\n            int ti = rnd.next(1, 100000);\n            expositions[i] = make_tuple(pxi, pyi, ti);\n        }\n        // Output expositions\n        for(int i = 0; i < q; ++i) {\n            int64_t pxi, pyi;\n            int ti;\n            tie(pxi, pyi, ti) = expositions[i];\n            printf(\"%lld %lld %d\\n\", pxi, pyi, ti);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -q 5 -k 2 -type boundary\n./gen -n 1000 -q 1000 -k 2 -type boundary\n./gen -n 100000 -q 100000 -k 2 -type boundary\n\n./gen -n 5 -q 5 -k 2 -type negative_wi\n./gen -n 1000 -q 1000 -k 2 -type negative_wi\n./gen -n 100000 -q 100000 -k 2 -type negative_wi\n\n./gen -n 5 -q 5 -k 2 -type impossible\n./gen -n 1000 -q 1000 -k 2 -type impossible\n./gen -n 100000 -q 100000 -k 2 -type impossible\n\n./gen -n 5 -q 5 -k 5 -type random\n./gen -n 1000 -q 1000 -k 5 -type random\n./gen -n 100000 -q 100000 -k 5 -type random\n\n./gen -n 5 -q 5 -k 10 -type random\n./gen -n 1000 -q 1000 -k 10 -type random\n./gen -n 100000 -q 100000 -k 10 -type random\n\n# Mixed test cases\n./gen -n 100 -q 100 -k 3 -type random\n./gen -n 100 -q 10 -k 7 -type random\n./gen -n 10000 -q 5000 -k 2 -type boundary\n./gen -n 5000 -q 10000 -k 2 -type negative_wi\n./gen -n 10000 -q 10000 -k 2 -type impossible\n\n./gen -n 100000 -q 1 -k 2 -type random\n./gen -n 1 -q 100000 -k 2 -type random\n\n# Small n and q, large k\n./gen -n 10 -q 10 -k 10 -type random\n\n# Small k, n, q\n./gen -n 1 -q 1 -k 2 -type boundary\n\n# Single factory, single exposition\n./gen -n 1 -q 1 -k 2 -type negative_wi\n\n# Large n and q, moderate k\n./gen -n 50000 -q 50000 -k 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:07.722228",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "854/A",
      "title": "A. Fraction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputIn the only line of input there is an integer n (3 ≤ n ≤ 1000), the sum of numerator and denominator of the fraction.",
      "output_spec": "OutputOutput two space-separated positive integers a and b, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.",
      "sample_tests": "ExamplesInputCopy3OutputCopy1 2InputCopy4OutputCopy1 3InputCopy12OutputCopy5 7",
      "description": "A. Fraction\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputIn the only line of input there is an integer n (3 ≤ n ≤ 1000), the sum of numerator and denominator of the fraction.\n\nOutputOutput two space-separated positive integers a and b, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.\n\nInputCopy3OutputCopy1 2InputCopy4OutputCopy1 3InputCopy12OutputCopy5 7\n\nOutputCopy1 2\n\nOutputCopy1 3\n\nInputCopy12\n\nOutputCopy5 7",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n != -1) {\n        // If n is provided, output n directly, but ensure it's within constraints\n        ensure(3 <= n && n <= 1000);\n    } else {\n        // Generate n according to type\n        if (type == \"min\") {\n            n = 3;\n        } else if (type == \"max\") {\n            n = 1000;\n        } else if (type == \"prime\") {\n            // Collect primes between 3 and 1000\n            vector<int> primes;\n            vector<bool> is_prime(1001, true);\n            is_prime[0] = is_prime[1] = false;\n            for (int i = 2; i <= 1000; ++i) {\n                if (is_prime[i]) {\n                    if (i >= 3)\n                        primes.push_back(i);\n                    for (int j = i * 2; j <= 1000; j += i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n            n = primes[rnd.next(0, (int)primes.size() - 1)];\n        } else if (type == \"even\") {\n            vector<int> even_numbers;\n            for (int i = 4; i <= 1000; i += 2) {\n                even_numbers.push_back(i);\n            }\n            n = even_numbers[rnd.next(0, (int)even_numbers.size() - 1)];\n        } else if (type == \"odd\") {\n            vector<int> odd_numbers;\n            for (int i = 3; i <= 999; i += 2) {\n                odd_numbers.push_back(i);\n            }\n            n = odd_numbers[rnd.next(0, (int)odd_numbers.size() - 1)];\n        } else if (type == \"max_fraction\") {\n            // Generate n where the maximum fraction has a large numerator\n            n = 1000;\n        } else if (type == \"one_numerator\") {\n            // n such that maximum fraction is 1/(n-1)\n            n = rnd.next(3, 1000);\n        } else {\n            // random n\n            n = rnd.next(3, 1000);\n        }\n    }\n\n    // Ensure n is within constraints\n    ensure(3 <= n && n <= 1000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n != -1) {\n        // If n is provided, output n directly, but ensure it's within constraints\n        ensure(3 <= n && n <= 1000);\n    } else {\n        // Generate n according to type\n        if (type == \"min\") {\n            n = 3;\n        } else if (type == \"max\") {\n            n = 1000;\n        } else if (type == \"prime\") {\n            // Collect primes between 3 and 1000\n            vector<int> primes;\n            vector<bool> is_prime(1001, true);\n            is_prime[0] = is_prime[1] = false;\n            for (int i = 2; i <= 1000; ++i) {\n                if (is_prime[i]) {\n                    if (i >= 3)\n                        primes.push_back(i);\n                    for (int j = i * 2; j <= 1000; j += i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n            n = primes[rnd.next(0, (int)primes.size() - 1)];\n        } else if (type == \"even\") {\n            vector<int> even_numbers;\n            for (int i = 4; i <= 1000; i += 2) {\n                even_numbers.push_back(i);\n            }\n            n = even_numbers[rnd.next(0, (int)even_numbers.size() - 1)];\n        } else if (type == \"odd\") {\n            vector<int> odd_numbers;\n            for (int i = 3; i <= 999; i += 2) {\n                odd_numbers.push_back(i);\n            }\n            n = odd_numbers[rnd.next(0, (int)odd_numbers.size() - 1)];\n        } else if (type == \"max_fraction\") {\n            // Generate n where the maximum fraction has a large numerator\n            n = 1000;\n        } else if (type == \"one_numerator\") {\n            // n such that maximum fraction is 1/(n-1)\n            n = rnd.next(3, 1000);\n        } else {\n            // random n\n            n = rnd.next(3, 1000);\n        }\n    }\n\n    // Ensure n is within constraints\n    ensure(3 <= n && n <= 1000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n./gen -n 11\n./gen -n 12\n\n./gen -type min\n./gen -type max\n./gen -type random\n./gen -type prime\n./gen -type even\n./gen -type odd\n./gen -type max_fraction\n./gen -type one_numerator\n\n./gen -n 13\n./gen -n 17\n./gen -n 23\n./gen -n 997\n./gen -n 999\n./gen -n 1000\n\n./gen -n 500\n./gen -n 501\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:09.933264",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "854/B",
      "title": "B. Максим покупает квартиру",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных содержатся два целых числа n и k (1 ≤ n ≤ 109, 0 ≤ k ≤ n).",
      "output_spec": "Выходные данныеВыведите минимально возможное и максимально возможное количество подходящих для Максима квартир.",
      "sample_tests": "ПримерВходные данныеСкопировать6 3Выходные данныеСкопировать1 3",
      "description": "B. Максим покупает квартиру\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке входных данных содержатся два целых числа n и k (1 ≤ n ≤ 109, 0 ≤ k ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите минимально возможное и максимально возможное количество подходящих для Максима квартир.\n\nВыходные данные\n\nВходные данныеСкопировать6 3Выходные данныеСкопировать1 3\n\nВходные данныеСкопировать6 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ примере из условия минимальное количество подходящих для Максима квартир достигается, если, например, заселены квартиры с номерами 1, 2 и 3, тогда подходит только квартира номер 4. Максимальное же количество достигается если, например, заселены квартиры с номерами 1, 3, 5, тогда подходят квартиры с номерами 2, 4 и 6.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = -1;\n    int k = -1;\n  \n    // Read arguments\n    vector<string> types;\n    for (int i = 1; i < argc; ++i) {\n        string arg = argv[i];\n        if (arg == \"-n\") {\n            n = atoi(argv[++i]);\n        } else if (arg == \"-k\") {\n            k = atoi(argv[++i]);\n        } else if (arg == \"-type\") {\n            types.push_back(argv[++i]);\n        }\n    }\n\n    // Process types\n    for (string type : types) {\n        if (type == \"min_n\") {\n            n = 1;\n        } else if (type == \"max_n\") {\n            n = 1000000000;\n        } else if (type == \"min_k\") {\n            k = 0;\n        } else if (type == \"max_k\") {\n            if (n != -1)\n                k = n;\n            else\n                k = 1000000000; // Will adjust later\n        } else if (type == \"mid_k\") {\n            if (n != -1)\n                k = n / 2;\n            else\n                k = 500000000; // Arbitrary\n        } else if (type == \"random\") {\n            // Generate random n and k if not set\n            if (n == -1) {\n                n = rnd.next(1, 1000000000);\n            }\n            k = rnd.next(0, n);\n        } else {\n            // Unknown type\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    // If n or k still not set, set random values\n    if (n == -1) {\n        n = rnd.next(1, 1000000000);\n    }\n\n    if (k == -1) {\n        k = rnd.next(0, n);\n    }\n\n    ensuref(1 <= n && n <= 1000000000, \"n must be in [1, 1e9]\");\n    ensuref(0 <= k && k <= n, \"k must be in [0, n]\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = -1;\n    int k = -1;\n  \n    // Read arguments\n    vector<string> types;\n    for (int i = 1; i < argc; ++i) {\n        string arg = argv[i];\n        if (arg == \"-n\") {\n            n = atoi(argv[++i]);\n        } else if (arg == \"-k\") {\n            k = atoi(argv[++i]);\n        } else if (arg == \"-type\") {\n            types.push_back(argv[++i]);\n        }\n    }\n\n    // Process types\n    for (string type : types) {\n        if (type == \"min_n\") {\n            n = 1;\n        } else if (type == \"max_n\") {\n            n = 1000000000;\n        } else if (type == \"min_k\") {\n            k = 0;\n        } else if (type == \"max_k\") {\n            if (n != -1)\n                k = n;\n            else\n                k = 1000000000; // Will adjust later\n        } else if (type == \"mid_k\") {\n            if (n != -1)\n                k = n / 2;\n            else\n                k = 500000000; // Arbitrary\n        } else if (type == \"random\") {\n            // Generate random n and k if not set\n            if (n == -1) {\n                n = rnd.next(1, 1000000000);\n            }\n            k = rnd.next(0, n);\n        } else {\n            // Unknown type\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    // If n or k still not set, set random values\n    if (n == -1) {\n        n = rnd.next(1, 1000000000);\n    }\n\n    if (k == -1) {\n        k = rnd.next(0, n);\n    }\n\n    ensuref(1 <= n && n <= 1000000000, \"n must be in [1, 1e9]\");\n    ensuref(0 <= k && k <= n, \"k must be in [0, n]\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with minimum n\n./gen -type min_n -type min_k\n./gen -type min_n -type max_k\n./gen -type min_n -k 0\n./gen -type min_n -k 1\n\n# Test cases with maximum n\n./gen -type max_n -type min_k\n./gen -type max_n -type max_k\n./gen -type max_n -k 0\n./gen -type max_n -k 1\n\n# Random n and k\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Specific n and k\n./gen -n 1000000000 -k 1000000000\n./gen -n 1000000000 -k 0\n./gen -n 1 -k 1\n./gen -n 1 -k 0\n\n# Mid n and k\n./gen -n 500000000 -k 250000000\n\n# n is small, k varies\n./gen -n 10 -type min_k\n./gen -n 10 -type max_k\n./gen -n 10 -type mid_k\n\n# k is n - 1\n./gen -n 1000000000 -k 999999999\n\n# Random n, k = n - 1\n./gen -n 123456789 -k 123456788\n./gen -n 987654321 -k 987654320\n\n# Edge cases\n./gen -type min_n -k 0\n./gen -type min_n -k 1\n\n./gen -type max_n -k 1\n./gen -type max_n -k 999999999\n\n# Random big n and random k\n./gen -n 999999999 -k 123456789\n./gen -n 888888888 -k 777777777\n\n# Random n and k\n./gen -type random\n./gen -type random\n./gen -type random\n\n# n is prime, k is prime\n./gen -n 999999937 -k 499999969\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:12.171351",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "854/C",
      "title": "C. Planning",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 300 000), here n is the number of flights, and k is the number of minutes in the beginning of the day that the flights did not depart.The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 107), here ci is the cost of delaying the i-th flight for one minute.",
      "output_spec": "OutputThe first line must contain the minimum possible total cost of delaying the flights.The second line must contain n different integers t1, t2, ..., tn (k + 1 ≤ ti ≤ k + n), here ti is the minute when the i-th flight must depart. If there are several optimal schedules, print any of them.",
      "sample_tests": "ExampleInputCopy5 24 2 1 10 2OutputCopy203 6 7 4 5",
      "description": "C. Planning\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 300 000), here n is the number of flights, and k is the number of minutes in the beginning of the day that the flights did not depart.The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 107), here ci is the cost of delaying the i-th flight for one minute.\n\nOutputThe first line must contain the minimum possible total cost of delaying the flights.The second line must contain n different integers t1, t2, ..., tn (k + 1 ≤ ti ≤ k + n), here ti is the minute when the i-th flight must depart. If there are several optimal schedules, print any of them.\n\nInputCopy5 24 2 1 10 2OutputCopy203 6 7 4 5\n\nInputCopy5 24 2 1 10 2\n\nOutputCopy203 6 7 4 5\n\nNoteLet us consider sample test. If Helen just moves all flights 2 minutes later preserving the order, the total cost of delaying the flights would be (3 - 1)·4 + (4 - 2)·2 + (5 - 3)·1 + (6 - 4)·10 + (7 - 5)·2 = 38 burles. However, the better schedule is shown in the sample answer, its cost is (3 - 1)·4 + (6 - 2)·2 + (7 - 3)·1 + (4 - 4)·10 + (5 - 5)·2 = 20 burles.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 10000000, \"c_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 10000000, \"c_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 10000000, \"c_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read input\n    int n = inf.readInt(1, 300000, \"n\");\n    int k = inf.readInt(1, n, \"k\");\n    vector<int> c(n + 1); // c[1..n]\n    for (int i = 1; i <= n; ++i) {\n        c[i] = inf.readInt(1, 10000000, format(\"c[%d]\", i).c_str());\n    }\n    \n    // Read jury's total cost\n    long long jury_total_cost = ans.readLong();\n\n    // Read participant's total cost\n    long long participant_total_cost = ouf.readLong();\n\n    // Read participant's t_i's\n    vector<int> t(n + 1); // t[1..n]\n    for (int i = 1; i <= n; ++i) {\n        t[i] = ouf.readInt(k + 1, k + n, format(\"t[%d]\", i).c_str());\n    }\n\n    // Check that t_i >= i\n    // Check that all t_i are distinct\n    set<int> used_times;\n    for (int i = 1; i <= n; ++i) {\n        if (t[i] < i) {\n            ouf.quitf(_wa, \"Flight %d departs earlier than scheduled: scheduled at %d, departs at %d\", i, i, t[i]);\n        }\n        if (used_times.count(t[i])) {\n            ouf.quitf(_wa, \"Departure time %d is used more than once\", t[i]);\n        }\n        used_times.insert(t[i]);\n    }\n\n    // Compute total_cost\n    long long computed_total_cost = 0;\n    for (int i = 1; i <= n; ++i) {\n        long long delay = t[i] - i;\n        computed_total_cost += delay * c[i];\n    }\n    if (computed_total_cost != participant_total_cost) {\n        ouf.quitf(_wa, \"Computed total cost (%lld) doesn't match participant's total cost (%lld)\", computed_total_cost, participant_total_cost);\n    }\n    if (participant_total_cost > jury_total_cost) {\n        quitf(_wa, \"Participant's total cost (%lld) is greater than jury's total cost (%lld)\", participant_total_cost, jury_total_cost);\n    } else if (participant_total_cost < jury_total_cost) {\n        quitf(_fail, \"Participant's total cost (%lld) is less than jury's total cost (%lld)\", participant_total_cost, jury_total_cost);\n    } else {\n        quitf(_ok, \"Total cost is %lld\", participant_total_cost);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= k && k <= n && n <= 300'000);\n\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    } else if (type == \"equal\") {\n        int c_val = rnd.next(1, 10000000);\n        for(int i = 0; i < n; ++i) {\n            c[i] = c_val;\n        }\n    } else if (type == \"increasing\") {\n        int min_c = 1;\n        int max_c = 10000000;\n        double step = (max_c - min_c) / double(n - 1);\n        for(int i = 0; i < n; ++i) {\n            c[i] = int(min_c + step * i + 0.5);\n            if (c[i] > max_c) c[i] = max_c;\n            if (c[i] < min_c) c[i] = min_c;\n        }\n    } else if (type == \"decreasing\") {\n        int min_c = 1;\n        int max_c = 10000000;\n        double step = (max_c - min_c) / double(n - 1);\n        for(int i = 0; i < n; ++i) {\n            c[i] = int(max_c - step * i + 0.5);\n            if (c[i] < min_c) c[i] = min_c;\n            if (c[i] > max_c) c[i] = max_c;\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = 10000000;\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n    /* Output c_i */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= k && k <= n && n <= 300'000);\n\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    } else if (type == \"equal\") {\n        int c_val = rnd.next(1, 10000000);\n        for(int i = 0; i < n; ++i) {\n            c[i] = c_val;\n        }\n    } else if (type == \"increasing\") {\n        int min_c = 1;\n        int max_c = 10000000;\n        double step = (max_c - min_c) / double(n - 1);\n        for(int i = 0; i < n; ++i) {\n            c[i] = int(min_c + step * i + 0.5);\n            if (c[i] > max_c) c[i] = max_c;\n            if (c[i] < min_c) c[i] = min_c;\n        }\n    } else if (type == \"decreasing\") {\n        int min_c = 1;\n        int max_c = 10000000;\n        double step = (max_c - min_c) / double(n - 1);\n        for(int i = 0; i < n; ++i) {\n            c[i] = int(max_c - step * i + 0.5);\n            if (c[i] < min_c) c[i] = min_c;\n            if (c[i] > max_c) c[i] = max_c;\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = 10000000;\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n    /* Output c_i */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 5 -k 3 -type random\n./gen -n 10 -k 1 -type equal\n./gen -n 10 -k 9 -type increasing\n./gen -n 10 -k 10 -type decreasing\n\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 50000 -type equal\n./gen -n 100000 -k 1 -type increasing\n./gen -n 100000 -k 1 -type decreasing\n\n./gen -n 300000 -k 299999 -type random\n./gen -n 300000 -k 300000 -type min\n\n./gen -n 5 -k 5 -type max\n\n./gen -n 300000 -k 1 -type max\n./gen -n 300000 -k 300000 -type min\n\n./gen -n 300000 -k 150000 -type min\n./gen -n 300000 -k 150000 -type max\n\n./gen -n 300000 -k 150000 -type random\n\n./gen -n 300000 -k 1 -type increasing\n./gen -n 300000 -k 1 -type decreasing\n./gen -n 300000 -k 1 -type equal\n\n./gen -n 200000 -k 100000 -type random\n./gen -n 200000 -k 100000 -type equal\n./gen -n 200000 -k 100000 -type min\n\n./gen -n 1 -k 1 -type min\n./gen -n 1 -k 1 -type max\n\n./gen -n 2 -k 1 -type random\n\n./gen -n 50 -k 25 -type equal\n\n./gen -n 100000 -k 100000 -type random\n./gen -n 100000 -k 100000 -type min\n\n./gen -n 100000 -k 1 -type max\n\n./gen -n 300000 -k 1 -type random\n\n./gen -n 300000 -k 150000 -type increasing\n\n./gen -n 300000 -k 150000 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:13.870212",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "854/D",
      "title": "D. Jury Meeting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains three integers n, m and k (1 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106). The i-th of the following m lines contains the description of the i-th flight defined by four integers di, fi, ti and ci (1 ≤ di ≤ 106, 0 ≤ fi ≤ n, 0 ≤ ti ≤ n, 1 ≤ ci ≤ 106, exactly one of fi and ti equals zero), the day of departure (and arrival), the departure city, the arrival city and the ticket cost.",
      "output_spec": "OutputOutput the only integer that is the minimum cost of gathering all jury members in city 0 for k days and then sending them back to their home cities.If it is impossible to gather everybody in Metropolis for k days and then send them back to their home cities, output \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy2 6 51 1 0 50003 2 0 55002 2 0 600015 0 2 90009 0 1 70008 0 2 6500OutputCopy24500InputCopy2 4 51 2 0 50002 1 0 45002 1 0 30008 0 1 6000OutputCopy-1",
      "description": "D. Jury Meeting\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers n, m and k (1 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106). The i-th of the following m lines contains the description of the i-th flight defined by four integers di, fi, ti and ci (1 ≤ di ≤ 106, 0 ≤ fi ≤ n, 0 ≤ ti ≤ n, 1 ≤ ci ≤ 106, exactly one of fi and ti equals zero), the day of departure (and arrival), the departure city, the arrival city and the ticket cost.\n\nOutputOutput the only integer that is the minimum cost of gathering all jury members in city 0 for k days and then sending them back to their home cities.If it is impossible to gather everybody in Metropolis for k days and then send them back to their home cities, output \"-1\" (without the quotes).\n\nInputCopy2 6 51 1 0 50003 2 0 55002 2 0 600015 0 2 90009 0 1 70008 0 2 6500OutputCopy24500InputCopy2 4 51 2 0 50002 1 0 45002 1 0 30008 0 1 6000OutputCopy-1\n\nInputCopy2 6 51 1 0 50003 2 0 55002 2 0 600015 0 2 90009 0 1 70008 0 2 6500\n\nOutputCopy24500\n\nInputCopy2 4 51 2 0 50002 1 0 45002 1 0 30008 0 1 6000\n\nOutputCopy-1\n\nNoteThe optimal way to gather everybody in Metropolis in the first sample test is to use flights that take place on days 1, 2, 8 and 9. The only alternative option is to send jury member from second city back home on day 15, that would cost 2500 more.In the second sample it is impossible to send jury member from city 2 back home from Metropolis.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int di = inf.readInt(1, 1000000, \"d_i\");\n        inf.readSpace();\n        int fi = inf.readInt(0, n, \"f_i\");\n        inf.readSpace();\n        int ti = inf.readInt(0, n, \"t_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000, \"c_i\");\n        inf.readEoln();\n\n        // Exactly one of fi and ti equals zero\n        ensuref((fi == 0) != (ti == 0), \"Exactly one of f_i and t_i must be zero on line %d\", i+2);\n\n        if (fi == 0) {\n            ensuref(1 <= ti && ti <= n, \"t_i must be in [1,n] when f_i == 0, but t_i=%d on line %d\", ti, i+2);\n        } else if (ti == 0) {\n            ensuref(1 <= fi && fi <= n, \"f_i must be in [1,n] when t_i == 0, but f_i=%d on line %d\", fi, i+2);\n        } else {\n            // Should have already ensured that exactly one of fi, ti equals zero\n            ensuref(false, \"Internal error on line %d\", i+2);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int di = inf.readInt(1, 1000000, \"d_i\");\n        inf.readSpace();\n        int fi = inf.readInt(0, n, \"f_i\");\n        inf.readSpace();\n        int ti = inf.readInt(0, n, \"t_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000, \"c_i\");\n        inf.readEoln();\n\n        // Exactly one of fi and ti equals zero\n        ensuref((fi == 0) != (ti == 0), \"Exactly one of f_i and t_i must be zero on line %d\", i+2);\n\n        if (fi == 0) {\n            ensuref(1 <= ti && ti <= n, \"t_i must be in [1,n] when f_i == 0, but t_i=%d on line %d\", ti, i+2);\n        } else if (ti == 0) {\n            ensuref(1 <= fi && fi <= n, \"f_i must be in [1,n] when t_i == 0, but f_i=%d on line %d\", fi, i+2);\n        } else {\n            // Should have already ensured that exactly one of fi, ti equals zero\n            ensuref(false, \"Internal error on line %d\", i+2);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int di = inf.readInt(1, 1000000, \"d_i\");\n        inf.readSpace();\n        int fi = inf.readInt(0, n, \"f_i\");\n        inf.readSpace();\n        int ti = inf.readInt(0, n, \"t_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000, \"c_i\");\n        inf.readEoln();\n\n        // Exactly one of fi and ti equals zero\n        ensuref((fi == 0) != (ti == 0), \"Exactly one of f_i and t_i must be zero on line %d\", i+2);\n\n        if (fi == 0) {\n            ensuref(1 <= ti && ti <= n, \"t_i must be in [1,n] when f_i == 0, but t_i=%d on line %d\", ti, i+2);\n        } else if (ti == 0) {\n            ensuref(1 <= fi && fi <= n, \"f_i must be in [1,n] when t_i == 0, but f_i=%d on line %d\", fi, i+2);\n        } else {\n            // Should have already ensured that exactly one of fi, ti equals zero\n            ensuref(false, \"Internal error on line %d\", i+2);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);      // Number of jury members (cities from 1 to n)\n    int m = opt<int>(\"m\", 0);      // Number of flights\n    int k = opt<int>(\"k\", 1);      // Number of working days in Metropolis\n    string type = opt<string>(\"type\", \"random\");  // Type of test case\n\n    if (type == \"random\") {\n        // Random test case\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < m; ++i) {\n            // Random day between 1 and 1e6\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n            // Random cost between 1 and 1e6\n            int ci = rnd.next(1, 1000000);\n            if (rnd.next(0, 1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    } else if (type == \"max_values\") {\n        // Test case with maximum input values\n        n = 100000;\n        m = 100000;\n        k = 1000000;\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < m; ++i) {\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n            int ci = rnd.next(1, 1000000);\n            if (rnd.next(0, 1) == 0) {\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    } else if (type == \"impossible_no_flights\") {\n        // Impossible test case (no flights available)\n        printf(\"%d %d %d\\n\", n, 0, k);\n        // No flights to output\n    } else if (type == \"impossible_no_incoming\") {\n        // Impossible test case (some jury members have no incoming flights)\n        int p = opt<int>(\"p\", 10); // Percentage of jury members without incoming flights\n        int num_no_incoming = n * p / 100;\n        int num_with_incoming = n - num_no_incoming;\n        m = m; // Use the provided m\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        // Generate jury member IDs\n        vector<int> jury_members(n);\n        for (int i = 0; i < n; ++i) jury_members[i] = i + 1;\n        shuffle(jury_members.begin(), jury_members.end());\n\n        // Mark jury members without incoming flights\n        set<int> no_incoming;\n        for (int i = 0; i < num_no_incoming; ++i)\n            no_incoming.insert(jury_members[i]);\n\n        int flights_output = 0;\n        while (flights_output < m) {\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n            int ci = rnd.next(1, 1000000);\n            if (rnd.next(0, 1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                if (no_incoming.count(fi)) continue; // Skip if no incoming flights for this member\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n            flights_output++;\n        }\n    } else {\n        // Default case\n        printf(\"%d %d %d\\n\", n, m, k);\n        // No flights to output\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);      // Number of jury members (cities from 1 to n)\n    int m = opt<int>(\"m\", 0);      // Number of flights\n    int k = opt<int>(\"k\", 1);      // Number of working days in Metropolis\n    string type = opt<string>(\"type\", \"random\");  // Type of test case\n\n    if (type == \"random\") {\n        // Random test case\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < m; ++i) {\n            // Random day between 1 and 1e6\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n            // Random cost between 1 and 1e6\n            int ci = rnd.next(1, 1000000);\n            if (rnd.next(0, 1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    } else if (type == \"max_values\") {\n        // Test case with maximum input values\n        n = 100000;\n        m = 100000;\n        k = 1000000;\n        printf(\"%d %d %d\\n\", n, m, k);\n        for (int i = 0; i < m; ++i) {\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n            int ci = rnd.next(1, 1000000);\n            if (rnd.next(0, 1) == 0) {\n                fi = rnd.next(1, n);\n                ti = 0;\n            } else {\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n        }\n    } else if (type == \"impossible_no_flights\") {\n        // Impossible test case (no flights available)\n        printf(\"%d %d %d\\n\", n, 0, k);\n        // No flights to output\n    } else if (type == \"impossible_no_incoming\") {\n        // Impossible test case (some jury members have no incoming flights)\n        int p = opt<int>(\"p\", 10); // Percentage of jury members without incoming flights\n        int num_no_incoming = n * p / 100;\n        int num_with_incoming = n - num_no_incoming;\n        m = m; // Use the provided m\n        printf(\"%d %d %d\\n\", n, m, k);\n\n        // Generate jury member IDs\n        vector<int> jury_members(n);\n        for (int i = 0; i < n; ++i) jury_members[i] = i + 1;\n        shuffle(jury_members.begin(), jury_members.end());\n\n        // Mark jury members without incoming flights\n        set<int> no_incoming;\n        for (int i = 0; i < num_no_incoming; ++i)\n            no_incoming.insert(jury_members[i]);\n\n        int flights_output = 0;\n        while (flights_output < m) {\n            int di = rnd.next(1, 1000000);\n            int fi, ti;\n            int ci = rnd.next(1, 1000000);\n            if (rnd.next(0, 1) == 0) {\n                // Flight to Metropolis\n                fi = rnd.next(1, n);\n                if (no_incoming.count(fi)) continue; // Skip if no incoming flights for this member\n                ti = 0;\n            } else {\n                // Flight from Metropolis\n                fi = 0;\n                ti = rnd.next(1, n);\n            }\n            printf(\"%d %d %d %d\\n\", di, fi, ti, ci);\n            flights_output++;\n        }\n    } else {\n        // Default case\n        printf(\"%d %d %d\\n\", n, m, k);\n        // No flights to output\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying sizes\n./gen -n 10 -m 20 -k 5 -type random\n./gen -n 100 -m 200 -k 10 -type random\n./gen -n 1000 -m 5000 -k 50 -type random\n./gen -n 10000 -m 50000 -k 100 -type random\n./gen -n 50000 -m 100000 -k 500 -type random\n\n# Test cases with maximum input values\n./gen -type max_values\n\n# Impossible test cases with no flights available\n./gen -n 10 -m 0 -k 5 -type impossible_no_flights\n./gen -n 100 -m 0 -k 10 -type impossible_no_flights\n\n# Impossible test cases where some jury members have no incoming flights\n./gen -n 10 -m 20 -k 5 -type impossible_no_incoming -p 50\n./gen -n 100 -m 200 -k 10 -type impossible_no_incoming -p 30\n./gen -n 1000 -m 5000 -k 50 -type impossible_no_incoming -p 10\n./gen -n 10000 -m 50000 -k 100 -type impossible_no_incoming -p 5\n./gen -n 50000 -m 100000 -k 500 -type impossible_no_incoming -p 1\n\n# Test cases with minimal input values\n./gen -n 1 -m 2 -k 1 -type random\n./gen -n 2 -m 4 -k 2 -type random\n\n# Test cases with large k values\n./gen -n 1000 -m 5000 -k 1000000 -type random\n./gen -n 10000 -m 50000 -k 1000000 -type random\n\n# Test cases with k = 1\n./gen -n 10000 -m 50000 -k 1 -type random\n./gen -n 50000 -m 100000 -k 1 -type random\n\n# Test cases where all flights happen on the same day\n./gen -n 1000 -m 2000 -k 10 -type random\n./gen -n 5000 -m 10000 -k 20 -type random\n\n# Test cases with only flights to Metropolis\n./gen -n 1000 -m 1000 -k 50 -type random\n./gen -n 10000 -m 10000 -k 100 -type random\n\n# Test cases with only flights from Metropolis\n./gen -n 1000 -m 1000 -k 50 -type random\n./gen -n 10000 -m 10000 -k 100 -type random\n\n# Test cases with no solution due to tight schedule\n./gen -n 100 -m 200 -k 1000000 -type impossible_no_incoming -p 100\n\n# Additional random test cases\n./gen -n 20000 -m 40000 -k 200 -type random\n./gen -n 30000 -m 60000 -k 300 -type random\n./gen -n 40000 -m 80000 -k 400 -type random\n./gen -n 60000 -m 120000 -k 600 -type random\n./gen -n 80000 -m 160000 -k 800 -type random\n./gen -n 90000 -m 180000 -k 900 -type random\n./gen -n 100000 -m 200000 -k 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:16.077025",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "854/E",
      "title": "E. Скука",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа n и q (2 ≤ n ≤ 200 000, 1 ≤ q ≤ 200 000) размер поля и число выбранных прямоугольников.Во второй строке содержатся n чисел p1, p2, ..., pn, разделённых пробелами (1 ≤ pi ≤ n, все pi различны), задающие клетки, отмеченные Ильёй. А именно, pi — это номер строки клетки, отмеченной в столбце i. Строки пронумерованы от 1 до n снизу вверх, столбцы пронумерованы от 1 до n слева направо.В следующих q строках содержатся описания выбранных прямоугольников. Каждый прямоугольник задаётся четвёркой чисел l, d, r, u (1 ≤ l ≤ r ≤ n, 1 ≤ d ≤ u ≤ n), где l и r — номера самого левого и самого правого столбца в прямоугольнике, а d и u — номера самой нижней и самой верхней строки.",
      "output_spec": "Выходные данныеДля каждого из отмеченных прямоугольников выведите степень его интересности в отдельной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 31 21 1 1 11 1 1 21 1 2 2Выходные данныеСкопировать111Входные данныеСкопировать4 21 3 2 44 1 4 41 1 2 3Выходные данныеСкопировать35",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся два целых числа n и q (2 ≤ n ≤ 200 000, 1 ≤ q ≤ 200 000) размер поля и число выбранных прямоугольников.Во второй строке содержатся n чисел p1, p2, ..., pn, разделённых пробелами (1 ≤ pi ≤ n, все pi различны), задающие клетки, отмеченные Ильёй. А именно, pi — это номер строки клетки, отмеченной в столбце i. Строки пронумерованы от 1 до n снизу вверх, столбцы пронумерованы от 1 до n слева направо.В следующих q строках содержатся описания выбранных прямоугольников. Каждый прямоугольник задаётся четвёркой чисел l, d, r, u (1 ≤ l ≤ r ≤ n, 1 ≤ d ≤ u ≤ n), где l и r — номера самого левого и самого правого столбца в прямоугольнике, а d и u — номера самой нижней и самой верхней строки.\n\nВходные данные\n\nВыходные данныеДля каждого из отмеченных прямоугольников выведите степень его интересности в отдельной строке.\n\nВыходные данные\n\nВходные данныеСкопировать2 31 21 1 1 11 1 1 21 1 2 2Выходные данныеСкопировать111Входные данныеСкопировать4 21 3 2 44 1 4 41 1 2 3Выходные данныеСкопировать35\n\nВходные данныеСкопировать2 31 21 1 1 11 1 1 21 1 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать111\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 21 3 2 44 1 4 41 1 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать35\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере существует только один интересный прямоугольник, занимающий всё поле. Поэтому ответ на любой запрос равен 1.Во втором тестовом примере для первого запроса 3 интересных прямоугольника, пересекающие данный, расположены так:  А 5 интересных прямоугольников, пересекающие данный, во втором запросе расположены так:",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> p_sorted = p;\n    sort(p_sorted.begin(), p_sorted.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(p_sorted[i] != p_sorted[i - 1],\n                \"All p_i must be different, but value %d occurs more than once\", p_sorted[i]);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\"); // l ≤ r ≤ n\n        inf.readSpace();\n        int u = inf.readInt(d, n, \"u_i\"); // d ≤ u ≤ n\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> p_sorted = p;\n    sort(p_sorted.begin(), p_sorted.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(p_sorted[i] != p_sorted[i - 1],\n                \"All p_i must be different, but value %d occurs more than once\", p_sorted[i]);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\"); // l ≤ r ≤ n\n        inf.readSpace();\n        int u = inf.readInt(d, n, \"u_i\"); // d ≤ u ≤ n\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> p_sorted = p;\n    sort(p_sorted.begin(), p_sorted.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(p_sorted[i] != p_sorted[i - 1],\n                \"All p_i must be different, but value %d occurs more than once\", p_sorted[i]);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\"); // l ≤ r ≤ n\n        inf.readSpace();\n        int u = inf.readInt(d, n, \"u_i\"); // d ≤ u ≤ n\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_p(int n, string p_type) {\n    vector<int> p(n);\n    if (p_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (p_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (p_type == \"zigzag\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = (i % 2 == 0) ? (i / 2) + 1 : n - (i / 2);\n    } else { // default is random\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n    return p;\n}\n\nvector<array<int,4>> generate_queries(int n, int q, string q_type) {\n    vector<array<int,4>> queries(q);\n    if (q_type == \"single_point\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            queries[i] = {l, d, l, d};\n        }\n    } else if (q_type == \"full_grid\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = {1, 1, n, n};\n        }\n    } else if (q_type == \"identical\") {\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int d = rnd.next(1, n);\n        int u = rnd.next(d, n);\n        for (int i = 0; i < q; ++i) {\n            queries[i] = {l, d, r, u};\n        }\n    } else if (q_type == \"rows\") {\n        for (int i = 0; i < q; ++i) {\n            int row = rnd.next(1, n);\n            queries[i] = {1, row, n, row};\n        }\n    } else if (q_type == \"columns\") {\n        for (int i = 0; i < q; ++i) {\n            int col = rnd.next(1, n);\n            queries[i] = {col, 1, col, n};\n        }\n    } else if (q_type == \"partial_corner\") {\n        for (int i = 0; i < q; ++i) {\n            int r = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            queries[i] = {1, 1, r, u};\n        }\n    } else { // default is random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries[i] = {l, d, r, u};\n        }\n    }\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> p = generate_p(n, p_type);\n    vector<array<int,4>> queries = generate_queries(n, q, q_type);\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output p1 p2 ... pn\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d %d %d\\n\", queries[i][0], queries[i][1], queries[i][2], queries[i][3]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_p(int n, string p_type) {\n    vector<int> p(n);\n    if (p_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (p_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (p_type == \"zigzag\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = (i % 2 == 0) ? (i / 2) + 1 : n - (i / 2);\n    } else { // default is random\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n    return p;\n}\n\nvector<array<int,4>> generate_queries(int n, int q, string q_type) {\n    vector<array<int,4>> queries(q);\n    if (q_type == \"single_point\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            queries[i] = {l, d, l, d};\n        }\n    } else if (q_type == \"full_grid\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = {1, 1, n, n};\n        }\n    } else if (q_type == \"identical\") {\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        int d = rnd.next(1, n);\n        int u = rnd.next(d, n);\n        for (int i = 0; i < q; ++i) {\n            queries[i] = {l, d, r, u};\n        }\n    } else if (q_type == \"rows\") {\n        for (int i = 0; i < q; ++i) {\n            int row = rnd.next(1, n);\n            queries[i] = {1, row, n, row};\n        }\n    } else if (q_type == \"columns\") {\n        for (int i = 0; i < q; ++i) {\n            int col = rnd.next(1, n);\n            queries[i] = {col, 1, col, n};\n        }\n    } else if (q_type == \"partial_corner\") {\n        for (int i = 0; i < q; ++i) {\n            int r = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            queries[i] = {1, 1, r, u};\n        }\n    } else { // default is random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, n);\n            int u = rnd.next(d, n);\n            queries[i] = {l, d, r, u};\n        }\n    }\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> p = generate_p(n, p_type);\n    vector<array<int,4>> queries = generate_queries(n, q, q_type);\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output p1 p2 ... pn\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d %d %d\\n\", queries[i][0], queries[i][1], queries[i][2], queries[i][3]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -q 1 -p_type increasing -q_type single_point\n\n./gen -n 5 -q 5 -p_type increasing -q_type random\n./gen -n 5 -q 5 -p_type decreasing -q_type random\n./gen -n 5 -q 5 -p_type random -q_type random\n\n./gen -n 5 -q 5 -p_type random -q_type single_point\n./gen -n 5 -q 5 -p_type random -q_type full_grid\n./gen -n 5 -q 5 -p_type random -q_type identical\n\n./gen -n 1000 -q 1000 -p_type random -q_type random\n./gen -n 1000 -q 1000 -p_type increasing -q_type random\n./gen -n 1000 -q 1000 -p_type decreasing -q_type random\n\n./gen -n 1000 -q 1000 -p_type zigzag -q_type random\n./gen -n 1000 -q 1000 -p_type random -q_type full_grid\n./gen -n 1000 -q 1000 -p_type random -q_type single_point\n./gen -n 1000 -q 1000 -p_type random -q_type identical\n./gen -n 1000 -q 1000 -p_type random -q_type rows\n./gen -n 1000 -q 1000 -p_type random -q_type columns\n\n./gen -n 200000 -q 200000 -p_type random -q_type random\n./gen -n 200000 -q 200000 -p_type increasing -q_type random\n./gen -n 200000 -q 200000 -p_type decreasing -q_type random\n\n./gen -n 200000 -q 200000 -p_type random -q_type full_grid\n./gen -n 200000 -q 200000 -p_type random -q_type single_point\n./gen -n 200000 -q 200000 -p_type random -q_type identical\n./gen -n 200000 -q 200000 -p_type random -q_type rows\n./gen -n 200000 -q 200000 -p_type random -q_type columns\n./gen -n 200000 -q 200000 -p_type zigzag -q_type random\n\n./gen -n 200000 -q 1 -p_type random -q_type random\n./gen -n 2 -q 200000 -p_type random -q_type random\n\n./gen -n 100000 -q 100000 -p_type decreasing -q_type single_point\n./gen -n 100000 -q 100000 -p_type increasing -q_type rows\n\n./gen -n 131072 -q 131072 -p_type random -q_type random\n\n./gen -n 100000 -q 100000 -p_type random -q_type partial_corner\n./gen -n 100000 -q 100000 -p_type random -q_type identical\n./gen -n 100000 -q 100000 -p_type random -q_type full_grid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:17.715274",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/A",
      "title": "A. Tom Riddle's Diary",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains an integer n (1 ≤ n ≤ 100) — the number of names in the list.Next n lines each contain a string si, consisting of lowercase English letters. The length of each string is between 1 and 100.",
      "output_spec": "OutputOutput n lines each containing either \"YES\" or \"NO\" (without quotes), depending on whether this string was already present in the stream or not.You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy6tomluciusginnyharryginnyharryOutputCopyNONONONOYESYESInputCopy3aaaOutputCopyNOYESYES",
      "description": "A. Tom Riddle's Diary\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains an integer n (1 ≤ n ≤ 100) — the number of names in the list.Next n lines each contain a string si, consisting of lowercase English letters. The length of each string is between 1 and 100.\n\nOutputOutput n lines each containing either \"YES\" or \"NO\" (without quotes), depending on whether this string was already present in the stream or not.You can print each letter in any case (upper or lower).\n\nInputCopy6tomluciusginnyharryginnyharryOutputCopyNONONONOYESYESInputCopy3aaaOutputCopyNOYESYES\n\nInputCopy6tomluciusginnyharryginnyharry\n\nOutputCopyNONONONOYESYES\n\nInputCopy3aaa\n\nOutputCopyNOYESYES\n\nNoteIn test case 1, for i = 5 there exists j = 3 such that si = sj and j < i, which means that answer for i = 5 is \"YES\".",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*A"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s(len, ' ');\n    for (int i = 0; i < len; ++i) {\n        s[i] = (char)rnd.next('a', 'z');\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> names(n);\n    if (type == \"unique\") {\n        // Generate n unique names\n        set<string> used;\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int len = rnd.next(1, 100);\n                name = randomString(len);\n            } while (used.count(name));\n            names[i] = name;\n            used.insert(name);\n        }\n    } else if (type == \"same\") {\n        // Generate n identical names\n        int len = rnd.next(1, 100);\n        string name = randomString(len);\n        for (int i = 0; i < n; ++i) {\n            names[i] = name;\n        }\n    } else if (type == \"pairwise_repeat\") {\n        // Alternate between two names\n        int len1 = rnd.next(1, 100);\n        int len2 = rnd.next(1, 100);\n        string name1 = randomString(len1);\n        string name2;\n        do {\n            name2 = randomString(len2);\n        } while (name2 == name1);\n        for (int i = 0; i < n; ++i) {\n            names[i] = (i % 2 == 0) ? name1 : name2;\n        }\n    } else if (type == \"max_length\") {\n        // All names are of maximum length (100)\n        for (int i = 0; i < n; ++i) {\n            names[i] = randomString(100);\n        }\n    } else if (type == \"min_length\") {\n        // All names are of minimum length (1)\n        for (int i = 0; i < n; ++i) {\n            names[i] = randomString(1);\n        }\n    } else if (type == \"random_with_duplicates\") {\n        // Generate random names with some duplicates\n        map<string, int> used;\n        for (int i = 0; i < n; ++i) {\n            if (i > 0 && rnd.next(0, 1)) {\n                // With 50% chance, repeat a previous name\n                int repeat_index = rnd.next(0, i - 1);\n                names[i] = names[repeat_index];\n            } else {\n                // Generate a new name\n                int len = rnd.next(1, 100);\n                string name;\n                do {\n                    name = randomString(len);\n                } while (used.count(name));\n                names[i] = name;\n                used[name] = 1;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random names\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 100);\n            names[i] = randomString(len);\n        }\n    } else {\n        // If no matching type, default to random\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 100);\n            names[i] = randomString(len);\n        }\n    }\n\n    // Output n and the names\n    printf(\"%d\\n\", n);\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s(len, ' ');\n    for (int i = 0; i < len; ++i) {\n        s[i] = (char)rnd.next('a', 'z');\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> names(n);\n    if (type == \"unique\") {\n        // Generate n unique names\n        set<string> used;\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int len = rnd.next(1, 100);\n                name = randomString(len);\n            } while (used.count(name));\n            names[i] = name;\n            used.insert(name);\n        }\n    } else if (type == \"same\") {\n        // Generate n identical names\n        int len = rnd.next(1, 100);\n        string name = randomString(len);\n        for (int i = 0; i < n; ++i) {\n            names[i] = name;\n        }\n    } else if (type == \"pairwise_repeat\") {\n        // Alternate between two names\n        int len1 = rnd.next(1, 100);\n        int len2 = rnd.next(1, 100);\n        string name1 = randomString(len1);\n        string name2;\n        do {\n            name2 = randomString(len2);\n        } while (name2 == name1);\n        for (int i = 0; i < n; ++i) {\n            names[i] = (i % 2 == 0) ? name1 : name2;\n        }\n    } else if (type == \"max_length\") {\n        // All names are of maximum length (100)\n        for (int i = 0; i < n; ++i) {\n            names[i] = randomString(100);\n        }\n    } else if (type == \"min_length\") {\n        // All names are of minimum length (1)\n        for (int i = 0; i < n; ++i) {\n            names[i] = randomString(1);\n        }\n    } else if (type == \"random_with_duplicates\") {\n        // Generate random names with some duplicates\n        map<string, int> used;\n        for (int i = 0; i < n; ++i) {\n            if (i > 0 && rnd.next(0, 1)) {\n                // With 50% chance, repeat a previous name\n                int repeat_index = rnd.next(0, i - 1);\n                names[i] = names[repeat_index];\n            } else {\n                // Generate a new name\n                int len = rnd.next(1, 100);\n                string name;\n                do {\n                    name = randomString(len);\n                } while (used.count(name));\n                names[i] = name;\n                used[name] = 1;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random names\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 100);\n            names[i] = randomString(len);\n        }\n    } else {\n        // If no matching type, default to random\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 100);\n            names[i] = randomString(len);\n        }\n    }\n\n    // Output n and the names\n    printf(\"%d\\n\", n);\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type unique\n./gen -n 1 -type same\n./gen -n 1 -type random\n\n./gen -n 2 -type pairwise_repeat\n./gen -n 2 -type same\n./gen -n 2 -type unique\n./gen -n 2 -type random_with_duplicates\n\n./gen -n 5 -type random_with_duplicates\n\n./gen -n 10 -type same\n./gen -n 10 -type pairwise_repeat\n./gen -n 10 -type random_with_duplicates\n\n./gen -n 50 -type unique\n./gen -n 50 -type random_with_duplicates\n./gen -n 50 -type max_length\n./gen -n 50 -type min_length\n\n./gen -n 50 -type random\n./gen -n 50 -type random_with_duplicates\n\n./gen -n 73 -type random_with_duplicates\n./gen -n 73 -type max_length\n./gen -n 73 -type min_length\n./gen -n 73 -type random\n\n./gen -n 99 -type unique\n./gen -n 99 -type random_with_duplicates\n\n./gen -n 100 -type unique\n./gen -n 100 -type same\n./gen -n 100 -type random\n./gen -n 100 -type random_with_duplicates\n./gen -n 100 -type pairwise_repeat\n./gen -n 100 -type max_length\n./gen -n 100 -type min_length\n\n./gen -n 100 -type random_with_duplicates\n./gen -n 100 -type random_with_duplicates\n./gen -n 100 -type random_with_duplicates\n\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:19.584174",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/B",
      "title": "B. Кольцо Марвала Мракса",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся 4 целых числа n, p, q, r ( - 109 ≤ p, q, r ≤ 109, 1 ≤ n ≤ 105).Во второй строке заданы n целых чисел a1, a2, ... an ( - 109 ≤ ai ≤ 109), разделённых пробелами.",
      "output_spec": "Выходные данныеВыведите максимальное значение выражения p·ai + q·aj + r·ak с учётом 1 ≤ i ≤ j ≤ k ≤ n.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 1 2 31 2 3 4 5Выходные данныеСкопировать30Входные данныеСкопировать5 1 2 -3-1 -2 -3 -4 -5Выходные данныеСкопировать12",
      "description": "B. Кольцо Марвала Мракса\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся 4 целых числа n, p, q, r ( - 109 ≤ p, q, r ≤ 109, 1 ≤ n ≤ 105).Во второй строке заданы n целых чисел a1, a2, ... an ( - 109 ≤ ai ≤ 109), разделённых пробелами.\n\nВходные данные\n\nВыходные данныеВыведите максимальное значение выражения p·ai + q·aj + r·ak с учётом 1 ≤ i ≤ j ≤ k ≤ n.\n\nВыходные данные\n\nВходные данныеСкопировать5 1 2 31 2 3 4 5Выходные данныеСкопировать30Входные данныеСкопировать5 1 2 -3-1 -2 -3 -4 -5Выходные данныеСкопировать12\n\nВходные данныеСкопировать5 1 2 31 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать30\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 1 2 -3-1 -2 -3 -4 -5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере можно выбрать i = j = k = 5, получив ответ 1·5 + 2·5 + 3·5 = 30.Во втором примере можно выбрать i = j = 1, k = 5, получив ответ 12.",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*B"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(-1000000000, 1000000000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(-1000000000, 1000000000, \"q\");\n    inf.readSpace();\n    int r = inf.readInt(-1000000000, 1000000000, \"r\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(-1000000000, 1000000000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(-1000000000, 1000000000, \"q\");\n    inf.readSpace();\n    int r = inf.readInt(-1000000000, 1000000000, \"r\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(-1000000000, 1000000000, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(-1000000000, 1000000000, \"q\");\n    inf.readSpace();\n    int r = inf.readInt(-1000000000, 1000000000, \"r\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long p = opt<long long>(\"p\");\n    long long q = opt<long long>(\"q\");\n    long long r = opt<long long>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"small\") {\n        // Small numbers, range [-10, 10]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10LL, 10LL);\n        }\n    } else if (type == \"positive_ai\") {\n        // All positive numbers\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000LL);\n        }\n    } else if (type == \"negative_ai\") {\n        // All negative numbers\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, -1LL);\n        }\n    } else if (type == \"mixed_ai\") {\n        // Mixed positive and negative numbers\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, 1000000000LL);\n        }\n    } else if (type == \"zeros_ai\") {\n        // All zeros\n        for(int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"max_ai\") {\n        // All maximum value 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000LL;\n        }\n    } else if (type == \"min_ai\") {\n        // All minimum value -1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = -1000000000LL;\n        }\n    } else if (type == \"sorted_increasing\") {\n        // Sorted in increasing order\n        long long start = -1000000000LL;\n        long long step = (2000000000LL) / max(1, n - 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + step * i;\n        }\n    } else if (type == \"sorted_decreasing\") {\n        // Sorted in decreasing order\n        long long start = 1000000000LL;\n        long long step = (2000000000LL) / max(1, n - 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start - step * i;\n        }\n    } else if (type == \"random\") {\n        // Random numbers in full range\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, 1000000000LL);\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, 1000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d %lld %lld %lld\\n\", n, p, q, r);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long p = opt<long long>(\"p\");\n    long long q = opt<long long>(\"q\");\n    long long r = opt<long long>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> a(n);\n\n    if (type == \"small\") {\n        // Small numbers, range [-10, 10]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10LL, 10LL);\n        }\n    } else if (type == \"positive_ai\") {\n        // All positive numbers\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1LL, 1000000000LL);\n        }\n    } else if (type == \"negative_ai\") {\n        // All negative numbers\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, -1LL);\n        }\n    } else if (type == \"mixed_ai\") {\n        // Mixed positive and negative numbers\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, 1000000000LL);\n        }\n    } else if (type == \"zeros_ai\") {\n        // All zeros\n        for(int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"max_ai\") {\n        // All maximum value 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000LL;\n        }\n    } else if (type == \"min_ai\") {\n        // All minimum value -1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = -1000000000LL;\n        }\n    } else if (type == \"sorted_increasing\") {\n        // Sorted in increasing order\n        long long start = -1000000000LL;\n        long long step = (2000000000LL) / max(1, n - 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + step * i;\n        }\n    } else if (type == \"sorted_decreasing\") {\n        // Sorted in decreasing order\n        long long start = 1000000000LL;\n        long long step = (2000000000LL) / max(1, n - 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start - step * i;\n        }\n    } else if (type == \"random\") {\n        // Random numbers in full range\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, 1000000000LL);\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000LL, 1000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d %lld %lld %lld\\n\", n, p, q, r);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -p 1 -q 2 -r 3 -type small\n./gen -n 5 -p -1 -q -2 -r -3 -type small\n./gen -n 5 -p 0 -q 0 -r 0 -type small\n./gen -n 7 -p 1000000000 -q 1000000000 -r 1000000000 -type small\n./gen -n 3 -p -1000000000 -q -1000000000 -r -1000000000 -type small\n\n./gen -n 1 -p 1000000000 -q -1000000000 -r 1000000000 -type random\n\n./gen -n 100000 -p 1 -q -1 -r 1 -type random\n./gen -n 100000 -p 1000000000 -q -1000000000 -r 1000000000 -type mixed_ai\n./gen -n 100000 -p -1000000000 -q 1000000000 -r -1000000000 -type mixed_ai\n\n./gen -n 100000 -p 0 -q 0 -r 0 -type zeros_ai\n\n./gen -n 100000 -p 1000000000 -q 1000000000 -r 1000000000 -type max_ai\n\n./gen -n 100000 -p -1000000000 -q -1000000000 -r -1000000000 -type min_ai\n\n./gen -n 100000 -p 1 -q 1 -r 1 -type sorted_increasing\n\n./gen -n 100000 -p -1 -q -1 -r -1 -type sorted_decreasing\n\n./gen -n 100000 -p 0 -q 0 -r 0 -type random\n\n./gen -n 100000 -p 1 -q 1 -r 1 -type negative_ai\n\n./gen -n 100000 -p -1 -q -1 -r -1 -type positive_ai\n\n./gen -n 100000 -p 1000000000 -q -1000000000 -r 1000000000 -type mixed_ai\n\n./gen -n 100000 -p -1000000000 -q 0 -r 1000000000 -type mixed_ai\n\n./gen -n 100000 -p 0 -q -1000000000 -r 0 -type mixed_ai\n\n./gen -n 100000 -p 1 -q -1 -r 1 -type zeros_ai\n\n./gen -n 10 -p 1000000000 -q -1000000000 -r 1000000000 -type small\n\n./gen -n 10 -p -1000000000 -q 1000000000 -r -1000000000 -type small\n\n./gen -n 1 -p -1000000000 -q 1000000000 -r -1000000000 -type max_ai\n\n./gen -n 100000 -p 1 -q 1 -r 1 -type max_ai\n\n./gen -n 100000 -p -1 -q -1 -r -1 -type min_ai\n\n./gen -n 99999 -p 1000000000 -q 0 -r -1000000000 -type mixed_ai\n\n./gen -n 88888 -p -1000000000 -q 1000000000 -r 0 -type mixed_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:21.647711",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/C",
      "title": "C. Чаша Пенелоппы Пуффендуй",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся два целых числа n и m — количество хранилищ и количество различных типов хранилищ, соответственно (1 ≤ n ≤ 105, 1 ≤ m ≤ 109).В следующей n - 1 строке содержатся пары целых чисел ui и vi (1 ≤ ui, vi ≤ n), описывающее i-е ребро, которое соединяет хранилища ui и vi. Гарантируется, что заданный граф является деревом.В последней строке содержатся два целых числа k и x (1 ≤ k ≤ m, 1 ≤ x ≤ 10) — тип хранилищ с идеальной охраной и максимальное количество таких хранилищ.",
      "output_spec": "Выходные данныеВыведите единственное число — количество способов назначить хранилищам типы для выполнения всех условий по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 21 22 31 41 2Выходные данныеСкопировать1Входные данныеСкопировать3 31 21 32 1Выходные данныеСкопировать13Входные данныеСкопировать3 11 21 31 1Выходные данныеСкопировать0",
      "description": "C. Чаша Пенелоппы Пуффендуй\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержатся два целых числа n и m — количество хранилищ и количество различных типов хранилищ, соответственно (1 ≤ n ≤ 105, 1 ≤ m ≤ 109).В следующей n - 1 строке содержатся пары целых чисел ui и vi (1 ≤ ui, vi ≤ n), описывающее i-е ребро, которое соединяет хранилища ui и vi. Гарантируется, что заданный граф является деревом.В последней строке содержатся два целых числа k и x (1 ≤ k ≤ m, 1 ≤ x ≤ 10) — тип хранилищ с идеальной охраной и максимальное количество таких хранилищ.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество способов назначить хранилищам типы для выполнения всех условий по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать4 21 22 31 41 2Выходные данныеСкопировать1Входные данныеСкопировать3 31 21 32 1Выходные данныеСкопировать13Входные данныеСкопировать3 11 21 31 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать4 21 22 31 41 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 21 32 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 11 21 31 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ примере 1, не может быть хранилищ с идеальной охраной, так тип хранилища с идеальной охраной равен 1, что значит, что соседние хранилища должны иметь тип меньше чем 1, что невозможно. Поэтому единственно возможный вариант — когда все хранилища имеют тип 2.",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*C"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n\n    // Read edges and check constraints\n    vector<int> u(n - 1), v(n - 1);\n    set<pair<int, int>> edgeSet;\n    for (int i = 0; i < n - 1; ++i) {\n        u[i] = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        v[i] = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u[i] != v[i], \"Edge %d is a loop (u_i == v_i)\", i + 1);\n        int a = u[i], b = v[i];\n        if (a > b) swap(a, b);\n        ensuref(edgeSet.count({a, b}) == 0, \"Multiple edges between %d and %d\", a, b);\n        edgeSet.insert({a, b});\n    }\n\n    // Check that the graph is connected and acyclic (i.e., it's a tree)\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int fu = find(u[i]);\n        int fv = find(v[i]);\n        ensuref(fu != fv, \"Graph contains a cycle (edge %d connects %d and %d which are already connected)\",\n                i + 1, u[i], v[i]);\n        parent[fu] = fv;\n    }\n\n    // Read k and x\n    int k = inf.readInt(1, m, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(1, 10, \"x\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n\n    // Read edges and check constraints\n    vector<int> u(n - 1), v(n - 1);\n    set<pair<int, int>> edgeSet;\n    for (int i = 0; i < n - 1; ++i) {\n        u[i] = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        v[i] = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u[i] != v[i], \"Edge %d is a loop (u_i == v_i)\", i + 1);\n        int a = u[i], b = v[i];\n        if (a > b) swap(a, b);\n        ensuref(edgeSet.count({a, b}) == 0, \"Multiple edges between %d and %d\", a, b);\n        edgeSet.insert({a, b});\n    }\n\n    // Check that the graph is connected and acyclic (i.e., it's a tree)\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int fu = find(u[i]);\n        int fv = find(v[i]);\n        ensuref(fu != fv, \"Graph contains a cycle (edge %d connects %d and %d which are already connected)\",\n                i + 1, u[i], v[i]);\n        parent[fu] = fv;\n    }\n\n    // Read k and x\n    int k = inf.readInt(1, m, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(1, 10, \"x\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n\n    // Read edges and check constraints\n    vector<int> u(n - 1), v(n - 1);\n    set<pair<int, int>> edgeSet;\n    for (int i = 0; i < n - 1; ++i) {\n        u[i] = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        v[i] = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u[i] != v[i], \"Edge %d is a loop (u_i == v_i)\", i + 1);\n        int a = u[i], b = v[i];\n        if (a > b) swap(a, b);\n        ensuref(edgeSet.count({a, b}) == 0, \"Multiple edges between %d and %d\", a, b);\n        edgeSet.insert({a, b});\n    }\n\n    // Check that the graph is connected and acyclic (i.e., it's a tree)\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int fu = find(u[i]);\n        int fv = find(v[i]);\n        ensuref(fu != fv, \"Graph contains a cycle (edge %d connects %d and %d which are already connected)\",\n                i + 1, u[i], v[i]);\n        parent[fu] = fv;\n    }\n\n    // Read k and x\n    int k = inf.readInt(1, m, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(1, 10, \"x\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that the parameters are within the constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 1000000000);\n    ensure(1 <= k && k <= m);\n    ensure(1 <= x && x <= 10);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain (path) tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"special\") {\n        // Generate a special tree: balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    }\n\n    // Shuffle edges for randomness\n    shuffle(edges.begin(), edges.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output k and x\n    printf(\"%d %d\\n\", k, x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that the parameters are within the constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 1000000000);\n    ensure(1 <= k && k <= m);\n    ensure(1 <= x && x <= 10);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain (path) tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"special\") {\n        // Generate a special tree: balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    }\n\n    // Shuffle edges for randomness\n    shuffle(edges.begin(), edges.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output k and x\n    printf(\"%d %d\\n\", k, x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with minimum n\n./gen -n 1 -m 1 -k 1 -x 1 -type chain\n./gen -n 2 -m 1 -k 1 -x 1 -type chain\n\n# Test cases where k = 1\n./gen -n 5 -m 5 -k 1 -x 2 -type chain\n./gen -n 5 -m 5 -k 1 -x 2 -type star\n\n# Test cases where k = m\n./gen -n 5 -m 5 -k 5 -x 2 -type chain\n./gen -n 5 -m 5 -k 5 -x 2 -type random\n\n# Test cases with m=1\n./gen -n 5 -m 1 -k 1 -x 1 -type chain\n\n# Test cases with x=1\n./gen -n 10 -m 10 -k 5 -x 1 -type random\n\n# Test cases with x=10\n./gen -n 10 -m 10 -k 5 -x 10 -type random\n\n# Maximal test cases\n./gen -n 100000 -m 1000000000 -k 500000000 -x 10 -type random\n\n# Large n, small m\n./gen -n 100000 -m 1 -k 1 -x 1 -type random\n\n# Large n, k=1\n./gen -n 100000 -m 1000000000 -k 1 -x 10 -type random\n\n# Large n, k=m\n./gen -n 100000 -m 1000000000 -k 1000000000 -x 10 -type random\n\n# Mid-size n, special tree shapes\n./gen -n 1000 -m 1000 -k 500 -x 5 -type chain\n./gen -n 1000 -m 1000 -k 500 -x 5 -type star\n./gen -n 1000 -m 1000 -k 500 -x 5 -type special\n\n# Small x\n./gen -n 1000 -m 1000 -k 500 -x 1 -type random\n\n# x = 10\n./gen -n 100000 -m 1000000000 -k 500000000 -x 10 -type chain\n\n# m = k\n./gen -n 100000 -m 1 -k 1 -x 10 -type star\n\n# Random trees with various parameters\n./gen -n 50000 -m 100000 -k 50000 -x 5 -type random\n./gen -n 50000 -m 10 -k 5 -x 10 -type random\n\n# Highly unbalanced tree\n./gen -n 100000 -m 1000000000 -k 1000000000 -x 10 -type special\n\n# Path tree\n./gen -n 100000 -m 1000000000 -k 1000000000 -x 10 -type chain\n\n# Star tree\n./gen -n 100000 -m 1000000000 -k 500000000 -x 10 -type star\n\n# Small n, large m\n./gen -n 100 -m 1000000000 -k 500000000 -x 5 -type random\n\n# n=1 edge case\n./gen -n 1 -m 1 -k 1 -x 1 -type random\n\n# All parameters mid-range\n./gen -n 5000 -m 5000 -k 2500 -x 7 -type special\n\n# Testing lower bounds of m and k\n./gen -n 1000 -m 1 -k 1 -x 1 -type random\n\n# Tree with large x\n./gen -n 100000 -m 1000000000 -k 500000000 -x 10 -type special\n\n# Tree with k=1 and m=1\n./gen -n 1000 -m 1 -k 1 -x 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:24.215445",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/D",
      "title": "D. Rowena Ravenclaw's Diadem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains the number n (1 ≤ n ≤ 105), the number of objects. Next n lines contain two integer parenti and typei ( - 1 ≤ parenti < i parenti ≠ 0,  - 1 ≤ typei ≤ 1), implying that the i-th object has the parent parenti. (If typei = 0, this implies that the object i is a special case of object parenti. If typei = 1, this implies that the object i is a part of object parenti). In case the i-th object has no parent, both parenti and typei are -1.Next line contains an integer q (1 ≤ q ≤ 105), the number of queries. Next q lines each represent a query having three space separated integers typei, ui, vi (1 ≤ typei ≤ 2, 1 ≤ u, v ≤ n).",
      "output_spec": "OutputOutput will contain q lines, each containing the answer for the corresponding query as \"YES\" (affirmative) or \"NO\" (without quotes).You can output each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy3-1 -11 02 021 1 32 1 3OutputCopyYESNOInputCopy3-1 -11 01 122 2 32 3 2OutputCopyYESNO",
      "description": "D. Rowena Ravenclaw's Diadem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains the number n (1 ≤ n ≤ 105), the number of objects. Next n lines contain two integer parenti and typei ( - 1 ≤ parenti < i parenti ≠ 0,  - 1 ≤ typei ≤ 1), implying that the i-th object has the parent parenti. (If typei = 0, this implies that the object i is a special case of object parenti. If typei = 1, this implies that the object i is a part of object parenti). In case the i-th object has no parent, both parenti and typei are -1.Next line contains an integer q (1 ≤ q ≤ 105), the number of queries. Next q lines each represent a query having three space separated integers typei, ui, vi (1 ≤ typei ≤ 2, 1 ≤ u, v ≤ n).\n\nOutputOutput will contain q lines, each containing the answer for the corresponding query as \"YES\" (affirmative) or \"NO\" (without quotes).You can output each letter in any case (upper or lower).\n\nInputCopy3-1 -11 02 021 1 32 1 3OutputCopyYESNOInputCopy3-1 -11 01 122 2 32 3 2OutputCopyYESNO\n\nInputCopy3-1 -11 02 021 1 32 1 3\n\nOutputCopyYESNO\n\nInputCopy3-1 -11 01 122 2 32 3 2\n\nOutputCopyYESNO\n\nNoteIn test case 1, as object 2 is a special case of object 1 and object 3 is a special case of object 2, this makes object 3 a special case of object 1.In test case 2, as object 2 is a special case of object 1 and object 1 has object 3, this will mean that object 2 will also have object 3. This is because when a general case (object 1) has object 3, its special case (object 2) will definitely have object 3.",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*D"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int parent = inf.readInt(-1, i - 1, \"parent\");\n        ensuref(parent != 0, \"parent cannot be zero (on line %d)\", i + 1);\n        inf.readSpace();\n        int type = inf.readInt(-1, 1, \"type\");\n        if (parent == -1) {\n            ensuref(type == -1, \"When parent == -1, type must be -1 (on line %d)\", i + 1);\n        }\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int query_type = inf.readInt(1, 2, \"query_type\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int parent = inf.readInt(-1, i - 1, \"parent\");\n        ensuref(parent != 0, \"parent cannot be zero (on line %d)\", i + 1);\n        inf.readSpace();\n        int type = inf.readInt(-1, 1, \"type\");\n        if (parent == -1) {\n            ensuref(type == -1, \"When parent == -1, type must be -1 (on line %d)\", i + 1);\n        }\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int query_type = inf.readInt(1, 2, \"query_type\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int parent = inf.readInt(-1, i - 1, \"parent\");\n        ensuref(parent != 0, \"parent cannot be zero (on line %d)\", i + 1);\n        inf.readSpace();\n        int type = inf.readInt(-1, 1, \"type\");\n        if (parent == -1) {\n            ensuref(type == -1, \"When parent == -1, type must be -1 (on line %d)\", i + 1);\n        }\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int query_type = inf.readInt(1, 2, \"query_type\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> parent(n + 1);\n    vector<int> typ(n + 1);\n\n    parent[1] = -1;\n    typ[1] = -1;\n\n    if (type == \"chain_special\") {\n        /* A chain where each object is a special case of its parent */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = 0;\n        }\n    } else if (type == \"chain_part\") {\n        /* A chain where each object is a part of its parent */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = 1;\n        }\n    } else if (type == \"star_special\") {\n        /* A star where all objects are special cases of the first object */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            typ[i] = 0;\n        }\n    } else if (type == \"star_part\") {\n        /* A star where all objects are parts of the first object */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            typ[i] = 1;\n        }\n    } else if (type == \"mixed\") {\n        /* A chain where the type alternates between special case and part */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = rnd.next(0,1);\n        }\n    } else if (type == \"deep_mixed\") {\n        /* A chain where types alternate in a fixed pattern */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = (i % 2 == 0) ? 0 : 1;\n        }\n    } else {\n        /* Random parent and random type */\n        for (int i = 2; i <= n; ++i) {\n            do {\n                parent[i] = rnd.next(-1, i - 1);\n            } while (parent[i] == 0);\n            if (parent[i] == -1) {\n                typ[i] = -1;\n            } else {\n                typ[i] = rnd.next(0, 1);\n            }\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output parent and type */\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d %d\\n\", parent[i], typ[i]);\n    }\n\n    /* Generate queries */\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int t = rnd.next(1, 2); // Query type\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        printf(\"%d %d %d\\n\", t, u, v);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> parent(n + 1);\n    vector<int> typ(n + 1);\n\n    parent[1] = -1;\n    typ[1] = -1;\n\n    if (type == \"chain_special\") {\n        /* A chain where each object is a special case of its parent */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = 0;\n        }\n    } else if (type == \"chain_part\") {\n        /* A chain where each object is a part of its parent */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = 1;\n        }\n    } else if (type == \"star_special\") {\n        /* A star where all objects are special cases of the first object */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            typ[i] = 0;\n        }\n    } else if (type == \"star_part\") {\n        /* A star where all objects are parts of the first object */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            typ[i] = 1;\n        }\n    } else if (type == \"mixed\") {\n        /* A chain where the type alternates between special case and part */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = rnd.next(0,1);\n        }\n    } else if (type == \"deep_mixed\") {\n        /* A chain where types alternate in a fixed pattern */\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            typ[i] = (i % 2 == 0) ? 0 : 1;\n        }\n    } else {\n        /* Random parent and random type */\n        for (int i = 2; i <= n; ++i) {\n            do {\n                parent[i] = rnd.next(-1, i - 1);\n            } while (parent[i] == 0);\n            if (parent[i] == -1) {\n                typ[i] = -1;\n            } else {\n                typ[i] = rnd.next(0, 1);\n            }\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output parent and type */\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d %d\\n\", parent[i], typ[i]);\n    }\n\n    /* Generate queries */\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int t = rnd.next(1, 2); // Query type\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        printf(\"%d %d %d\\n\", t, u, v);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type chain_special\n./gen -n 1 -q 1 -type random\n\n./gen -n 10 -q 5 -type chain_special\n./gen -n 10 -q 5 -type chain_part\n./gen -n 10 -q 5 -type star_special\n./gen -n 10 -q 5 -type star_part\n./gen -n 10 -q 5 -type random\n./gen -n 10 -q 5 -type mixed\n./gen -n 10 -q 5 -type deep_mixed\n\n./gen -n 100 -q 50 -type chain_special\n./gen -n 100 -q 50 -type chain_part\n./gen -n 100 -q 50 -type star_special\n./gen -n 100 -q 50 -type star_part\n./gen -n 100 -q 50 -type random\n./gen -n 100 -q 50 -type mixed\n./gen -n 100 -q 50 -type deep_mixed\n\n./gen -n 1000 -q 500 -type chain_special\n./gen -n 1000 -q 500 -type chain_part\n./gen -n 1000 -q 500 -type star_special\n./gen -n 1000 -q 500 -type star_part\n./gen -n 1000 -q 500 -type random\n./gen -n 1000 -q 500 -type mixed\n./gen -n 1000 -q 500 -type deep_mixed\n\n./gen -n 10000 -q 10000 -type random\n./gen -n 10000 -q 10000 -type mixed\n./gen -n 10000 -q 10000 -type deep_mixed\n./gen -n 100000 -q 100000 -type chain_special\n./gen -n 100000 -q 100000 -type chain_part\n./gen -n 100000 -q 100000 -type star_special\n./gen -n 100000 -q 100000 -type star_part\n./gen -n 100000 -q 100000 -type random\n./gen -n 100000 -q 100000 -type mixed\n./gen -n 100000 -q 100000 -type deep_mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:26.071470",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/E",
      "title": "E. Salazar Slytherin's Locket",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains q (1 ≤ q ≤ 105) — number of queries.Each of the next q lines contain three space separated integers bi, li, ri (2 ≤ bi ≤ 10, 1 ≤ li ≤ ri ≤ 1018).",
      "output_spec": "OutputYou have to output q lines, each containing a single integer, the answer to the corresponding query.",
      "sample_tests": "ExamplesInputCopy22 4 93 1 10OutputCopy12InputCopy22 1 1005 1 100OutputCopy214",
      "description": "E. Salazar Slytherin's Locket\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains q (1 ≤ q ≤ 105) — number of queries.Each of the next q lines contain three space separated integers bi, li, ri (2 ≤ bi ≤ 10, 1 ≤ li ≤ ri ≤ 1018).\n\nOutputYou have to output q lines, each containing a single integer, the answer to the corresponding query.\n\nInputCopy22 4 93 1 10OutputCopy12InputCopy22 1 1005 1 100OutputCopy214\n\nInputCopy22 4 93 1 10\n\nOutputCopy12\n\nInputCopy22 1 1005 1 100\n\nOutputCopy214\n\nNoteIn sample test case 1, for first query, when we convert numbers 4 to 9 into base 2, we get:   4 = 1002,  5 = 1012,  6 = 1102,  7 = 1112,  8 = 10002,  9 = 10012. Out of these, only base 2 representation of 9 has even number of 1 and 0. Thus, the answer is 1.",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*E"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read q: number of queries\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        // Read bi\n        int b = inf.readInt(2, 10, \"bi\");\n        inf.readSpace();\n\n        // Read li\n        long long li = inf.readLong(1LL, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n\n        // Read ri\n        long long ri = inf.readLong(li, 1000000000000000000LL, \"ri\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read q: number of queries\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        // Read bi\n        int b = inf.readInt(2, 10, \"bi\");\n        inf.readSpace();\n\n        // Read li\n        long long li = inf.readLong(1LL, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n\n        // Read ri\n        long long ri = inf.readLong(li, 1000000000000000000LL, \"ri\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read q: number of queries\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        // Read bi\n        int b = inf.readInt(2, 10, \"bi\");\n        inf.readSpace();\n\n        // Read li\n        long long li = inf.readLong(1LL, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n\n        // Read ri\n        long long ri = inf.readLong(li, 1000000000000000000LL, \"ri\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_LR = 1e18;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    if (type == \"max_queries\") {\n        // Generate q queries with maximum ranges\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10); // Random base between 2 and 10\n            long long li = 1;\n            long long ri = MAX_LR;\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"max_ranges\") {\n        // Generate queries with maximum li and ri\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = 1;\n            long long ri = MAX_LR;\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"li_eq_ri\") {\n        // Generate queries where li == ri\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long x = rnd.next(1LL, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, x, x);\n        }\n    } else if (type == \"small_ranges\") {\n        // Generate queries with small ranges (li and ri close)\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, MAX_LR - 1000);\n            long long ri = li + rnd.next(0LL, 1000LL);\n            ri = min(ri, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"large_ranges\") {\n        // Generate queries with large ranges\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, MAX_LR / 2);\n            long long ri = li + rnd.next(MAX_LR / 2, MAX_LR - li);\n            ri = min(ri, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"min_base\") {\n        // Generate queries with bi = 2\n        for (int i = 0; i < q; ++i) {\n            int bi = 2;\n            long long li = rnd.next(1LL, MAX_LR);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"max_base\") {\n        // Generate queries with bi = 10\n        for (int i = 0; i < q; ++i) {\n            int bi = 10;\n            long long li = rnd.next(1LL, MAX_LR);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate specific edge cases\n        for (int i = 0; i < q; ++i) {\n            int bi;\n            long long li, ri;\n            if (i % 2 == 0) {\n                bi = 2;\n                li = 1;\n                ri = 1;\n            } else {\n                bi = 10;\n                li = MAX_LR;\n                ri = MAX_LR;\n            }\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"random\") {\n        // Default: random queries\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, MAX_LR);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"small_li\") {\n        // Generate queries with small li\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, 1000LL);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"full_range\") {\n        // Generate queries with li = 1, ri = MAX_LR\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            printf(\"%d %lld %lld\\n\", bi, 1LL, MAX_LR);\n        }\n    } else if (type == \"bi_li_ri_fixed\") {\n        // Generate queries with fixed bi, li, ri\n        int bi = opt<int>(\"bi\", 2);\n        long long li = opt<long long>(\"li\", 1LL);\n        long long ri = opt<long long>(\"ri\", MAX_LR);\n        for (int i = 0; i < q; ++i) {\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_LR = 1e18;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    if (type == \"max_queries\") {\n        // Generate q queries with maximum ranges\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10); // Random base between 2 and 10\n            long long li = 1;\n            long long ri = MAX_LR;\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"max_ranges\") {\n        // Generate queries with maximum li and ri\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = 1;\n            long long ri = MAX_LR;\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"li_eq_ri\") {\n        // Generate queries where li == ri\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long x = rnd.next(1LL, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, x, x);\n        }\n    } else if (type == \"small_ranges\") {\n        // Generate queries with small ranges (li and ri close)\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, MAX_LR - 1000);\n            long long ri = li + rnd.next(0LL, 1000LL);\n            ri = min(ri, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"large_ranges\") {\n        // Generate queries with large ranges\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, MAX_LR / 2);\n            long long ri = li + rnd.next(MAX_LR / 2, MAX_LR - li);\n            ri = min(ri, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"min_base\") {\n        // Generate queries with bi = 2\n        for (int i = 0; i < q; ++i) {\n            int bi = 2;\n            long long li = rnd.next(1LL, MAX_LR);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"max_base\") {\n        // Generate queries with bi = 10\n        for (int i = 0; i < q; ++i) {\n            int bi = 10;\n            long long li = rnd.next(1LL, MAX_LR);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate specific edge cases\n        for (int i = 0; i < q; ++i) {\n            int bi;\n            long long li, ri;\n            if (i % 2 == 0) {\n                bi = 2;\n                li = 1;\n                ri = 1;\n            } else {\n                bi = 10;\n                li = MAX_LR;\n                ri = MAX_LR;\n            }\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"random\") {\n        // Default: random queries\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, MAX_LR);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"small_li\") {\n        // Generate queries with small li\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            long long li = rnd.next(1LL, 1000LL);\n            long long ri = rnd.next(li, MAX_LR);\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    } else if (type == \"full_range\") {\n        // Generate queries with li = 1, ri = MAX_LR\n        for (int i = 0; i < q; ++i) {\n            int bi = rnd.next(2, 10);\n            printf(\"%d %lld %lld\\n\", bi, 1LL, MAX_LR);\n        }\n    } else if (type == \"bi_li_ri_fixed\") {\n        // Generate queries with fixed bi, li, ri\n        int bi = opt<int>(\"bi\", 2);\n        long long li = opt<long long>(\"li\", 1LL);\n        long long ri = opt<long long>(\"ri\", MAX_LR);\n        for (int i = 0; i < q; ++i) {\n            printf(\"%d %lld %lld\\n\", bi, li, ri);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying q\n./gen -q 100000 -type random\n./gen -q 50000  -type random\n./gen -q 1000   -type random\n\n# Test cases with maximum queries and maximum ranges\n./gen -q 100000 -type max_queries\n\n# Test cases where li == ri\n./gen -q 100000 -type li_eq_ri\n./gen -q 100    -type li_eq_ri\n\n# Test cases with small ranges (li and ri close to each other)\n./gen -q 100000 -type small_ranges\n./gen -q 100    -type small_ranges\n\n# Test cases with large ranges\n./gen -q 100000 -type large_ranges\n./gen -q 100    -type large_ranges\n\n# Test cases with minimum base (bi = 2)\n./gen -q 100000 -type min_base\n./gen -q 100    -type min_base\n\n# Test cases with maximum base (bi = 10)\n./gen -q 100000 -type max_base\n./gen -q 100    -type max_base\n\n# Edge cases with bi = 2 and li = ri = 1, bi = 10 and li = ri = MAX_LR\n./gen -q 1000 -type edge_cases\n\n# Test cases with small li\n./gen -q 100000 -type small_li\n./gen -q 100    -type small_li\n\n# Test cases with full range (li = 1, ri = MAX_LR)\n./gen -q 100000 -type full_range\n./gen -q 100    -type full_range\n\n# Test cases with fixed bi, li, ri\n./gen -q 100000 -type bi_li_ri_fixed -bi 2 -li 1 -ri 1\n./gen -q 100    -type bi_li_ri_fixed -bi 10 -li 1 -ri 1\n./gen -q 100000 -type bi_li_ri_fixed -bi 2 -li 1 -ri 1000\n./gen -q 100000 -type bi_li_ri_fixed -bi 10 -li 1 -ri 1000\n\n# Diverse test cases\n./gen -q 100000 -type random\n./gen -q 1000   -type random\n\n# Examples matching sample inputs\n./gen -q 2 -type bi_li_ri_fixed -bi 2 -li 4 -ri 9\n./gen -q 2 -type bi_li_ri_fixed -bi 3 -li 1 -ri 10\n\n# Edge cases with maximum values\n./gen -q 1 -type bi_li_ri_fixed -bi 10 -li 1000000000000000000 -ri 1000000000000000000\n./gen -q 1 -type bi_li_ri_fixed -bi 2 -li 999999999999999999 -ri 1000000000000000000\n\n# Edge cases with minimum values\n./gen -q 1 -type bi_li_ri_fixed -bi 2 -li 1 -ri 1\n\n# Mixed types\n./gen -q 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:28.169312",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/F",
      "title": "F. Нагайна",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число q (1 ≤ q ≤ 5·104), показывающее число запросов. Следующие q строк описывают запросы. Описание каждого запроса начинается с типа запроса typei (1 ≤ typei ≤ 2). Затем идёт дальшнейшее описание запросов. Для запросов типа 1 задаются три целых числа li, ri и ki (,  - 109 ≤ ki ≤ 109, k ≠ 0). Иначе задана пара целых чисел li и ri (1 ≤ li < ri ≤ 105).",
      "output_spec": "Выходные данныеДля каждого запроса типа 2 выведите ответ.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 1 10 101 2 4 -72 1 10Выходные данныеСкопировать34Входные данныеСкопировать71 2 3 51 1 10 101 4 5 -52 4 81 1 10 -102 4 82 1 10Выходные данныеСкопировать1575170",
      "description": "ограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержится целое число q (1 ≤ q ≤ 5·104), показывающее число запросов. Следующие q строк описывают запросы. Описание каждого запроса начинается с типа запроса typei (1 ≤ typei ≤ 2). Затем идёт дальшнейшее описание запросов. Для запросов типа 1 задаются три целых числа li, ri и ki (,  - 109 ≤ ki ≤ 109, k ≠ 0). Иначе задана пара целых чисел li и ri (1 ≤ li < ri ≤ 105).\n\nВходные данные\n\nВыходные данныеДля каждого запроса типа 2 выведите ответ.\n\nВыходные данные\n\nВходные данныеСкопировать31 1 10 101 2 4 -72 1 10Выходные данныеСкопировать34Входные данныеСкопировать71 2 3 51 1 10 101 4 5 -52 4 81 1 10 -102 4 82 1 10Выходные данныеСкопировать1575170\n\nВходные данныеСкопировать31 1 10 101 2 4 -72 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать34\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать71 2 3 51 1 10 101 4 5 -52 4 81 1 10 -102 4 82 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1575170\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере опасность координаты x, равной 1, равна 0, так как не существует y2, удовлетворяющего условию для x = 1.Опасность x-координат 2 и 3 равна 10 + | - 7| = 17.Опасность x-координат от 4 до 9 снова 0, так как не существует y2, удовлетворяющего условию.Таким образом, суммарная опасность равна 17 + 17 = 34.",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*F"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            // Type 1 query: 1 l r k\n            inf.readSpace();\n            int l = inf.readInt(1, 99999, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l + 1, 100000, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(-1000000000, 1000000000, \"k\");\n            ensuref(k != 0, \"k cannot be zero\");\n            inf.readEoln();\n        } else {\n            // Type 2 query: 2 l r\n            inf.readSpace();\n            int l = inf.readInt(1, 99999, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l + 1, 100000, \"r\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            // Type 1 query: 1 l r k\n            inf.readSpace();\n            int l = inf.readInt(1, 99999, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l + 1, 100000, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(-1000000000, 1000000000, \"k\");\n            ensuref(k != 0, \"k cannot be zero\");\n            inf.readEoln();\n        } else {\n            // Type 2 query: 2 l r\n            inf.readSpace();\n            int l = inf.readInt(1, 99999, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l + 1, 100000, \"r\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            // Type 1 query: 1 l r k\n            inf.readSpace();\n            int l = inf.readInt(1, 99999, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l + 1, 100000, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(-1000000000, 1000000000, \"k\");\n            ensuref(k != 0, \"k cannot be zero\");\n            inf.readEoln();\n        } else {\n            // Type 2 query: 2 l r\n            inf.readSpace();\n            int l = inf.readInt(1, 99999, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l + 1, 100000, \"r\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    int maxx = opt<int>(\"maxx\", 100000);\n    int maxk = opt<int>(\"maxk\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", q);\n\n    if (type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1; // Ensure k != 0\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"max_queries\") {\n        q = 50000;\n        printf(\"%d\\n\", q);\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"maxk_pos\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = maxk;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx -1);\n                int r = rnd.next(l +1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"maxk_neg\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = -maxk;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx -1);\n                int r = rnd.next(l +1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"overlapping_snakes\") {\n        int num_snakes = q / 2;\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int l = rnd.next(1, maxx - 1);\n            int r = rnd.next(l + 1, maxx);\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"edge_snakes\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, 10);\n                int r = rnd.next(maxx - 10, maxx);\n                if (l >= r) r = l + 1;\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, 10);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"full_coverage\") {\n        int num_snakes = q / 2;\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int l = 1;\n            int r = maxx;\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"sparse_snakes\") {\n        int num_snakes = q / 10; // 10% snakes\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"only_type1\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l +1, maxx);\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n    } else if (type == \"only_type2\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l +1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"single_position_snakes\") {\n        int num_snakes = q / 2;\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int pos = rnd.next(1, maxx -1);\n            int l = pos;\n            int r = pos + 1;\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k =1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"stress\") {\n        for (int i = 0; i < q; ++i) {\n            if (i % 2 == 0) {\n                // Type 1 query\n                int l = 1;\n                int r = maxx;\n                int k = (i % 4 == 0) ? maxk : -maxk;\n                printf(\"1 %d %d %d\\n\", l, r, k);\n            } else {\n                // Type 2 query\n                int l = 1;\n                int r = maxx;\n                printf(\"2 %d %d\\n\", l, r);\n            }\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1; // Ensure k != 0\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    int maxx = opt<int>(\"maxx\", 100000);\n    int maxk = opt<int>(\"maxk\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", q);\n\n    if (type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1; // Ensure k != 0\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"max_queries\") {\n        q = 50000;\n        printf(\"%d\\n\", q);\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"maxk_pos\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = maxk;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx -1);\n                int r = rnd.next(l +1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"maxk_neg\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = -maxk;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx -1);\n                int r = rnd.next(l +1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"overlapping_snakes\") {\n        int num_snakes = q / 2;\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int l = rnd.next(1, maxx - 1);\n            int r = rnd.next(l + 1, maxx);\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"edge_snakes\") {\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, 10);\n                int r = rnd.next(maxx - 10, maxx);\n                if (l >= r) r = l + 1;\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1;\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, 10);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    } else if (type == \"full_coverage\") {\n        int num_snakes = q / 2;\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int l = 1;\n            int r = maxx;\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"sparse_snakes\") {\n        int num_snakes = q / 10; // 10% snakes\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"only_type1\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l +1, maxx);\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k = 1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n    } else if (type == \"only_type2\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l +1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"single_position_snakes\") {\n        int num_snakes = q / 2;\n        int num_queries = q - num_snakes;\n        for (int i = 0; i < num_snakes; ++i) {\n            int pos = rnd.next(1, maxx -1);\n            int l = pos;\n            int r = pos + 1;\n            int k = rnd.next(-maxk, maxk);\n            if (k == 0) k =1;\n            printf(\"1 %d %d %d\\n\", l, r, k);\n        }\n        for (int i = 0; i < num_queries; ++i) {\n            int l = rnd.next(1, maxx -1);\n            int r = rnd.next(l+1, maxx);\n            printf(\"2 %d %d\\n\", l, r);\n        }\n    } else if (type == \"stress\") {\n        for (int i = 0; i < q; ++i) {\n            if (i % 2 == 0) {\n                // Type 1 query\n                int l = 1;\n                int r = maxx;\n                int k = (i % 4 == 0) ? maxk : -maxk;\n                printf(\"1 %d %d %d\\n\", l, r, k);\n            } else {\n                // Type 2 query\n                int l = 1;\n                int r = maxx;\n                printf(\"2 %d %d\\n\", l, r);\n            }\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < q; ++i) {\n            int query_type = rnd.next(1,2);\n            if (query_type == 1) {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                int k = rnd.next(-maxk, maxk);\n                if (k == 0) k = 1; // Ensure k != 0\n                printf(\"%d %d %d %d\\n\", query_type, l, r, k);\n            } else {\n                int l = rnd.next(1, maxx - 1);\n                int r = rnd.next(l + 1, maxx);\n                printf(\"%d %d %d\\n\", query_type, l, r);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -q 3 -type random\n./gen -q 10 -type random\n./gen -q 100 -type random\n./gen -q 50000 -maxx 100000 -type max_queries\n\n./gen -q 15 -type maxk_pos\n./gen -q 20 -maxk 1000000000 -type maxk_pos\n\n./gen -q 15 -type maxk_neg\n./gen -q 20 -maxk 1000000000 -type maxk_neg\n\n./gen -q 30 -type overlapping_snakes\n\n./gen -q 50 -type edge_snakes\n\n./gen -q 100 -type full_coverage\n\n./gen -q 1000 -type sparse_snakes\n\n./gen -q 2000 -type only_type1\n\n./gen -q 2000 -type only_type2\n\n./gen -q 5000 -type single_position_snakes\n\n./gen -q 50000 -type stress\n\n./gen -q 50000 -type random\n\n./gen -q 1000 -maxk 10 -type random\n./gen -q 1000 -maxk 100 -type random\n./gen -q 1000 -maxk 1000 -type random\n\n./gen -q 1000 -maxx 10 -type random\n./gen -q 1000 -maxx 100 -type random\n./gen -q 1000 -maxx 1000 -type random\n\n./gen -q 5000 -maxx 2 -type only_type1\n\n./gen -q 5000 -maxk 1 -type only_type1\n\n./gen -q 5000 -type single_position_snakes\n\n./gen -q 10000 -type edge_snakes\n\n./gen -q 10000 -type random\n./gen -q 10000 -type full_coverage\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:30.140380",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "855/G",
      "title": "G. Harry Vs Voldemort",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains an integer n (1 ≤ n ≤ 105), the number of places in Hogwarts.Each of the next n - 1 lines contains two space separated integers u and v (1 ≤ u, v ≤ n) indicating a road between places u and v. It is guaranteed that the given roads form a connected tree.Next line contains a single integer q (1 ≤ q ≤ 105), the number of new edges being added.Each of the next q lines contains two space separated integers u and v (1 ≤ u, v ≤ n) representing the new road being added.Note that it is possible that a newly added road connects places that were connected by a road before. Also, a newly added road may connect a place to itself.",
      "output_spec": "OutputIn the first line print the value for the number of triplets before any changes occurred.After that print q lines, a single integer ansi in each line containing the value for the number of triplets after i-th edge addition.",
      "sample_tests": "ExamplesInputCopy31 22 312 3OutputCopy24InputCopy41 22 32 421 43 4OutputCopy61824InputCopy51 22 33 44 511 5OutputCopy2060",
      "description": "G. Harry Vs Voldemort\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line contains an integer n (1 ≤ n ≤ 105), the number of places in Hogwarts.Each of the next n - 1 lines contains two space separated integers u and v (1 ≤ u, v ≤ n) indicating a road between places u and v. It is guaranteed that the given roads form a connected tree.Next line contains a single integer q (1 ≤ q ≤ 105), the number of new edges being added.Each of the next q lines contains two space separated integers u and v (1 ≤ u, v ≤ n) representing the new road being added.Note that it is possible that a newly added road connects places that were connected by a road before. Also, a newly added road may connect a place to itself.\n\nOutputIn the first line print the value for the number of triplets before any changes occurred.After that print q lines, a single integer ansi in each line containing the value for the number of triplets after i-th edge addition.\n\nInputCopy31 22 312 3OutputCopy24InputCopy41 22 32 421 43 4OutputCopy61824InputCopy51 22 33 44 511 5OutputCopy2060\n\nInputCopy31 22 312 3\n\nOutputCopy24\n\nInputCopy41 22 32 421 43 4\n\nOutputCopy61824\n\nInputCopy51 22 33 44 511 5\n\nOutputCopy2060\n\nNoteIn the first sample case, for the initial tree, we have (1, 3, 2) and (3, 1, 2) as the only possible triplets (u, v, w).After addition of edge from 2 to 3, we have (1, 3, 2), (3, 1, 2), (1, 2, 3) and (2, 1, 3) as the possible triplets.",
      "solutions": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces",
          "content": "855A - Tom Riddle's DiaryFor each string si iterate j from 1 to i - 1. Check if si = sj for any value of j. If it is output \"YES\", otherwise output \"NO\". Output will always be \"NO\" for the first string.The expected complexity was Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j;\n string s[102];\n sd(n);\n for(i=0;i<n;i++)\n {\n \tcin>>s[i];\n \tfor(j=0;j<i;j++)\n \t{\n \t\tif(s[i]==s[j])\n \t\t\tbreak;\n \t}\n \tif(j==i)\n \t\tprintf(\"NO\\n\");\n \telse\n \t\tprintf(\"YES\\n\");\n }\n return 0;\n} 855B - Marvolo Gaunt's RingThere can be two approaches:First solution :Create a dynamic programming table of size n·3. In this, dp[i][0] stores maximum of value p·ax for x between 1 and i. Similarly dp[i][1] stores the maximum value of p·ax + q·ay such that x ≤ y ≤ i and dp[i][2] stores maximum value of p·ax + q·ay + r·az for x ≤ y ≤ z ≤ i.To calculate the dp:dp[i][0] = max(dp[i - 1][0], p·ai)dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·ai)dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·ai)The answer will be stored in dp[n][2]Second Solution :Maintain 4 arrays, storing maximum and minimum from left, maximum and minimum from right. Let us call them minLeft, minRight, maxLeft and maxRight.Then iterate j through the array. Calculate sum = q·aj. Now, if p < 0, add minLefti·p to sum. Otherwise add maxLefti·p to sum. Similarly, if r > 0, add maxRighti·r, otherwise add minRighti·r to sum. Expected time complexity: O(n) DP solution 1#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,p,q,r,i;\n sd(n);\n sd(p);\n sd(q);\n sd(r);\n for(i=0;i<n;i++)\n \tsd(a[i]);\n dp[0][0]=1ll*p*a[0];\n for(i=1;i<n;i++)\n \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n dp[0][1]=dp[0][0]+1ll*q*a[0];\n for(i=1;i<n;i++)\n \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n dp[0][2]=dp[0][1]+1ll*r*a[0];\n for(i=1;i<n;i++)\n \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n printf(\"%lld\\n\",dp[n-1][2]);\n return 0;\n} DP solution 2 with minimum and maximum computation#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} 855C - Helga Hufflepuff's CupThis problem can be solved by using the concept of dp on trees.The dp table for this problem will be of the size n·3·x.We can assume any one node as the root and apply dfs while computing the dp array. Let the root be 1.Here, dp[curr][0][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is less than k.dp[curr][1][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is equal to k.dp[curr][2][cnt] represent the number of ways of assigning type to each node in the subtree of curr such that number of nodes with value k in this subtree is cnt and type at curr is greater than k.Now, to compute this dp for a node, curr, we assume this dp array is computed for its children. Then, we can combine them two nodes at a time to form the dp array for the node curr. While assigning the value to dp[curr][1][cnt], we take into account only the values of dp[childofcurr][0][cnt - z]. Similarly for dp[curr][2][cnt], we take into account only dp[child of curr][0][cnt - z] and dp[child of curr][2][cnt - z]. For combining the value we make x * x computations. Final answer will be The expected time complexity of the solution is: O(n·3·x·x) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n int n,i,j,ans;\n sd(n);\n sd(m);\n for(i=1;i<n;i++)\n {\n \tsd(j);\n \tsd(k);\n \tq[j].pb(k);\n \tq[k].pb(j);\n }\n sd(k);\n sd(x);\n dfs(1,0);\n ans=0;\n for(i=0;i<3;i++)\n {\n \tfor(j=0;j<=x;j++)\n \t{\n \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n \t\tans+=dp[1][i][j];\n \t\tif(ans>=mod)\n \t\t\tans-=mod;\n \t}\n }\n printf(\"%d\\n\",ans);\n return 0;\n} 855D - Rowena Ravenclaw's DiademIn this problem, the relations \"is a part of\" and \"is a special case of\" were transitive. And also, if some object \"a\" had \"b\" as its special case and \"c\" as its part, \"c\" was also a part of \"b\".Now, when we need to process the queries, we use the concept of lowest common ancestor (lca). For query 1 u v, answer will be \"YES\" iff u ≠ v (as u is not special case of itself) and lca(u, v) = u and all the relations from u to v are of type 0 (is a special case of)For query 2 u v, answer will be \"YES\" iff the following conditions hold: If w = lca(u, v), path from w to u has only edges of type 0 (is a special case of) and those from w to v has only edges of type 1 (is a part of). Also, w ≠ v.Expected time complexity: O((n + q)·log(n)) Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n} 855E - Salazar Slytherin's LocketThis problem can be solved using precomputation of dp table dp[base][mask][len]. This stores the number of integers in base b and length len that forms the given mask in their representation. The mask is defined as having i - th bit as 1, if the digit i - 1 occurs odd number of times in the representation.Using this precomputed dp array, we can easily calculate the answer for the queries, by converting l - 1 and r to the given base b, then adding the total integers less than equal to r with mask = 0 and subtracting those less than l with mask = 0.Now, to find the number of integers less than equal to l - 1 with mask = 0, we first add all the integers with mask = 0 who have length less than length of l - 1 in base b representation. If length of l - 1 in base b is lb, this value can be calculated as . The second term is subtracted to take into account the trailing zeros. Now, we need to calculate the number of integers with length = lb and value ≤ l - 1 and mask = 0. Let the number l - 1 in base b representation be l0, l1... llb. Then, if we fix the first digit of our answer, x from 0 to l0 - 1, we can simply calculate the mask for remaining digits we need as 2x and thus adding dp[b][2x][len - 1] to answer. Now, if we fix the first digit as l0 only, we can simply perform the same operation for the second digit, selecting value of second digit, y from 0 to l1 - 1, and thus adding to answer. And, we can move forward to rest of the digits in the same way.The overall complexity of the solution will be Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n //freopen(\"in.txt\",\"r\",stdin);\n //freopen(\"out.txt\",\"w\",stdout);\n ll n,i,j,k,in;\n ll ans,l,r,m,q,b;\n k=1e18;\n memset(dp,-1,sizeof dp);\n for(i=2;i<=10;i++)\n {\n \tlen[i]=1;\n \tj=i;\n \twhile(j<k)\n \t{\n \t\tlen[i]++;\n \t\tj*=i;\n \t}\n \tf(i,0,0,len[i]+1);\n }\n sd(q);\n while(q--)\n {\n \tsd(b);\n \tsd(l);\n \tsd(r);\n \tans=0;\n \tl--;\n \tif(l)\n \t{\n \t\tj=l;\n \t\ti=0;\n \t\twhile(j)\n \t\t{\n \t\t\ta[i]=j%b;\n \t\t\tj/=b;\n \t\t\ti++;\n \t\t}\n \t\tm=0;\n \t\tin=0;\n \t\tfor(j=i-1;j>=0;j--)\n \t\t{\n \t\t\tfor(k=0;k<a[j];k++)\n \t\t\t{\n \t\t\t\tif(k!=0)\n \t\t\t\t\tin=1;\n \t\t\t\tif(in==0)\n \t\t\t\t\tans-=dp[b][0][m][j];\n \t\t\t\telse\n \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n \t\t\t}\n \t\t\tif(in|a[j])\n \t\t\t{\n \t\t\t\tin=1;\n \t\t\t\tm=(m^(1<<a[j]));\n \t\t\t}\n \t\t}\n \t\tans-=dp[b][in][m][0];\n \t}\n \tj=r;\n \ti=0;\n \twhile(j)\n \t{\n \t\ta[i]=j%b;\n \t\tj/=b;\n \t\ti++;\n \t}\n \tin=0;\n \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n }\n return 0;\n} 855F - NaginiThis problem can be solved by using the concept of square root decomposition. Let us divide the total range of x-axis, that is, from 1 to 105 in . Then, blockSize = , and number of blocks, nb = 105 / blockSize. Now, we maintain the following structures: An array ans that stores the answer for each block. Two values upper and lower for each block. upper stores the closest line segment with y > 0 that covers the complete block. Similarly lower stores the closest line with y < 0 that covers the complete block. Maps low and up for each block. up maps for each height y > 0, the number of x-coordinates with its minimum height as y. Similarly low maps for each height y < 0, the number of x-coordinates with its maximum height as y. Also, note that this map stores the information only for those x-coordinates which have atleast one line segment on both sides of axis. Maps vnotup and vnotdown for each block. These are similar to maps low and up except that these stores value for those coordinates that do not have line on one of the sides. That is, vnotup maps the height y to its count for y < 0 such that at those coordinates, there do not exists any line for y > 0. Value notboth for each block, this stores the number of x-coordinates that do not have line segments on any of the two sides of axis. Arrays minup and mindown for each value from 1 to 105. minup stores the minimum value for y such that y > 0 and there is a snake at that point and that snake does not cover the complete block. Similar value for y < 0 is stored by mindown Now we have to maintain these structure throughout the update operation. To do so, we divide the update operations into two halves, the update for initial and final blocks which are only partially covered by a line, and the update for complete block. For now, let us assume that the update is for some y > 0. For y < 0, a similar approach can be done: Updating the initial and final blocks: Iterate through every x-coordinate in the range. There can be four cases: If all the values, minup, mindown for that coordinate and value lower and upper for that block are inf, this means that this is the first time a line is coming at this coordinate. Reduce notboth of the block by 1 and update the map vnotdown. Else if minup and upper are inf, this means that for this x-coordinate there is a line below axis, but not above. Update vnotup, up, low and ans accordingly. Else if mindown and lower are inf, this means that there is no line with y < 0 at this x-coordinate. Just update vnotdown. Else if both side lines are there, just update ans and up. Also, update the value of minup for each coordinate. Updating the complete block Remove all the elements from vnotup and update the up, low maps and ans for that block accordingly. Put notboth as 0 and update the map vnotdown acccordingly. Remove elements from vnotdown which are greater than this value of y and update it again. Finally update the up array and value of ans for that block. Also update the value of upper. For answering the queries, you will need to answer the half-block(initial and final block) queries by iterating through each x-coordinate. For answering full-block queries, just return the ans for that block.If we take n = 105, the expected complexity of the solution is Solution#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n} 855G - Harry Vs Voldemort At first let's solve the problem for the initial tree. You can use dynamic programming. The second part of the problem was to realize that we need to count the triple (u, v, w) if and only if the following condition holds: w is in a edge-2-connectivity component that is on the path from the edge-2-connectivity component of u and the edge-2-connectivity of v. When an edge is added, it compresses all edge-2-connectivity components on the path between its ends. We can list all these components and then merge them in O(number of the components) time, because once we list all these components, they disappear. In other words, each component is listed at most once through the entire process, and the total number of components is O(n). How do we recalculate the answer given the components we need to merge into a single one? It can be done directly considering all cases of which of u, v and w are in this new component. The only tough idea may be that you need to, for each component, keep the number of pairs (u, v) such that u and v are not in this component, and edges (bridges) towards u and v from this component are different. For more details about case-work see the code below. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n #define LLD \"%I64d\"\n#else\n #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n int rep, sz;\n ll ansmiddle;\n int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n a = find(a);\n b = find(b);\n if (a == b) return;\n if (s[a] > s[b]) swap(a, b);\n p[a] = b;\n if (s[a] == s[b]) s[b]++;\n if (tin[top[a]] < tin[top[b]])\n {\n sz[top[a]] += sz[top[b]];\n top[b] = top[a];\n } else\n {\n sz[top[b]] += sz[top[a]];\n }\n}\n\nvoid findpath(int a, int b)\n{\n a = top[find(a)];\n b = top[find(b)];\n// cout << \"findpath \" << a << ' ' << b << endl;\n int lastdowna = 0;\n while (!isparent(a, b))\n {\n path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n lastdowna = down[a];\n a = top[find(up[a])];\n }\n path2.clear();\n int lastdownb = 0;\n while (a != b)\n {\n path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n lastdownb = down[b];\n b = top[find(up[b])];\n }\n path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n reverse(all(path2));\n for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n if (find(a) == find(b)) return;\n path.clear();\n findpath(a, b);\n\n// cout << \"addedge \" << a << ' ' << b << endl;\n// for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n\n // 3\n ll cnt0 = 1;\n ll cnt1 = 0;\n ll cnt2 = 0;\n for (auto t : path)\n {\n answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n cnt1 += t.sz * cnt0;\n }\n ll sum = cnt1;\n answer += ((ll)sum * (sum - 1) * (sum - 2));\n\n// cout << \"after 3: \" << answer << endl;\n\n // 2\n cnt1 = 0;\n for (auto t : path)\n {\n answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n cnt1 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n cnt1 += t.sz;\n }\n\n// cout << \"after 2: \" << answer << endl; \n\n // 1\n cnt1 = 0;\n cnt2 = 0;\n for (auto t : path)\n {\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n }\n cnt1 = 0;\n cnt2 = 0;\n for (int i = (int)path.size() - 1; i >= 0; i--)\n {\n auto &t = path[i];\n answer += cnt2 * t.sz * 2;\n cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n }\n// cout << \"after 1 old: \" << answer << endl;\n ll ttldown1 = 0;\n ll ttldown2 = 0;\n for (auto t : path)\n {\n ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n answer += curdown2 * (sum - t.sz);\n ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n ttldown1 += curdown;\n }\n\n// cout << \"after 1: \" << answer << endl;\n\n for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n down[cur] = 1;\n up[cur] = pr;\n dp1[cur] = 0;\n ansmiddle[cur] = 0;\n tin[cur] = timer++;\n for (auto t : gr[cur]) if (t != pr)\n {\n down[cur] += go(t, cur);\n answer += (ll)dp1[t] * dp1[cur] * 2;\n answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n answer += dp2[t] * 2;\n dp2[cur] += dp2[t];\n dp1[cur] += dp1[t];\n }\n ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n dp2[cur] += dp1[cur];\n dp1[cur] += 1;\n tout[cur] = timer - 1;\n// cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n return down[cur];\n}\n\nint main()\n{\n scanf(\"%d\", &n);\n for (int i = 0; i < n - 1; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n gr[a].pb(b);\n gr[b].pb(a);\n }\n go(0, -1);\n for (int i = 0; i < n; i++)\n {\n p[i] = i;\n s[i] = 0;\n top[i] = i;\n sz[i] = 1;\n }\n printf(\"%lld\\n\", answer);\n scanf(\"%d\", &m);\n for (int i = 0; i < m; i++)\n {\n int a, b;\n scanf(\"%d%d\", &a, &b);\n a--, b--;\n addedge(a, b);\n printf(\"%lld\\n\", answer);\n }\n\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54750",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 855\\s*G"
          },
          "content_length": 28150
        }
      ],
      "code_examples": [
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 1",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 2",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j;\n    string s[102];\n    sd(n);\n    for(i=0;i<n;i++)\n    {\n    \tcin>>s[i];\n    \tfor(j=0;j<i;j++)\n    \t{\n    \t\tif(s[i]==s[j])\n    \t\t\tbreak;\n    \t}\n    \tif(j==i)\n    \t\tprintf(\"NO\\n\");\n    \telse\n    \t\tprintf(\"YES\\n\");\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint a[100005];\nll dp[100005][3];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,p,q,r,i;\n    sd(n);\n    sd(p);\n    sd(q);\n    sd(r);\n    for(i=0;i<n;i++)\n    \tsd(a[i]);\n    dp[0][0]=1ll*p*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][0]=max(dp[i-1][0],1ll*p*a[i]);\n    dp[0][1]=dp[0][0]+1ll*q*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][1]=max(dp[i-1][1],dp[i][0]+1ll*q*a[i]);\n    dp[0][2]=dp[0][1]+1ll*r*a[0];\n    for(i=1;i<n;i++)\n    \tdp[i][2]=max(dp[i-1][2],dp[i][1]+1ll*r*a[i]);\n    printf(\"%lld\\n\",dp[n-1][2]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 5",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 6",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nint minleft[100005],minright[100005],maxleft[100005],maxright[100005],a[100005];\nint main()\n{\n\tint i,j,k;\n\tint n,p,q,r;\n\tcin>>n>>p>>q>>r;\n\tfor(i=1;i<=n;i++)\n\t\tsd(a[i]);\n\tminleft[1]=maxleft[1]=a[1];\n\tminright[n]=maxright[n]=a[n];\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tminleft[i]=min(minleft[i-1],a[i]);\n\t\tmaxleft[i]=max(maxleft[i-1],a[i]);\n\t}\n\tfor(i=n-1;i>=1;i--)\n\t{\n\t\tminright[i]=min(minright[i+1],a[i]);\n\t\tmaxright[i]=max(maxright[i+1],a[i]);\n\t}\n\tll ans=-3e18;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tll leftval = (p<0) ? 1ll*minleft[i]*p : 1ll*maxleft[i]*p;\n\t\tll rightval = (r<0) ? 1ll*minright[i]*r : 1ll*maxright[i]*r;\n\t\tans=max(ans,leftval+rightval+1ll*q*a[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nint dp[100005][3][12],x,k,m;\nint a[3][12],b[3][12];\nvector <int> q[100005];\nvoid dfs(int cur,int par)\n{\n\tint i,j=0,l,r,temp;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tj=1;\n\t\tdfs(q[cur][i],cur);\n\t}\n\tif(!j)\n\t{\n\t\tdp[cur][0][0]=k-1;\n\t\tdp[cur][1][1]=1;\n\t\tdp[cur][2][0]=m-k;\n\t\treturn;\n\t}\n\tfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\tfor(i=0;i<q[cur].size();i++)\n\t{\n\t\tif(q[cur][i]==par)\n\t\t\tcontinue;\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\tfor(r=0;r<=x;r++)\n\t\t\t\t{\n\t\t\t\t\tif(l+r>x)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][1][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\ttemp+=dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*(dp[q[cur][i]][0][r]))%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=dp[q[cur][i]][0][r]+dp[q[cur][i]][2][r];\n\t\t\t\t\t\tif(temp>=mod)\n\t\t\t\t\t\t\ttemp-=mod;\n\t\t\t\t\t\tb[j][l+r]+=(1ll*a[j][l]*temp)%mod;\n\t\t\t\t\t\tif(b[j][l+r]>=mod)\n\t\t\t\t\t\t\tb[j][l+r]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<3;j++)\n\t\t{\n\t\t\tfor(l=0;l<=x;l++)\n\t\t\t{\n\t\t\t\ta[j][l]=b[j][l];\n\t\t\t\tb[j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,i,j,ans;\n    sd(n);\n    sd(m);\n    for(i=1;i<n;i++)\n    {\n    \tsd(j);\n    \tsd(k);\n    \tq[j].pb(k);\n    \tq[k].pb(j);\n    }\n    sd(k);\n    sd(x);\n    dfs(1,0);\n    ans=0;\n    for(i=0;i<3;i++)\n    {\n    \tfor(j=0;j<=x;j++)\n    \t{\n    \t\t//printf(\"%d %d %d\\n\",i,j,dp[1][i][j]);\n    \t\tans+=dp[1][i][j];\n    \t\tif(ans>=mod)\n    \t\t\tans-=mod;\n    \t}\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nvector<int>v[100005],v2[100005];\nint inherit[100005],comp[100005],parent[100005][25],height[100005];\nint parr[100005];\nint findpar(int node)\n{\n\treturn parr[node]==node ? node : parr[node]=findpar(parr[node]);\n}\nvoid dfs(int node, int par, int inh, int com)\n{\n\tparent[node][0]=par;\n\tinherit[node]=inh;\n\tcomp[node]=com;\n\theight[node]=height[par]+1;\n\tfor(int i=1;i<=20;i++)\n\t{\n\t\tparent[node][i]=parent[parent[node][i-1]][i-1];\n\t}\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tif(v[node][i]==par)\n\t\t\tcontinue;\n\t\tif(v2[node][i]==0)\n\t\t\tdfs(v[node][i],node,inh+1,com);\n\t\telse\n\t\t\tdfs(v[node][i],node,inh,com+1);\n\t}\n}\nint findlca(int u, int v)\n{\n\tif(height[u]>height[v])\n\t\tswap(u,v);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(height[parent[v][i]]>=height[u])\n\t\t{\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\tif(u!=v)\n\t{\n\t\tfor(int i=20;i>=0;i--)\n\t\t{\n\t\t\tif(parent[u][i]!=parent[v][i])\n\t\t\t{\n\t\t\t\tu=parent[u][i];\n\t\t\t\tv=parent[v][i];\n\t\t\t}\n\t\t}\n\t\tu=parent[u][0];\n\t\tv=parent[v][0];\n\t}\n\treturn u;\n}\nint main()\n{\n\tint i,j,k;\n\tint n,q;\n\tsd(n);\n\tfor(i=1;i<=n;i++)\n\t\tparr[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsd(j);\n\t\tsd(k);\n\t\tif(j==-1 && k==-1)\n\t\t\tcontinue;\n\t\tv[i].pb(j);\n\t\tv[j].pb(i);\n\t\tv2[i].pb(k);\n\t\tv2[j].pb(k);\n\t\tint x=findpar(i);\n\t\tint y=findpar(j);\n\t\tif(x!=y)\n\t\t\tparr[x]=y;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(parent[i][0]==0)\n\t\t{\n\t\t\tdfs(i,i,0,0);\n\t\t}\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(i);\n\t\tsd(j);\n\t\tsd(k);\n\t\tint x=findpar(j);\n\t\tint y=findpar(k);\n\t\tif(x!=y)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tx=findlca(j,k);\n\t\tif(i==1)\n\t\t{\n\t\t\tif(x!=j || comp[k]-comp[x]!=0 || j==k)\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(inherit[k]-inherit[x]!=0 || comp[j]-comp[x]!=0 || x==k)\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define ll long long\n#define mod 1000000007\n#define bitcount    __builtin_popcountll\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\nll dp[11][2][1030][70];\nll len[12],a[100];\nll f(ll b,ll in,ll m,ll pos)\n{\n\tif(dp[b][in][m][pos]!=-1)\n\t\treturn dp[b][in][m][pos];\n\tif(pos==0)\n\t{\n\t\tif(in!=0&&m==0)\n\t\t\treturn dp[b][in][m][pos]=1;\n\t\telse\n\t\t\treturn dp[b][in][m][pos]=0;\n\t\treturn dp[b][in][m][pos];\n\t}\n\tll j=0;\n\tif(in==0)\n\t\tj+=f(b,0,m,pos-1);\n\telse\n\t\tj+=f(b,1,(m^1),pos-1);\n\tfor(ll i=1;i<b;i++)\n\t\tj+=f(b,1,(m^(1<<i)),pos-1);\n\tdp[b][in][m][pos]=j;\n\treturn j;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    ll n,i,j,k,in;\n    ll ans,l,r,m,q,b;\n    k=1e18;\n    memset(dp,-1,sizeof dp);\n    for(i=2;i<=10;i++)\n    {\n    \tlen[i]=1;\n    \tj=i;\n    \twhile(j<k)\n    \t{\n    \t\tlen[i]++;\n    \t\tj*=i;\n    \t}\n    \tf(i,0,0,len[i]+1);\n    }\n    sd(q);\n    while(q--)\n    {\n    \tsd(b);\n    \tsd(l);\n    \tsd(r);\n    \tans=0;\n    \tl--;\n    \tif(l)\n    \t{\n    \t\tj=l;\n    \t\ti=0;\n    \t\twhile(j)\n    \t\t{\n    \t\t\ta[i]=j%b;\n    \t\t\tj/=b;\n    \t\t\ti++;\n    \t\t}\n    \t\tm=0;\n    \t\tin=0;\n    \t\tfor(j=i-1;j>=0;j--)\n    \t\t{\n    \t\t\tfor(k=0;k<a[j];k++)\n    \t\t\t{\n    \t\t\t\tif(k!=0)\n    \t\t\t\t\tin=1;\n    \t\t\t\tif(in==0)\n    \t\t\t\t\tans-=dp[b][0][m][j];\n    \t\t\t\telse\n    \t\t\t\t\tans-=dp[b][1][(m^(1<<k))][j];\n    \t\t\t}\n    \t\t\tif(in|a[j])\n    \t\t\t{\n    \t\t\t\tin=1;\n    \t\t\t\tm=(m^(1<<a[j]));\n    \t\t\t}\n    \t\t}\n    \t\tans-=dp[b][in][m][0];\n    \t}\n    \tj=r;\n    \ti=0;\n    \twhile(j)\n    \t{\n    \t\ta[i]=j%b;\n    \t\tj/=b;\n    \t\ti++;\n    \t}\n    \tin=0;\n    \tm=0;\n\t\tfor(j=i-1;j>=0;j--)\n\t\t{\n\t\t\tfor(k=0;k<a[j];k++)\n\t\t\t{\n\t\t\t\tif(k!=0)\n\t\t\t\t\tin=1;\n\t\t\t\tif(in==0)\n\t\t\t\t\tans+=dp[b][0][m][j];\n\t\t\t\telse\n\t\t\t\t\tans+=dp[b][1][(m^(1<<k))][j];\n\t\t\t}\n\t\t\tif(in|a[j])\n\t\t\t{\n\t\t\t\tin=1;\n\t\t\t\tm=(m^(1<<a[j]));\n\t\t\t}\n\t\t}\n\t\tans+=dp[b][in][m][0];\n\t\tprintf(\"%lld\\n\",ans);\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define mp make_pair\nll ans[1000];\nint upper[1000],lower[1000];\nint block;\nmap <int,int> low[1000],up[1000];\nmap <int,int> vnotup[1000],vnotdown[1000];\nint notboth[1000];\nint minup[100005],mindown[100005];\nvoid updateup(int i,int l,int r,int val)\n{\n\tif(upper[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(minup[j]>val)\n\t\t{\n\t\t\tif(minup[j]==mod&&mindown[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notdown[i]++;\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t\t//notdownsum[i]+=val;\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\t//notup[i]--;\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\t//notupsum[i]-=min(lower[i],mindown[j]);\n\t\t\t\tup[i][val]++;\n\t\t\t\tlow[i][temp]++;\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(lower[i],mindown[j]);\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tvnotdown[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(upper[i],minup[j]);\n\t\t\t\tup[i][min(minup[j],upper[i])]--;\n\t\t\t\tup[i][val]++;\n\t\t\t}\n\t\t\tminup[j]=val;\n\t\t}\n\t}\n}\nvoid updatefullup(int i,int val)\n{\n\tif(val>=upper[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=up[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotup[i].begin();it!=vnotup[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tlow[i][it->fi]+=it->se;\n\t}\n\tvnotup[i].clear();\n\tit=vnotdown[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotdown[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotdown[i].upper_bound(val);\n\tvnotdown[i].erase(it,vnotdown[i].end());\n\tvnotdown[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=up[i].upper_bound(val);\n\tfor(it;it!=up[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=up[i].upper_bound(val);\n\tup[i].erase(it,up[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tup[i][val]+=len+len2;\n\tupper[i]=val;\n}\nvoid updatedown(int i,int l,int r,int val)\n{\n\tif(lower[i]<=val)\n\t\treturn;\n\t//map<int,int> m;\n\tmap<int,int> :: iterator it;\n\t//m.clear();\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(mindown[j]>val)\n\t\t{\n\t\t\tif(mindown[j]==mod&&minup[j]==mod&&upper[i]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\tnotboth[i]--;\n\t\t\t\t//notup[i]++;\n\t\t\t\t//notupsum[i]+=val;\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse if(mindown[j]==mod&&lower[i]==mod)\n\t\t\t{\n\t\t\t\t//notdown[i]--;\n\t\t\t\tint temp=min(upper[i],minup[j]);\n\t\t\t\tvnotdown[i][temp]--;\n\t\t\t\tif(vnotdown[i][temp]==0)\n\t\t\t\t\tvnotdown[i].erase(temp);\n\t\t\t\tlow[i][val]++;\n\t\t\t\tup[i][temp]++;\n\t\t\t\t//notdownsum[i]-=min(upper[i],minup[j]);\n\t\t\t\tans[i]+=val;\n\t\t\t\tans[i]+=min(upper[i],minup[j]);\n\t\t\t}\n\t\t\telse if(minup[j]==mod&&upper[i]==mod)\n\t\t\t{\n\t\t\t\tint temp=min(lower[i],mindown[j]);\n\t\t\t\tvnotup[i][temp]--;\n\t\t\t\tif(vnotup[i][temp]==0)\n\t\t\t\t\tvnotup[i].erase(temp);\n\t\t\t\tvnotup[i][val]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i]+=val-min(lower[i],mindown[j]);\n\t\t\t\tlow[i][min(mindown[j],lower[i])]--;\n\t\t\t\tlow[i][val]++;\n\t\t\t}\n\t\t\tmindown[j]=val;\n\t\t}\n\t}\n}\nvoid updatefulldown(int i,int val)\n{\n\tif(val>=lower[i])\n\t\treturn;\n\tmap <int,int> :: iterator it; \n\tint n=low[i].size();\n\tn--;\n\tll sum=0;\n\tint len2=0;\n\tfor(it=vnotdown[i].begin();it!=vnotdown[i].end();it++)\n\t{\n\t\tans[i]+=1ll*(it->fi)*(it->se)+1ll*(it->se)*val;\n\t\tlen2+=it->se;\n\t\tup[i][it->fi]+=it->se;\n\t}\n\tvnotdown[i].clear();\n\tit=vnotup[i].upper_bound(val);\n\tint temp=0;\n\tfor(it;it!=vnotup[i].end();it++)\n\t{\n\t\ttemp+=it->se;\n\t}\n\tit=vnotup[i].upper_bound(val);\n\tvnotup[i].erase(it,vnotup[i].end());\n\tvnotup[i][val]+=temp+notboth[i];\n\tnotboth[i]=0;\n\tint len=0;\n\tit=low[i].upper_bound(val);\n\tfor(it;it!=low[i].end();it++)\n\t{\n\t\tsum+=1ll*(it->fi)*(it->se);\n\t\tlen+=it->se;\n\t}\n\tit=low[i].upper_bound(val);\n\tlow[i].erase(it,low[i].end());\n\tans[i]+=1ll*len*val-sum;\n\tlow[i][val]+=len+len2;\n\tlower[i]=val;\n}\nll query(int i,int l,int r)\n{\n\tll sum=0;\n\tfor(int j=l;j<=r;j++)\n\t{\n\t\tif(min(upper[i],minup[j])<mod&&min(lower[i],mindown[j])<mod)\n\t\t\tsum+=min(upper[i],minup[j])+min(lower[i],mindown[j]);\n\t}\n\treturn sum;\n}\nll queryfull(int i)\n{\n\treturn ans[i];\n}\nint main()\n{\n\tint i,j,k,q,n,t,l,r,val,block;\n\tll s;\n\tn=100000;\n\tfor(i=0;i<1000;i++)\n\t\tlower[i]=upper[i]=mod;\n\tfor(i=0;i<=100000;i++)\n\t\tminup[i]=mindown[i]=mod;\n\tblock=300;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tj=i/block;\n\t\tnotboth[j]++;\n\t}\n\tsd(q);\n\twhile(q--)\n\t{\n\t\tsd(t);\n\t\tsd(l);\n\t\tsd(r);\n\t\tr--;\n\t\tif(t==1)\n\t\t{\n\t\t\tsd(val);\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(val>0)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdateup(j,l,r,val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdateup(i,l,(i+1)*block-1,val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updateup(i,i*block,(i+1)*block-1,val);\n\t\t\t\t\t\tupdatefullup(i,val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdateup(j,j*block,r,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tupdatedown(j,l,r,-val);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupdatedown(i,l,(i+1)*block-1,-val);\n\t\t\t\t\ti++;\n\t\t\t\t\twhile(i<j)\n\t\t\t\t\t{\n\t\t\t\t\t\t// updatedown(i,i*block,(i+1)*block-1,-val);\n\t\t\t\t\t\tupdatefulldown(i,-val);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tupdatedown(j,j*block,r,-val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=0;\n\t\t\ti=l/block;\n\t\t\tj=r/block;\n\t\t\tif(i==j)\n\t\t\t\ts=query(j,l,r);\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=query(i,l,(i+1)*block-1);\n\t\t\t\ti++;\n\t\t\t\twhile(i<j)\n\t\t\t\t{\n\t\t\t\t\t//s+=query(i,i*block,(i+1)*block-1);\n\t\t\t\t\ts+=queryfull(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ts+=query(j,j*block,r);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nstruct tpath\n{\n    int rep, sz;\n    ll ansmiddle;\n    int edgeleft, edgeright;\n};\n\nint p[maxn], s[maxn];\nint sz[maxn], down[maxn], up[maxn], top[maxn];\nvector<tpath> path, path2;\nvector<int> gr[maxn];\nll dp1[maxn], dp2[maxn], ansmiddle[maxn];\nint n, m;\nll answer;\nint tin[maxn], tout[maxn];\nint timer;\n\ninline int find(int a)\n{\n    return (a == p[a] ? a : p[a] = find(p[a]));\n}\n\ninline bool isparent(int a, int b)\n{\n    return tin[a] <= tin[b] && tout[a] >= tin[b];\n}\n\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (s[a] > s[b]) swap(a, b);\n    p[a] = b;\n    if (s[a] == s[b]) s[b]++;\n    if (tin[top[a]] < tin[top[b]])\n    {\n        sz[top[a]] += sz[top[b]];\n        top[b] = top[a];\n    } else\n    {\n        sz[top[b]] += sz[top[a]];\n    }\n}\n\nvoid findpath(int a, int b)\n{\n    a = top[find(a)];\n    b = top[find(b)];\n//     cout << \"findpath \" << a << ' ' << b << endl;\n    int lastdowna = 0;\n    while (!isparent(a, b))\n    {\n        path.pb({a, sz[a], ansmiddle[a], lastdowna, n - down[a]});\n        lastdowna = down[a];\n        a = top[find(up[a])];\n    }\n    path2.clear();\n    int lastdownb = 0;\n    while (a != b)\n    {\n        path2.pb({b, sz[b], ansmiddle[b], n - down[b], lastdownb});\n        lastdownb = down[b];\n        b = top[find(up[b])];\n    }\n    path.pb({a, sz[a], ansmiddle[a], lastdowna, lastdownb});\n    reverse(all(path2));\n    for (auto t : path2) path.pb(t);\n}\n\nvoid addedge(int a, int b)\n{\n    if (find(a) == find(b)) return;\n    path.clear();\n    findpath(a, b);\n    \n//     cout << \"addedge \" << a << ' ' << b << endl;\n//     for (auto t : path) cout << \"(\" << t.rep << ' ' << t.sz << ' ' << t.ansmiddle << ' ' << t.edgeleft << ' ' << t.edgeright << \")\" << endl;\n    \n    // 3\n    ll cnt0 = 1;\n    ll cnt1 = 0;\n    ll cnt2 = 0;\n    for (auto t : path)\n    {\n        answer -= t.sz * cnt2 * 2 + (ll)t.sz * (t.sz - 1) * cnt1 * 2 + (ll)t.sz * (t.sz - 1) * (t.sz - 2);\n        cnt2 += t.sz * cnt1 + (ll)t.sz * (t.sz - 1) * cnt0;\n        cnt1 += t.sz * cnt0;\n    }\n    ll sum = cnt1;\n    answer += ((ll)sum * (sum - 1) * (sum - 2));\n    \n//     cout << \"after 3: \" << answer << endl;\n    \n    // 2\n    cnt1 = 0;\n    for (auto t : path)\n    {\n        answer += cnt1 * (t.edgeleft - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n    cnt1 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt1 * (t.edgeright - cnt1) * t.sz * 2;\n        cnt1 += t.sz;\n    }\n\n//     cout << \"after 2: \" << answer << endl;    \n    \n    // 1\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto t : path)\n    {\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeright - t.edgeleft - t.sz) * cnt1;\n        cnt1 += n - t.edgeright - t.edgeleft - t.sz;\n    }\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = (int)path.size() - 1; i >= 0; i--)\n    {\n        auto &t = path[i];\n        answer += cnt2 * t.sz * 2;\n        cnt2 += (n - t.edgeleft - t.edgeright - t.sz) * cnt1;\n        cnt1 += n - t.edgeleft - t.edgeright - t.sz;\n    }\n//     cout << \"after 1 old: \" << answer << endl;\n    ll ttldown1 = 0;\n    ll ttldown2 = 0;\n    for (auto t : path)\n    {\n        ll curdown = n - t.edgeleft - t.edgeright - t.sz;\n        ll curdown2 = t.ansmiddle - curdown * (t.edgeleft + t.edgeright) * 2 - (ll)t.edgeleft * t.edgeright * 2;\n        answer += curdown2 * (sum - t.sz);\n        ttldown2 = ttldown2 + curdown2 + ttldown1 * curdown * 2;\n        ttldown1 += curdown;\n    }\n\n//     cout << \"after 1: \" << answer << endl;\n    \n    for (int i = 1; i < (int)path.size(); i++) unite(path[i - 1].rep, path[i].rep);\n    ansmiddle[top[find(path[0].rep)]] = ttldown2;\n}\n\nint go(int cur, int pr)\n{\n    down[cur] = 1;\n    up[cur] = pr;\n    dp1[cur] = 0;\n    ansmiddle[cur] = 0;\n    tin[cur] = timer++;\n    for (auto t : gr[cur]) if (t != pr)\n    {\n        down[cur] += go(t, cur);\n        answer += (ll)dp1[t] * dp1[cur] * 2;\n        answer += (ll)dp1[t] * dp2[cur] * 2 + dp2[t] * dp1[cur] * 2;\n        ansmiddle[cur] += (ll)dp1[t] * dp1[cur] * 2;\n        answer += dp2[t] * 2;\n        dp2[cur] += dp2[t];\n        dp1[cur] += dp1[t];\n    }\n    ansmiddle[cur] += (ll)(n - down[cur]) * dp1[cur] * 2;\n    dp2[cur] += dp1[cur];\n    dp1[cur] += 1;\n    tout[cur] = timer - 1;\n//     cout << \"exit \" << cur << ' ' << answer << ' ' << dp1[cur] << ' ' << dp2[cur] << endl;\n    return down[cur];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    go(0, -1);\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = i;\n        s[i] = 0;\n        top[i] = i;\n        sz[i] = 1;\n    }\n    printf(\"%lld\\n\", answer);\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        addedge(a, b);\n        printf(\"%lld\\n\", answer);\n    }\n    \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 17",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        },
        {
          "title": "Editorial — Manthan Codefest '17 - Codeforces - Code 18",
          "code": "void dfs(int curr, int par)\n{\n//something\n\nfor(i=0;i<3;i++)\n\t{\n\t\tfor(j=0;j<=x;j++)\n\t\t{\n\t\t\ta[i][j]=0;\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<3;i++)\n\t\ta[i][0]=1;\n\n//calculation of a and b here\n\nfor(l=0;l<=x;l++)\n\t{\n\t\tdp[cur][0][l]=(1ll*a[0][l]*(k-1))%mod;\n\t\tif(l>=1)\n\t\t\tdp[cur][1][l]=a[1][l-1];\n\t\tdp[cur][2][l]=(1ll*a[2][l]*(m-k))%mod;\n\t}\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54750",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        edges.emplace_back(u, v);\n    }\n\n    // Check that the initial edges form a connected tree\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find_parent = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find_parent(parent[x]);\n        return parent[x];\n    };\n\n    for (const auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        int pu = find_parent(u);\n        int pv = find_parent(v);\n        ensuref(pu != pv, \"The initial edges must not form cycles\");\n        parent[pu] = pv;\n    }\n\n    int root = find_parent(1);\n    for (int i = 2; i <= n; ++i) {\n        int pi = find_parent(i);\n        ensuref(pi == root, \"The initial tree must be connected\");\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        edges.emplace_back(u, v);\n    }\n\n    // Check that the initial edges form a connected tree\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find_parent = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find_parent(parent[x]);\n        return parent[x];\n    };\n\n    for (const auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        int pu = find_parent(u);\n        int pv = find_parent(v);\n        ensuref(pu != pv, \"The initial edges must not form cycles\");\n        parent[pu] = pv;\n    }\n\n    int root = find_parent(1);\n    for (int i = 2; i <= n; ++i) {\n        int pi = find_parent(i);\n        ensuref(pi == root, \"The initial tree must be connected\");\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        edges.emplace_back(u, v);\n    }\n\n    // Check that the initial edges form a connected tree\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find_parent = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find_parent(parent[x]);\n        return parent[x];\n    };\n\n    for (const auto& e : edges) {\n        int u = e.first;\n        int v = e.second;\n        int pu = find_parent(u);\n        int pv = find_parent(v);\n        ensuref(pu != pv, \"The initial edges must not form cycles\");\n        parent[pu] = pv;\n    }\n\n    int root = find_parent(1);\n    for (int i = 2; i <= n; ++i) {\n        int pi = find_parent(i);\n        ensuref(pi == root, \"The initial tree must be connected\");\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of nodes\n    int q = opt<int>(\"q\"); // Number of new edges\n    string tree_type = opt<string>(\"tree\", \"random\"); // Type of initial tree\n    string edge_type = opt<string>(\"edges\", \"random\"); // Type of new edges\n\n    vector<pair<int, int>> tree_edges;\n    tree_edges.reserve(n - 1);\n\n    // Generate the initial tree\n    if (tree_type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            tree_edges.emplace_back(u, v);\n        }\n        shuffle(tree_edges.begin(), tree_edges.end());\n    } else if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.emplace_back(i - 1, i);\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.emplace_back(1, i);\n        }\n    } else if (tree_type == \"balanced\") {\n        // Balanced binary tree\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n        function<void(int, int)> build = [&](int l, int r) {\n            if (l >= r) return;\n            int m = (l + r) / 2;\n            if (l < m) tree_edges.emplace_back(nodes[m], nodes[(l + m - 1) / 2]);\n            if (m + 1 <= r) tree_edges.emplace_back(nodes[m], nodes[(m + 1 + r) / 2]);\n            build(l, m - 1);\n            build(m + 1, r);\n        };\n        build(0, n - 1);\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            tree_edges.emplace_back(u, v);\n        }\n        shuffle(tree_edges.begin(), tree_edges.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the tree edges\n    for (const auto &e : tree_edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate q new edges\n    printf(\"%d\\n\", q);\n    vector<pair<int, int>> new_edges;\n    new_edges.reserve(q);\n\n    if (edge_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    } else if (edge_type == \"self-loops\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            new_edges.emplace_back(u, u);\n        }\n    } else if (edge_type == \"repeated\") {\n        // Repeated edges between nodes that already have an edge in the tree\n        vector<pair<int, int>> existing_edges = tree_edges;\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(0, (int)existing_edges.size() - 1);\n            new_edges.push_back(existing_edges[idx]);\n        }\n    } else if (edge_type == \"already-connected\") {\n        // Edges between nodes that are already connected (but not necessarily adjacent)\n        // For simplicity, we generate random pairs (u, v)\n        // This may include nodes that are not connected directly\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    } else if (edge_type == \"maximal\") {\n        // Add edges to try to make the graph as dense as possible\n        int limit = min(q, n * (n - 1) / 2 - (n - 1));\n        set<pair<int, int>> added_edges(tree_edges.begin(), tree_edges.end());\n        for (int i = 1; i <= n && (int)new_edges.size() < limit; ++i) {\n            for (int j = i + 1; j <= n && (int)new_edges.size() < limit; ++j) {\n                pair<int, int> e = {i, j};\n                if (added_edges.find(e) == added_edges.end()) {\n                    new_edges.push_back(e);\n                    added_edges.insert(e);\n                }\n            }\n        }\n        while ((int)new_edges.size() < q) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    } else {\n        // Default to random edges\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    }\n\n    // Output new edges\n    for (const auto &e : new_edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of nodes\n    int q = opt<int>(\"q\"); // Number of new edges\n    string tree_type = opt<string>(\"tree\", \"random\"); // Type of initial tree\n    string edge_type = opt<string>(\"edges\", \"random\"); // Type of new edges\n\n    vector<pair<int, int>> tree_edges;\n    tree_edges.reserve(n - 1);\n\n    // Generate the initial tree\n    if (tree_type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            tree_edges.emplace_back(u, v);\n        }\n        shuffle(tree_edges.begin(), tree_edges.end());\n    } else if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.emplace_back(i - 1, i);\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.emplace_back(1, i);\n        }\n    } else if (tree_type == \"balanced\") {\n        // Balanced binary tree\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n        function<void(int, int)> build = [&](int l, int r) {\n            if (l >= r) return;\n            int m = (l + r) / 2;\n            if (l < m) tree_edges.emplace_back(nodes[m], nodes[(l + m - 1) / 2]);\n            if (m + 1 <= r) tree_edges.emplace_back(nodes[m], nodes[(m + 1 + r) / 2]);\n            build(l, m - 1);\n            build(m + 1, r);\n        };\n        build(0, n - 1);\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            tree_edges.emplace_back(u, v);\n        }\n        shuffle(tree_edges.begin(), tree_edges.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the tree edges\n    for (const auto &e : tree_edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate q new edges\n    printf(\"%d\\n\", q);\n    vector<pair<int, int>> new_edges;\n    new_edges.reserve(q);\n\n    if (edge_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    } else if (edge_type == \"self-loops\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            new_edges.emplace_back(u, u);\n        }\n    } else if (edge_type == \"repeated\") {\n        // Repeated edges between nodes that already have an edge in the tree\n        vector<pair<int, int>> existing_edges = tree_edges;\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(0, (int)existing_edges.size() - 1);\n            new_edges.push_back(existing_edges[idx]);\n        }\n    } else if (edge_type == \"already-connected\") {\n        // Edges between nodes that are already connected (but not necessarily adjacent)\n        // For simplicity, we generate random pairs (u, v)\n        // This may include nodes that are not connected directly\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    } else if (edge_type == \"maximal\") {\n        // Add edges to try to make the graph as dense as possible\n        int limit = min(q, n * (n - 1) / 2 - (n - 1));\n        set<pair<int, int>> added_edges(tree_edges.begin(), tree_edges.end());\n        for (int i = 1; i <= n && (int)new_edges.size() < limit; ++i) {\n            for (int j = i + 1; j <= n && (int)new_edges.size() < limit; ++j) {\n                pair<int, int> e = {i, j};\n                if (added_edges.find(e) == added_edges.end()) {\n                    new_edges.push_back(e);\n                    added_edges.insert(e);\n                }\n            }\n        }\n        while ((int)new_edges.size() < q) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    } else {\n        // Default to random edges\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            new_edges.emplace_back(u, v);\n        }\n    }\n\n    // Output new edges\n    for (const auto &e : new_edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and q values\n./gen -n 1 -q 0 -tree random -edges random\n./gen -n 2 -q 1 -tree chain -edges random\n./gen -n 3 -q 2 -tree star -edges self-loops\n\n# Small n, larger q values\n./gen -n 10 -q 15 -tree random -edges random\n./gen -n 10 -q 20 -tree chain -edges repeated\n\n# Medium n and q values\n./gen -n 1000 -q 500 -tree random -edges random\n./gen -n 1000 -q 1000 -tree balanced -edges already-connected\n\n# Large n, small q values\n./gen -n 100000 -q 1 -tree random -edges random\n./gen -n 100000 -q 5 -tree star -edges random\n\n# Large n and q values\n./gen -n 100000 -q 100000 -tree random -edges random\n./gen -n 100000 -q 100000 -tree chain -edges random\n\n# Special tree types\n./gen -n 10000 -q 5000 -tree chain -edges random\n./gen -n 10000 -q 5000 -tree star -edges random\n./gen -n 10000 -q 5000 -tree balanced -edges random\n\n# Tests with self-loops\n./gen -n 50000 -q 50000 -tree random -edges self-loops\n./gen -n 100000 -q 100000 -tree random -edges self-loops\n\n# Tests adding edges between nodes that are already connected\n./gen -n 10000 -q 10000 -tree random -edges already-connected\n./gen -n 50000 -q 50000 -tree chain -edges already-connected\n\n# Maximal edges\n./gen -n 500 -q 1000 -tree random -edges maximal\n./gen -n 1000 -q 100000 -tree random -edges maximal\n\n# Tests with q = 0\n./gen -n 100000 -q 0 -tree random -edges random\n./gen -n 50000 -q 0 -tree chain -edges random\n\n# Tests with n = 1\n./gen -n 1 -q 10 -tree random -edges random\n\n# Tests with repeated edges\n./gen -n 100000 -q 100000 -tree random -edges repeated\n./gen -n 50000 -q 50000 -tree star -edges repeated\n\n# Edge case with maximum n and q\n./gen -n 100000 -q 100000 -tree balanced -edges random\n\n# Edge case with edges between the same node (self-loops)\n./gen -n 100000 -q 100000 -tree random -edges self-loops\n\n# Tests adding edges in a fully connected manner up to q\n./gen -n 1000 -q 500000 -tree random -edges maximal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:31.871405",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "856/A",
      "title": "A. Теория множеств",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВходные данные содержат несколько тестовых наборов. В первой строке задано количество тестов t (1 ≤ t ≤ 100).Каждый из тестов описывается следующим образом: в первой строке описания теста содержатся одно число n — размер множества A (1 ≤ n ≤ 100).В следующей строке содержатся n чисел ai — числа, принадлежащие множеству A (1 ≤ ai ≤ 106).",
      "output_spec": "Выходные данныеДля каждого теста в отдельной строке сначала выведите ответ на него:   NO, если не существует ни одного способа построить множество B, чтобы выполнить условие задачи.  YES, если способ решить задачу есть. В этом случае в следующей строке выведите n различных целых положительных чисел bj — элементы множества B (1 ≤ bj ≤ 106). Если подходящих ответов несколько, выведите любой из них.",
      "sample_tests": "ПримерВходные данныеСкопировать331 10 1001122 4Выходные данныеСкопироватьYES1 2 3 YES1 YES1 2",
      "description": "A. Теория множеств\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВходные данные содержат несколько тестовых наборов. В первой строке задано количество тестов t (1 ≤ t ≤ 100).Каждый из тестов описывается следующим образом: в первой строке описания теста содержатся одно число n — размер множества A (1 ≤ n ≤ 100).В следующей строке содержатся n чисел ai — числа, принадлежащие множеству A (1 ≤ ai ≤ 106).\n\nВходные данные\n\nВыходные данныеДля каждого теста в отдельной строке сначала выведите ответ на него:   NO, если не существует ни одного способа построить множество B, чтобы выполнить условие задачи.  YES, если способ решить задачу есть. В этом случае в следующей строке выведите n различных целых положительных чисел bj — элементы множества B (1 ≤ bj ≤ 106). Если подходящих ответов несколько, выведите любой из них.\n\nВыходные данные\n\nВходные данныеСкопировать331 10 1001122 4Выходные данныеСкопироватьYES1 2 3 YES1 YES1 2\n\nВходные данныеСкопировать331 10 1001122 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 2 3 YES1 YES1 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2017 — Финал + трансляция на CF - Codeforces",
          "content": "Всем привет!10 сентября 2017 года, в 13:00 по московскому времени состоится финал Russian Code Cup 2017! Раунд продлится 3 часа. 55 участников финального раунда сразятся за призы, и мы все с нетерпением ждем возможности поболеть за них на сайте http://russiancodecup.ru.Ну а для всех остальных участников мы подготовили сюрприз: если вы хотите попробовать свои силы в решении задач, приходите на codeforces.com после финала, в 16:35 по московскому времени состоится раунд по задачам RCC 2017, открытый для всех желающих. Несколько уточнений: Раунд пройдет по правилам ACM; Раунд будет нерейтинговым; Сложность задач будет близка к Div 1 раунду; Мы просим участников финала после окончания официального соревнования воздержаться от публикации и обсуждения задач до окончания раунда-трансляции, и, разумеется, в нем не участвовать; Производительность инвокеров сайта RCC и CF различная, \"у меня прошло/не прошло решение на CF, а на RCC было по-другому\" не может быть поводом для апелляции. UPD Официальное соревнование завершено, поздравляем победителей! Всем остальным удачи на раунде.UPD2 Разбор задач",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1101
        },
        {
          "title": "Russian Code Cup 2017 Finals — Results and Editorial - Codeforces",
          "content": "Во-первых, поздравляем jqdai0815 с победой, LHiC и jcvb со вторым и третьим местом. Финал оказался сложным и мы рады, что борьба была жесткой.Задачи для раунда придумали и готовили Aksenov239, GShark, izban, manoprenko, niyaznigmatul, qwerty787788 и SpyCheese, руководитель жюри andrewzta. Отдельно хочется отметить Илью Збаня izban, который является автором задач D, E и F, а также дал огромное количество полезных комментариев по всем задачам раунда.Теперь перейдем к разбору.A. Теория множествДля начала докажем, что ответ всегда YES.Будем последовательно перебирать bj и проверять, что при суммировании его со всеми ai мы не получим сумму, которую уже можно получить другим способом. Оценим максимальный элемент в множестве B. Посмотрим, почему некоторый элемент bj2, может не подходить. Это означает, что ai1 + bj1 = ai2 + bj2, то есть bj2 = bj1 - (ai2 - ai1). Каждый элемент B таким образом запрещает O(n2) различных значений, из чего следует, что max(B) есть O(n3) в худшем случае, поэтому, в частности, при заданных ограничениях ответ всегда существует.Теперь ускорим проверку, что очередной элемент подходит. Заведем массив bad, в котором будем отмечать числа, которые в дальнейшем не подойдут для множества B. Теперь при переборе bj, если текущее число не отмечено в bad, то его можно взять в ответ. В дальнейшем в ответ нельзя будет взять числа, которые равны bj + ai1 - ai2, отметим их в массиве bad. Сложность решения O(n3). B. Похожие словаРассмотрим следующий граф: множеством вершин в нем будет множество всех префиксов данных нам слов, ребро будем проводить между двумя вершинами, если соответствующие этим вершинам префиксы являются похожими. Заметим, что количество вершин в этом графе не превышает суммарной длины строк.Несложно доказать, что получившийся граф будет являться лесом. Действительно, если два префикса похожи, то давайте скажем, что более короткий является родителем более длинного. Таким образом, у каждой вершины есть не более одного родителя, а при переходе к родителю длина уменьшается, поэтому циклов нет. Значит, граф является лесом.Заметим теперь, что множество, которое состоит из префиксов исходных слов, и не содержит похожих слов, в построенном нами графе является независимым множеством. Построив этот граф, мы сможем применить какой-нибудь из методов нахождения максимального независимого множества в дереве, например, жадность или динамическое программирование.Рассмотрим два способа построения этого графа.Способ 1. ХешиДля каждого префикса посчитаем его хеш, и сохраним все эти хеши. Теперь, для каждого префикса посчитаем его хеш без первой буквы, и проверим, есть ли этот хеш среди хешей всех префиксов. Если есть, то соединим соответствующие префиксы ребром.Способ 2. Ахо-КорасикПостроим автомат Ахо-Корасик для данного набора строк. Вершинами нашего графа будут вершины автомата. Заметим, что ребро в нашем графе следует провести между двумя вершинами тогда и только тогда, когда глубины этих вершин отличаются на 1, и из одной в другую ведет суффиксная ссылка. C. ОдиннадцатилетиеВоспользуемся признаком делимости на одиннадцать. А именно нам необходимо, чтобы сумма цифр, стоящих на нечетных позициях, равнялась сумме цифр на четных позициях по модулю одиннадцать. Значит, во-первых, из числа на карточке нас интересует только сумма его цифр по модулю одиннадцать, где цифры на четных позициях взяты со знаком плюс, а на нечетных — со знаком минус. Во-вторых, для каждой карточки нам интересна четность количества цифр в карточках до нее, а вся остальная информация о других карточках не нужна.Все карточки разобьем на две группы по четности длины цифр на них. Вначале расставим все карточки, на которых числа нечетной длины. Половина из них будет взята со знаком плюс, а другая половина с минусом. Воспользуемся методом динамического программирования. В состояние будет входить количество уже просмотренных карточек, количество карточек, которое взято со знаком плюс и текущая сумма по модулю одиннадцать. Из каждого состояния всего два перехода — либо взять карточку со знаком плюс, либо со знаком минус.Если нет ни одной карточки с числом нечетной длины, то вне зависимости от расстановки карточек, остаток от деления на 11 будет один и тот же, так что ответ равен либо 0, либо n!. Иначе, каждое число четной длины можно взять как с плюсом, так и с минусом. Также воспользуемся аналогичным методом динамического программирования, чтобы посчитать количество способов получить некоторый остаток по модулю 11 с помощью карточек с числами четной длины. В конце объединим результаты для чисел четной и нечетной длины и посчитаем только те варианты, где суммарный остаток от деления на одиннадцать равен нулю. Итого суммарное временем работы O(n2). D. КактусоманияДля решения воспользуемся динамическим программированием на корневом дереве. Пусть fv — максимальное число ребер, у которых оба конца лежат в поддереве с корнем в вершине v, и при их добавлении это поддерево становится кактусом. Для подсчета функции f нужно разобрать два случая: вершина v покрыта каким-нибудь циклом или нет. Если вершина v не покрыта циклом, то fv равно сумме fu, для всех u детей вершины v. Если же вершина v покрыта циклом, то нужно перебрать, каким именно циклом она покрыта. Для этого переберем все ребра (x, y) такие, что LCA(x, y) = v. Перебрав добавляемое ребро, нужно мысленно удалить этот путь из x в y, посчитать сумму fu по всем u — корням получившихся после удаления этого пути поддеревьев, и прибавить к ней красоту рассматриваемого ребра.Так мы получили решение за O(nm).Для ускорения решения придется воспользоваться структурами данных. Во-первых, надо будет вычислить LCA (наименьшего общего предка), чтобы понять, когда следует пытаться добавить это ребро. Любой достаточно быстрый стандартный алгоритм подойдет. Во-вторых, надо быстро вычислять сумму fu всех поддеревьев, получившихся после удаления пути. Для этого заведем вспомогательные значения: gu = fp - fu, где p — родитель u в дереве, а также sv = sum(fu), где u — дети вершины v. Тогда сумма fu всех поддеревьев после удаления — это сумма значений sx, sy, sv - fx' - fy', суммы на пути [x, x') значения gi и суммы на пути [y, y') значения gi, где x' — это ребенок v, в поддереве которого лежит x и y' — ребенок v, в поддереве которого лежит y. Понадобится структура данных, которая поддерживает изменение в вершине и сумму на пути. Подойдет любая структура для суммы на отрезке, дерево отрезков или дерево Фенвика. Время работы: O((n + m)log(n)). E. СпутникиЛюбая точка X задаётся двумя углами α = XAB и β = XBA. Точка (α2, β2) находится в зоне покрытия спутника в точке (α1, β1), если α2 ≤ α1 и β2 ≤ β1.Пусть два спутника, между которыми нужно установить связь, находятся в точках (α1, β1) и (α2, β2). Ретранслятор должен находиться в такой точке (α0, β0), что α0 ≤ min(α1, α2) и β0 ≤ min(β1, β2). Поскльку требуется, чтобы он не находился в зоне видимости других спутников, следует выбирать α0 и β0 как можно больше: α0 = min(α1, α2), β0 = min(β1, β2).Перейдём к решению. Рассмотрим запрос типа 3: даны два спутника (α1, β1) и (α2, β2). Нужно проверить, что точку (α0, β0) = (min(α1, α2), min(β1, β2)) не видит ни один другой спутник. Это означает, что среди спутников с α ≥ α0 максимальный β меньше β0.Отсортируем все спутники из всего теста по α. В каждый момент времени для каждого спутника будем хранить его β, если он сейчас существует, и  - ∞, если нет. Построим на этом дерево отрезков на максимум. При добавлении и удалении спутника будем обновлять значения. При запросе типа 3 будем запрашивать максимум на суффиксе. Чтобы не учитывать два спутника из запроса 3, перед запросом максимума присвоим в их ячейки  - ∞, а затем вернём соответствующие β.В этом решении используются числа с плавающей запятой. От них следует избавиться. Для этого не будем явно считать углы. Сортировать по α будем при помощи векторного произведения. Вместо того, чтобы хранить в дереве отрезков β, отсортируем спутники по β при помощи векорных произведений и будем хранить индексы.Кроме того, нужно проверять, что точка (α0, β0) не лежит внутри планеты. Точка X лежит внутри, если угол AXB тупой, то есть, скалярное произведение XA и XB меньше нуля. Точку X плохо искать в явном виде, так как её координаты не обязательно целые, но векторы, коллинеарные XA и XB, найти можно — это некоторые из векторов, соединяющие точки запроса и точки A и B. F. Играть или не игратьПерейдем в координаты y(x), где x = exp1 - exp2, а y = exp1 (exp1, exp2 — опыт первого и второго игроков в некоторый момент времени соответственно). Будем идти по отрезкам времени и поддерживать множество достижимых состояний на этой плоскости.Лемма 1: есть оптимальное решение, в котором на всех отрезках, где могут играть оба, оба играют (доказательство в конце).Есть три перехода: Может играть лишь первый игрок t времени. Это значит, что новый многоугольник — сумма Минковского старого многоугольника и вырожденного многоугольника на двух вершинах (0, 0) и (t, t). Может играть лишь второй игрок t времени. Это значит, что новый многоугольник — сумма Минковского старого многоугольника и вырожденного многоугольника на двух вершинах (0, 0) и ( - t, 0). Могут играть оба игрока t времени. Поскольку не выгодно, чтобы играл лишь один из них (лемма 1), нужно всем точкам с координатами в [ - C;C] прибавить 2t в y-координату, а остальным точкам прибавить t в y-координату. Посмотрим на структуру множества достижимых точек. Это многоугольник, монотонный относительно оси OX (любая прямая параллельная OY пересекает его в  ≤ 2 точках), при чем нижняя ломаная этого многоугольника — y = 0 при x ≤ 0 и y = x при x > 0. Эти два факта непосредственно следуют из того, что все три операции сохраняют эти инварианты. Таким образом, нам интересно следить лишь за верхней огибающей многоугольника.Покажем, что y-координата верхней части многоугольника у нас будет не убывать с ростом x-координаты, и состоит верхняя часть ломаной из векторов (+1,0) и (+1,+1). Пусть по индукции это верно. После переходов первых двух типов монотонность сохраняется на всей ломаной: первый переход лишь сдвигает старую верхнюю часть ломаной на (+1, +1), а второй переход сдвигает верхнюю часть ломаной на (-1,0). Но вот операция третьего типа может нарушить монотонность в точке x = C, так там происходит сдвиг по OY на разные величины. Исправим это, несколько изменив смысл многоугольника, который мы поддерживаем: если раньше это было множество всех достижимых состояний, то теперь будем поддерживать монотонное множество точек, возможно не все из которых можно получить, но имеющее такой же максимальный достижимый опыт из любой точки множества.Для этого докажем лемму: если в момент времени t взять две точки (не важно, достижимы ли они к моменту времени t) P1 = (x1, y1) и P2 = (x2, y2) такие, что C ≤ x1 ≤ x2, и y1 ≥ y2, то ответ для точки P2 не больше, чем ответ для точки P1. Для этого возьмем сертификат, ведущий к оптимальному ответу из точки P2 — это некоторая последовательность переходов первого, второго и третьего типа, и выкинем из нее первых переходов второго типа ровно на x2 - x1 (единственных, уменьшающих x). Можно заметить, что полученный сертификат — корректный набор действий из точки P1, и имеет такой же сдвиг по y, так как области двойного опыта будут ровно такими же (до момента совпадения x-координат его быть не может, т.к. x2 - C ≥ x2 - x1, а с этого момента времени графики движения будут совпадать).Таким образом, после операции третьего типа можно взять на суффиксе x для [C; + inf) максимум между сдвинутой ломаной и прямой y = y(C). Абсолютно аналогично доказывается, что ломаную можно промажорировать прямой y = y(C) - (C - x) на отрезке ( - inf;C]. Таким образом, после перехода ломаная все еще осталась монотонно неубывающей, состоящей из ребер (+1,0) и (+1,+1).Для решения задачи нужно научиться быстро совершать необходимые переходы с этой ломаной.Легко заметить, что в ней линейное число вершин, так как все операции добавляют константное число новых ребер: первые две не изменяют количество вершин ломаной, а третья создает два новых ребра и, возможно, выкидывает несколько старых. Можно хранить ломаную в декартовом дереве — тогда легко разрезать ломаную в точках  - C и  + C, вставить в нужное место новые ребра и удалить несколько старых. Таким образом, получили решение, работающее за O(nlogn).Лемма 1, доказательство: рассмотрим оптимальное решение, и посмотрим на первый отрезок, где могли играть оба, но играет лишь один. Если |x| = |exp1 - exp2| ≤ C, это делать точно не выгодно. Иначе, для определенности, x <  - C. Понятно, что в оптимальном решении точка еще вернется в полосу |x| ≤ C (иначе оба могут спокойно играть). Если сейчас играет лишь первый игрок (прибавляется вектор (+1, +1)), то раньше, естественно, был момент после последнего посещения полосы двойного опыта, когда играл лишь второй игрок (вектор (-1, 0)). Пусть в тот момент второй игрок не играл, а сейчас играют оба, итоговая позиция сохраняется, а первый момент, когда играет один, но не оба, отдалился. Случаи, когда играет лишь первый игрок, и x > C, разбираются абсолютно аналогично, убирая момент времени, когда играет лишь один из игроков, но добавляя момент, когда играют оба.",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54452",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 13148
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n    for (int test = 1; test <= t; ++test) {\n        int n = inf.readInt(1, 100, \"n\");\n        inf.readEoln();\n        vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n        inf.readEoln();\n        set<int> s(a.begin(), a.end());\n        ensuref(s.size() == n, \"Elements of A must be distinct, but test case %d has duplicates\", test);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n    for (int test = 1; test <= t; ++test) {\n        int n = inf.readInt(1, 100, \"n\");\n        inf.readEoln();\n        vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n        inf.readEoln();\n        set<int> s(a.begin(), a.end());\n        ensuref(s.size() == n, \"Elements of A must be distinct, but test case %d has duplicates\", test);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n    for (int test = 1; test <= t; ++test) {\n        int n = inf.readInt(1, 100, \"n\");\n        inf.readEoln();\n        vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n        inf.readEoln();\n        set<int> s(a.begin(), a.end());\n        ensuref(s.size() == n, \"Elements of A must be distinct, but test case %d has duplicates\", test);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int t = inf.readInt();\n\n    for(int test = 1; test <= t; test++){\n        int n = inf.readInt();\n        vector<int> A(n);\n        for(int i = 0; i < n; i++){\n            A[i] = inf.readInt();\n        }\n\n        string pans = ouf.readToken();\n        transform(pans.begin(), pans.end(), pans.begin(), ::toupper);\n\n        if (pans != \"YES\" && pans != \"NO\")\n            quitf(_wa, \"Participant's answer is neither YES nor NO on test case %d\", test);\n\n        if (pans == \"NO\") {\n            // Acceptable\n            continue;\n        } else { // pans == \"YES\"\n            vector<int> B(n);\n            for(int i = 0; i < n; i++){\n                if (ouf.eof())\n                    quitf(_wa, \"Participant's output is incomplete on test case %d\", test);\n                B[i] = ouf.readInt(1, 1000000, format(\"B[%d]\", i + 1).c_str());\n            }\n            // Check that bj are distinct\n            set<int> bSet(B.begin(), B.end());\n            if (bSet.size() != n)\n                quitf(_wa, \"Duplicate elements in B on test case %d\", test);\n\n            // Check that ai + bj are all distinct\n            set<int> sumSet;\n            for (int i = 0; i < n; i++){\n                for (int j = 0; j < n; j++){\n                    int sum = A[i] + B[j];\n                    if (sumSet.count(sum))\n                        quitf(_wa, \"Sums of ai + bj are not unique on test case %d\", test);\n                    sumSet.insert(sum);\n                }\n            }\n            // Answer is acceptable\n            continue;\n        }\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1); // number of test cases\n    int n = opt<int>(\"n\");    // size of set A (must be provided)\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    assert(1 <= t && t <= 100);\n    assert(1 <= n && n <= 100);\n\n    printf(\"%d\\n\", t);\n\n    for (int test = 0; test < t; test++) {\n        vector<int> a;\n\n        if (type == \"random\") {\n            // Generate n distinct random ai in [1, 1e6]\n            set<int> s;\n            while ((int)s.size() < n) {\n                int x = rnd.next(1, 1000000);\n                s.insert(x);\n            }\n            a.assign(s.begin(), s.end());\n            shuffle(a.begin(), a.end());\n        } else if (type == \"small_ai\") {\n            // Generate ai = 1 to n\n            for (int i = 1; i <= n; i++)\n                a.push_back(i);\n        } else if (type == \"large_ai\") {\n            // Generate ai = 1e6 - n + 1 to 1e6\n            for (int i = 1000000 - n + 1; i <= 1000000; i++)\n                a.push_back(i);\n        } else if (type == \"impossible\") {\n            // Generate ai = 1 to n, designed to be impossible\n            for (int i = 1; i <= n; i++)\n                a.push_back(i);\n        } else if (type == \"same_mod\") {\n            // Generate ai such that ai mod k = c\n            int k = opt<int>(\"k\", 10);\n            int c = rnd.next(0, k - 1);\n            set<int> s;\n            while ((int)s.size() < n) {\n                int x = rnd.next(1, 1000000);\n                if (x % k == c)\n                    s.insert(x);\n            }\n            a.assign(s.begin(), s.end());\n            shuffle(a.begin(), a.end());\n        } else if (type == \"middle_ai\") {\n            // Generate ai around 500000\n            int base = 500000 - n / 2;\n            for (int i = 0; i < n; i++)\n                a.push_back(base + i);\n        } else {\n            // default to random\n            set<int> s;\n            while ((int)s.size() < n) {\n                int x = rnd.next(1, 1000000);\n                s.insert(x);\n            }\n            a.assign(s.begin(), s.end());\n            shuffle(a.begin(), a.end());\n        }\n\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; i++)\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1); // number of test cases\n    int n = opt<int>(\"n\");    // size of set A (must be provided)\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    assert(1 <= t && t <= 100);\n    assert(1 <= n && n <= 100);\n\n    printf(\"%d\\n\", t);\n\n    for (int test = 0; test < t; test++) {\n        vector<int> a;\n\n        if (type == \"random\") {\n            // Generate n distinct random ai in [1, 1e6]\n            set<int> s;\n            while ((int)s.size() < n) {\n                int x = rnd.next(1, 1000000);\n                s.insert(x);\n            }\n            a.assign(s.begin(), s.end());\n            shuffle(a.begin(), a.end());\n        } else if (type == \"small_ai\") {\n            // Generate ai = 1 to n\n            for (int i = 1; i <= n; i++)\n                a.push_back(i);\n        } else if (type == \"large_ai\") {\n            // Generate ai = 1e6 - n + 1 to 1e6\n            for (int i = 1000000 - n + 1; i <= 1000000; i++)\n                a.push_back(i);\n        } else if (type == \"impossible\") {\n            // Generate ai = 1 to n, designed to be impossible\n            for (int i = 1; i <= n; i++)\n                a.push_back(i);\n        } else if (type == \"same_mod\") {\n            // Generate ai such that ai mod k = c\n            int k = opt<int>(\"k\", 10);\n            int c = rnd.next(0, k - 1);\n            set<int> s;\n            while ((int)s.size() < n) {\n                int x = rnd.next(1, 1000000);\n                if (x % k == c)\n                    s.insert(x);\n            }\n            a.assign(s.begin(), s.end());\n            shuffle(a.begin(), a.end());\n        } else if (type == \"middle_ai\") {\n            // Generate ai around 500000\n            int base = 500000 - n / 2;\n            for (int i = 0; i < n; i++)\n                a.push_back(base + i);\n        } else {\n            // default to random\n            set<int> s;\n            while ((int)s.size() < n) {\n                int x = rnd.next(1, 1000000);\n                s.insert(x);\n            }\n            a.assign(s.begin(), s.end());\n            shuffle(a.begin(), a.end());\n        }\n\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; i++)\n            printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying n and t\n./gen -t 1 -n 1 -type random\n./gen -t 1 -n 2 -type random\n./gen -t 1 -n 10 -type random\n./gen -t 5 -n 20 -type random\n./gen -t 10 -n 50 -type random\n./gen -t 20 -n 100 -type random\n\n# Test cases with small_ai (A = 1..n)\n./gen -t 1 -n 1 -type small_ai\n./gen -t 2 -n 2 -type small_ai\n./gen -t 5 -n 10 -type small_ai\n./gen -t 10 -n 50 -type small_ai\n./gen -t 20 -n 100 -type small_ai\n\n# Test cases with large_ai (A = 1e6 - n + 1 .. 1e6)\n./gen -t 1 -n 1 -type large_ai\n./gen -t 2 -n 2 -type large_ai\n./gen -t 5 -n 10 -type large_ai\n./gen -t 10 -n 50 -type large_ai\n./gen -t 20 -n 100 -type large_ai\n\n# Test cases designed to be impossible (answer should be NO)\n./gen -t 1 -n 2 -type impossible\n./gen -t 1 -n 50 -type impossible\n./gen -t 1 -n 100 -type impossible\n\n# Test cases with same_mod (all ai have the same remainder modulo k)\n./gen -t 5 -n 10 -type same_mod -k 2\n./gen -t 5 -n 10 -type same_mod -k 5\n./gen -t 5 -n 20 -type same_mod -k 10\n./gen -t 5 -n 50 -type same_mod -k 2\n./gen -t 5 -n 100 -type same_mod -k 5\n\n# Test cases with middle_ai (ai around 500,000)\n./gen -t 1 -n 1 -type middle_ai\n./gen -t 5 -n 10 -type middle_ai\n./gen -t 10 -n 50 -type middle_ai\n./gen -t 20 -n 100 -type middle_ai\n\n# Mixed types and larger test cases\n./gen -t 10 -n 25 -type random\n./gen -t 20 -n 100 -type random\n./gen -t 10 -n 100 -type random\n./gen -t 5 -n 100 -type small_ai\n./gen -t 5 -n 100 -type large_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:34.059383",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "856/B",
      "title": "B. Similar Words",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputInput data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases. The descriptions of test cases follow.The first line of each description contains an integer n — the number of words in the set S (1 ≤ n ≤ 106). Each of the following n lines contains one non-empty word — elements of S. All words in S are different.It is guaranteed that the total length of all words in one input data doesn't exceed 106.",
      "output_spec": "OutputFor each test case print one line that contains one integer m — the maximal number of words that X can contain.",
      "sample_tests": "ExampleInputCopy23abababaaaab2aaaOutputCopy61",
      "description": "B. Similar Words\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases. The descriptions of test cases follow.The first line of each description contains an integer n — the number of words in the set S (1 ≤ n ≤ 106). Each of the following n lines contains one non-empty word — elements of S. All words in S are different.It is guaranteed that the total length of all words in one input data doesn't exceed 106.\n\nOutputFor each test case print one line that contains one integer m — the maximal number of words that X can contain.\n\nInputCopy23abababaaaab2aaaOutputCopy61\n\nInputCopy23abababaaaab2aaa\n\nOutputCopy61",
      "solutions": [
        {
          "title": "RCC 2017 — Finals + CF Round - Codeforces",
          "content": "Hi, everyone!On September 10, 2017 at 13:00 Moscow time the final round of Russian Code Cup 2017 will take place! The round will be 3 hours long. 55 participants of the final round will compete for prizes and glory, and we are eager to watch their competition at http://russiancodecup.ru.And we have a nice surprise for the others: if you would like to apply your skills at our finals problems, come to codeforces.com after the Finals is over, at 16:35 Moscow time, the round featuring RCC Finals 2017 problems will take place, open for everybody.Some notes: Round will use ACM rules; It will be unrated; Problem difficulty will be close to Div 1 round; We ask RCC finalists not to publish or discuss problems after the end of the Finals before the CF round ends, of course you shouldn't participate in CF round; Judging machines at RCC and CF are different, \"my solution passed/failed at CF, and it was different at RCC\" is not a valid appeal. UPD The official contest is over, congratulations to the winners! And good luck to CF Round participants.UPD2 Editorial",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Russian Code Cup 2017 Finals — Results and Editorial - Codeforces",
          "content": "First of all, congratulations to jqdai0815 for winning, LHiC and jcvb for coming second and third. The Final Round proved to be quite challenging, and we are happy that the results are tight.The round was prepared by Aksenov239, GShark, izban, manoprenko, niyaznigmatul, qwerty787788 and SpyCheese, supervisor andrewzta. Special thanks for this round goes to izban who is the author of problems D, E and F, and also gave a lot of important comments for all problems of the round.Now let us move on to the editorial.A. Set TheoryFirst let us prove that the answer is always YES.Let us iterate over bj and check if summing it up with all ai values don't result in values that we already have. If no conflict is found, add the corresponding bj to B.Let us give some estimate for the maximum element of B. The reason that we cannot include bj2, to B is the equality ai1 + bj1 = ai2 + bj2, so bj2 = bj1 - (ai2 - ai1). Each element of B forbids O(n2) values, so max(B) is O(n3). That means that the answer always exists for the given constraints.Now let us speed up the test that we can add a number to B. Let us use an array bad, that marks the numbers that we are not able to include to B. When trying the value bj, we can add it to B if it is not marked in bad. Now the numbers that are equal to bj + ai1 - ai2 are forbidden, let us mark them in bad. The complexity is O(n3) for each test case. B. Similar WordsLet us consider the following similarity graph: the vertices are the prefixes of the given words, two vertices are connected by an edge if the corresponding words are similar. Note that the set of vertices in this graph is the same as in the trie for the given words, so it doesn't exceed the sum of lengths of words.Let us prove that the resulting graph is a forest. If two words are similar, let us call the shorter one the parent of the longer one. Each vertex now has at most one parent, and there are no cycles, so the graph is a set of trees — a forest.Now the required set is the independent set in the constructed similarity graph, so we can use dynamic programming or greedy algorithm to find it.There are two ways to construct the similarity graph.Way 1. Hashes For each prefix find its hash, make a set of all hashes. Now for each prefix remove its first letter, check if such hash exists. If it does, connect them by an edge.Way 2. Aho-CorasickLet us build Aho-Corasick automaton for the given set of words. The vertices of the similarity graph are automaton vertices. An edge exists between two vertices if the suffix link from one of them goes to the other one, and their depths differ by exacly 1. C. Eleventh BirthdayLet us use divisibility rule for eleven. The number is divisible by eleven if the sum of digits at odd positions is equal to the sum of digits at even positions modulo 11. So for each number on a card there are only two parameters that we care about: the sign interchanging sum of its digits with digits at odd positions positive and digits at even position negative, and the parity of its digit count.Let us divide all cards to two groups: with even digit count and with odd digit count. Let us first put cards with numbers that have odd count of digits. Half of them (rounded up) will have their sign interchanging sum used as positive, other half as negative. Let us use dynamic programming to find the number of ways to sum them up to have a given sum modulo 11. The state includes the number of cards considered, the number of cards that are used as positive, and the current sum modulo 11. There are two transitions: take the current card as positive, and take it as negative.If there are no cards with odd digit count, no matter how you order even digit count cards the result modulo 11 is the same. So the answer is either 0 or n!. In the other case each even digit count card can be used either as positive, or as negative, independent of the other cards. Use analogous dynamic programming to count the number of ways to get each possible sum modulo 11. Finally, combine results for even and odd digit count cards, getting the total sum modulo 11 equal to 0. Time complexity is O(n2). D. Masha and CactusLet us use dynamic programming for a rooted tree and some data structures. Denote as fv the maximal total beauty of edges that have both ends in a subtree of v, such that if we add them all to the subtree it would be a cactus.To calculate fv let us consider two cases: v belongs to some cycle, or it doesn't. If it doesn't belong to any cycle, fv is equal to the sum of fu for all children u of v. If v belongs to a cycle, let us iterate over all possible cycles it can belong to. Such cycle is generated by an added edge (x, y) such that LCA(x, y) = v. Try all possible such edges and then temporarily delete a path from x to y from a tree, calculate the sum of fu for all u — roots of the isolated subtrees after the deletion of the path, and add it to the beauty of (x, y).Now we have an O(nm) solution.To speed up this solution let us use some data structures. First, we need to calculate LCA for all endpoints of the given edges, any fast enough standard algorithm is fine. The second thing to do is to be able to calculate the sum of fu for all subtrees after removing the path. To do it, use the following additional values: gu = fp - fu, where p is the parent of u, and sv = sum(fu), where u are the children of v. Now the sum of fu for all subtrees after x - y path removal is the sum of the following values: sx, sy, sv - fx' - fy', the sum of gi for all i at [x, x'), the sum of gi for all i at [y, y'), where x' is the child of v that has x in its subtree, and y' is the child of v that has y in its subtree. We need some data structure for a tree that supports value change in a vertex and the sum for a path, range tree or Fenwick are fine. The complexity is O((n + m)log(n)). E. SatellitesAny point X can be given by two angles α = XAB and β = XBA. The point (α2, β2) is in coverage area of a satellite at the point (α1, β1), if α2 ≤ α1 and β2 ≤ β1.Let two satellites that want to create a communication channel are at points (α1, β1) and (α2, β2). Repeater must be positioned in such point (α0, β0), that α0 ≤ min(α1, α2) and β0 ≤ min(β1, β2). To make it harder for it to get to other satellites coverage area, it is reasonable to maximize α0 and β0: α0 = min(α1, α2), β0 = min(β1, β2).Now let us move to a solution. Consider a query of type 3: you are given two satellites at points (α1, β1) and (α2, β2). You must check whether the point (α0, β0) = (min(α1, α2), min(β1, β2)) is not in the coverage area of any other satellite. That means that among all satellites with α ≥ α0 the maximum value of β is smaller than β0.The solution is offline, it considers all satellites from the test data and just turns them on and off. Sort all satellites by α. Each moment for each satellite we store its β if it exists, or  - ∞ if it doesn't. Let us build a range tree for maximum, and update values as satellites come and go. The query is a range maximum. To avoid considering the satellites from the query, change their values to  - ∞ before the query, and restore them afterwards.The next thing to do is to get rid of floating point numbers. Instead of calculating the angle values, we will only compare them using cross product. Similarly, instead of storing β values in range tree, we will store indices and compare them by cross product in integers.The final remark: we need to check that the point (α0, β0) is not inside the planet. The point is inside the planet, if the angle AXB is obtuse, that can be checked by a scalar product of XA and XB. The point X can have non-integer coordinates, so we will not look for it, but will use colinear vectors from among those connecting satellite points to A and B. F. To Play or not to PlayWe give the main ideas of the solution, leaving proofs as an exercise.Let us introduce coordinates y(x), where x = exp1 - exp2, and y = exp1 (exp1, exp2 — experience of the first and the second player, respectively). Let us proceed with time, and keep the set of possible states at this plane. It is a polygon.Lemma 1: in the optimal solution if at some moment both players can play the game simultaneously, they should do so.Now consider all moments of time, one after another. There are three transitions that modify the polygon: The first player can play for t seconds. The new polygon is the Minkowski sum of the previous polygon and the degenerate polygon: segment with two vertices (0, 0) and (t, t). The second player can play for t seconds. The new polygon is the Minkowski sum of the previous polygon and the segment with vertices (0, 0) and ( - t, 0). Both players can play for t seconds. Now all points with x-coordinates [ - C;C] have 2t added to their y coordinate, and other points have t added to their y coordinate. Let us now see how the polygon looks like. It is x-monotonous polygon (each line parallel to y-axis intersects it via a segment), the lower bound of this polygon is y = 0 if x ≤ 0 and y = x if x > 0. Let us see how the upper bound of the polygon looks like.We want to prove that y-coordinate of the upper bound of the polygon doesn't decrease, and it only contains segments that move by vectors ( + 1, 0) and ( + 1,  + 1). We attempt an induction, and the induction step is fine for the first two transitions. But the third transition can make the upper bound non-monotonous at a point x = C. To fix it, let us change the definition of our polygon.Instead of storing all possible reachable points, we will keep larger set, that contains the original set, and for each of its point we can get maximal experience for the first player not greater than what we could originally get.Lemma 2: if at some moment t we take two points P1 = (x1, y1) and P2 = (x2, y2) such that C ≤ x1 ≤ x2, and y1 ≥ y2, and our player start training from those states, the maximal experience for point P2 is not greater than for the point P1. So we can expand our upper bound for x from [C; + inf) by a maximum value of the correct upper bound and y = y(C). The similar proof works for a line y = y(C) - (C - x) for x in ( - inf;C]. Now we have an upper bound as a polyline that contains ( + 1, 0) and ( + 1,  + 1) segments. All is left to do is to modify the polyline using the described transitions. This can be done using some appropriate data structure, treap for example. The solution works in O(nlog(n)).",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54452",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10417
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int T_MAX = 1000000;\n    const long long N_MAX = 1000000LL;\n    const long long TOTAL_LENGTH_MAX = 1000000LL;\n\n    int t = inf.readInt(1, T_MAX, \"t\");\n    inf.readEoln();\n\n    long long total_n = 0;\n    long long total_length = 0;\n\n    for (int tc = 1; tc <= t; tc++) {\n        int n = inf.readInt(1, 1000000, \"n\");\n        total_n += n;\n        ensuref(total_n <= N_MAX, \"Total number of words exceeds %lld after test case %d\", N_MAX, tc);\n        inf.readEoln();\n\n        unordered_set<string> s;\n\n        for (int i = 0; i < n; i++) {\n            string word = inf.readToken(\"[a-z]+\", \"word\");\n            total_length += word.length();\n            ensuref(total_length <= TOTAL_LENGTH_MAX, \"Total length of words exceeds %lld after test case %d\", TOTAL_LENGTH_MAX, tc);\n            ensuref(s.find(word) == s.end(), \"Word '%s' occurs multiple times in test case %d\", word.c_str(), tc);\n            s.insert(word);\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int T_MAX = 1000000;\n    const long long N_MAX = 1000000LL;\n    const long long TOTAL_LENGTH_MAX = 1000000LL;\n\n    int t = inf.readInt(1, T_MAX, \"t\");\n    inf.readEoln();\n\n    long long total_n = 0;\n    long long total_length = 0;\n\n    for (int tc = 1; tc <= t; tc++) {\n        int n = inf.readInt(1, 1000000, \"n\");\n        total_n += n;\n        ensuref(total_n <= N_MAX, \"Total number of words exceeds %lld after test case %d\", N_MAX, tc);\n        inf.readEoln();\n\n        unordered_set<string> s;\n\n        for (int i = 0; i < n; i++) {\n            string word = inf.readToken(\"[a-z]+\", \"word\");\n            total_length += word.length();\n            ensuref(total_length <= TOTAL_LENGTH_MAX, \"Total length of words exceeds %lld after test case %d\", TOTAL_LENGTH_MAX, tc);\n            ensuref(s.find(word) == s.end(), \"Word '%s' occurs multiple times in test case %d\", word.c_str(), tc);\n            s.insert(word);\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int T_MAX = 1000000;\n    const long long N_MAX = 1000000LL;\n    const long long TOTAL_LENGTH_MAX = 1000000LL;\n\n    int t = inf.readInt(1, T_MAX, \"t\");\n    inf.readEoln();\n\n    long long total_n = 0;\n    long long total_length = 0;\n\n    for (int tc = 1; tc <= t; tc++) {\n        int n = inf.readInt(1, 1000000, \"n\");\n        total_n += n;\n        ensuref(total_n <= N_MAX, \"Total number of words exceeds %lld after test case %d\", N_MAX, tc);\n        inf.readEoln();\n\n        unordered_set<string> s;\n\n        for (int i = 0; i < n; i++) {\n            string word = inf.readToken(\"[a-z]+\", \"word\");\n            total_length += word.length();\n            ensuref(total_length <= TOTAL_LENGTH_MAX, \"Total length of words exceeds %lld after test case %d\", TOTAL_LENGTH_MAX, tc);\n            ensuref(s.find(word) == s.end(), \"Word '%s' occurs multiple times in test case %d\", word.c_str(), tc);\n            s.insert(word);\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read in parameters\n    int t = opt<int>(\"t\", 1);\n    int n = opt<int>(\"n\", 1000); // default n = 1000\n    string type = opt<string>(\"type\", \"random\"); // default type is \"random\"\n\n    int total_length = 0;\n    const int MAX_TOTAL_LENGTH = 1000000;\n\n    // Initialize vector to hold test cases\n    vector<vector<string>> test_cases;\n\n    for (int tc = 0; tc < t; ++tc) {\n        vector<string> words;\n        int case_n = 0;\n\n        if (type == \"minimal\") {\n            // Test case with minimal sizes\n            case_n = 1;\n            words.push_back(\"a\");\n            total_length += 1;\n        } else if (type == \"maximal\") {\n            // Test case with maximal n and minimal word length\n            case_n = min(n, MAX_TOTAL_LENGTH - total_length);\n            for (int i = 0; i < case_n; ++i) {\n                char c = rnd.next('a', 'z');\n                string word(1, c);\n                words.push_back(word);\n            }\n            total_length += case_n * 1;\n        } else if (type == \"maximal_length\") {\n            // Test case with a single word of maximum length\n            int word_length = min(MAX_TOTAL_LENGTH - total_length, 1000000);\n            case_n = 1;\n            string word = \"\";\n            for (int j = 0; j < word_length; ++j) {\n                word += rnd.next('a', 'z');\n            }\n            words.push_back(word);\n            total_length += word_length;\n        } else if (type == \"overlapping_prefixes\") {\n            // Words that share common prefixes\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 10);\n            string base = \"\";\n            int base_length = rnd.next(5, 10);\n            for (int i = 0; i < base_length; ++i) {\n                base += rnd.next('a', 'z');\n            }\n            for (int i = 0; i < case_n; ++i) {\n                int len = rnd.next(1, base_length);\n                string word = base.substr(0, len);\n                // Add random suffix\n                int suffix_length = rnd.next(0, 5);\n                for (int j = 0; j < suffix_length; ++j) {\n                    word += rnd.next('a', 'z');\n                }\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n        } else if (type == \"similar_words\") {\n            // Words where removing first letter creates other words\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 5);\n            set<string> s;\n            for (int i = 0; i < case_n; ++i) {\n                int len = rnd.next(2, 10);\n                string word = \"\";\n                for (int j = 0; j < len; ++j) {\n                    word += rnd.next('a', 'z');\n                }\n                s.insert(word);\n                s.insert(word.substr(1));\n            }\n            for (auto& word : s) {\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n            case_n = words.size();\n        } else if (type == \"dissimilar_words\") {\n            // Words designed to have maximum possible set X\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 10);\n            string word = \"\";\n            for (int i = 0; i < case_n; ++i) {\n                word += rnd.next('a', 'z');\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n        } else {\n            // Random words\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 10);\n            for (int i = 0; i < case_n; ++i) {\n                int len = rnd.next(1, min(1000, MAX_TOTAL_LENGTH - total_length));\n                string word = \"\";\n                for (int j = 0; j < len; ++j) {\n                    word += rnd.next('a', 'z');\n                }\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n        }\n        if (words.empty()) break;\n        // Remove duplicates\n        sort(words.begin(), words.end());\n        words.erase(unique(words.begin(), words.end()), words.end());\n        case_n = words.size();\n        test_cases.push_back(words);\n\n        if (total_length >= MAX_TOTAL_LENGTH) break;\n    }\n\n    // Output t\n    printf(\"%d\\n\", int(test_cases.size()));\n    for (auto& words : test_cases) {\n        printf(\"%d\\n\", int(words.size()));\n        for (auto& word : words) {\n            printf(\"%s\\n\", word.c_str());\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read in parameters\n    int t = opt<int>(\"t\", 1);\n    int n = opt<int>(\"n\", 1000); // default n = 1000\n    string type = opt<string>(\"type\", \"random\"); // default type is \"random\"\n\n    int total_length = 0;\n    const int MAX_TOTAL_LENGTH = 1000000;\n\n    // Initialize vector to hold test cases\n    vector<vector<string>> test_cases;\n\n    for (int tc = 0; tc < t; ++tc) {\n        vector<string> words;\n        int case_n = 0;\n\n        if (type == \"minimal\") {\n            // Test case with minimal sizes\n            case_n = 1;\n            words.push_back(\"a\");\n            total_length += 1;\n        } else if (type == \"maximal\") {\n            // Test case with maximal n and minimal word length\n            case_n = min(n, MAX_TOTAL_LENGTH - total_length);\n            for (int i = 0; i < case_n; ++i) {\n                char c = rnd.next('a', 'z');\n                string word(1, c);\n                words.push_back(word);\n            }\n            total_length += case_n * 1;\n        } else if (type == \"maximal_length\") {\n            // Test case with a single word of maximum length\n            int word_length = min(MAX_TOTAL_LENGTH - total_length, 1000000);\n            case_n = 1;\n            string word = \"\";\n            for (int j = 0; j < word_length; ++j) {\n                word += rnd.next('a', 'z');\n            }\n            words.push_back(word);\n            total_length += word_length;\n        } else if (type == \"overlapping_prefixes\") {\n            // Words that share common prefixes\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 10);\n            string base = \"\";\n            int base_length = rnd.next(5, 10);\n            for (int i = 0; i < base_length; ++i) {\n                base += rnd.next('a', 'z');\n            }\n            for (int i = 0; i < case_n; ++i) {\n                int len = rnd.next(1, base_length);\n                string word = base.substr(0, len);\n                // Add random suffix\n                int suffix_length = rnd.next(0, 5);\n                for (int j = 0; j < suffix_length; ++j) {\n                    word += rnd.next('a', 'z');\n                }\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n        } else if (type == \"similar_words\") {\n            // Words where removing first letter creates other words\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 5);\n            set<string> s;\n            for (int i = 0; i < case_n; ++i) {\n                int len = rnd.next(2, 10);\n                string word = \"\";\n                for (int j = 0; j < len; ++j) {\n                    word += rnd.next('a', 'z');\n                }\n                s.insert(word);\n                s.insert(word.substr(1));\n            }\n            for (auto& word : s) {\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n            case_n = words.size();\n        } else if (type == \"dissimilar_words\") {\n            // Words designed to have maximum possible set X\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 10);\n            string word = \"\";\n            for (int i = 0; i < case_n; ++i) {\n                word += rnd.next('a', 'z');\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n        } else {\n            // Random words\n            case_n = min(n, (MAX_TOTAL_LENGTH - total_length) / 10);\n            for (int i = 0; i < case_n; ++i) {\n                int len = rnd.next(1, min(1000, MAX_TOTAL_LENGTH - total_length));\n                string word = \"\";\n                for (int j = 0; j < len; ++j) {\n                    word += rnd.next('a', 'z');\n                }\n                words.push_back(word);\n                total_length += word.length();\n                if (total_length >= MAX_TOTAL_LENGTH) break;\n            }\n        }\n        if (words.empty()) break;\n        // Remove duplicates\n        sort(words.begin(), words.end());\n        words.erase(unique(words.begin(), words.end()), words.end());\n        case_n = words.size();\n        test_cases.push_back(words);\n\n        if (total_length >= MAX_TOTAL_LENGTH) break;\n    }\n\n    // Output t\n    printf(\"%d\\n\", int(test_cases.size()));\n    for (auto& words : test_cases) {\n        printf(\"%d\\n\", int(words.size()));\n        for (auto& word : words) {\n            printf(\"%s\\n\", word.c_str());\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -n 1 -type minimal\n./gen -t 1 -n 1 -type maximal_length\n./gen -t 1 -n 1000000 -type maximal\n./gen -t 1 -n 1000000 -type similar_words\n./gen -t 1 -n 1 -type maximal_length\n./gen -t 1 -n 50000 -type overlapping_prefixes\n./gen -t 1 -n 100000 -type dissimilar_words\n./gen -t 1 -n 10000 -type similar_words\n./gen -t 1 -n 1000 -type dissimilar_words\n./gen -t 1 -n 100000 -type random\n./gen -t 1 -n 50000 -type random\n./gen -t 1 -n 50000 -type random\n./gen -t 5 -n 200000 -type overlapping_prefixes\n./gen -t 10 -n 100000 -type random\n./gen -t 5 -n 200000 -type random\n./gen -t 99 -n 1000 -type random\n./gen -t 1 -n 500000 -type overlapping_prefixes\n./gen -t 1 -n 2 -type minimal\n./gen -t 1 -n 1 -type maximal_length\n./gen -t 1 -n 999999 -type maximal\n./gen -t 1 -n 50000 -type similar_words\n./gen -t 20 -n 5000 -type overlapping_prefixes\n./gen -t 1 -n 50000 -type random\n./gen -t 1 -n 50000 -type random\n./gen -t 1 -n 50000 -type overlapping_prefixes\n./gen -t 5 -n 200000 -type overlapping_prefixes\n./gen -t 1 -n 50000 -type dissimilar_words\n./gen -t 1 -n 1000000 -type maximal\n./gen -t 1 -n 1000000 -type similar_words\n./gen -t 1 -n 100000 -type dissimilar_words\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:36.038615",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "856/C",
      "title": "C. Eleventh Birthday",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputInput data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases (1 ≤ t ≤ 100). The descriptions of test cases follow.Each test is described by two lines.The first line contains an integer n (1 ≤ n ≤ 2000) — the number of cards in Borya's present.The second line contains n integers ai (1 ≤ ai ≤ 109) — numbers written on the cards.It is guaranteed that the total number of cards in all tests of one input data doesn't exceed 2000.",
      "output_spec": "OutputFor each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by 11, print the number modulo 998244353.",
      "sample_tests": "ExampleInputCopy421 131 31 12312345 67 8491 2 3 4 5 6 7 8 9OutputCopy22231680",
      "description": "C. Eleventh Birthday\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases (1 ≤ t ≤ 100). The descriptions of test cases follow.Each test is described by two lines.The first line contains an integer n (1 ≤ n ≤ 2000) — the number of cards in Borya's present.The second line contains n integers ai (1 ≤ ai ≤ 109) — numbers written on the cards.It is guaranteed that the total number of cards in all tests of one input data doesn't exceed 2000.\n\nOutputFor each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by 11, print the number modulo 998244353.\n\nInputCopy421 131 31 12312345 67 8491 2 3 4 5 6 7 8 9OutputCopy22231680\n\nInputCopy421 131 31 12312345 67 8491 2 3 4 5 6 7 8 9\n\nOutputCopy22231680",
      "solutions": [
        {
          "title": "RCC 2017 — Finals + CF Round - Codeforces",
          "content": "Hi, everyone!On September 10, 2017 at 13:00 Moscow time the final round of Russian Code Cup 2017 will take place! The round will be 3 hours long. 55 participants of the final round will compete for prizes and glory, and we are eager to watch their competition at http://russiancodecup.ru.And we have a nice surprise for the others: if you would like to apply your skills at our finals problems, come to codeforces.com after the Finals is over, at 16:35 Moscow time, the round featuring RCC Finals 2017 problems will take place, open for everybody.Some notes: Round will use ACM rules; It will be unrated; Problem difficulty will be close to Div 1 round; We ask RCC finalists not to publish or discuss problems after the end of the Finals before the CF round ends, of course you shouldn't participate in CF round; Judging machines at RCC and CF are different, \"my solution passed/failed at CF, and it was different at RCC\" is not a valid appeal. UPD The official contest is over, congratulations to the winners! And good luck to CF Round participants.UPD2 Editorial",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Russian Code Cup 2017 Finals — Results and Editorial - Codeforces",
          "content": "First of all, congratulations to jqdai0815 for winning, LHiC and jcvb for coming second and third. The Final Round proved to be quite challenging, and we are happy that the results are tight.The round was prepared by Aksenov239, GShark, izban, manoprenko, niyaznigmatul, qwerty787788 and SpyCheese, supervisor andrewzta. Special thanks for this round goes to izban who is the author of problems D, E and F, and also gave a lot of important comments for all problems of the round.Now let us move on to the editorial.A. Set TheoryFirst let us prove that the answer is always YES.Let us iterate over bj and check if summing it up with all ai values don't result in values that we already have. If no conflict is found, add the corresponding bj to B.Let us give some estimate for the maximum element of B. The reason that we cannot include bj2, to B is the equality ai1 + bj1 = ai2 + bj2, so bj2 = bj1 - (ai2 - ai1). Each element of B forbids O(n2) values, so max(B) is O(n3). That means that the answer always exists for the given constraints.Now let us speed up the test that we can add a number to B. Let us use an array bad, that marks the numbers that we are not able to include to B. When trying the value bj, we can add it to B if it is not marked in bad. Now the numbers that are equal to bj + ai1 - ai2 are forbidden, let us mark them in bad. The complexity is O(n3) for each test case. B. Similar WordsLet us consider the following similarity graph: the vertices are the prefixes of the given words, two vertices are connected by an edge if the corresponding words are similar. Note that the set of vertices in this graph is the same as in the trie for the given words, so it doesn't exceed the sum of lengths of words.Let us prove that the resulting graph is a forest. If two words are similar, let us call the shorter one the parent of the longer one. Each vertex now has at most one parent, and there are no cycles, so the graph is a set of trees — a forest.Now the required set is the independent set in the constructed similarity graph, so we can use dynamic programming or greedy algorithm to find it.There are two ways to construct the similarity graph.Way 1. Hashes For each prefix find its hash, make a set of all hashes. Now for each prefix remove its first letter, check if such hash exists. If it does, connect them by an edge.Way 2. Aho-CorasickLet us build Aho-Corasick automaton for the given set of words. The vertices of the similarity graph are automaton vertices. An edge exists between two vertices if the suffix link from one of them goes to the other one, and their depths differ by exacly 1. C. Eleventh BirthdayLet us use divisibility rule for eleven. The number is divisible by eleven if the sum of digits at odd positions is equal to the sum of digits at even positions modulo 11. So for each number on a card there are only two parameters that we care about: the sign interchanging sum of its digits with digits at odd positions positive and digits at even position negative, and the parity of its digit count.Let us divide all cards to two groups: with even digit count and with odd digit count. Let us first put cards with numbers that have odd count of digits. Half of them (rounded up) will have their sign interchanging sum used as positive, other half as negative. Let us use dynamic programming to find the number of ways to sum them up to have a given sum modulo 11. The state includes the number of cards considered, the number of cards that are used as positive, and the current sum modulo 11. There are two transitions: take the current card as positive, and take it as negative.If there are no cards with odd digit count, no matter how you order even digit count cards the result modulo 11 is the same. So the answer is either 0 or n!. In the other case each even digit count card can be used either as positive, or as negative, independent of the other cards. Use analogous dynamic programming to count the number of ways to get each possible sum modulo 11. Finally, combine results for even and odd digit count cards, getting the total sum modulo 11 equal to 0. Time complexity is O(n2). D. Masha and CactusLet us use dynamic programming for a rooted tree and some data structures. Denote as fv the maximal total beauty of edges that have both ends in a subtree of v, such that if we add them all to the subtree it would be a cactus.To calculate fv let us consider two cases: v belongs to some cycle, or it doesn't. If it doesn't belong to any cycle, fv is equal to the sum of fu for all children u of v. If v belongs to a cycle, let us iterate over all possible cycles it can belong to. Such cycle is generated by an added edge (x, y) such that LCA(x, y) = v. Try all possible such edges and then temporarily delete a path from x to y from a tree, calculate the sum of fu for all u — roots of the isolated subtrees after the deletion of the path, and add it to the beauty of (x, y).Now we have an O(nm) solution.To speed up this solution let us use some data structures. First, we need to calculate LCA for all endpoints of the given edges, any fast enough standard algorithm is fine. The second thing to do is to be able to calculate the sum of fu for all subtrees after removing the path. To do it, use the following additional values: gu = fp - fu, where p is the parent of u, and sv = sum(fu), where u are the children of v. Now the sum of fu for all subtrees after x - y path removal is the sum of the following values: sx, sy, sv - fx' - fy', the sum of gi for all i at [x, x'), the sum of gi for all i at [y, y'), where x' is the child of v that has x in its subtree, and y' is the child of v that has y in its subtree. We need some data structure for a tree that supports value change in a vertex and the sum for a path, range tree or Fenwick are fine. The complexity is O((n + m)log(n)). E. SatellitesAny point X can be given by two angles α = XAB and β = XBA. The point (α2, β2) is in coverage area of a satellite at the point (α1, β1), if α2 ≤ α1 and β2 ≤ β1.Let two satellites that want to create a communication channel are at points (α1, β1) and (α2, β2). Repeater must be positioned in such point (α0, β0), that α0 ≤ min(α1, α2) and β0 ≤ min(β1, β2). To make it harder for it to get to other satellites coverage area, it is reasonable to maximize α0 and β0: α0 = min(α1, α2), β0 = min(β1, β2).Now let us move to a solution. Consider a query of type 3: you are given two satellites at points (α1, β1) and (α2, β2). You must check whether the point (α0, β0) = (min(α1, α2), min(β1, β2)) is not in the coverage area of any other satellite. That means that among all satellites with α ≥ α0 the maximum value of β is smaller than β0.The solution is offline, it considers all satellites from the test data and just turns them on and off. Sort all satellites by α. Each moment for each satellite we store its β if it exists, or  - ∞ if it doesn't. Let us build a range tree for maximum, and update values as satellites come and go. The query is a range maximum. To avoid considering the satellites from the query, change their values to  - ∞ before the query, and restore them afterwards.The next thing to do is to get rid of floating point numbers. Instead of calculating the angle values, we will only compare them using cross product. Similarly, instead of storing β values in range tree, we will store indices and compare them by cross product in integers.The final remark: we need to check that the point (α0, β0) is not inside the planet. The point is inside the planet, if the angle AXB is obtuse, that can be checked by a scalar product of XA and XB. The point X can have non-integer coordinates, so we will not look for it, but will use colinear vectors from among those connecting satellite points to A and B. F. To Play or not to PlayWe give the main ideas of the solution, leaving proofs as an exercise.Let us introduce coordinates y(x), where x = exp1 - exp2, and y = exp1 (exp1, exp2 — experience of the first and the second player, respectively). Let us proceed with time, and keep the set of possible states at this plane. It is a polygon.Lemma 1: in the optimal solution if at some moment both players can play the game simultaneously, they should do so.Now consider all moments of time, one after another. There are three transitions that modify the polygon: The first player can play for t seconds. The new polygon is the Minkowski sum of the previous polygon and the degenerate polygon: segment with two vertices (0, 0) and (t, t). The second player can play for t seconds. The new polygon is the Minkowski sum of the previous polygon and the segment with vertices (0, 0) and ( - t, 0). Both players can play for t seconds. Now all points with x-coordinates [ - C;C] have 2t added to their y coordinate, and other points have t added to their y coordinate. Let us now see how the polygon looks like. It is x-monotonous polygon (each line parallel to y-axis intersects it via a segment), the lower bound of this polygon is y = 0 if x ≤ 0 and y = x if x > 0. Let us see how the upper bound of the polygon looks like.We want to prove that y-coordinate of the upper bound of the polygon doesn't decrease, and it only contains segments that move by vectors ( + 1, 0) and ( + 1,  + 1). We attempt an induction, and the induction step is fine for the first two transitions. But the third transition can make the upper bound non-monotonous at a point x = C. To fix it, let us change the definition of our polygon.Instead of storing all possible reachable points, we will keep larger set, that contains the original set, and for each of its point we can get maximal experience for the first player not greater than what we could originally get.Lemma 2: if at some moment t we take two points P1 = (x1, y1) and P2 = (x2, y2) such that C ≤ x1 ≤ x2, and y1 ≥ y2, and our player start training from those states, the maximal experience for point P2 is not greater than for the point P1. So we can expand our upper bound for x from [C; + inf) by a maximum value of the correct upper bound and y = y(C). The similar proof works for a line y = y(C) - (C - x) for x in ( - inf;C]. Now we have an upper bound as a polyline that contains ( + 1, 0) and ( + 1,  + 1) segments. All is left to do is to modify the polyline using the described transitions. This can be done using some appropriate data structure, treap for example. The solution works in O(nlog(n)).",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54452",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10417
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    for (int tc = 0; tc < t; tc++) {\n        int n = inf.readInt(1, 2000, \"n\");\n        total_n += n;\n        ensuref(total_n <= 2000, \"Total n exceeds 2000\");\n        inf.readEoln();\n        vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    for (int tc = 0; tc < t; tc++) {\n        int n = inf.readInt(1, 2000, \"n\");\n        total_n += n;\n        ensuref(total_n <= 2000, \"Total n exceeds 2000\");\n        inf.readEoln();\n        vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    for (int tc = 0; tc < t; tc++) {\n        int n = inf.readInt(1, 2000, \"n\");\n        total_n += n;\n        ensuref(total_n <= 2000, \"Total n exceeds 2000\");\n        inf.readEoln();\n        vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int t = opt<int>(\"t\", 1);\n    int total_n = opt<int>(\"total_n\", 2000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (total_n > 2000) total_n = 2000;\n    \n    printf(\"%d\\n\", t);\n\n    if (type == \"edge_n1\") {\n        // t test cases, each n = 1\n        for (int test = 0; test < t; ++test) {\n            printf(\"1\\n\");\n            int ai = rnd.next(1, 1000000000);\n            printf(\"%d\\n\", ai);\n        }\n    } else if (type == \"max_n\") {\n        // One test case with n = total_n\n        printf(\"%d\\n\", total_n);\n        for (int i = 0; i < total_n; ++i) {\n            int ai = rnd.next(1, 1000000000);\n            printf(\"%d\", ai);\n            if (i + 1 < total_n) printf(\" \");\n            else printf(\"\\n\");\n        }\n        for (int test = 1; test < t; ++test) {\n            printf(\"1\\n\");\n            int ai = rnd.next(1, 1000000000);\n            printf(\"%d\\n\", ai);\n        }\n    } else if (type == \"all_same\") {\n        // t test cases, n = total_n / t, ai all same\n        int per_n = total_n / t;\n        if (per_n == 0) per_n = 1;\n        for (int test = 0; test < t; ++test) {\n            printf(\"%d\\n\", per_n);\n            int ai = rnd.next(1, 1000000000);\n            for (int i = 0; i < per_n; ++i) {\n                printf(\"%d\", ai);\n                if (i + 1 < per_n) printf(\" \");\n                else printf(\"\\n\");\n            }\n        }\n    } else if (type == \"alternating_lengths\") {\n        // t test cases, n = total_n / t\n        int per_n = total_n / t;\n        if (per_n == 0) per_n = 1;\n        for (int test = 0; test < t; ++test) {\n            printf(\"%d\\n\", per_n);\n            for (int i = 0; i < per_n; ++i) {\n                int ai;\n                if (i % 2 == 0) {\n                    ai = rnd.next(1, 9); // 1-digit number\n                } else {\n                    ai = rnd.next(100000000, 1000000000); // large number\n                }\n                printf(\"%d\", ai);\n                if (i + 1 < per_n) printf(\" \");\n                else printf(\"\\n\");\n            }\n        }\n    } else if (type == \"maximal_output\") {\n        // Try to generate a test case where the number of good permutations is high\n        t = 1;\n        printf(\"%d\\n\", t);\n        int n = 2;\n        printf(\"%d\\n\", n);\n        printf(\"11 22\\n\"); // Numbers chosen such that concatenations are multiple of 11\n    } else {\n        // Default type: random\n        int per_n = total_n / t;\n        if (per_n == 0) per_n = 1;\n        int assigned_n = per_n * t;\n        int remaining_n = total_n - assigned_n;\n        for (int test = 0; test < t; ++test) {\n            int n = per_n;\n            if (remaining_n > 0) {\n                n++;\n                remaining_n--;\n            }\n            printf(\"%d\\n\", n);\n            for (int i = 0; i < n; ++i) {\n                int ai = rnd.next(1, 1000000000);\n                printf(\"%d\", ai);\n                if (i + 1 < n) printf(\" \");\n                else printf(\"\\n\");\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int t = opt<int>(\"t\", 1);\n    int total_n = opt<int>(\"total_n\", 2000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (total_n > 2000) total_n = 2000;\n    \n    printf(\"%d\\n\", t);\n\n    if (type == \"edge_n1\") {\n        // t test cases, each n = 1\n        for (int test = 0; test < t; ++test) {\n            printf(\"1\\n\");\n            int ai = rnd.next(1, 1000000000);\n            printf(\"%d\\n\", ai);\n        }\n    } else if (type == \"max_n\") {\n        // One test case with n = total_n\n        printf(\"%d\\n\", total_n);\n        for (int i = 0; i < total_n; ++i) {\n            int ai = rnd.next(1, 1000000000);\n            printf(\"%d\", ai);\n            if (i + 1 < total_n) printf(\" \");\n            else printf(\"\\n\");\n        }\n        for (int test = 1; test < t; ++test) {\n            printf(\"1\\n\");\n            int ai = rnd.next(1, 1000000000);\n            printf(\"%d\\n\", ai);\n        }\n    } else if (type == \"all_same\") {\n        // t test cases, n = total_n / t, ai all same\n        int per_n = total_n / t;\n        if (per_n == 0) per_n = 1;\n        for (int test = 0; test < t; ++test) {\n            printf(\"%d\\n\", per_n);\n            int ai = rnd.next(1, 1000000000);\n            for (int i = 0; i < per_n; ++i) {\n                printf(\"%d\", ai);\n                if (i + 1 < per_n) printf(\" \");\n                else printf(\"\\n\");\n            }\n        }\n    } else if (type == \"alternating_lengths\") {\n        // t test cases, n = total_n / t\n        int per_n = total_n / t;\n        if (per_n == 0) per_n = 1;\n        for (int test = 0; test < t; ++test) {\n            printf(\"%d\\n\", per_n);\n            for (int i = 0; i < per_n; ++i) {\n                int ai;\n                if (i % 2 == 0) {\n                    ai = rnd.next(1, 9); // 1-digit number\n                } else {\n                    ai = rnd.next(100000000, 1000000000); // large number\n                }\n                printf(\"%d\", ai);\n                if (i + 1 < per_n) printf(\" \");\n                else printf(\"\\n\");\n            }\n        }\n    } else if (type == \"maximal_output\") {\n        // Try to generate a test case where the number of good permutations is high\n        t = 1;\n        printf(\"%d\\n\", t);\n        int n = 2;\n        printf(\"%d\\n\", n);\n        printf(\"11 22\\n\"); // Numbers chosen such that concatenations are multiple of 11\n    } else {\n        // Default type: random\n        int per_n = total_n / t;\n        if (per_n == 0) per_n = 1;\n        int assigned_n = per_n * t;\n        int remaining_n = total_n - assigned_n;\n        for (int test = 0; test < t; ++test) {\n            int n = per_n;\n            if (remaining_n > 0) {\n                n++;\n                remaining_n--;\n            }\n            printf(\"%d\\n\", n);\n            for (int i = 0; i < n; ++i) {\n                int ai = rnd.next(1, 1000000000);\n                printf(\"%d\", ai);\n                if (i + 1 < n) printf(\" \");\n                else printf(\"\\n\");\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type random\n./gen -t 1 -type max_n -total_n 2000\n./gen -t 100 -type edge_n1 -total_n 100\n./gen -t 5 -type all_same -total_n 1000\n./gen -t 5 -type alternating_lengths -total_n 1000\n./gen -t 1 -type maximal_output\n./gen -t 20 -type random -total_n 2000\n./gen -t 10 -type random -total_n 200\n./gen -t 10 -type random -total_n 1500\n./gen -t 50 -type edge_n1 -total_n 50\n./gen -t 2 -type random -total_n 2000\n./gen -t 1 -type all_same -total_n 2000\n./gen -t 100 -type random -total_n 2000\n./gen -t 100 -type random -total_n 200\n./gen -t 1 -type alternating_lengths -total_n 2000\n./gen -t 10 -type random -total_n 10\n./gen -t 10 -type random -total_n 20\n./gen -t 50 -type all_same -total_n 50\n./gen -t 100 -type edge_n1 -total_n 100\n./gen -t 25 -type alternating_lengths -total_n 2000\n./gen -t 2 -type maximal_output\n./gen -t 3 -type maximal_output\n./gen -t 1 -type random -total_n 1\n./gen -t 1 -type random -total_n 2000\n./gen -t 5 -type all_same -total_n 5\n./gen -t 5 -type all_same -total_n 2000\n./gen -t 50 -type alternating_lengths -total_n 1500\n./gen -t 70 -type edge_n1 -total_n 70\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:38.064629",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "856/D",
      "title": "D. Masha and Cactus",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available (3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·105).Let us describe Masha's tree. It has a root at vertex 1. The second line contains n - 1 integers: p2, p3, ..., pn, here pi — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree (1 ≤ pi < i).The following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge (1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 104).It is guaranteed that no additional edge coincides with the edge of the tree.",
      "output_spec": "OutputOutput one integer — the maximum beauty of a cactus Masha can achieve.",
      "sample_tests": "ExampleInputCopy7 31 1 2 2 3 34 5 16 7 12 3 1OutputCopy2",
      "description": "D. Masha and Cactus\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available (3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·105).Let us describe Masha's tree. It has a root at vertex 1. The second line contains n - 1 integers: p2, p3, ..., pn, here pi — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree (1 ≤ pi < i).The following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge (1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 104).It is guaranteed that no additional edge coincides with the edge of the tree.\n\nOutputOutput one integer — the maximum beauty of a cactus Masha can achieve.\n\nInputCopy7 31 1 2 2 3 34 5 16 7 12 3 1OutputCopy2\n\nInputCopy7 31 1 2 2 3 34 5 16 7 12 3 1\n\nOutputCopy2",
      "solutions": [
        {
          "title": "RCC 2017 — Finals + CF Round - Codeforces",
          "content": "Hi, everyone!On September 10, 2017 at 13:00 Moscow time the final round of Russian Code Cup 2017 will take place! The round will be 3 hours long. 55 participants of the final round will compete for prizes and glory, and we are eager to watch their competition at http://russiancodecup.ru.And we have a nice surprise for the others: if you would like to apply your skills at our finals problems, come to codeforces.com after the Finals is over, at 16:35 Moscow time, the round featuring RCC Finals 2017 problems will take place, open for everybody.Some notes: Round will use ACM rules; It will be unrated; Problem difficulty will be close to Div 1 round; We ask RCC finalists not to publish or discuss problems after the end of the Finals before the CF round ends, of course you shouldn't participate in CF round; Judging machines at RCC and CF are different, \"my solution passed/failed at CF, and it was different at RCC\" is not a valid appeal. UPD The official contest is over, congratulations to the winners! And good luck to CF Round participants.UPD2 Editorial",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Russian Code Cup 2017 Finals — Results and Editorial - Codeforces",
          "content": "First of all, congratulations to jqdai0815 for winning, LHiC and jcvb for coming second and third. The Final Round proved to be quite challenging, and we are happy that the results are tight.The round was prepared by Aksenov239, GShark, izban, manoprenko, niyaznigmatul, qwerty787788 and SpyCheese, supervisor andrewzta. Special thanks for this round goes to izban who is the author of problems D, E and F, and also gave a lot of important comments for all problems of the round.Now let us move on to the editorial.A. Set TheoryFirst let us prove that the answer is always YES.Let us iterate over bj and check if summing it up with all ai values don't result in values that we already have. If no conflict is found, add the corresponding bj to B.Let us give some estimate for the maximum element of B. The reason that we cannot include bj2, to B is the equality ai1 + bj1 = ai2 + bj2, so bj2 = bj1 - (ai2 - ai1). Each element of B forbids O(n2) values, so max(B) is O(n3). That means that the answer always exists for the given constraints.Now let us speed up the test that we can add a number to B. Let us use an array bad, that marks the numbers that we are not able to include to B. When trying the value bj, we can add it to B if it is not marked in bad. Now the numbers that are equal to bj + ai1 - ai2 are forbidden, let us mark them in bad. The complexity is O(n3) for each test case. B. Similar WordsLet us consider the following similarity graph: the vertices are the prefixes of the given words, two vertices are connected by an edge if the corresponding words are similar. Note that the set of vertices in this graph is the same as in the trie for the given words, so it doesn't exceed the sum of lengths of words.Let us prove that the resulting graph is a forest. If two words are similar, let us call the shorter one the parent of the longer one. Each vertex now has at most one parent, and there are no cycles, so the graph is a set of trees — a forest.Now the required set is the independent set in the constructed similarity graph, so we can use dynamic programming or greedy algorithm to find it.There are two ways to construct the similarity graph.Way 1. Hashes For each prefix find its hash, make a set of all hashes. Now for each prefix remove its first letter, check if such hash exists. If it does, connect them by an edge.Way 2. Aho-CorasickLet us build Aho-Corasick automaton for the given set of words. The vertices of the similarity graph are automaton vertices. An edge exists between two vertices if the suffix link from one of them goes to the other one, and their depths differ by exacly 1. C. Eleventh BirthdayLet us use divisibility rule for eleven. The number is divisible by eleven if the sum of digits at odd positions is equal to the sum of digits at even positions modulo 11. So for each number on a card there are only two parameters that we care about: the sign interchanging sum of its digits with digits at odd positions positive and digits at even position negative, and the parity of its digit count.Let us divide all cards to two groups: with even digit count and with odd digit count. Let us first put cards with numbers that have odd count of digits. Half of them (rounded up) will have their sign interchanging sum used as positive, other half as negative. Let us use dynamic programming to find the number of ways to sum them up to have a given sum modulo 11. The state includes the number of cards considered, the number of cards that are used as positive, and the current sum modulo 11. There are two transitions: take the current card as positive, and take it as negative.If there are no cards with odd digit count, no matter how you order even digit count cards the result modulo 11 is the same. So the answer is either 0 or n!. In the other case each even digit count card can be used either as positive, or as negative, independent of the other cards. Use analogous dynamic programming to count the number of ways to get each possible sum modulo 11. Finally, combine results for even and odd digit count cards, getting the total sum modulo 11 equal to 0. Time complexity is O(n2). D. Masha and CactusLet us use dynamic programming for a rooted tree and some data structures. Denote as fv the maximal total beauty of edges that have both ends in a subtree of v, such that if we add them all to the subtree it would be a cactus.To calculate fv let us consider two cases: v belongs to some cycle, or it doesn't. If it doesn't belong to any cycle, fv is equal to the sum of fu for all children u of v. If v belongs to a cycle, let us iterate over all possible cycles it can belong to. Such cycle is generated by an added edge (x, y) such that LCA(x, y) = v. Try all possible such edges and then temporarily delete a path from x to y from a tree, calculate the sum of fu for all u — roots of the isolated subtrees after the deletion of the path, and add it to the beauty of (x, y).Now we have an O(nm) solution.To speed up this solution let us use some data structures. First, we need to calculate LCA for all endpoints of the given edges, any fast enough standard algorithm is fine. The second thing to do is to be able to calculate the sum of fu for all subtrees after removing the path. To do it, use the following additional values: gu = fp - fu, where p is the parent of u, and sv = sum(fu), where u are the children of v. Now the sum of fu for all subtrees after x - y path removal is the sum of the following values: sx, sy, sv - fx' - fy', the sum of gi for all i at [x, x'), the sum of gi for all i at [y, y'), where x' is the child of v that has x in its subtree, and y' is the child of v that has y in its subtree. We need some data structure for a tree that supports value change in a vertex and the sum for a path, range tree or Fenwick are fine. The complexity is O((n + m)log(n)). E. SatellitesAny point X can be given by two angles α = XAB and β = XBA. The point (α2, β2) is in coverage area of a satellite at the point (α1, β1), if α2 ≤ α1 and β2 ≤ β1.Let two satellites that want to create a communication channel are at points (α1, β1) and (α2, β2). Repeater must be positioned in such point (α0, β0), that α0 ≤ min(α1, α2) and β0 ≤ min(β1, β2). To make it harder for it to get to other satellites coverage area, it is reasonable to maximize α0 and β0: α0 = min(α1, α2), β0 = min(β1, β2).Now let us move to a solution. Consider a query of type 3: you are given two satellites at points (α1, β1) and (α2, β2). You must check whether the point (α0, β0) = (min(α1, α2), min(β1, β2)) is not in the coverage area of any other satellite. That means that among all satellites with α ≥ α0 the maximum value of β is smaller than β0.The solution is offline, it considers all satellites from the test data and just turns them on and off. Sort all satellites by α. Each moment for each satellite we store its β if it exists, or  - ∞ if it doesn't. Let us build a range tree for maximum, and update values as satellites come and go. The query is a range maximum. To avoid considering the satellites from the query, change their values to  - ∞ before the query, and restore them afterwards.The next thing to do is to get rid of floating point numbers. Instead of calculating the angle values, we will only compare them using cross product. Similarly, instead of storing β values in range tree, we will store indices and compare them by cross product in integers.The final remark: we need to check that the point (α0, β0) is not inside the planet. The point is inside the planet, if the angle AXB is obtuse, that can be checked by a scalar product of XA and XB. The point X can have non-integer coordinates, so we will not look for it, but will use colinear vectors from among those connecting satellite points to A and B. F. To Play or not to PlayWe give the main ideas of the solution, leaving proofs as an exercise.Let us introduce coordinates y(x), where x = exp1 - exp2, and y = exp1 (exp1, exp2 — experience of the first and the second player, respectively). Let us proceed with time, and keep the set of possible states at this plane. It is a polygon.Lemma 1: in the optimal solution if at some moment both players can play the game simultaneously, they should do so.Now consider all moments of time, one after another. There are three transitions that modify the polygon: The first player can play for t seconds. The new polygon is the Minkowski sum of the previous polygon and the degenerate polygon: segment with two vertices (0, 0) and (t, t). The second player can play for t seconds. The new polygon is the Minkowski sum of the previous polygon and the segment with vertices (0, 0) and ( - t, 0). Both players can play for t seconds. Now all points with x-coordinates [ - C;C] have 2t added to their y coordinate, and other points have t added to their y coordinate. Let us now see how the polygon looks like. It is x-monotonous polygon (each line parallel to y-axis intersects it via a segment), the lower bound of this polygon is y = 0 if x ≤ 0 and y = x if x > 0. Let us see how the upper bound of the polygon looks like.We want to prove that y-coordinate of the upper bound of the polygon doesn't decrease, and it only contains segments that move by vectors ( + 1, 0) and ( + 1,  + 1). We attempt an induction, and the induction step is fine for the first two transitions. But the third transition can make the upper bound non-monotonous at a point x = C. To fix it, let us change the definition of our polygon.Instead of storing all possible reachable points, we will keep larger set, that contains the original set, and for each of its point we can get maximal experience for the first player not greater than what we could originally get.Lemma 2: if at some moment t we take two points P1 = (x1, y1) and P2 = (x2, y2) such that C ≤ x1 ≤ x2, and y1 ≥ y2, and our player start training from those states, the maximal experience for point P2 is not greater than for the point P1. So we can expand our upper bound for x from [C; + inf) by a maximum value of the correct upper bound and y = y(C). The similar proof works for a line y = y(C) - (C - x) for x in ( - inf;C]. Now we have an upper bound as a polyline that contains ( + 1, 0) and ( + 1,  + 1) segments. All is left to do is to modify the polyline using the described transitions. This can be done using some appropriate data structure, treap for example. The solution works in O(nlog(n)).",
          "author": "RussianCodeCup",
          "url": "https://codeforces.com/blog/entry/54452",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10417
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent = inf.readInts(n - 1, 1, n - 1, \"p\");\n    inf.readEoln();\n\n    set<pair<int, int>> tree_edges;\n\n    for (int i = 2; i <= n; i++) {\n        int pi = parent[i - 2];\n        ensuref(pi <= i - 1, \"pi=%d is greater than i-1=%d, where i=%d\", pi, i - 1, i);\n        int u = pi;\n        int v = i;\n        if (u > v) swap(u, v);\n        tree_edges.insert({u, v});\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Self-loop detected: u_i (%d) equals v_i (%d) on line %d\", u, v, i + 3);\n        inf.readSpace();\n        int c = inf.readInt(1, 10000, \"c_i\");\n        inf.readEoln();\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(tree_edges.count({a, b}) == 0, \"Edge (%d, %d) is already in the tree\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent = inf.readInts(n - 1, 1, n - 1, \"p\");\n    inf.readEoln();\n\n    set<pair<int, int>> tree_edges;\n\n    for (int i = 2; i <= n; i++) {\n        int pi = parent[i - 2];\n        ensuref(pi <= i - 1, \"pi=%d is greater than i-1=%d, where i=%d\", pi, i - 1, i);\n        int u = pi;\n        int v = i;\n        if (u > v) swap(u, v);\n        tree_edges.insert({u, v});\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Self-loop detected: u_i (%d) equals v_i (%d) on line %d\", u, v, i + 3);\n        inf.readSpace();\n        int c = inf.readInt(1, 10000, \"c_i\");\n        inf.readEoln();\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(tree_edges.count({a, b}) == 0, \"Edge (%d, %d) is already in the tree\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent = inf.readInts(n - 1, 1, n - 1, \"p\");\n    inf.readEoln();\n\n    set<pair<int, int>> tree_edges;\n\n    for (int i = 2; i <= n; i++) {\n        int pi = parent[i - 2];\n        ensuref(pi <= i - 1, \"pi=%d is greater than i-1=%d, where i=%d\", pi, i - 1, i);\n        int u = pi;\n        int v = i;\n        if (u > v) swap(u, v);\n        tree_edges.insert({u, v});\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Self-loop detected: u_i (%d) equals v_i (%d) on line %d\", u, v, i + 3);\n        inf.readSpace();\n        int c = inf.readInt(1, 10000, \"c_i\");\n        inf.readEoln();\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(tree_edges.count({a, b}) == 0, \"Edge (%d, %d) is already in the tree\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string t = opt<string>(\"t\", \"random\");\n\n    vector<pair<int, int>> tree_edges;\n\n    if (t == \"chain\") {\n        // Build a chain tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.push_back({i - 1, i});\n        }\n    } else if (t == \"star\") {\n        // Build a star tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.push_back({1, i});\n        }\n    } else {\n        // Build a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i -1);\n            tree_edges.push_back({parent, i});\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Build p2 to pn\n    vector<int> parent(n + 1);\n\n    for (auto edge : tree_edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (v < u) swap(u, v);\n        parent[v] = u;\n    }\n\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", parent[i], (i == n) ? '\\n' : ' ');\n    }\n\n    // Now, generate m additional edges\n    set<pair<int, int>> tree_edge_set;\n    for (auto edge : tree_edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (u > v) swap(u, v);\n        tree_edge_set.insert({u, v});\n    }\n\n    set<pair<int, int>> used_edges = tree_edge_set;\n    vector<tuple<int, int, int>> additional_edges;\n\n    int max_possible_edges = (long long)n * (n - 1) / 2 - (n - 1);\n    if (m > max_possible_edges) m = max_possible_edges;\n\n    int trials = 0;\n    while ((int)additional_edges.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v)\n            continue;\n        if (u > v) swap(u, v);\n        if (used_edges.count({u, v}))\n            continue;\n        used_edges.insert({u, v});\n\n        int ci;\n        if (t == \"max_beauty\") {\n            ci = 10000;\n        } else if (t == \"min_beauty\") {\n            ci = 1;\n        } else if (t == \"same_beauty\") {\n            ci = 5000;\n        } else {\n            ci = rnd.next(1, 10000);\n        }\n\n        additional_edges.push_back(make_tuple(u, v, ci));\n\n        // Avoid infinite loop\n        ++trials;\n        if (trials > 10 * m) {\n            break;\n        }\n    }\n\n    // Output m lines: ui vi ci\n    for (auto edge : additional_edges) {\n        int ui, vi, ci;\n        tie(ui, vi, ci) = edge;\n        printf(\"%d %d %d\\n\", ui, vi, ci);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string t = opt<string>(\"t\", \"random\");\n\n    vector<pair<int, int>> tree_edges;\n\n    if (t == \"chain\") {\n        // Build a chain tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.push_back({i - 1, i});\n        }\n    } else if (t == \"star\") {\n        // Build a star tree\n        for (int i = 2; i <= n; ++i) {\n            tree_edges.push_back({1, i});\n        }\n    } else {\n        // Build a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i -1);\n            tree_edges.push_back({parent, i});\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Build p2 to pn\n    vector<int> parent(n + 1);\n\n    for (auto edge : tree_edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (v < u) swap(u, v);\n        parent[v] = u;\n    }\n\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", parent[i], (i == n) ? '\\n' : ' ');\n    }\n\n    // Now, generate m additional edges\n    set<pair<int, int>> tree_edge_set;\n    for (auto edge : tree_edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (u > v) swap(u, v);\n        tree_edge_set.insert({u, v});\n    }\n\n    set<pair<int, int>> used_edges = tree_edge_set;\n    vector<tuple<int, int, int>> additional_edges;\n\n    int max_possible_edges = (long long)n * (n - 1) / 2 - (n - 1);\n    if (m > max_possible_edges) m = max_possible_edges;\n\n    int trials = 0;\n    while ((int)additional_edges.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v)\n            continue;\n        if (u > v) swap(u, v);\n        if (used_edges.count({u, v}))\n            continue;\n        used_edges.insert({u, v});\n\n        int ci;\n        if (t == \"max_beauty\") {\n            ci = 10000;\n        } else if (t == \"min_beauty\") {\n            ci = 1;\n        } else if (t == \"same_beauty\") {\n            ci = 5000;\n        } else {\n            ci = rnd.next(1, 10000);\n        }\n\n        additional_edges.push_back(make_tuple(u, v, ci));\n\n        // Avoid infinite loop\n        ++trials;\n        if (trials > 10 * m) {\n            break;\n        }\n    }\n\n    // Output m lines: ui vi ci\n    for (auto edge : additional_edges) {\n        int ui, vi, ci;\n        tie(ui, vi, ci) = edge;\n        printf(\"%d %d %d\\n\", ui, vi, ci);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 0 -t chain\n./gen -n 3 -m 1 -t chain\n./gen -n 3 -m 3 -t chain\n\n./gen -n 10 -m 10 -t random\n./gen -n 10 -m 45 -t random\n\n./gen -n 1000 -m 1000 -t random\n./gen -n 1000 -m 1000 -t star\n./gen -n 1000 -m 1000 -t chain\n\n./gen -n 200000 -m 200000 -t random\n./gen -n 200000 -m 200000 -t chain\n./gen -n 200000 -m 200000 -t star\n\n./gen -n 200000 -m 200000 -t max_beauty\n./gen -n 200000 -m 200000 -t min_beauty\n./gen -n 200000 -m 200000 -t same_beauty\n\n./gen -n 200000 -m 200000 -t random\n\n./gen -n 200000 -m 100000 -t chain\n./gen -n 200000 -m 100000 -t star\n./gen -n 200000 -m 100000 -t random\n\n./gen -n 199999 -m 199999 -t random\n\n./gen -n 100000 -m 200000 -t random\n\n./gen -n 2 -m 1 -t random\n\n./gen -n 2 -m 0 -t random\n\n./gen -n 199990 -m 200000 -t random\n\n./gen -n 199999 -m 0 -t random\n\n./gen -n 199999 -m 0 -t chain\n\n./gen -n 3 -m 3 -t max_beauty\n./gen -n 3 -m 3 -t min_beauty\n\n./gen -n 100000 -m 100000 -t random\n./gen -n 100000 -m 100000 -t chain\n\n./gen -n 199999 -m 199999 -t chain\n./gen -n 200000 -m 199999 -t star\n\n./gen -n 200000 -m 199999 -t random\n\n./gen -n 4 -m 6 -t random\n./gen -n 5 -m 10 -t random\n\n./gen -n 50000 -m 0 -t random\n\n./gen -n 200000 -m 1 -t random\n\n./gen -n 100 -m 4950 -t random\n\n./gen -n 200000 -m 199999 -t random\n\n./gen -n 1000 -m 500 -t random\n\n./gen -n 200000 -m 200000 -t same_beauty\n\n./gen -n 200000 -m 200000 -t max_beauty\n\n./gen -n 200000 -m 200000 -t min_beauty\n\n./gen -n 10 -m 1000 -t random\n\n./gen -n 200000 -m 0 -t random\n\n./gen -n 3 -m 0 -t random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:40.021845",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "856/E",
      "title": "Problem 856/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 1000000000, \"r\"); // 1 ≤ r ≤ 1e9\n    inf.readSpace();\n    int n = inf.readInt(1, 500000, \"n\"); // 1 ≤ n ≤ 5e5\n    inf.readEoln();\n    // Now process n events\n    int satelliteCount = 0; // Total satellites ever launched\n    set<int> existingSatellites; // indices of existing satellites\n    map<int, pair<int, int> > satellitePositions; // positions of satellites (x,y)\n    map<pair<int,int>, int> positionCount; // counts of satellites at positions\n    for (int eventIndex = 0; eventIndex < n; ++eventIndex) {\n        int t = inf.readInt(1, 3, \"t\"); // t can be 1, 2, or 3\n        if (t == 1) {\n            // Event type 1: \"1 x y\"\n            inf.readSpace();\n            int x = inf.readInt(-1000000000, 1000000000, \"x\"); // |x| ≤ 1e9\n            inf.readSpace();\n            int y = inf.readInt(1, 1000000000, \"y\"); // 0 < y ≤ 1e9\n            inf.readEoln();\n            ++satelliteCount; // assign index satelliteCount to this satellite\n            // Check that distance from (0,0) to (x,y) is strictly greater than r\n            long long distSq = 1LL*x*x + 1LL*y*y;\n            long long rSq = 1LL*r*r;\n            ensuref(distSq > rSq, \"Distance from satellite %d to planet center is not strictly greater than r\", satelliteCount);\n            // Check that no other existing satellite occupies the same position\n            pair<int,int> pos = make_pair(x, y);\n            ensuref(positionCount[pos]==0, \"Satellite position (%d,%d) is already occupied\", x, y);\n            positionCount[pos]++;\n            existingSatellites.insert(satelliteCount);\n            satellitePositions[satelliteCount] = pos;\n        } else if (t == 2) {\n            // Event type 2: \"2 i\"\n            inf.readSpace();\n            int i = inf.readInt(1, satelliteCount, \"i\");\n            inf.readEoln();\n            // Check that satellite i exists\n            ensuref(existingSatellites.count(i), \"Satellite %d does not exist at event %d\", i, eventIndex+2);\n            // Remove satellite i\n            existingSatellites.erase(i);\n            pair<int,int> pos = satellitePositions[i];\n            positionCount[pos]--;\n        } else if (t == 3) {\n            // Event type 3: \"3 i j\"\n            inf.readSpace();\n            int i = inf.readInt(1, satelliteCount, \"i\");\n            inf.readSpace();\n            int j = inf.readInt(1, satelliteCount, \"j\");\n            inf.readEoln();\n            // Check that satellites i and j exist\n            ensuref(existingSatellites.count(i), \"Satellite %d does not exist at event %d\", i, eventIndex+2);\n            ensuref(existingSatellites.count(j), \"Satellite %d does not exist at event %d\", j, eventIndex+2);\n            // Check that i != j\n            ensuref(i != j, \"In event %d, satellite indices i (%d) and j (%d) must not be equal\", eventIndex+2, i, j);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 1000000000, \"r\"); // 1 ≤ r ≤ 1e9\n    inf.readSpace();\n    int n = inf.readInt(1, 500000, \"n\"); // 1 ≤ n ≤ 5e5\n    inf.readEoln();\n    // Now process n events\n    int satelliteCount = 0; // Total satellites ever launched\n    set<int> existingSatellites; // indices of existing satellites\n    map<int, pair<int, int> > satellitePositions; // positions of satellites (x,y)\n    map<pair<int,int>, int> positionCount; // counts of satellites at positions\n    for (int eventIndex = 0; eventIndex < n; ++eventIndex) {\n        int t = inf.readInt(1, 3, \"t\"); // t can be 1, 2, or 3\n        if (t == 1) {\n            // Event type 1: \"1 x y\"\n            inf.readSpace();\n            int x = inf.readInt(-1000000000, 1000000000, \"x\"); // |x| ≤ 1e9\n            inf.readSpace();\n            int y = inf.readInt(1, 1000000000, \"y\"); // 0 < y ≤ 1e9\n            inf.readEoln();\n            ++satelliteCount; // assign index satelliteCount to this satellite\n            // Check that distance from (0,0) to (x,y) is strictly greater than r\n            long long distSq = 1LL*x*x + 1LL*y*y;\n            long long rSq = 1LL*r*r;\n            ensuref(distSq > rSq, \"Distance from satellite %d to planet center is not strictly greater than r\", satelliteCount);\n            // Check that no other existing satellite occupies the same position\n            pair<int,int> pos = make_pair(x, y);\n            ensuref(positionCount[pos]==0, \"Satellite position (%d,%d) is already occupied\", x, y);\n            positionCount[pos]++;\n            existingSatellites.insert(satelliteCount);\n            satellitePositions[satelliteCount] = pos;\n        } else if (t == 2) {\n            // Event type 2: \"2 i\"\n            inf.readSpace();\n            int i = inf.readInt(1, satelliteCount, \"i\");\n            inf.readEoln();\n            // Check that satellite i exists\n            ensuref(existingSatellites.count(i), \"Satellite %d does not exist at event %d\", i, eventIndex+2);\n            // Remove satellite i\n            existingSatellites.erase(i);\n            pair<int,int> pos = satellitePositions[i];\n            positionCount[pos]--;\n        } else if (t == 3) {\n            // Event type 3: \"3 i j\"\n            inf.readSpace();\n            int i = inf.readInt(1, satelliteCount, \"i\");\n            inf.readSpace();\n            int j = inf.readInt(1, satelliteCount, \"j\");\n            inf.readEoln();\n            // Check that satellites i and j exist\n            ensuref(existingSatellites.count(i), \"Satellite %d does not exist at event %d\", i, eventIndex+2);\n            ensuref(existingSatellites.count(j), \"Satellite %d does not exist at event %d\", j, eventIndex+2);\n            // Check that i != j\n            ensuref(i != j, \"In event %d, satellite indices i (%d) and j (%d) must not be equal\", eventIndex+2, i, j);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 1000000000, \"r\"); // 1 ≤ r ≤ 1e9\n    inf.readSpace();\n    int n = inf.readInt(1, 500000, \"n\"); // 1 ≤ n ≤ 5e5\n    inf.readEoln();\n    // Now process n events\n    int satelliteCount = 0; // Total satellites ever launched\n    set<int> existingSatellites; // indices of existing satellites\n    map<int, pair<int, int> > satellitePositions; // positions of satellites (x,y)\n    map<pair<int,int>, int> positionCount; // counts of satellites at positions\n    for (int eventIndex = 0; eventIndex < n; ++eventIndex) {\n        int t = inf.readInt(1, 3, \"t\"); // t can be 1, 2, or 3\n        if (t == 1) {\n            // Event type 1: \"1 x y\"\n            inf.readSpace();\n            int x = inf.readInt(-1000000000, 1000000000, \"x\"); // |x| ≤ 1e9\n            inf.readSpace();\n            int y = inf.readInt(1, 1000000000, \"y\"); // 0 < y ≤ 1e9\n            inf.readEoln();\n            ++satelliteCount; // assign index satelliteCount to this satellite\n            // Check that distance from (0,0) to (x,y) is strictly greater than r\n            long long distSq = 1LL*x*x + 1LL*y*y;\n            long long rSq = 1LL*r*r;\n            ensuref(distSq > rSq, \"Distance from satellite %d to planet center is not strictly greater than r\", satelliteCount);\n            // Check that no other existing satellite occupies the same position\n            pair<int,int> pos = make_pair(x, y);\n            ensuref(positionCount[pos]==0, \"Satellite position (%d,%d) is already occupied\", x, y);\n            positionCount[pos]++;\n            existingSatellites.insert(satelliteCount);\n            satellitePositions[satelliteCount] = pos;\n        } else if (t == 2) {\n            // Event type 2: \"2 i\"\n            inf.readSpace();\n            int i = inf.readInt(1, satelliteCount, \"i\");\n            inf.readEoln();\n            // Check that satellite i exists\n            ensuref(existingSatellites.count(i), \"Satellite %d does not exist at event %d\", i, eventIndex+2);\n            // Remove satellite i\n            existingSatellites.erase(i);\n            pair<int,int> pos = satellitePositions[i];\n            positionCount[pos]--;\n        } else if (t == 3) {\n            // Event type 3: \"3 i j\"\n            inf.readSpace();\n            int i = inf.readInt(1, satelliteCount, \"i\");\n            inf.readSpace();\n            int j = inf.readInt(1, satelliteCount, \"j\");\n            inf.readEoln();\n            // Check that satellites i and j exist\n            ensuref(existingSatellites.count(i), \"Satellite %d does not exist at event %d\", i, eventIndex+2);\n            ensuref(existingSatellites.count(j), \"Satellite %d does not exist at event %d\", j, eventIndex+2);\n            // Check that i != j\n            ensuref(i != j, \"In event %d, satellite indices i (%d) and j (%d) must not be equal\", eventIndex+2, i, j);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> generate_valid_position(int r, set<pair<int, int>>& existing_positions) {\n    while (true) {\n        int x = rnd.next(-1000000000, 1000000000);\n        int y = rnd.next(1, 1000000000);\n        if (1LL*x*x + 1LL*y*y <= 1LL*r*r) {\n            continue; // inside planet or on planet's border, invalid\n        }\n        pair<int, int> pos = make_pair(x, y);\n        if (existing_positions.count(pos)) {\n            continue; // position already used by another satellite\n        }\n        return pos; // valid position\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> events;\n\n    if (type == \"random\") {\n        int satellite_ID_counter = 0;\n        map<int, pair<int, int>> existing_sats;\n        vector<int> existing_sat_ids;\n        set<pair<int, int>> existing_positions;\n        for (int event_idx = 0; event_idx < n; event_idx++) {\n            vector<int> possible_event_types;\n            possible_event_types.push_back(1);\n            if (!existing_sat_ids.empty()) {\n                possible_event_types.push_back(2);\n            }\n            if (existing_sat_ids.size() >= 2) {\n                possible_event_types.push_back(3);\n            }\n\n            int event_type = possible_event_types[rnd.next(0, (int)possible_event_types.size() - 1)];\n\n            if (event_type == 1) {\n                // Generate satellite\n                satellite_ID_counter++;\n                pair<int,int> pos = generate_valid_position(r, existing_positions);\n                existing_sats[satellite_ID_counter] = pos;\n                existing_positions.insert(pos);\n                existing_sat_ids.push_back(satellite_ID_counter);\n                char buf[100];\n                sprintf(buf, \"1 %d %d\", pos.first, pos.second);\n                events.push_back(string(buf));\n            } else if (event_type == 2) {\n                // Remove satellite\n                int idx = rnd.next(0, (int)existing_sat_ids.size() - 1);\n                int id_to_remove = existing_sat_ids[idx];\n                pair<int,int> pos = existing_sats[id_to_remove];\n                existing_sats.erase(id_to_remove);\n                existing_positions.erase(pos);\n                existing_sat_ids.erase(existing_sat_ids.begin() + idx);\n                char buf[100];\n                sprintf(buf, \"2 %d\", id_to_remove);\n                events.push_back(string(buf));\n            } else if (event_type == 3) {\n                // Attempt to create communication channel\n                int idx1 = rnd.next(0, (int)existing_sat_ids.size() - 1);\n                int idx2;\n                do {\n                    idx2 = rnd.next(0, (int)existing_sat_ids.size() - 1);\n                } while (idx2 == idx1);\n                int id1 = existing_sat_ids[idx1];\n                int id2 = existing_sat_ids[idx2];\n                char buf[100];\n                sprintf(buf, \"3 %d %d\", id1, id2);\n                events.push_back(string(buf));\n            }\n        }\n    } else if (type == \"all_possible_channels\") {\n        int satellite_ID_counter = 0;\n        int x = 0;\n        int y_base = r + 1;\n        int y_step = 1;\n        map<int, pair<int, int>> existing_sats;\n        vector<int> existing_sat_ids;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                // Type 1 event\n                satellite_ID_counter++;\n                int y = y_base + satellite_ID_counter * y_step;\n                pair<int,int> pos = make_pair(x, y);\n                existing_sats[satellite_ID_counter] = pos;\n                existing_sat_ids.push_back(satellite_ID_counter);\n                char buf[100];\n                sprintf(buf, \"1 %d %d\", pos.first, pos.second);\n                events.push_back(string(buf));\n            } else {\n                // Type 3 event\n                if (existing_sat_ids.size() >= 2) {\n                    int id1 = existing_sat_ids[existing_sat_ids.size() - 1];\n                    int id2 = existing_sat_ids[existing_sat_ids.size() - 2];\n                    char buf[100];\n                    sprintf(buf, \"3 %d %d\", id1, id2);\n                    events.push_back(string(buf));\n                } else {\n                    // Not enough satellites, generate another type 1 event\n                    satellite_ID_counter++;\n                    int y = y_base + satellite_ID_counter * y_step;\n                    pair<int,int> pos = make_pair(x, y);\n                    existing_sats[satellite_ID_counter] = pos;\n                    existing_sat_ids.push_back(satellite_ID_counter);\n                    char buf[100];\n                    sprintf(buf, \"1 %d %d\", pos.first, pos.second);\n                    events.push_back(string(buf));\n                }\n            }\n        }\n    }\n\n    /* Output r and n */\n    printf(\"%d %d\\n\", r, (int)events.size());\n\n    /* Output events */\n    for (auto &e : events) {\n        printf(\"%s\\n\", e.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> generate_valid_position(int r, set<pair<int, int>>& existing_positions) {\n    while (true) {\n        int x = rnd.next(-1000000000, 1000000000);\n        int y = rnd.next(1, 1000000000);\n        if (1LL*x*x + 1LL*y*y <= 1LL*r*r) {\n            continue; // inside planet or on planet's border, invalid\n        }\n        pair<int, int> pos = make_pair(x, y);\n        if (existing_positions.count(pos)) {\n            continue; // position already used by another satellite\n        }\n        return pos; // valid position\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> events;\n\n    if (type == \"random\") {\n        int satellite_ID_counter = 0;\n        map<int, pair<int, int>> existing_sats;\n        vector<int> existing_sat_ids;\n        set<pair<int, int>> existing_positions;\n        for (int event_idx = 0; event_idx < n; event_idx++) {\n            vector<int> possible_event_types;\n            possible_event_types.push_back(1);\n            if (!existing_sat_ids.empty()) {\n                possible_event_types.push_back(2);\n            }\n            if (existing_sat_ids.size() >= 2) {\n                possible_event_types.push_back(3);\n            }\n\n            int event_type = possible_event_types[rnd.next(0, (int)possible_event_types.size() - 1)];\n\n            if (event_type == 1) {\n                // Generate satellite\n                satellite_ID_counter++;\n                pair<int,int> pos = generate_valid_position(r, existing_positions);\n                existing_sats[satellite_ID_counter] = pos;\n                existing_positions.insert(pos);\n                existing_sat_ids.push_back(satellite_ID_counter);\n                char buf[100];\n                sprintf(buf, \"1 %d %d\", pos.first, pos.second);\n                events.push_back(string(buf));\n            } else if (event_type == 2) {\n                // Remove satellite\n                int idx = rnd.next(0, (int)existing_sat_ids.size() - 1);\n                int id_to_remove = existing_sat_ids[idx];\n                pair<int,int> pos = existing_sats[id_to_remove];\n                existing_sats.erase(id_to_remove);\n                existing_positions.erase(pos);\n                existing_sat_ids.erase(existing_sat_ids.begin() + idx);\n                char buf[100];\n                sprintf(buf, \"2 %d\", id_to_remove);\n                events.push_back(string(buf));\n            } else if (event_type == 3) {\n                // Attempt to create communication channel\n                int idx1 = rnd.next(0, (int)existing_sat_ids.size() - 1);\n                int idx2;\n                do {\n                    idx2 = rnd.next(0, (int)existing_sat_ids.size() - 1);\n                } while (idx2 == idx1);\n                int id1 = existing_sat_ids[idx1];\n                int id2 = existing_sat_ids[idx2];\n                char buf[100];\n                sprintf(buf, \"3 %d %d\", id1, id2);\n                events.push_back(string(buf));\n            }\n        }\n    } else if (type == \"all_possible_channels\") {\n        int satellite_ID_counter = 0;\n        int x = 0;\n        int y_base = r + 1;\n        int y_step = 1;\n        map<int, pair<int, int>> existing_sats;\n        vector<int> existing_sat_ids;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                // Type 1 event\n                satellite_ID_counter++;\n                int y = y_base + satellite_ID_counter * y_step;\n                pair<int,int> pos = make_pair(x, y);\n                existing_sats[satellite_ID_counter] = pos;\n                existing_sat_ids.push_back(satellite_ID_counter);\n                char buf[100];\n                sprintf(buf, \"1 %d %d\", pos.first, pos.second);\n                events.push_back(string(buf));\n            } else {\n                // Type 3 event\n                if (existing_sat_ids.size() >= 2) {\n                    int id1 = existing_sat_ids[existing_sat_ids.size() - 1];\n                    int id2 = existing_sat_ids[existing_sat_ids.size() - 2];\n                    char buf[100];\n                    sprintf(buf, \"3 %d %d\", id1, id2);\n                    events.push_back(string(buf));\n                } else {\n                    // Not enough satellites, generate another type 1 event\n                    satellite_ID_counter++;\n                    int y = y_base + satellite_ID_counter * y_step;\n                    pair<int,int> pos = make_pair(x, y);\n                    existing_sats[satellite_ID_counter] = pos;\n                    existing_sat_ids.push_back(satellite_ID_counter);\n                    char buf[100];\n                    sprintf(buf, \"1 %d %d\", pos.first, pos.second);\n                    events.push_back(string(buf));\n                }\n            }\n        }\n    }\n\n    /* Output r and n */\n    printf(\"%d %d\\n\", r, (int)events.size());\n\n    /* Output events */\n    for (auto &e : events) {\n        printf(\"%s\\n\", e.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -r 5 -type random\n./gen -n 100 -r 5 -type random\n./gen -n 1000 -r 100 -type random\n./gen -n 10000 -r 1000 -type random\n./gen -n 50000 -r 100000 -type random\n./gen -n 100000 -r 1000000 -type random\n./gen -n 500000 -r 1000000000 -type random\n\n./gen -n 10 -r 5 -type all_possible_channels\n./gen -n 50 -r 10 -type all_possible_channels\n./gen -n 100 -r 100 -type all_possible_channels\n./gen -n 200 -r 1000 -type all_possible_channels\n./gen -n 500 -r 100000 -type all_possible_channels\n./gen -n 1000 -r 1000000 -type all_possible_channels\n./gen -n 10000 -r 10000000 -type all_possible_channels\n./gen -n 500000 -r 1000000000 -type all_possible_channels\n\n./gen -n 10 -r 1 -type random\n./gen -n 100 -r 1 -type random\n./gen -n 1000 -r 1 -type random\n./gen -n 10000 -r 1 -type random\n./gen -n 100000 -r 1 -type random\n\n./gen -n 500000 -r 5 -type random\n./gen -n 500000 -r 1000 -type random\n\n./gen -n 1000 -r 1000000000 -type all_possible_channels\n./gen -n 100000 -r 1000000000 -type all_possible_channels\n./gen -n 500000 -r 1000000000 -type all_possible_channels\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:42.327328",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "856/F",
      "title": "Problem 856/F",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    long long C = inf.readLong(0LL, 1000000000000000000LL, \"C\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(0LL, 1000000000000000000LL, \"a_i\");\n        inf.readSpace();\n        long long bi = inf.readLong(0LL, 1000000000000000000LL, \"b_i\");\n        inf.readEoln();\n        ensuref(ai < bi, \"Vasya's interval %d: a_i (%lld) must be less than b_i (%lld)\", i+1, ai, bi);\n    }\n    for (int i = 0; i < m; ++i) {\n        long long ci = inf.readLong(0LL, 1000000000000000000LL, \"c_i\");\n        inf.readSpace();\n        long long di = inf.readLong(0LL, 1000000000000000000LL, \"d_i\");\n        inf.readEoln();\n        ensuref(ci < di, \"Petya's interval %d: c_i (%lld) must be less than d_i (%lld)\", i+1, ci, di);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    long long C = inf.readLong(0LL, 1000000000000000000LL, \"C\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(0LL, 1000000000000000000LL, \"a_i\");\n        inf.readSpace();\n        long long bi = inf.readLong(0LL, 1000000000000000000LL, \"b_i\");\n        inf.readEoln();\n        ensuref(ai < bi, \"Vasya's interval %d: a_i (%lld) must be less than b_i (%lld)\", i+1, ai, bi);\n    }\n    for (int i = 0; i < m; ++i) {\n        long long ci = inf.readLong(0LL, 1000000000000000000LL, \"c_i\");\n        inf.readSpace();\n        long long di = inf.readLong(0LL, 1000000000000000000LL, \"d_i\");\n        inf.readEoln();\n        ensuref(ci < di, \"Petya's interval %d: c_i (%lld) must be less than d_i (%lld)\", i+1, ci, di);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    long long C = inf.readLong(0LL, 1000000000000000000LL, \"C\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(0LL, 1000000000000000000LL, \"a_i\");\n        inf.readSpace();\n        long long bi = inf.readLong(0LL, 1000000000000000000LL, \"b_i\");\n        inf.readEoln();\n        ensuref(ai < bi, \"Vasya's interval %d: a_i (%lld) must be less than b_i (%lld)\", i+1, ai, bi);\n    }\n    for (int i = 0; i < m; ++i) {\n        long long ci = inf.readLong(0LL, 1000000000000000000LL, \"c_i\");\n        inf.readSpace();\n        long long di = inf.readLong(0LL, 1000000000000000000LL, \"d_i\");\n        inf.readEoln();\n        ensuref(ci < di, \"Petya's interval %d: c_i (%lld) must be less than d_i (%lld)\", i+1, ci, di);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<long long, long long>> generate_random_intervals(int count, long long time_max) {\n    vector<pair<long long, long long>> intervals;\n    for(int i = 0; i < count; ++i) {\n        long long start = rnd.next(0LL, time_max - 1);\n        long long end = rnd.next(start + 1, time_max);\n        intervals.push_back({start, end});\n    }\n    return intervals;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long C = opt<long long>(\"C\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within [1, 200000]\n    n = min(max(n, 1), 200000);\n    m = min(max(m, 1), 200000);\n    C = min(max(C, 0LL), (long long)(1e18));\n\n    vector<pair<long long, long long>> vasya_intervals;\n    vector<pair<long long, long long>> petya_intervals;\n\n    if (type == \"random\") {\n        long long time_max = (long long)(1e18);\n        vasya_intervals = generate_random_intervals(n, time_max);\n        petya_intervals = generate_random_intervals(m, time_max);\n    } else if (type == \"overlapping\") {\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = vasya_intervals;\n        if (m < n)\n            petya_intervals.resize(m);\n        else\n            while ((int)petya_intervals.size() < m)\n                petya_intervals.push_back(vasya_intervals[rnd.next(0, n-1)]);\n    } else if (type == \"non_overlap\") {\n        long long time_max = (long long)(1e18 / 2);\n        vasya_intervals = generate_random_intervals(n, time_max);\n        petya_intervals = generate_random_intervals(m, time_max);\n        // Shift Petya's intervals to be after time_max\n        for(auto& interval : petya_intervals) {\n            interval.first += time_max;\n            interval.second += time_max;\n        }\n    } else if (type == \"max_exp\") {\n        // Vasya and Petya play together as much as possible\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = vasya_intervals;\n        if (m < n)\n            petya_intervals.resize(m);\n        else\n            while ((int)petya_intervals.size() < m)\n                petya_intervals.push_back(vasya_intervals[rnd.next(0, n-1)]);\n        C = (long long)(1e18);\n    } else if (type == \"min_exp\") {\n        // Vasya plays alone\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals.clear();\n    } else if (type == \"huge_C\") {\n        // Set C to maximum value\n        C = (long long)(1e18);\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = generate_random_intervals(m, (long long)(1e18));\n    } else if (type == \"zero_C\") {\n        // Set C to 0\n        C = 0;\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = generate_random_intervals(m, (long long)(1e18));\n    } else {\n        // Default to random\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = generate_random_intervals(m, (long long)(1e18));\n    }\n\n    // Output n, m, C\n    printf(\"%d %d %lld\\n\", n, m, C);\n\n    // Output Vasya's intervals\n    for(auto interval : vasya_intervals) {\n        printf(\"%lld %lld\\n\", interval.first, interval.second);\n    }\n\n    // Output Petya's intervals\n    for(auto interval : petya_intervals) {\n        printf(\"%lld %lld\\n\", interval.first, interval.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<long long, long long>> generate_random_intervals(int count, long long time_max) {\n    vector<pair<long long, long long>> intervals;\n    for(int i = 0; i < count; ++i) {\n        long long start = rnd.next(0LL, time_max - 1);\n        long long end = rnd.next(start + 1, time_max);\n        intervals.push_back({start, end});\n    }\n    return intervals;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long C = opt<long long>(\"C\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within [1, 200000]\n    n = min(max(n, 1), 200000);\n    m = min(max(m, 1), 200000);\n    C = min(max(C, 0LL), (long long)(1e18));\n\n    vector<pair<long long, long long>> vasya_intervals;\n    vector<pair<long long, long long>> petya_intervals;\n\n    if (type == \"random\") {\n        long long time_max = (long long)(1e18);\n        vasya_intervals = generate_random_intervals(n, time_max);\n        petya_intervals = generate_random_intervals(m, time_max);\n    } else if (type == \"overlapping\") {\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = vasya_intervals;\n        if (m < n)\n            petya_intervals.resize(m);\n        else\n            while ((int)petya_intervals.size() < m)\n                petya_intervals.push_back(vasya_intervals[rnd.next(0, n-1)]);\n    } else if (type == \"non_overlap\") {\n        long long time_max = (long long)(1e18 / 2);\n        vasya_intervals = generate_random_intervals(n, time_max);\n        petya_intervals = generate_random_intervals(m, time_max);\n        // Shift Petya's intervals to be after time_max\n        for(auto& interval : petya_intervals) {\n            interval.first += time_max;\n            interval.second += time_max;\n        }\n    } else if (type == \"max_exp\") {\n        // Vasya and Petya play together as much as possible\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = vasya_intervals;\n        if (m < n)\n            petya_intervals.resize(m);\n        else\n            while ((int)petya_intervals.size() < m)\n                petya_intervals.push_back(vasya_intervals[rnd.next(0, n-1)]);\n        C = (long long)(1e18);\n    } else if (type == \"min_exp\") {\n        // Vasya plays alone\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals.clear();\n    } else if (type == \"huge_C\") {\n        // Set C to maximum value\n        C = (long long)(1e18);\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = generate_random_intervals(m, (long long)(1e18));\n    } else if (type == \"zero_C\") {\n        // Set C to 0\n        C = 0;\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = generate_random_intervals(m, (long long)(1e18));\n    } else {\n        // Default to random\n        vasya_intervals = generate_random_intervals(n, (long long)(1e18));\n        petya_intervals = generate_random_intervals(m, (long long)(1e18));\n    }\n\n    // Output n, m, C\n    printf(\"%d %d %lld\\n\", n, m, C);\n\n    // Output Vasya's intervals\n    for(auto interval : vasya_intervals) {\n        printf(\"%lld %lld\\n\", interval.first, interval.second);\n    }\n\n    // Output Petya's intervals\n    for(auto interval : petya_intervals) {\n        printf(\"%lld %lld\\n\", interval.first, interval.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -C 5 -type random\n./gen -n 100 -m 100 -C 0 -type zero_C\n./gen -n 1000 -m 1000 -C 1000000000000000000 -type huge_C\n./gen -n 2000 -m 2000 -C 100000 -type overlapping\n./gen -n 5000 -m 5000 -C 100000 -type non_overlap\n./gen -n 10000 -m 10000 -C 1000000000 -type max_exp\n./gen -n 20000 -m 20000 -C 1000000000 -type min_exp\n./gen -n 50000 -m 50000 -C 500 -type random\n./gen -n 100000 -m 100000 -C 1 -type zero_C\n./gen -n 200000 -m 200000 -C 1000000000000000000 -type huge_C\n./gen -n 10 -m 10 -C 1000000000 -type overlapping\n./gen -n 100 -m 100 -C 1000000000 -type overlapping\n./gen -n 1000 -m 1000 -C 1000000000 -type overlapping\n./gen -n 10000 -m 10000 -C 1000000000 -type overlapping\n./gen -n 100000 -m 100000 -C 1000000000 -type overlapping\n./gen -n 200000 -m 200000 -C 1000000000000000000 -type random\n./gen -n 1 -m 1 -C 5 -type random\n./gen -n 1 -m 200000 -C 5 -type random\n./gen -n 200000 -m 1 -C 5 -type random\n./gen -n 200000 -m 200000 -C 0 -type zero_C\n./gen -n 200000 -m 200000 -C 1 -type zero_C\n./gen -n 200000 -m 200000 -C 1000000 -type non_overlap\n./gen -n 200000 -m 200000 -C 1000000 -type max_exp\n./gen -n 200000 -m 200000 -C 1000000 -type min_exp\n./gen -n 200000 -m 200000 -C 500000 -type overlapping\n./gen -n 200000 -m 200000 -C 500000 -type non_overlap\n./gen -n 200000 -m 200000 -C 1000000000000000000 -type max_exp\n./gen -n 200000 -m 200000 -C 0 -type min_exp\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:44.192321",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "858/A",
      "title": "A. k-Округление",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных записаны два целых числа n и k (1 ≤ n ≤ 109, 0 ≤ k ≤ 8).",
      "output_spec": "Выходные данныеВыведите k-округление числа n.",
      "sample_tests": "ПримерыВходные данныеСкопировать375 4Выходные данныеСкопировать30000Входные данныеСкопировать10000 1Выходные данныеСкопировать10000Входные данныеСкопировать38101 0Выходные данныеСкопировать38101Входные данныеСкопировать123456789 8Выходные данныеСкопировать12345678900000000",
      "description": "A. k-Округление\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке входных данных записаны два целых числа n и k (1 ≤ n ≤ 109, 0 ≤ k ≤ 8).\n\nВходные данные\n\nВыходные данныеВыведите k-округление числа n.\n\nВыходные данные\n\nВходные данныеСкопировать375 4Выходные данныеСкопировать30000Входные данныеСкопировать10000 1Выходные данныеСкопировать10000Входные данныеСкопировать38101 0Выходные данныеСкопировать38101Входные данныеСкопировать123456789 8Выходные данныеСкопировать12345678900000000\n\nВходные данныеСкопировать375 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать30000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10000 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать38101 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать38101\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать123456789 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12345678900000000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Технокубок 2018 — Отборочный Раунд 1 (и открытые рейтинговые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces",
          "content": "Приношу свои извинения участникам раунда. Так получилось, что я случайно загасил все тестирующие серверы, просто промахнувшись скриптом их управления. Самому крайне обидно, ведь почти все задачи были предложены мной и я очень надеялся провести интересное соревнование. На подготовку было потрачено много сил. Видимо, ошибка именно такого человеческого характера случилась впервые. Очень надеюсь не повторять в будущем. MikeMirzayanov Обратите внимание, что мы напряглись и подготовили дополнительные задачи для Div 1. Таким образом, параллельно с отборочным раундом будет проведен Codeforces Round 434 Div.1+Div.2 (рейтинговый раунд для обоих дивизионов — всё как вы любите). Участвуют все! Добрый день. 17-го сентября в 16:05 (московское время) стартует Отборочный Раунд 1 (и открытые раунды для обоих дивизионов по его мотивам) олимпиады для школьников Технокубок 2018. Раунд будет длиться два часа, участникам будут предложены 6 задач. По его результатам лучшие участники (но не более 45% от общего числа участников раунда) будут приглашены на финальный этап в Москву. Для регистрации на раунды и участия перейдите по ссылке. Не забудьте заранее зарегистрироваться на раунд. Впрочем, если забудете — не беда. Через 10 минут после старта будет открыта дополнительная регистрация для опоздавших (ее длительность — 20 минут). Зарегистрироваться на Отборочный Раунд 1 → Соревнование открыто для всех в виде отдельных раундов для первого и второго дивизионов. Для всех участников всех трех редакций этого соревнования будет пересчитан рейтинг. Напомним, что согласно правилам раундов Codeforces во время соревнования ваши решения будут тестироваться только на претестах (предварительном и неполном наборе тестов), а системное тестирование состоится после окончания раунда. Обратите внимание, что претесты не покрывают все возможные случаи входных данных, поэтому тщательно тестируйте свои программы! После прохождения претестов у вас будет возможность заблокировать решение, тем самым получив привилегию искать ошибки и взламывать чужие решения, но отказавшись от возможности перепослать ваше решение при каких-либо обстоятельствах (например, даже если вы найдете ошибку или вас взломают). Со временем задачи падают в стоимости. После системного тестирования учитываются только полные решения. Подробнее про правила соревнований можно прочитать по ссылкам: короткое описание формата полное описание формата Регистрация на олимпиаду Технокубок еще открыта. На кону — значительные квоты при поступлении в престижные технические вузы России и ценные призы. Если вы — школьник 8-11 классов и пока не зарегистрировались на Технокубок, то самое время сделать это: Зарегистрироваться на олимпиаду → В финал соревнования будут приглашены лучшие участники каждого из отборочных раундов (но не более 45% от общего числа участников раунда). Большое спасибо KAN, vovuh, Neon, ifsmirnov, irkstepanov и WHITE2302, все они участвовали в подготовке раунда. Желаем удачи на олимпиаде, MikeMirzayanov и команда Технокубка UPD: Соревнование завершено. В отборочном раунде Технокубка первые три места заняли: Рамазан never_giveup Рахматуллин Роман pomo_mondreganto Никитин Филипп grphil Грибов Место в Финале Технокубка достается лучшим 100 участникам раунда (по участника dfczyjd включительно). Поздравляем победителей!",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/54580",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3298
        },
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces",
          "content": "858A - k-ОкруглениеЗаметим, что число x заканчивается хотя бы на k нулей, если максимальная степень 2, на которую делится число x, не менее k, и максимальная степень 5, на которую делится число, также не менее k. Тогда посчитаем максимальные степени 2 и 5, на которые делится заданное n. Если одна из степеней меньше чем k, домножим на нужное количество 2 и 5.Так же можно заметить, что ответ это НОК(n, 10k). 858B - Какой этаж?Сохраним переменную ans, отвечающую за ответ, которая изначально будет равна -1.Давайте переберём количество квартир на этаже от 1 до 100. Пусть эта величина равняется cf. Теперь мы должны проверить, что такое количество квартир является корректным для заданного набора входных данных. Если хотя бы для какого-нибудь , то это количество квартир некорректно, пропускаем его.Теперь же, если , то значит, мы не можем однозначно определить, на каком этаже располагается квартира n. Выводим -1. Иначе же просто присвоим . 858C - Возможно, вы имели в виду...Давайте решать задачу жадно. Посмотрим, где находится самая левая опечатка. Очевидно, это будут такие три последовательные буквы si - 1, si и si + 1 такие, что все они согласные и среди них есть хотя бы две различные. Очевидно, что выгоднее всего будет \"порезать\" строку после позиции i, потому что в таком случае наш префикс останется корректным, а в суффикс мы перенесём всего лишь одну букву. Таким образом, можно пройти слева направо по строке и резать её в позициях с некорректными тройками букв. Только необходимо не забывать, что после разреза строки в позиции i мы должны дальше рассматривать её с позиции i + 2, а не i + 1. 858D - Телефонная книга ПоликарпаДля каждой строки необходимо найти кратчайшую подстроку, которая не встречается как подстрока в других строках. Для этого для каждой подстроки будем хранить номер строки, в которой она встречается, или  - 1, если она встречается более чем в одной строке. После этого пройдемся по всем подстрокам, для которых значение не равно  - 1, и попробуем обновить ответ для той строки, которая записана как значение. 858E - Перенумерация тестовСразу выбросим все корректные тесты из рассмотрения. Будем называть тестами типа 1 примеры, а тестами типа 2 — обычные тесты.Далее назовём свободными все такие позиции , что в оставшемся наборе нет теста с названием, соответствующим номеру i. Если есть хотя бы одна свободная позиция — это хороший случай. Иначе, очевидно, мы не сможем за одну операцию move переместить какой-нибудь тест на своё место, потому что мы сначала должны освободить строку, соответствующую его номеру.Можно показать, что нам всегда достаточно иметь хотя бы одну свободную позицию. Если она есть, то давайте поставим тест, соответствующий типу этой позиции, на своё место. Очевидно, что такой тест найдётся, иначе бы это означало, что все тесты этого типа стоят на своих местах. Далее может возникнуть два случая — либо мы освободили какую-то другую позицию (когда мы перемещали тест с названием, соответствующим некоторой корректной позиции), либо же мы не освободили ничего (когда мы перемещали тест с названием, не соответствующим какой-то корректной позиции).Выгоднее в первую очередь перемещать тесты, соответствующие корректным позициям, потому что иначе у нас просто не будут появляться новые свободные позиции для тестов. Очевидно, что когда у нас закончатся тесты, которые имеют корректные номера, мы больше никогда не получим новой свободной позиции.Делая так, можно добиться оптимального ответа, потому что будет произведено либо cnt действий, где cnt — количество некорректных тестов в изначальном наборе, либо cnt + 1 действий. cnt + 1 может получиться только тогда, когда нам иногда необходимо совершить дополнительное действие, чтобы освободить какую-либо позицию.Очевидно, что это количество действий оптимально, потому что если у нас изначально было cnt некорректных тестов, то мы должны сделать хотя бы cnt операций, чтобы переместить каждый тест на своё место. Так как выше мы показали, что если есть свободная позиция, то ей точно соответствует какой-либо некорректный тест, то единственный плохой случай возникает тогда, когда у нас нет свободных позиций. Тогда нам необходимо сделать ещё одну операцию, чтобы освободить позицию. 858F - Турне волшебникаОчевидно, что задачу можно решать для каждой компоненты связности независимо. Опишем алгоритм, который позволит набирать ровно туров, где m — количество ребер в компоненте связности. Рассмотрим произвольное дерево обхода в глубину. Будем в процессе обхода, выходя из вершины v, обрабатывать все ребра, исходящие из этой вершины вниз по дереву, а также ребро, соединяющее v с ее родителем в дереве (если v — не корень). Если ребер, идущих вниз, четное количество, разобьем их на пары. Иначе добавим в разбиение ребро, выходящее из родителя, и не будем его рассматривать для родителя. Такой алгоритм для всех вершин, кроме корня, найдет пару для каждого ребра. Будет не более одного ребра без пары, поэтому ответ будет оптимальным. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 858\\s*A"
          },
          "content_length": 6637
        }
      ],
      "code_examples": [
        {
          "title": "Технокубок 2018 — Отборочный Раунд 1 (и открытые рейтинговые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 1",
          "code": "Wrong answer on pretest 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Технокубок 2018 — Отборочный Раунд 1 (и открытые рейтинговые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 2",
          "code": "(long long) pow(10, k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Технокубок 2018 — Отборочный Раунд 1 (и открытые рейтинговые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 3",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Технокубок 2018 — Отборочный Раунд 1 (и открытые рейтинговые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 4",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Технокубок 2018 — Отборочный Раунд 1 (и открытые рейтинговые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 5",
          "code": "dfaccc babc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 8, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 8, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 8, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Helper function to compute 10^k\nlong long pow10(int k) {\n    long long res = 1;\n    for (int i = 0; i < k; ++i)\n        res *= 10;\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n_input = opt<int>(\"n\", -1);\n    int k_input = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, k;\n\n    // Generate n and k according to type\n    if (type == \"min_n\") {\n        n = 1;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"max_n\") {\n        n = 1000000000;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"min_k\") {\n        n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        k = 0;\n    } else if (type == \"max_k\") {\n        n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        k = 8;\n    } else if (type == \"power_of_10\") {\n        // n is a power of 10\n        int exp = rnd.next(1, 9);\n        n = (int)pow10(exp);\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"multiple_of_power_of_10\") {\n        // n is multiple of some power of 10\n        int exp = rnd.next(1, 8);\n        long long factor = pow10(exp);\n        int max_m = 1000000000 / factor;\n        int m = rnd.next(1, max_m);\n        n = (int)(m * factor);\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"n_ends_with_k_zeros\") {\n        // n ends with k zeros\n        k = (k_input == -1) ? rnd.next(1, 8) : k_input;\n        if (k == 0) {\n            n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        } else {\n            long long factor = pow10(k);\n            int max_m = 1000000000 / factor;\n            if (max_m < 1) max_m = 1;\n            int m = (n_input == -1) ? rnd.next(1, max_m) : n_input / factor;\n            n = (int)(m * factor);\n        }\n    } else if (type == \"n_already_k_rounding\") {\n        // n is already divisible by 10^k and ends with at least k zeros\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n        if (k == 0) {\n            n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        } else {\n            long long factor = pow10(k);\n            int max_m = 1000000000 / factor;\n            if (max_m < 1) max_m = 1;\n            int m = (n_input == -1) ? rnd.next(1, max_m) : n_input / factor;\n            n = (int)(m * factor);\n        }\n    } else if (type == \"special\") {\n        // n is a large prime number\n        n = 999999937;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else {\n        // Random n and k within constraints\n        n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    }\n\n    // Ensure n and k are within constraints\n    if (n < 1) n = 1;\n    if (n > 1000000000) n = 1000000000;\n    if (k < 0) k = 0;\n    if (k > 8) k = 8;\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Helper function to compute 10^k\nlong long pow10(int k) {\n    long long res = 1;\n    for (int i = 0; i < k; ++i)\n        res *= 10;\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n_input = opt<int>(\"n\", -1);\n    int k_input = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, k;\n\n    // Generate n and k according to type\n    if (type == \"min_n\") {\n        n = 1;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"max_n\") {\n        n = 1000000000;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"min_k\") {\n        n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        k = 0;\n    } else if (type == \"max_k\") {\n        n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        k = 8;\n    } else if (type == \"power_of_10\") {\n        // n is a power of 10\n        int exp = rnd.next(1, 9);\n        n = (int)pow10(exp);\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"multiple_of_power_of_10\") {\n        // n is multiple of some power of 10\n        int exp = rnd.next(1, 8);\n        long long factor = pow10(exp);\n        int max_m = 1000000000 / factor;\n        int m = rnd.next(1, max_m);\n        n = (int)(m * factor);\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else if (type == \"n_ends_with_k_zeros\") {\n        // n ends with k zeros\n        k = (k_input == -1) ? rnd.next(1, 8) : k_input;\n        if (k == 0) {\n            n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        } else {\n            long long factor = pow10(k);\n            int max_m = 1000000000 / factor;\n            if (max_m < 1) max_m = 1;\n            int m = (n_input == -1) ? rnd.next(1, max_m) : n_input / factor;\n            n = (int)(m * factor);\n        }\n    } else if (type == \"n_already_k_rounding\") {\n        // n is already divisible by 10^k and ends with at least k zeros\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n        if (k == 0) {\n            n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        } else {\n            long long factor = pow10(k);\n            int max_m = 1000000000 / factor;\n            if (max_m < 1) max_m = 1;\n            int m = (n_input == -1) ? rnd.next(1, max_m) : n_input / factor;\n            n = (int)(m * factor);\n        }\n    } else if (type == \"special\") {\n        // n is a large prime number\n        n = 999999937;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    } else {\n        // Random n and k within constraints\n        n = (n_input == -1) ? rnd.next(1, 1000000000) : n_input;\n        k = (k_input == -1) ? rnd.next(0, 8) : k_input;\n    }\n\n    // Ensure n and k are within constraints\n    if (n < 1) n = 1;\n    if (n > 1000000000) n = 1000000000;\n    if (k < 0) k = 0;\n    if (k > 8) k = 8;\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen\n./gen\n./gen\n\n# Minimum and maximum values of n\n./gen -type min_n\n./gen -type max_n\n\n# Minimum and maximum values of k\n./gen -type min_k\n./gen -type max_k\n\n# n is a power of 10\n./gen -type power_of_10\n./gen -type power_of_10\n\n# n is a multiple of a power of 10\n./gen -type multiple_of_power_of_10\n./gen -type multiple_of_power_of_10\n\n# n ends with at least k zeros\n./gen -type n_ends_with_k_zeros\n./gen -type n_ends_with_k_zeros -k 5\n./gen -type n_ends_with_k_zeros -k 8\n\n# n is already the k-rounding of itself\n./gen -type n_already_k_rounding\n./gen -type n_already_k_rounding -k 3\n\n# Special cases\n./gen -type special\n./gen -type special -k 0\n./gen -type special -k 8\n\n# Fixed values of n and random k\n./gen -n 1\n./gen -n 1000000000\n./gen -n 123456789\n\n# Fixed values of k and random n\n./gen -k 0\n./gen -k 8\n./gen -k 4\n\n# Fixed values of both n and k\n./gen -n 10000 -k 1\n./gen -n 375 -k 4\n./gen -n 38101 -k 0\n./gen -n 123456789 -k 8\n\n# Random test cases with specified type\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases for n and k\n./gen -n 1 -k 0\n./gen -n 1 -k 8\n./gen -n 1000000000 -k 0\n./gen -n 1000000000 -k 8\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:46.248550",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "858/B",
      "title": "B. Which floor?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 100, 0 ≤ m ≤ 100), where n is the number of the flat you need to restore floor for, and m is the number of flats in Polycarp's memory.m lines follow, describing the Polycarp's memory: each of these lines contains a pair of integers ki, fi (1 ≤ ki ≤ 100, 1 ≤ fi ≤ 100), which means that the flat ki is on the fi-th floor. All values ki are distinct.It is guaranteed that the given information is not self-contradictory.",
      "output_spec": "OutputPrint the number of the floor in which the n-th flat is located, if it is possible to determine it in a unique way. Print -1 if it is not possible to uniquely restore this floor.",
      "sample_tests": "ExamplesInputCopy10 36 22 17 3OutputCopy4InputCopy8 43 16 25 22 1OutputCopy-1",
      "description": "B. Which floor?\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 100, 0 ≤ m ≤ 100), where n is the number of the flat you need to restore floor for, and m is the number of flats in Polycarp's memory.m lines follow, describing the Polycarp's memory: each of these lines contains a pair of integers ki, fi (1 ≤ ki ≤ 100, 1 ≤ fi ≤ 100), which means that the flat ki is on the fi-th floor. All values ki are distinct.It is guaranteed that the given information is not self-contradictory.\n\nOutputPrint the number of the floor in which the n-th flat is located, if it is possible to determine it in a unique way. Print -1 if it is not possible to uniquely restore this floor.\n\nInputCopy10 36 22 17 3OutputCopy4InputCopy8 43 16 25 22 1OutputCopy-1\n\nInputCopy10 36 22 17 3\n\nOutputCopy4\n\nInputCopy8 43 16 25 22 1\n\nOutputCopy-1\n\nNoteIn the first example the 6-th flat is on the 2-nd floor, while the 7-th flat is on the 3-rd, so, the 6-th flat is the last on its floor and there are 3 flats on each floor. Thus, the 10-th flat is on the 4-th floor.In the second example there can be 3 or 4 flats on each floor, so we can't restore the floor for the 8-th flat.",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces",
          "content": "I apologize to the participants of the round. It happened that I accidentally had run improper script and it rebooted the judging machines. It is very insulting, because most problems were proposed by me and I hoped to host an interesting competition for you. A lot of effort was spent on preparation. Apparently, the mistake of just such a human character happened for the first time. I really hope not to repeat it in the future.MikeMirzayanov Want problems? We have some!Codeforces Round 434 will start on September 17 (Sunday), 13:05 (UTC). It will be based on Technocup 2018 Elimination Round 1. So, if you are a Russian-speaking high-school student, please take part in the Technocup 2018.Many thanks to KAN, vovuh, Neon, ifsmirnov, irkstepanov and WHITE2302 for their help in round preparation. Some problem ideas are mine.I hope you will like problems. There will be 6 problems in div. 2 and 5 problems in div. 1.Wish you good luck and bugless code.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/54580",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 858\\s*B"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 1",
          "code": "Wrong answer on pretest 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 2",
          "code": "(long long) pow(10, k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 3",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 4",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 5",
          "code": "dfaccc babc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_K = (int)1e9;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n    set<int> flats;\n    int lb = 1; // lower bound for k\n    int ub = MAX_K; // upper bound for k\n\n    for (int i = 0; i < m; i++) {\n        int ki = inf.readInt(1, 100, \"ki\");\n        inf.readSpace();\n        int fi = inf.readInt(1, 100, \"fi\");\n        inf.readEoln();\n        ensuref(flats.insert(ki).second, \"All ki must be distinct\");\n\n        if (fi == 1) {\n            lb = std::max(lb, ki);\n            // ub remains unchanged\n        } else {\n            int lb_candidate = (ki + fi - 2) / fi;\n            lb = std::max(lb, lb_candidate);\n\n            int denominator = fi - 1;\n            if (denominator != 0) {\n                int ub_candidate = (ki - 1) / denominator;\n                ub = std::min(ub, ub_candidate);\n            }\n            // else, when denominator == 0, ub remains unchanged\n        }\n    }\n    ensuref(lb <= ub, \"No valid k exists for the observations\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_K = (int)1e9;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n    set<int> flats;\n    int lb = 1; // lower bound for k\n    int ub = MAX_K; // upper bound for k\n\n    for (int i = 0; i < m; i++) {\n        int ki = inf.readInt(1, 100, \"ki\");\n        inf.readSpace();\n        int fi = inf.readInt(1, 100, \"fi\");\n        inf.readEoln();\n        ensuref(flats.insert(ki).second, \"All ki must be distinct\");\n\n        if (fi == 1) {\n            lb = std::max(lb, ki);\n            // ub remains unchanged\n        } else {\n            int lb_candidate = (ki + fi - 2) / fi;\n            lb = std::max(lb, lb_candidate);\n\n            int denominator = fi - 1;\n            if (denominator != 0) {\n                int ub_candidate = (ki - 1) / denominator;\n                ub = std::min(ub, ub_candidate);\n            }\n            // else, when denominator == 0, ub remains unchanged\n        }\n    }\n    ensuref(lb <= ub, \"No valid k exists for the observations\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_K = (int)1e9;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n    set<int> flats;\n    int lb = 1; // lower bound for k\n    int ub = MAX_K; // upper bound for k\n\n    for (int i = 0; i < m; i++) {\n        int ki = inf.readInt(1, 100, \"ki\");\n        inf.readSpace();\n        int fi = inf.readInt(1, 100, \"fi\");\n        inf.readEoln();\n        ensuref(flats.insert(ki).second, \"All ki must be distinct\");\n\n        if (fi == 1) {\n            lb = std::max(lb, ki);\n            // ub remains unchanged\n        } else {\n            int lb_candidate = (ki + fi - 2) / fi;\n            lb = std::max(lb, lb_candidate);\n\n            int denominator = fi - 1;\n            if (denominator != 0) {\n                int ub_candidate = (ki - 1) / denominator;\n                ub = std::min(ub, ub_candidate);\n            }\n            // else, when denominator == 0, ub remains unchanged\n        }\n    }\n    ensuref(lb <= ub, \"No valid k exists for the observations\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10); // default n=10\n    int m = opt<int>(\"m\", 0);  // default m=0\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n in [1, 100], m in [0, min(100, n)]\n    n = max(1, min(n, 100));\n    m = max(0, min(m, 100));\n\n    vector<int> ks; // known flat numbers\n    vector<int> fs; // their corresponding floor numbers\n\n    if (type == \"random\" || type == \"unique_possible\") {\n        // Pick a random flats_per_floor value\n        int flats_per_floor = rnd.next(1, 100);\n        int total_flats = n;\n        m = min(m, n);\n        m = m ? m : rnd.next(1, n);\n\n        set<int> used_ks;\n        for (int i = 0; i < m; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while (used_ks.count(k));\n            used_ks.insert(k);\n            int f = (k + flats_per_floor - 1) / flats_per_floor; // ceil division\n            ks.push_back(k);\n            fs.push_back(f);\n        }\n    } else if (type == \"zero_m\") {\n        m = 0;\n        // No need to generate any ks and fs\n    } else if (type == \"multiple_possible\") {\n        // Generate data where multiple flats per floor values are possible\n        m = 4;\n        n = max(n, 8);\n        ks.push_back(3); fs.push_back(1);\n        ks.push_back(6); fs.push_back(2);\n        ks.push_back(5); fs.push_back(2);\n        ks.push_back(2); fs.push_back(1);\n    } else if (type == \"floor_vs_ceil\") {\n        // Generate data where using floor division instead of ceiling division would produce wrong answer\n        int flats_per_floor = rnd.next(2, 100); // at least 2\n\n        int k1 = flats_per_floor - 1; // Should be on floor 1\n        int f1 = 1;\n\n        int k2 = flats_per_floor + 1; // Should be on floor 2\n        int f2 = 2;\n\n        ks.push_back(k1);\n        fs.push_back(f1);\n        ks.push_back(k2);\n        fs.push_back(f2);\n\n        n = k2 + rnd.next(0, flats_per_floor); // n slightly larger than k2\n        m = 2;\n    } else if (type == \"min_n\") {\n        n = 1;\n        m = 0;\n    } else if (type == \"max_n\") {\n        n = 100;\n        m = min(m, 100);\n        int flats_per_floor = rnd.next(1, 100);\n        set<int> used_ks;\n        for (int i = 0; i < m; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while (used_ks.count(k));\n            used_ks.insert(k);\n            int f = (k + flats_per_floor - 1) / flats_per_floor;\n            ks.push_back(k);\n            fs.push_back(f);\n        }\n    } else if (type == \"max_m\") {\n        m = 100;\n        n = max(n, 100);\n        int flats_per_floor = rnd.next(1, 100);\n        n = max(n, flats_per_floor * 100);\n\n        set<int> used_ks;\n\n        for (int i = 0; i < m; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while (used_ks.count(k));\n            used_ks.insert(k);\n            int f = (k + flats_per_floor - 1) / flats_per_floor;\n            ks.push_back(k);\n            fs.push_back(f);\n        }\n    } else {\n        // unknown type, exit with error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", ks[i], fs[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10); // default n=10\n    int m = opt<int>(\"m\", 0);  // default m=0\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n in [1, 100], m in [0, min(100, n)]\n    n = max(1, min(n, 100));\n    m = max(0, min(m, 100));\n\n    vector<int> ks; // known flat numbers\n    vector<int> fs; // their corresponding floor numbers\n\n    if (type == \"random\" || type == \"unique_possible\") {\n        // Pick a random flats_per_floor value\n        int flats_per_floor = rnd.next(1, 100);\n        int total_flats = n;\n        m = min(m, n);\n        m = m ? m : rnd.next(1, n);\n\n        set<int> used_ks;\n        for (int i = 0; i < m; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while (used_ks.count(k));\n            used_ks.insert(k);\n            int f = (k + flats_per_floor - 1) / flats_per_floor; // ceil division\n            ks.push_back(k);\n            fs.push_back(f);\n        }\n    } else if (type == \"zero_m\") {\n        m = 0;\n        // No need to generate any ks and fs\n    } else if (type == \"multiple_possible\") {\n        // Generate data where multiple flats per floor values are possible\n        m = 4;\n        n = max(n, 8);\n        ks.push_back(3); fs.push_back(1);\n        ks.push_back(6); fs.push_back(2);\n        ks.push_back(5); fs.push_back(2);\n        ks.push_back(2); fs.push_back(1);\n    } else if (type == \"floor_vs_ceil\") {\n        // Generate data where using floor division instead of ceiling division would produce wrong answer\n        int flats_per_floor = rnd.next(2, 100); // at least 2\n\n        int k1 = flats_per_floor - 1; // Should be on floor 1\n        int f1 = 1;\n\n        int k2 = flats_per_floor + 1; // Should be on floor 2\n        int f2 = 2;\n\n        ks.push_back(k1);\n        fs.push_back(f1);\n        ks.push_back(k2);\n        fs.push_back(f2);\n\n        n = k2 + rnd.next(0, flats_per_floor); // n slightly larger than k2\n        m = 2;\n    } else if (type == \"min_n\") {\n        n = 1;\n        m = 0;\n    } else if (type == \"max_n\") {\n        n = 100;\n        m = min(m, 100);\n        int flats_per_floor = rnd.next(1, 100);\n        set<int> used_ks;\n        for (int i = 0; i < m; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while (used_ks.count(k));\n            used_ks.insert(k);\n            int f = (k + flats_per_floor - 1) / flats_per_floor;\n            ks.push_back(k);\n            fs.push_back(f);\n        }\n    } else if (type == \"max_m\") {\n        m = 100;\n        n = max(n, 100);\n        int flats_per_floor = rnd.next(1, 100);\n        n = max(n, flats_per_floor * 100);\n\n        set<int> used_ks;\n\n        for (int i = 0; i < m; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while (used_ks.count(k));\n            used_ks.insert(k);\n            int f = (k + flats_per_floor - 1) / flats_per_floor;\n            ks.push_back(k);\n            fs.push_back(f);\n        }\n    } else {\n        // unknown type, exit with error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", ks[i], fs[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type unique_possible\n./gen -n 10 -type multiple_possible\n./gen -n 10 -type zero_m\n./gen -n 10 -type floor_vs_ceil\n\n./gen -n 100 -type random\n./gen -n 100 -type unique_possible\n./gen -n 100 -type multiple_possible\n./gen -n 100 -type zero_m\n./gen -n 100 -type floor_vs_ceil\n\n./gen -n 1 -type min_n\n./gen -n 100 -type max_n\n./gen -n 100 -m 100 -type max_m\n\n./gen -n 50 -type random\n./gen -n 50 -type unique_possible\n./gen -n 50 -type multiple_possible\n./gen -n 50 -type zero_m\n./gen -n 50 -type floor_vs_ceil\n\n./gen -n 75 -type random\n./gen -n 75 -type unique_possible\n./gen -n 75 -type floor_vs_ceil\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type unique_possible\n./gen -n 100 -m 100 -type multiple_possible\n\n./gen -n 99 -type random\n./gen -n 99 -type unique_possible\n./gen -n 99 -type floor_vs_ceil\n\n./gen -n 1 -m 0 -type random\n./gen -n 100 -m 0 -type zero_m\n\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 100 -type max_n\n\n./gen -n 100 -type floor_vs_ceil\n./gen -n 99 -type floor_vs_ceil\n\n./gen -n 50 -m 25 -type random\n./gen -n 100 -m 50 -type unique_possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:47.912178",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "858/C",
      "title": "C. Did you mean...",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.",
      "output_spec": "OutputPrint the given word without any changes if there are no typos.If there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopyhellnoOutputCopyhell no InputCopyabacabaOutputCopyabacaba InputCopyasdfasdfOutputCopyasd fasd f",
      "description": "C. Did you mean...\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.\n\nOutputPrint the given word without any changes if there are no typos.If there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.\n\nInputCopyhellnoOutputCopyhell no InputCopyabacabaOutputCopyabacaba InputCopyasdfasdfOutputCopyasd fasd f\n\nInputCopyhellno\n\nOutputCopyhell no\n\nInputCopyabacaba\n\nOutputCopyabacaba\n\nInputCopyasdfasdf\n\nOutputCopyasd fasd f",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces",
          "content": "I apologize to the participants of the round. It happened that I accidentally had run improper script and it rebooted the judging machines. It is very insulting, because most problems were proposed by me and I hoped to host an interesting competition for you. A lot of effort was spent on preparation. Apparently, the mistake of just such a human character happened for the first time. I really hope not to repeat it in the future.MikeMirzayanov Want problems? We have some!Codeforces Round 434 will start on September 17 (Sunday), 13:05 (UTC). It will be based on Technocup 2018 Elimination Round 1. So, if you are a Russian-speaking high-school student, please take part in the Technocup 2018.Many thanks to KAN, vovuh, Neon, ifsmirnov, irkstepanov and WHITE2302 for their help in round preparation. Some problem ideas are mine.I hope you will like problems. There will be 6 problems in div. 2 and 5 problems in div. 1.Wish you good luck and bugless code.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/54580",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 858\\s*C"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 1",
          "code": "Wrong answer on pretest 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 2",
          "code": "(long long) pow(10, k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 3",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 4",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 5",
          "code": "dfaccc babc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 3000, \n        \"Length of word must be between 1 and 3000, but it is %d\", (int)s.length());\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"Invalid character '%c' in word\", c);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 3000, \n        \"Length of word must be between 1 and 3000, but it is %d\", (int)s.length());\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"Invalid character '%c' in word\", c);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 3000, \n        \"Length of word must be between 1 and 3000, but it is %d\", (int)s.length());\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"Invalid character '%c' in word\", c);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool isVowel(char ch) {\n    return ch == 'a'|| ch == 'e'|| ch == 'i'|| ch == 'o'|| ch == 'u';\n}\n\nbool hasTypo(const string& word) {\n    int cnt = 0;\n    set<char> consonants;\n    for (int i = 0; i < word.size(); ++i) {\n        char ch = word[i];\n        if (!isVowel(ch)) {\n            cnt++;\n            consonants.insert(ch);\n            if (cnt >= 3 && consonants.size() >=2 ) {\n                return true; // typo found\n            }\n        } else {\n            cnt = 0;\n            consonants.clear();\n        }\n    }\n    return false; // no typo\n}\n\nint computeMinSpaces(const string& s) {\n    int N = s.size();\n    int spaces = 0;\n    int cnt = 0;\n    set<char> consonants;\n    for (int i = 0; i < N; ++i) {\n        char ch = s[i];\n        if (!isVowel(ch)) {\n            cnt++;\n            consonants.insert(ch);\n            if (cnt >= 3 && consonants.size() >= 2) {\n                // need to insert a space before current character\n                spaces++;\n                // reset counters, start new word\n                cnt = 1;\n                consonants.clear();\n                consonants.insert(ch); // start with current consonant\n            }\n        } else {\n            cnt = 0;\n            consonants.clear();\n        }\n    }\n    return spaces;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    s = inf.readString();\n    \n    string ans_line = ouf.readLine();\n    // Remove leading/trailing whitespaces\n    ans_line = ans_line.substr(ans_line.find_first_not_of(\" \\t\"),\n                              ans_line.find_last_not_of(\" \\t\") - ans_line.find_first_not_of(\" \\t\") + 1);\n\n    // Split ans_line into words at spaces\n    vector<string> contestant_words;\n    stringstream ss(ans_line);\n    string word;\n    while (ss >> word) {\n        contestant_words.push_back(word);\n    }\n    // Concatenate words and compare with input\n    string t;\n    for (const string& w : contestant_words) {\n        t += w;\n    }\n    if (t != s) {\n        quitf(_wa, \"The concatenation of the words in the output does not match the input word.\");\n    }\n    // Check that each word has no typos\n    for (const string& w : contestant_words) {\n        if (hasTypo(w)) {\n            quitf(_wa, \"The word '%s' in the output contains a typo.\", w.c_str());\n        }\n        // Also check that the word contains only lowercase letters\n        for (char ch : w) {\n            if (ch < 'a' || ch > 'z') {\n                quitf(_wa, \"The word '%s' contains invalid characters.\", w.c_str());\n            }\n        }\n    }\n    // Count the number of spaces in contestant's output\n    int contestant_spaces = contestant_words.size() - 1;\n    // Compute minimal number of spaces required\n    int minimal_spaces = computeMinSpaces(s);\n    if (contestant_spaces != minimal_spaces) {\n        quitf(_wa, \"The number of spaces in the output (%d) is not minimal (%d).\", contestant_spaces, minimal_spaces);\n    }\n    quitf(_ok, \"The output is correct.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring vowels = \"aeiou\";\nstring consonants = \"bcdfghjklmnpqrstvwxyz\";\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random word of length n\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26); // Random letter from 'a' to 'z'\n            s += c;\n        }\n    } else if (type == \"typo\") {\n        // Ensure there is at least one typo in the word\n        if (n < 3) {\n            ensuref(false, \"Length must be at least 3 for type 'typo'\");\n        }\n\n        // Decide the position and length of the typo block\n        int l = rnd.next(3, min(10, n)); // Length of the typo block (at least 3)\n        int pos = rnd.next(0, n - l);    // Starting position of the typo block\n\n        // Generate a typo block (consonant block with at least two different letters)\n        char c1 = consonants[rnd.next(21)];\n        char c2 = c1;\n        while (c2 == c1)\n            c2 = consonants[rnd.next(21)];\n\n        string typoBlock;\n        for (int i = 0; i < l; ++i) {\n            if (rnd.next(2))\n                typoBlock += c1;\n            else\n                typoBlock += c2;\n        }\n\n        // Build the complete word\n        for (int i = 0; i < n; ++i) {\n            if (i >= pos && i < pos + l) {\n                s += typoBlock[i - pos];\n            } else {\n                // Randomly pick a letter (vowel or consonant)\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n        }\n    } else if (type == \"no-typo\") {\n        // Generate a word without any typos\n        int cCnt = 0;    // Count of consecutive consonants\n        char cPrev = '#'; // Previous character\n\n        for (int i = 0; i < n; ++i) {\n            char c;\n            if (cCnt == 2) {\n                // Avoid forming a typo (third consonant with a different letter)\n                if (rnd.next(2)) {\n                    // Insert a vowel to break the consonant sequence\n                    c = vowels[rnd.next(5)];\n                    cCnt = 0;\n                    cPrev = '#';\n                } else {\n                    // Repeat the same consonant\n                    c = cPrev;\n                    cCnt++;\n                }\n            } else {\n                // Randomly decide to insert a vowel or consonant\n                if (rnd.next(2)) {\n                    // Insert a vowel\n                    c = vowels[rnd.next(5)];\n                    cCnt = 0;\n                    cPrev = '#';\n                } else {\n                    // Insert a consonant\n                    c = consonants[rnd.next(21)];\n                    if (cPrev == c || cCnt == 0) {\n                        cCnt++;\n                    } else {\n                        cCnt = 1;\n                    }\n                    cPrev = c;\n                }\n            }\n            s += c;\n        }\n    } else if (type == \"long-same-consonant\") {\n        // Generate a word with long sequences of the same consonant\n        char c = consonants[rnd.next(21)];\n        s = string(n, c);\n    } else if (type == \"long-vowels\") {\n        // Generate a word with long sequences of vowels\n        char c = vowels[rnd.next(5)];\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        // Generate a word alternating between vowels and consonants\n        for (int i = 0; i < n; ++i) {\n            char c;\n            if (i % 2 == 0) {\n                c = vowels[rnd.next(5)];\n            } else {\n                c = consonants[rnd.next(21)];\n            }\n            s += c;\n        }\n    } else if (type == \"max-typos\") {\n        // Generate a word with as many typos as possible\n        for (int i = 0; i < n; ++i) {\n            char c = consonants[rnd.next(21)];\n            s += c;\n        }\n    } else {\n        ensuref(false, \"Unknown type '%s'\", type.c_str());\n    }\n\n    // Output the word\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring vowels = \"aeiou\";\nstring consonants = \"bcdfghjklmnpqrstvwxyz\";\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random word of length n\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26); // Random letter from 'a' to 'z'\n            s += c;\n        }\n    } else if (type == \"typo\") {\n        // Ensure there is at least one typo in the word\n        if (n < 3) {\n            ensuref(false, \"Length must be at least 3 for type 'typo'\");\n        }\n\n        // Decide the position and length of the typo block\n        int l = rnd.next(3, min(10, n)); // Length of the typo block (at least 3)\n        int pos = rnd.next(0, n - l);    // Starting position of the typo block\n\n        // Generate a typo block (consonant block with at least two different letters)\n        char c1 = consonants[rnd.next(21)];\n        char c2 = c1;\n        while (c2 == c1)\n            c2 = consonants[rnd.next(21)];\n\n        string typoBlock;\n        for (int i = 0; i < l; ++i) {\n            if (rnd.next(2))\n                typoBlock += c1;\n            else\n                typoBlock += c2;\n        }\n\n        // Build the complete word\n        for (int i = 0; i < n; ++i) {\n            if (i >= pos && i < pos + l) {\n                s += typoBlock[i - pos];\n            } else {\n                // Randomly pick a letter (vowel or consonant)\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n        }\n    } else if (type == \"no-typo\") {\n        // Generate a word without any typos\n        int cCnt = 0;    // Count of consecutive consonants\n        char cPrev = '#'; // Previous character\n\n        for (int i = 0; i < n; ++i) {\n            char c;\n            if (cCnt == 2) {\n                // Avoid forming a typo (third consonant with a different letter)\n                if (rnd.next(2)) {\n                    // Insert a vowel to break the consonant sequence\n                    c = vowels[rnd.next(5)];\n                    cCnt = 0;\n                    cPrev = '#';\n                } else {\n                    // Repeat the same consonant\n                    c = cPrev;\n                    cCnt++;\n                }\n            } else {\n                // Randomly decide to insert a vowel or consonant\n                if (rnd.next(2)) {\n                    // Insert a vowel\n                    c = vowels[rnd.next(5)];\n                    cCnt = 0;\n                    cPrev = '#';\n                } else {\n                    // Insert a consonant\n                    c = consonants[rnd.next(21)];\n                    if (cPrev == c || cCnt == 0) {\n                        cCnt++;\n                    } else {\n                        cCnt = 1;\n                    }\n                    cPrev = c;\n                }\n            }\n            s += c;\n        }\n    } else if (type == \"long-same-consonant\") {\n        // Generate a word with long sequences of the same consonant\n        char c = consonants[rnd.next(21)];\n        s = string(n, c);\n    } else if (type == \"long-vowels\") {\n        // Generate a word with long sequences of vowels\n        char c = vowels[rnd.next(5)];\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        // Generate a word alternating between vowels and consonants\n        for (int i = 0; i < n; ++i) {\n            char c;\n            if (i % 2 == 0) {\n                c = vowels[rnd.next(5)];\n            } else {\n                c = consonants[rnd.next(21)];\n            }\n            s += c;\n        }\n    } else if (type == \"max-typos\") {\n        // Generate a word with as many typos as possible\n        for (int i = 0; i < n; ++i) {\n            char c = consonants[rnd.next(21)];\n            s += c;\n        }\n    } else {\n        ensuref(false, \"Unknown type '%s'\", type.c_str());\n    }\n\n    // Output the word\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type long-same-consonant\n./gen -n 3 -type typo\n./gen -n 4 -type long-vowels\n./gen -n 5 -type no-typo\n./gen -n 10 -type random\n./gen -n 10 -type typo\n./gen -n 10 -type alternating\n./gen -n 10 -type max-typos\n./gen -n 15 -type typo\n./gen -n 15 -type no-typo\n./gen -n 20 -type long-vowels\n./gen -n 20 -type long-same-consonant\n./gen -n 50 -type max-typos\n./gen -n 50 -type long-same-consonant\n./gen -n 50 -type long-vowels\n./gen -n 60 -type alternating\n./gen -n 70 -type typo\n./gen -n 80 -type no-typo\n./gen -n 90 -type random\n./gen -n 100 -type random\n./gen -n 100 -type typo\n./gen -n 100 -type no-typo\n./gen -n 100 -type alternating\n./gen -n 300 -type typo\n./gen -n 400 -type no-typo\n./gen -n 500 -type random\n./gen -n 500 -type alternating\n./gen -n 500 -type max-typos\n./gen -n 600 -type max-typos\n./gen -n 700 -type long-same-consonant\n./gen -n 800 -type long-vowels\n./gen -n 900 -type alternating\n./gen -n 1000 -type random\n./gen -n 1000 -type typo\n./gen -n 1000 -type no-typo\n./gen -n 1200 -type typo\n./gen -n 1500 -type no-typo\n./gen -n 1800 -type alternating\n./gen -n 2000 -type random\n./gen -n 2000 -type long-vowels\n./gen -n 2000 -type long-same-consonant\n./gen -n 2500 -type max-typos\n./gen -n 2800 -type typo\n./gen -n 3000 -type random\n./gen -n 3000 -type typo\n./gen -n 3000 -type no-typo\n./gen -n 3000 -type max-typos\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:49.975776",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "858/D",
      "title": "D. Polycarp's phone book",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 70000) — the total number of phone contacts in Polycarp's contacts.The phone numbers follow, one in each line. Each number is a positive 9-digit integer starting with a digit from 1 to 9. All the numbers are distinct.",
      "output_spec": "OutputPrint exactly n lines: the i-th of them should contain the shortest non-empty sequence of digits, such that if Polycarp enters it, the Berdroid OS shows up only the i-th number from the contacts. If there are several such sequences, print any of them.",
      "sample_tests": "ExamplesInputCopy3123456789100000000100123456OutputCopy900001InputCopy4123456789193456789134567819934567891OutputCopy21938191",
      "description": "D. Polycarp's phone book\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 70000) — the total number of phone contacts in Polycarp's contacts.The phone numbers follow, one in each line. Each number is a positive 9-digit integer starting with a digit from 1 to 9. All the numbers are distinct.\n\nOutputPrint exactly n lines: the i-th of them should contain the shortest non-empty sequence of digits, such that if Polycarp enters it, the Berdroid OS shows up only the i-th number from the contacts. If there are several such sequences, print any of them.\n\nInputCopy3123456789100000000100123456OutputCopy900001InputCopy4123456789193456789134567819934567891OutputCopy21938191\n\nInputCopy3123456789100000000100123456\n\nOutputCopy900001\n\nInputCopy4123456789193456789134567819934567891\n\nOutputCopy21938191",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces",
          "content": "I apologize to the participants of the round. It happened that I accidentally had run improper script and it rebooted the judging machines. It is very insulting, because most problems were proposed by me and I hoped to host an interesting competition for you. A lot of effort was spent on preparation. Apparently, the mistake of just such a human character happened for the first time. I really hope not to repeat it in the future.MikeMirzayanov Want problems? We have some!Codeforces Round 434 will start on September 17 (Sunday), 13:05 (UTC). It will be based on Technocup 2018 Elimination Round 1. So, if you are a Russian-speaking high-school student, please take part in the Technocup 2018.Many thanks to KAN, vovuh, Neon, ifsmirnov, irkstepanov and WHITE2302 for their help in round preparation. Some problem ideas are mine.I hope you will like problems. There will be 6 problems in div. 2 and 5 problems in div. 1.Wish you good luck and bugless code.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/54580",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 858\\s*D"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 1",
          "code": "Wrong answer on pretest 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 2",
          "code": "(long long) pow(10, k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 3",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 4",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 5",
          "code": "dfaccc babc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readEoln();\n\n    set<long long> numbers;\n\n    for (int i = 0; i < n; ++i) {\n        string num_str = inf.readLine(\"^[1-9][0-9]{8}$\", \"number\");\n\n        long long num = atoll(num_str.c_str());\n\n        ensuref(numbers.count(num) == 0, \"Number %lld occurs more than once\", num);\n\n        numbers.insert(num);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readEoln();\n\n    set<long long> numbers;\n\n    for (int i = 0; i < n; ++i) {\n        string num_str = inf.readLine(\"^[1-9][0-9]{8}$\", \"number\");\n\n        long long num = atoll(num_str.c_str());\n\n        ensuref(numbers.count(num) == 0, \"Number %lld occurs more than once\", num);\n\n        numbers.insert(num);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readEoln();\n\n    set<long long> numbers;\n\n    for (int i = 0; i < n; ++i) {\n        string num_str = inf.readLine(\"^[1-9][0-9]{8}$\", \"number\");\n\n        long long num = atoll(num_str.c_str());\n\n        ensuref(numbers.count(num) == 0, \"Number %lld occurs more than once\", num);\n\n        numbers.insert(num);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   Since the problem may have multiple valid solutions for a single test,\n   we need a custom checker to verify that each provided \"shortest sequence\"\n   is indeed:\n     1) A substring of the corresponding phone number.\n     2) Unique to that phone number (i.e., does not appear in any other).\n     3) Minimal in length among all substrings that uniquely identify it.\n\n   IMPORTANT CHANGE:\n   Instead of readToken(), we will use readLine() for participants' answers\n   and manually verify they are non-empty and contain only digits. This\n   helps avoid \"expected EOF\" errors caused by extra newlines/spaces.\n\n   We'll read the n phone numbers from the input file and build a map from\n   \"substring\" -> \"list of indices of phone numbers containing that substring\".\n   Then for each answer line from the contestant (ouf), we check the conditions.\n   If anything is violated, we quit with WA; if everything is fine, we accept.\n*/\n\nstatic const int MAXN = 70000;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read number of phone contacts\n    int n = inf.readInt(1, MAXN, \"n\");\n\n    // Read the phone numbers (each is 9 digits, starting with nonzero digit)\n    vector<string> phones(n);\n    for (int i = 0; i < n; i++) {\n        // Restrict to exactly 9 digits, first digit is from 1-9\n        phones[i] = inf.readToken(\"[1-9][0-9]{8}\",\n                                  format(\"phone number #%d\", i+1).c_str());\n    }\n\n    // Build a map of all substrings -> list of indices of phone numbers\n    // in which this substring appears. Each phone number has at most\n    // 9*(9+1)/2 = 45 distinct substrings, so n=70000 can be up to ~3.15 million\n    // entries in the worst case. This is large but can be done with\n    // efficient hashing in optimized C++.\n    unordered_map<string, vector<int>> subMap;\n    subMap.reserve(n * 45);\n    subMap.max_load_factor(0.7f);\n\n    for (int i = 0; i < n; i++) {\n        // We'll treat phones[i] as a string of length 9.\n        // Insert all substrings into subMap.\n        for (int start = 0; start < 9; start++) {\n            for (int length = 1; length + start <= 9; length++) {\n                string sub = phones[i].substr(start, length);\n                subMap[sub].push_back(i);\n            }\n        }\n    }\n\n    // Now read the contestant's output:\n    // They should provide exactly n lines, each line containing a non-empty\n    // sequence of digits for the i-th phone number.\n    for (int i = 0; i < n; i++) {\n        // Read one full line from participant's solution\n        string s = ouf.readLine();\n        // Trim leading/trailing whitespace just in case\n        // (Though readLine() shouldn't keep trailing spaces, it's safe to trim.)\n        while (!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin());\n        while (!s.empty() && isspace((unsigned char)s.back())) s.pop_back();\n\n        // Check non-empty\n        if (s.empty()) {\n            quitf(_wa,\n                  \"Empty line for phone number #%d, expected a non-empty digit sequence\",\n                  i + 1);\n        }\n        // Check all digits\n        if (!all_of(s.begin(), s.end(), ::isdigit)) {\n            quitf(_wa,\n                  \"Answer for phone number #%d contains non-digit characters: '%s'\",\n                  i + 1, s.c_str());\n        }\n\n        // 1) Check s is actually a substring of the i-th phone number\n        if (phones[i].find(s) == string::npos) {\n            quitf(_wa,\n                  \"The provided substring '%s' for phone number #%d is not a substring of that number.\",\n                  s.c_str(), i+1);\n        }\n\n        // 2) Check uniqueness: s should appear in exactly one phone number, namely i\n        auto it = subMap.find(s);\n        if (it == subMap.end()) {\n            // Shouldn't happen if s is truly a substring, but just in case\n            quitf(_wa,\n                  \"Checker internal error: substring '%s' not found in map for phone number #%d.\",\n                  s.c_str(), i+1);\n        }\n        for (int idx : it->second) {\n            if (idx != i) {\n                quitf(_wa,\n                      \"The provided substring '%s' for phone number #%d also appears in phone number #%d, not unique.\",\n                      s.c_str(), i+1, idx+1);\n            }\n        }\n\n        // 3) Check minimality:\n        //    If there's a strictly shorter substring t of phones[i] that also identifies i uniquely,\n        //    then 's' is not minimal.\n        int sLen = (int)s.size();\n        for (int length = 1; length < sLen; length++) {\n            for (int start = 0; start + length <= 9; start++) {\n                string t = phones[i].substr(start, length);\n                auto it2 = subMap.find(t);\n                if (it2 != subMap.end()) {\n                    // Check if it2->second has only i\n                    bool onlyThis = true;\n                    for (int idx2 : it2->second) {\n                        if (idx2 != i) {\n                            onlyThis = false;\n                            break;\n                        }\n                    }\n                    if (onlyThis) {\n                        // Found a strictly shorter substring that also uniquely identifies phone i\n                        quitf(_wa,\n                              \"The substring '%s' for phone number #%d is not minimal (shorter '%s' also identifies it).\",\n                              s.c_str(), i+1, t.c_str());\n                    }\n                }\n            }\n        }\n    }\n\n    // Ensure no extra unexpected data in participant's output\n    ouf.readEof();\n\n    // If we reach here, everything is correct\n    quitf(_ok, \"All phone numbers have a correct unique minimal substring.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_number() {\n    string num;\n    num += '0' + rnd.next(1,9); // First digit cannot be zero\n    for(int i = 1; i < 9; ++i)\n        num += '0' + rnd.next(0,9);\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> phone_numbers;\n    unordered_set<string> s;\n\n    if(type == \"random\") {\n        while((int)s.size() < n) {\n            string num = generate_random_number();\n            if(s.count(num) == 0) {\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    } else if(type == \"common_prefix\") {\n        int prefix_length = 4;\n        string prefix = \"\";\n        prefix += '0' + rnd.next(1,9); // First digit cannot be zero\n        for(int i = 1; i < prefix_length; ++i)\n            prefix += '0' + rnd.next(0,9);\n        unordered_set<int> suffixes;\n        while((int)suffixes.size() < n) {\n            int suffix = rnd.next(0, 99999);\n            if(suffixes.count(suffix) == 0) {\n                suffixes.insert(suffix);\n                char buf[10];\n                snprintf(buf, 10, \"%05d\", suffix); // Pad with zeros to length 5\n                string num = prefix + string(buf);\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    } else if(type == \"common_suffix\") {\n        int suffix_length = 4;\n        string suffix = \"\";\n        for(int i = 0; i < suffix_length; ++i)\n            suffix += '0' + rnd.next(0,9);\n        unordered_set<string> prefixes;\n        while((int)prefixes.size() < n) {\n            string prefix = \"\";\n            prefix += '0' + rnd.next(1,9); // First digit cannot be zero\n            for(int i = 1; i < 5; ++i)\n                prefix += '0' + rnd.next(0,9);\n            if(prefixes.count(prefix) == 0) {\n                prefixes.insert(prefix);\n                string num = prefix + suffix;\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    } else if(type == \"identical_until_last\") {\n        string prefix = \"\";\n        for(int i = 0; i < 8; ++i) {\n            if(i == 0)\n                prefix += '0' + rnd.next(1,9);\n            else\n                prefix += '0' + rnd.next(0,9);\n        }\n        unordered_set<char> last_digits;\n        while((int)last_digits.size() < n) {\n            char last_digit = '0' + rnd.next(0,9);\n            if(last_digits.count(last_digit) == 0) {\n                last_digits.insert(last_digit);\n                string num = prefix + last_digit;\n                if(s.count(num) == 0) {\n                    s.insert(num);\n                    phone_numbers.push_back(num);\n                }\n            }\n            if(last_digits.size() >= 10) {\n                // All digits from '0' to '9' have been used, cannot generate more numbers by varying only last digit\n                break;\n            }\n        }\n        // If n exceeds 10, need to vary more digits\n        if((int)phone_numbers.size() < n) {\n            // Vary the second last digit\n            for(int d1 = 0; d1 <= 9 && (int)phone_numbers.size() < n; ++d1) {\n                for(int d2 = 0; d2 <=9 && (int)phone_numbers.size() < n; ++d2) {\n                    string num = prefix.substr(0,7) + (char)('0'+d1) + (char)('0'+d2);\n                    if(s.count(num) == 0) {\n                        s.insert(num);\n                        phone_numbers.push_back(num);\n                    }\n                }\n            }\n        }\n    } else if(type == \"identical_until_first\") {\n        string suffix = \"\";\n        for(int i = 1; i < 9; ++i)\n            suffix += '0' + rnd.next(0,9);\n        unordered_set<char> first_digits;\n        while((int)first_digits.size() < n && (int)first_digits.size() < 9) {\n            char first_digit = '0' + rnd.next(1,9);\n            if(first_digits.count(first_digit) == 0) {\n                first_digits.insert(first_digit);\n                string num = first_digit + suffix;\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n        // If n > 9, need to vary more digits\n        if((int)phone_numbers.size() < n) {\n            // Vary the second digit\n            for(int d = 0; d <=9 && (int)phone_numbers.size() < n; ++d) {\n                for(char fd : first_digits) {\n                    string num = \"\";\n                    num += fd;\n                    num += '0' + d;\n                    num += suffix.substr(1);\n                    if(s.count(num) == 0) {\n                        s.insert(num);\n                        phone_numbers.push_back(num);\n                    }\n                }\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        while((int)s.size() < n) {\n            string num = generate_random_number();\n            if(s.count(num) == 0) {\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    }\n\n    // Shuffle the phone numbers to reduce any unintended patterns\n    shuffle(phone_numbers.begin(), phone_numbers.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(const string &num : phone_numbers)\n        printf(\"%s\\n\", num.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_number() {\n    string num;\n    num += '0' + rnd.next(1,9); // First digit cannot be zero\n    for(int i = 1; i < 9; ++i)\n        num += '0' + rnd.next(0,9);\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> phone_numbers;\n    unordered_set<string> s;\n\n    if(type == \"random\") {\n        while((int)s.size() < n) {\n            string num = generate_random_number();\n            if(s.count(num) == 0) {\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    } else if(type == \"common_prefix\") {\n        int prefix_length = 4;\n        string prefix = \"\";\n        prefix += '0' + rnd.next(1,9); // First digit cannot be zero\n        for(int i = 1; i < prefix_length; ++i)\n            prefix += '0' + rnd.next(0,9);\n        unordered_set<int> suffixes;\n        while((int)suffixes.size() < n) {\n            int suffix = rnd.next(0, 99999);\n            if(suffixes.count(suffix) == 0) {\n                suffixes.insert(suffix);\n                char buf[10];\n                snprintf(buf, 10, \"%05d\", suffix); // Pad with zeros to length 5\n                string num = prefix + string(buf);\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    } else if(type == \"common_suffix\") {\n        int suffix_length = 4;\n        string suffix = \"\";\n        for(int i = 0; i < suffix_length; ++i)\n            suffix += '0' + rnd.next(0,9);\n        unordered_set<string> prefixes;\n        while((int)prefixes.size() < n) {\n            string prefix = \"\";\n            prefix += '0' + rnd.next(1,9); // First digit cannot be zero\n            for(int i = 1; i < 5; ++i)\n                prefix += '0' + rnd.next(0,9);\n            if(prefixes.count(prefix) == 0) {\n                prefixes.insert(prefix);\n                string num = prefix + suffix;\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    } else if(type == \"identical_until_last\") {\n        string prefix = \"\";\n        for(int i = 0; i < 8; ++i) {\n            if(i == 0)\n                prefix += '0' + rnd.next(1,9);\n            else\n                prefix += '0' + rnd.next(0,9);\n        }\n        unordered_set<char> last_digits;\n        while((int)last_digits.size() < n) {\n            char last_digit = '0' + rnd.next(0,9);\n            if(last_digits.count(last_digit) == 0) {\n                last_digits.insert(last_digit);\n                string num = prefix + last_digit;\n                if(s.count(num) == 0) {\n                    s.insert(num);\n                    phone_numbers.push_back(num);\n                }\n            }\n            if(last_digits.size() >= 10) {\n                // All digits from '0' to '9' have been used, cannot generate more numbers by varying only last digit\n                break;\n            }\n        }\n        // If n exceeds 10, need to vary more digits\n        if((int)phone_numbers.size() < n) {\n            // Vary the second last digit\n            for(int d1 = 0; d1 <= 9 && (int)phone_numbers.size() < n; ++d1) {\n                for(int d2 = 0; d2 <=9 && (int)phone_numbers.size() < n; ++d2) {\n                    string num = prefix.substr(0,7) + (char)('0'+d1) + (char)('0'+d2);\n                    if(s.count(num) == 0) {\n                        s.insert(num);\n                        phone_numbers.push_back(num);\n                    }\n                }\n            }\n        }\n    } else if(type == \"identical_until_first\") {\n        string suffix = \"\";\n        for(int i = 1; i < 9; ++i)\n            suffix += '0' + rnd.next(0,9);\n        unordered_set<char> first_digits;\n        while((int)first_digits.size() < n && (int)first_digits.size() < 9) {\n            char first_digit = '0' + rnd.next(1,9);\n            if(first_digits.count(first_digit) == 0) {\n                first_digits.insert(first_digit);\n                string num = first_digit + suffix;\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n        // If n > 9, need to vary more digits\n        if((int)phone_numbers.size() < n) {\n            // Vary the second digit\n            for(int d = 0; d <=9 && (int)phone_numbers.size() < n; ++d) {\n                for(char fd : first_digits) {\n                    string num = \"\";\n                    num += fd;\n                    num += '0' + d;\n                    num += suffix.substr(1);\n                    if(s.count(num) == 0) {\n                        s.insert(num);\n                        phone_numbers.push_back(num);\n                    }\n                }\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        while((int)s.size() < n) {\n            string num = generate_random_number();\n            if(s.count(num) == 0) {\n                s.insert(num);\n                phone_numbers.push_back(num);\n            }\n        }\n    }\n\n    // Shuffle the phone numbers to reduce any unintended patterns\n    shuffle(phone_numbers.begin(), phone_numbers.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(const string &num : phone_numbers)\n        printf(\"%s\\n\", num.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 70000 -type random\n\n./gen -n 5 -type common_prefix\n./gen -n 10 -type common_prefix\n./gen -n 100 -type common_prefix\n./gen -n 1000 -type common_prefix\n./gen -n 10000 -type common_prefix\n./gen -n 70000 -type common_prefix\n\n./gen -n 5 -type common_suffix\n./gen -n 10 -type common_suffix\n./gen -n 100 -type common_suffix\n./gen -n 1000 -type common_suffix\n./gen -n 10000 -type common_suffix\n./gen -n 70000 -type common_suffix\n\n./gen -n 10 -type identical_until_last\n./gen -n 100 -type identical_until_last\n./gen -n 1000 -type identical_until_last\n\n./gen -n 9 -type identical_until_first\n./gen -n 90 -type identical_until_first\n\n./gen -n 100 -type random\n./gen -n 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:52.073579",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "858/E",
      "title": "E. Tests Renumeration",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 105) — the number of files with tests.n lines follow, each describing a file with test. Each line has a form of \"name_i type_i\", where \"name_i\" is the filename, and \"type_i\" equals \"1\", if the i-th file contains an example test, and \"0\" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.",
      "output_spec": "OutputIn the first line print the minimum number of lines in Vladimir's script file.After that print the script file, each line should be \"move file_1 file_2\", where \"file_1\" is an existing at the moment of this line being run filename, and \"file_2\" — is a string of digits and small English letters with length from 1 to 6.",
      "sample_tests": "ExamplesInputCopy501 02 12extra 03 199 0OutputCopy4move 3 1move 01 5move 2extra 4move 99 3InputCopy21 02 1OutputCopy3move 1 3move 2 1move 3 2InputCopy51 011 1111 01111 111111 0OutputCopy5move 1 5move 11 1move 1111 2move 111 4move 11111 3",
      "description": "E. Tests Renumeration\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 105) — the number of files with tests.n lines follow, each describing a file with test. Each line has a form of \"name_i type_i\", where \"name_i\" is the filename, and \"type_i\" equals \"1\", if the i-th file contains an example test, and \"0\" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.\n\nOutputIn the first line print the minimum number of lines in Vladimir's script file.After that print the script file, each line should be \"move file_1 file_2\", where \"file_1\" is an existing at the moment of this line being run filename, and \"file_2\" — is a string of digits and small English letters with length from 1 to 6.\n\nInputCopy501 02 12extra 03 199 0OutputCopy4move 3 1move 01 5move 2extra 4move 99 3InputCopy21 02 1OutputCopy3move 1 3move 2 1move 3 2InputCopy51 011 1111 01111 111111 0OutputCopy5move 1 5move 11 1move 1111 2move 111 4move 11111 3\n\nInputCopy501 02 12extra 03 199 0\n\nOutputCopy4move 3 1move 01 5move 2extra 4move 99 3\n\nInputCopy21 02 1\n\nOutputCopy3move 1 3move 2 1move 3 2\n\nInputCopy51 011 1111 01111 111111 0\n\nOutputCopy5move 1 5move 11 1move 1111 2move 111 4move 11111 3",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces",
          "content": "I apologize to the participants of the round. It happened that I accidentally had run improper script and it rebooted the judging machines. It is very insulting, because most problems were proposed by me and I hoped to host an interesting competition for you. A lot of effort was spent on preparation. Apparently, the mistake of just such a human character happened for the first time. I really hope not to repeat it in the future.MikeMirzayanov Want problems? We have some!Codeforces Round 434 will start on September 17 (Sunday), 13:05 (UTC). It will be based on Technocup 2018 Elimination Round 1. So, if you are a Russian-speaking high-school student, please take part in the Technocup 2018.Many thanks to KAN, vovuh, Neon, ifsmirnov, irkstepanov and WHITE2302 for their help in round preparation. Some problem ideas are mine.I hope you will like problems. There will be 6 problems in div. 2 and 5 problems in div. 1.Wish you good luck and bugless code.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/54580",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 858\\s*E"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 1",
          "code": "Wrong answer on pretest 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 2",
          "code": "(long long) pow(10, k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 3",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 4",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 5",
          "code": "dfaccc babc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<string> names;\n\n    for (int i = 0; i < n; ++i) {\n        string name_i = inf.readToken(\"[0-9a-z]{1,6}\", \"name_i\");\n        inf.readSpace();\n        int type_i = inf.readInt(0, 1, \"type_i\");\n        inf.readEoln();\n        ensuref(names.insert(name_i).second, \"Filename '%s' is not unique\", name_i.c_str());\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<string> names;\n\n    for (int i = 0; i < n; ++i) {\n        string name_i = inf.readToken(\"[0-9a-z]{1,6}\", \"name_i\");\n        inf.readSpace();\n        int type_i = inf.readInt(0, 1, \"type_i\");\n        inf.readEoln();\n        ensuref(names.insert(name_i).second, \"Filename '%s' is not unique\", name_i.c_str());\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<string> names;\n\n    for (int i = 0; i < n; ++i) {\n        string name_i = inf.readToken(\"[0-9a-z]{1,6}\", \"name_i\");\n        inf.readSpace();\n        int type_i = inf.readInt(0, 1, \"type_i\");\n        inf.readEoln();\n        ensuref(names.insert(name_i).second, \"Filename '%s' is not unique\", name_i.c_str());\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll store an original mapping from filename -> test type (0 or 1).\n// The checker will read the supposed solution (script), simulate the moves,\n// and then verify that in the end:\n// 1) There are exactly n distinct files named \"1\", \"2\", ..., \"n\".\n// 2) Exactly e of them (where e is the count of example tests among the original n) have type = 1,\n//    and those must be named \"1\", \"2\", ..., to_string(e).\n// 3) The remaining files \"e+1\", ..., \"n\" must have type = 0.\n//\n// Additionally, we compare the participant's script length to the jury's script\n// length and confirm it is no larger; otherwise we produce WA. If it is strictly\n// smaller, that implies the jury's solution was not minimal, leading to _fail.\n\nstatic const int MAXN = 100000;\n\n// We simulate reading and applying the moves, and then we check correctness.\nint readAnswerAndCheck(InStream &stream,\n                       const vector<pair<string,int>> &filesInfo, // (filename, type)\n                       int totalFiles,\n                       int examplesCount)\n{\n    // We'll keep a mapping of currentName -> type.\n    // Initially, this matches the input data.\n    unordered_map<string,int> current;\n    current.reserve(filesInfo.size());\n    for (auto &p : filesInfo) {\n        current[p.first] = p.second;\n    }\n\n    // Number of lines in the script\n    int k = stream.readInt(0, 2 * totalFiles, \"number_of_moves\"); \n    // (very loose upper bound, just to avoid extremes)\n\n    // Simulate each move.\n    // Format: \"move file_1 file_2\"\n    for (int i = 0; i < k; i++) {\n        string f1 = stream.readToken(); // file_1\n        if (f1 != \"move\") {\n            // If the first token is not \"move\", that's a format error\n            // but we call it WA (or FAIL if from ans).\n            stream.quitf(_wa, \"expected 'move' but found '%s'\", f1.c_str());\n        }\n        string file1 = stream.readToken(\"(\\\\w{1,6})\", \"file_1\"); // existing filename\n        string file2 = stream.readToken(\"(\\\\w{1,6})\", \"file_2\"); // new filename\n\n        // Check if file1 currently exists\n        auto it = current.find(file1);\n        if (it == current.end()) {\n            stream.quitf(_wa, \"attempt to move from non-existent file '%s'\", file1.c_str());\n        }\n        int t = it->second; // type of file1\n\n        // Overwrite file2 if it exists\n        if (current.find(file2) != current.end()) {\n            current.erase(file2);\n        }\n        // Remove file1\n        current.erase(it);\n        // Create file2\n        current[file2] = t;\n    }\n\n    // After all moves, check that the final configuration is correct.\n    // 1) Must have exactly totalFiles distinct files.\n    if ((int)current.size() != totalFiles) {\n        stream.quitf(_wa, \"final number of files is %d instead of %d\", (int)current.size(), totalFiles);\n    }\n\n    // We'll parse each final filename as an integer in [1..n], ensuring no duplicates\n    // and check the type constraints: first e must be type=1, the rest type=0.\n    vector<int> slotType(totalFiles+1, -1); // 1-based indexing\n    // We'll try to fill slot i with -1 or the actual type.\n\n    for (auto &kv : current) {\n        const string &fname = kv.first;\n        int ftype = kv.second;\n        // Try to parse fname as integer\n        bool okInt = true;\n        for (char c : fname) {\n            if (!isdigit((unsigned char)c)) {\n                okInt = false;\n                break;\n            }\n        }\n        if (!okInt) {\n            stream.quitf(_wa, \"final filename '%s' is not a valid integer\", fname.c_str());\n        }\n        long long val = atoll(fname.c_str());\n        if (val < 1 || val > totalFiles) {\n            stream.quitf(_wa, \"final filename '%s' out of range [1..%d]\", fname.c_str(), totalFiles);\n        }\n        if (slotType[val] != -1) {\n            stream.quitf(_wa, \"final filename '%lld' appears more than once\", val);\n        }\n        slotType[val] = ftype;\n    }\n\n    // Now check the first 'examplesCount' final files are type=1, others are type=0.\n    for (int i = 1; i <= examplesCount; i++) {\n        if (slotType[i] != 1) {\n            stream.quitf(_wa, \"final file %d should be an example (type=1), found type=%d\", i, slotType[i]);\n        }\n    }\n    for (int i = examplesCount + 1; i <= totalFiles; i++) {\n        if (slotType[i] != 0) {\n            stream.quitf(_wa, \"final file %d should be a regular test (type=0), found type=%d\", i, slotType[i]);\n        }\n    }\n\n    // If we reach here, the final arrangement is correct.\n    return k;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input.\n    int n = inf.readInt(1, MAXN, \"n\"); // number of files\n    vector<pair<string,int>> filesInfo(n);\n    int exampleCount = 0;\n    for (int i = 0; i < n; i++) {\n        // name_i type_i\n        string fname = inf.readToken(\"(\\\\w{1,6})\", \"filename\");\n        int t = inf.readInt(0, 1, \"test_type\");\n        filesInfo[i] = {fname, t};\n        if (t == 1) {\n            exampleCount++;\n        }\n    }\n\n    // Read the jury's answer (ans). If it fails, produce _fail.\n    int juryMoves = readAnswerAndCheck(ans, filesInfo, n, exampleCount);\n\n    // Read the participant's answer (ouf). If it fails, produce _wa.\n    int partMoves = readAnswerAndCheck(ouf, filesInfo, n, exampleCount);\n\n    // Compare the number of moves:\n    // p < j => the participant found a strictly smaller number => _fail (jury's official answer not minimal)\n    // p > j => participant's solution not minimal => _wa\n    // p == j => OK\n    if (partMoves < juryMoves) {\n        quitf(_fail, \"Participant's solution uses fewer moves than jury's official solution (%d < %d). Jury's solution not minimal.\",\n                        partMoves, juryMoves);\n    } else if (partMoves > juryMoves) {\n        quitf(_wa, \"Participant's solution uses more moves than required minimal %d, got %d\", juryMoves, partMoves);\n    } else {\n        quitf(_ok, \"Correct solution with %d moves.\", partMoves);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generates distinct file names of length [1..6] using letters and digits.\nstatic string genName(set<string> &used) {\n    static const string chars = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    while (true) {\n        int len = rnd.next(1, 6);\n        string s;\n        s.reserve(len);\n        for (int i = 0; i < len; i++) {\n            s.push_back(chars[rnd.next((int)chars.size())]);\n        }\n        if (!used.count(s)) {\n            used.insert(s);\n            return s;\n        }\n    }\n}\n\n// Generates distinct numeric names that might have leading zeros or be out of [1..n].\nstatic string genNumericTrickName(set<string> &used, int maxN) {\n    // We'll randomly decide how to form tricky numeric names:\n    //  1) Possibly \"0\" or \"00..000\"\n    //  2) Possibly leading zeros but eventually a number <= maxN\n    //  3) Possibly a number > maxN\n    //  4) Possibly exactly in [1..maxN]\n    // Ensure distinctness regardless.\n    while (true) {\n        int choice = rnd.next(1, 5);\n        string candidate;\n        if (choice == 1) {\n            // Just a random number with leading zeros\n            int length = rnd.next(1, 6);\n            candidate = \"\";\n            for (int i = 0; i < length; i++) {\n                candidate.push_back((char)('0' + rnd.next(10)));\n            }\n        } else if (choice == 2) {\n            // A random numeric in [1..maxN], possibly with leading zeros\n            int val = rnd.next(1, maxN);\n            // give it some random leading zeros\n            int lead = rnd.next(0, 3);\n            candidate = string(lead, '0') + to_string(val);\n        } else if (choice == 3) {\n            // A random numeric bigger than maxN\n            int val = rnd.next(maxN + 1, maxN * 2 + 1000); // just bigger\n            candidate = to_string(val);\n        } else if (choice == 4) {\n            // Possibly zero \"0\"\n            candidate = \"0\";\n        } else {\n            // A random numeric with length in [1..6], no direct range guarantee\n            int length = rnd.next(1, 6);\n            candidate = \"\";\n            for (int i = 0; i < length; i++) {\n                candidate.push_back((char)('0' + rnd.next(10)));\n            }\n            // forbid all-zero to avoid duplicates if \"0\" was already used\n        }\n        if (!used.count(candidate)) {\n            used.insert(candidate);\n            return candidate;\n        }\n    }\n}\n\n// This generator will create an input for the \"rename files\" problem.\n// Usage example with testlib arguments:\n//   ./gen -n 10 -mode random\n//   ./gen -n 5 -mode special\n//   ./gen -n 5 -mode all-examples\n//   ./gen -n 5 -mode no-examples\n//\n// Where:\n//   n: number of files\n//   mode: how we generate the distribution and names\n//     - \"random\": random distribution of 0/1, random distinct names\n//     - \"all-examples\": all type=1\n//     - \"no-examples\": all type=0\n//     - \"special\": produce tricky or corner-case numeric/alphanumeric names\n//\n// We do NOT set any random seed here; testlib does that externally.\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // We'll store (name, type).\n    vector<string> names(n);\n    vector<int> types(n, 0);\n\n    // We'll fill up a set to ensure distinct names.\n    set<string> used;\n\n    // Decide how many examples\n    // For \"all-examples\" => e = n\n    // For \"no-examples\" => e = 0\n    // For \"random\"/\"special\" => random e in [0..n]\n    int e = 0;\n    if (mode == \"all-examples\") {\n        e = n;\n    } else if (mode == \"no-examples\") {\n        e = 0;\n    } else {\n        // random or special\n        e = rnd.next(0, n);\n    }\n\n    // Assign types: first e are examples (1), rest are 0\n    // (We can shuffle afterwards if we like, or we can just do them in some random order.)\n    // We'll assign them in order for \"all-examples\"/\"no-examples\", but for \"random\"/\"special\"\n    // we randomly permute the positions to avoid trivial ordering.\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 0);\n    if (mode == \"random\" || mode == \"special\") {\n        shuffle(perm.begin(), perm.end());\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (i < e) types[perm[i]] = 1;\n        else types[perm[i]] = 0;\n    }\n\n    // Now generate names\n    // If mode == \"special\", we try some \"tricky\" names, else we do random.\n    for (int i = 0; i < n; i++) {\n        if (mode == \"special\") {\n            // We'll interleave tricky numeric and random alphanumeric\n            // to provoke corner cases in solutions.\n            if (rnd.next(2) == 0) {\n                // tricky numeric name\n                names[i] = genNumericTrickName(used, n);\n            } else {\n                // random general name\n                names[i] = genName(used);\n            }\n        } else {\n            // random or all-examples or no-examples\n            names[i] = genName(used);\n        }\n    }\n\n    // Output\n    // n lines, each is \"names[i] types[i]\"\n    // But first print n\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << names[i] << \" \" << types[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generates distinct file names of length [1..6] using letters and digits.\nstatic string genName(set<string> &used) {\n    static const string chars = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    while (true) {\n        int len = rnd.next(1, 6);\n        string s;\n        s.reserve(len);\n        for (int i = 0; i < len; i++) {\n            s.push_back(chars[rnd.next((int)chars.size())]);\n        }\n        if (!used.count(s)) {\n            used.insert(s);\n            return s;\n        }\n    }\n}\n\n// Generates distinct numeric names that might have leading zeros or be out of [1..n].\nstatic string genNumericTrickName(set<string> &used, int maxN) {\n    // We'll randomly decide how to form tricky numeric names:\n    //  1) Possibly \"0\" or \"00..000\"\n    //  2) Possibly leading zeros but eventually a number <= maxN\n    //  3) Possibly a number > maxN\n    //  4) Possibly exactly in [1..maxN]\n    // Ensure distinctness regardless.\n    while (true) {\n        int choice = rnd.next(1, 5);\n        string candidate;\n        if (choice == 1) {\n            // Just a random number with leading zeros\n            int length = rnd.next(1, 6);\n            candidate = \"\";\n            for (int i = 0; i < length; i++) {\n                candidate.push_back((char)('0' + rnd.next(10)));\n            }\n        } else if (choice == 2) {\n            // A random numeric in [1..maxN], possibly with leading zeros\n            int val = rnd.next(1, maxN);\n            // give it some random leading zeros\n            int lead = rnd.next(0, 3);\n            candidate = string(lead, '0') + to_string(val);\n        } else if (choice == 3) {\n            // A random numeric bigger than maxN\n            int val = rnd.next(maxN + 1, maxN * 2 + 1000); // just bigger\n            candidate = to_string(val);\n        } else if (choice == 4) {\n            // Possibly zero \"0\"\n            candidate = \"0\";\n        } else {\n            // A random numeric with length in [1..6], no direct range guarantee\n            int length = rnd.next(1, 6);\n            candidate = \"\";\n            for (int i = 0; i < length; i++) {\n                candidate.push_back((char)('0' + rnd.next(10)));\n            }\n            // forbid all-zero to avoid duplicates if \"0\" was already used\n        }\n        if (!used.count(candidate)) {\n            used.insert(candidate);\n            return candidate;\n        }\n    }\n}\n\n// This generator will create an input for the \"rename files\" problem.\n// Usage example with testlib arguments:\n//   ./gen -n 10 -mode random\n//   ./gen -n 5 -mode special\n//   ./gen -n 5 -mode all-examples\n//   ./gen -n 5 -mode no-examples\n//\n// Where:\n//   n: number of files\n//   mode: how we generate the distribution and names\n//     - \"random\": random distribution of 0/1, random distinct names\n//     - \"all-examples\": all type=1\n//     - \"no-examples\": all type=0\n//     - \"special\": produce tricky or corner-case numeric/alphanumeric names\n//\n// We do NOT set any random seed here; testlib does that externally.\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // We'll store (name, type).\n    vector<string> names(n);\n    vector<int> types(n, 0);\n\n    // We'll fill up a set to ensure distinct names.\n    set<string> used;\n\n    // Decide how many examples\n    // For \"all-examples\" => e = n\n    // For \"no-examples\" => e = 0\n    // For \"random\"/\"special\" => random e in [0..n]\n    int e = 0;\n    if (mode == \"all-examples\") {\n        e = n;\n    } else if (mode == \"no-examples\") {\n        e = 0;\n    } else {\n        // random or special\n        e = rnd.next(0, n);\n    }\n\n    // Assign types: first e are examples (1), rest are 0\n    // (We can shuffle afterwards if we like, or we can just do them in some random order.)\n    // We'll assign them in order for \"all-examples\"/\"no-examples\", but for \"random\"/\"special\"\n    // we randomly permute the positions to avoid trivial ordering.\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 0);\n    if (mode == \"random\" || mode == \"special\") {\n        shuffle(perm.begin(), perm.end());\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (i < e) types[perm[i]] = 1;\n        else types[perm[i]] = 0;\n    }\n\n    // Now generate names\n    // If mode == \"special\", we try some \"tricky\" names, else we do random.\n    for (int i = 0; i < n; i++) {\n        if (mode == \"special\") {\n            // We'll interleave tricky numeric and random alphanumeric\n            // to provoke corner cases in solutions.\n            if (rnd.next(2) == 0) {\n                // tricky numeric name\n                names[i] = genNumericTrickName(used, n);\n            } else {\n                // random general name\n                names[i] = genName(used);\n            }\n        } else {\n            // random or all-examples or no-examples\n            names[i] = genName(used);\n        }\n    }\n\n    // Output\n    // n lines, each is \"names[i] types[i]\"\n    // But first print n\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << names[i] << \" \" << types[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below is a list of commands to run the generator, producing\n# around 20-30 different test cases covering a wide range of scenarios.\n# Each command simply outputs to standard output. No files are redirected.\n\n# Small tests\n./gen -n 1 -mode all-examples\n./gen -n 1 -mode no-examples\n./gen -n 2 -mode random\n./gen -n 2 -mode special\n\n# More tests with small n\n./gen -n 5 -mode all-examples\n./gen -n 5 -mode no-examples\n./gen -n 5 -mode random\n./gen -n 5 -mode special\n\n# Medium tests\n./gen -n 10 -mode all-examples\n./gen -n 10 -mode no-examples\n./gen -n 10 -mode random\n./gen -n 10 -mode special\n\n# Larger tests\n./gen -n 20 -mode random\n./gen -n 20 -mode special\n./gen -n 50 -mode random\n./gen -n 50 -mode special\n\n# Even bigger\n./gen -n 100 -mode random\n./gen -n 100 -mode special\n./gen -n 200 -mode random\n./gen -n 200 -mode special\n\n# Larger scale near constraints\n./gen -n 99999 -mode random\n./gen -n 100000 -mode no-examples\n./gen -n 100000 -mode all-examples\n./gen -n 100000 -mode special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:54.527825",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "858/F",
      "title": "F. Wizard's Tour",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n ≤ 2·105, 0 ≤ m ≤ 2·105) — the number of cities and the number of roads in Berland, respectively.The roads description follow, one in each line. Each description is a pair of two integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), where ai and bi are the ids of the cities connected by the i-th road. It is guaranteed that there are no two roads connecting the same pair of cities. Every road is bidirectional. The cities are numbered from 1 to n.It is possible that the road network in Berland is not connected.",
      "output_spec": "OutputIn the first line print w — the maximum possible number of episodes. The next w lines should contain the episodes in format x, y, z — the three integers denoting the ids of the cities in the order of the wizard's visits.",
      "sample_tests": "ExamplesInputCopy4 51 23 22 43 44 1OutputCopy21 4 24 3 2InputCopy5 85 31 24 55 12 54 31 43 2OutputCopy41 4 52 3 41 5 35 2 1",
      "description": "F. Wizard's Tour\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n ≤ 2·105, 0 ≤ m ≤ 2·105) — the number of cities and the number of roads in Berland, respectively.The roads description follow, one in each line. Each description is a pair of two integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), where ai and bi are the ids of the cities connected by the i-th road. It is guaranteed that there are no two roads connecting the same pair of cities. Every road is bidirectional. The cities are numbered from 1 to n.It is possible that the road network in Berland is not connected.\n\nOutputIn the first line print w — the maximum possible number of episodes. The next w lines should contain the episodes in format x, y, z — the three integers denoting the ids of the cities in the order of the wizard's visits.\n\nInputCopy4 51 23 22 43 44 1OutputCopy21 4 24 3 2InputCopy5 85 31 24 55 12 54 31 43 2OutputCopy41 4 52 3 41 5 35 2 1\n\nInputCopy4 51 23 22 43 44 1\n\nOutputCopy21 4 24 3 2\n\nInputCopy5 85 31 24 55 12 54 31 43 2\n\nOutputCopy41 4 52 3 41 5 35 2 1",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces",
          "content": "I apologize to the participants of the round. It happened that I accidentally had run improper script and it rebooted the judging machines. It is very insulting, because most problems were proposed by me and I hoped to host an interesting competition for you. A lot of effort was spent on preparation. Apparently, the mistake of just such a human character happened for the first time. I really hope not to repeat it in the future.MikeMirzayanov Want problems? We have some!Codeforces Round 434 will start on September 17 (Sunday), 13:05 (UTC). It will be based on Technocup 2018 Elimination Round 1. So, if you are a Russian-speaking high-school student, please take part in the Technocup 2018.Many thanks to KAN, vovuh, Neon, ifsmirnov, irkstepanov and WHITE2302 for their help in round preparation. Some problem ideas are mine.I hope you will like problems. There will be 6 problems in div. 2 and 5 problems in div. 1.Wish you good luck and bugless code.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/54580",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 858\\s*F"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 1",
          "code": "Wrong answer on pretest 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 2",
          "code": "(long long) pow(10, k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 3",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 4",
          "code": "int n = 500000, d = 0;\nwhile (3 * n - 3 * (d + 1 + (d + 1 + 2)*(d + 1 - 1) / 2) >= 2 * n) ++d;\nvector<int> p(n);\np[0] = -1;\nFORE(i, 1, d - 1) p[i] = i - 1;\nint at = d;\nREPE(i, d - 2) {\n\tint prv = i;\n\tREP(j, d - i) { assert(at < n); p[at] = prv; prv = at++; }\n}\nwhile (at < n) p[at++] = d - 1;\nprintf(\"%d\\n\", n);\nREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", p[i] + 1); } puts(\"\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) - Codeforces - Code 5",
          "code": "dfaccc babc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54580",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n    set<pair<int,int>> roads;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Road cannot connect a city to itself: road %d connects city %d to itself\", i+1, a);\n        int u = min(a,b);\n        int v = max(a,b);\n        pair<int,int> edge = make_pair(u,v);\n        ensuref(roads.count(edge) == 0, \"Duplicate road between cities %d and %d\", u, v);\n        roads.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n    set<pair<int,int>> roads;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Road cannot connect a city to itself: road %d connects city %d to itself\", i+1, a);\n        int u = min(a,b);\n        int v = max(a,b);\n        pair<int,int> edge = make_pair(u,v);\n        ensuref(roads.count(edge) == 0, \"Duplicate road between cities %d and %d\", u, v);\n        roads.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n    set<pair<int,int>> roads;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Road cannot connect a city to itself: road %d connects city %d to itself\", i+1, a);\n        int u = min(a,b);\n        int v = max(a,b);\n        pair<int,int> edge = make_pair(u,v);\n        ensuref(roads.count(edge) == 0, \"Duplicate road between cities %d and %d\", u, v);\n        roads.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, w_expected;\nset<pair<int, int>> edges;\nset<pair<int, int>> used_edges;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    n = inf.readInt();\n    m = inf.readInt();\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        if (u == v)\n            quitf(_fail, \"Self-loops are not allowed in the input graph\");\n        if (u > n || u < 1 || v > n || v < 1)\n            quitf(_fail, \"Invalid city number in input: %d or %d\", u, v);\n        if (u > v) swap(u, v);\n        if (!edges.insert({u, v}).second)\n            quitf(_fail, \"Duplicate edge between cities %d and %d in input\", u, v);\n    }\n\n    // Read expected answer (maximum number of episodes)\n    w_expected = ans.readInt(0, m / 2, \"maximum number of episodes\");\n\n    // Read contestant's answer\n    int w_output = ouf.readInt(0, m / 2, \"number of episodes\");\n    if (w_output != w_expected)\n        quitf(_wa, \"Incorrect number of episodes: expected %d, found %d\", w_expected, w_output);\n\n    for (int i = 1; i <= w_output; i++) {\n        // Read x, y, z\n        int x = ouf.readInt(1, n, format(\"x%d\", i).c_str());\n        int y = ouf.readInt(1, n, format(\"y%d\", i).c_str());\n        int z = ouf.readInt(1, n, format(\"z%d\", i).c_str());\n\n        // Check edges exist and have not been used\n        vector<pair<int, int>> episode_edges = {{x, y}, {y, z}};\n        for (auto e : episode_edges) {\n            int u = e.first, v = e.second;\n            if (u > v) swap(u, v);\n            if (edges.find({u, v}) == edges.end())\n                quitf(_wa, \"Edge between cities %d and %d does not exist\", u, v);\n            if (!used_edges.insert({u, v}).second)\n                quitf(_wa, \"Edge between cities %d and %d is used more than once\", u, v);\n        }\n    }\n\n    quitf(_ok, \"Correct answer with %d episodes\", w_expected);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"empty\") {\n        // No edges\n        if (m == -1) m = 0;\n        else if (m != 0) {\n            fprintf(stderr, \"For empty type, m must be 0\\n\");\n            exit(1);\n        }\n        // edges remains empty\n    } else if (type == \"path\") {\n        if (m == -1) m = n - 1;\n        else if (m != n - 1) {\n            fprintf(stderr, \"For path type, m must be n - 1\\n\");\n            exit(1);\n        }\n        if (n < 1 || m < 0 || m > 200000) {\n            fprintf(stderr, \"Invalid n or m for path type\\n\");\n            exit(1);\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        if (m == -1) m = n - 1;\n        else if (m != n - 1) {\n            fprintf(stderr, \"For star type, m must be n - 1\\n\");\n            exit(1);\n        }\n        if (n < 1 || m < 0 || m > 200000) {\n            fprintf(stderr, \"Invalid n or m for star type\\n\");\n            exit(1);\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        // Check that n(n-1)/2 <= 200000\n        if (n > 632) {\n            fprintf(stderr, \"n too large for complete graph\\n\");\n            exit(1);\n        }\n        if (m == -1) m = n * (n -1) / 2;\n        else if (m != n*(n-1)/2) {\n            fprintf(stderr, \"For complete type, m must be n(n-1)/2\\n\");\n            exit(1);\n        }\n        if (n < 1 || m < 0 || m > 200000) {\n            fprintf(stderr, \"Invalid n or m for complete type\\n\");\n            exit(1);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i+1; j <= n; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"random\") {\n        if (m == -1) {\n            fprintf(stderr, \"For random type, m must be specified\\n\");\n            exit(1);\n        }\n        if (m < 0 || m > 200000 || n < 1) {\n            fprintf(stderr, \"Invalid n or m for random type\\n\");\n            exit(1);\n        }\n        if (m > 1LL * n * (n - 1) / 2) {\n            fprintf(stderr, \"m too large for given n in random type\\n\");\n            exit(1);\n        }\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            auto e = make_pair(a, b);\n            if (edge_set.count(e)) continue;\n            edge_set.insert(e);\n        }\n        for (auto e : edge_set) {\n            edges.push_back(e);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    // Output n m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"empty\") {\n        // No edges\n        if (m == -1) m = 0;\n        else if (m != 0) {\n            fprintf(stderr, \"For empty type, m must be 0\\n\");\n            exit(1);\n        }\n        // edges remains empty\n    } else if (type == \"path\") {\n        if (m == -1) m = n - 1;\n        else if (m != n - 1) {\n            fprintf(stderr, \"For path type, m must be n - 1\\n\");\n            exit(1);\n        }\n        if (n < 1 || m < 0 || m > 200000) {\n            fprintf(stderr, \"Invalid n or m for path type\\n\");\n            exit(1);\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        if (m == -1) m = n - 1;\n        else if (m != n - 1) {\n            fprintf(stderr, \"For star type, m must be n - 1\\n\");\n            exit(1);\n        }\n        if (n < 1 || m < 0 || m > 200000) {\n            fprintf(stderr, \"Invalid n or m for star type\\n\");\n            exit(1);\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        // Check that n(n-1)/2 <= 200000\n        if (n > 632) {\n            fprintf(stderr, \"n too large for complete graph\\n\");\n            exit(1);\n        }\n        if (m == -1) m = n * (n -1) / 2;\n        else if (m != n*(n-1)/2) {\n            fprintf(stderr, \"For complete type, m must be n(n-1)/2\\n\");\n            exit(1);\n        }\n        if (n < 1 || m < 0 || m > 200000) {\n            fprintf(stderr, \"Invalid n or m for complete type\\n\");\n            exit(1);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i+1; j <= n; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"random\") {\n        if (m == -1) {\n            fprintf(stderr, \"For random type, m must be specified\\n\");\n            exit(1);\n        }\n        if (m < 0 || m > 200000 || n < 1) {\n            fprintf(stderr, \"Invalid n or m for random type\\n\");\n            exit(1);\n        }\n        if (m > 1LL * n * (n - 1) / 2) {\n            fprintf(stderr, \"m too large for given n in random type\\n\");\n            exit(1);\n        }\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            auto e = make_pair(a, b);\n            if (edge_set.count(e)) continue;\n            edge_set.insert(e);\n        }\n        for (auto e : edge_set) {\n            edges.push_back(e);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    // Output n m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type empty\n./gen -n 2 -type empty\n./gen -n 2 -type path\n./gen -n 5 -type empty\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 10 -type star\n./gen -n 10 -type path\n./gen -n 10 -m 20 -type random\n./gen -n 100 -type star\n./gen -n 100 -type path\n./gen -n 200000 -type empty\n./gen -n 200000 -type path\n./gen -n 200000 -type star\n./gen -n 200000 -m 200000 -type random\n./gen -n 1000 -m 200000 -type random\n./gen -n 632 -type complete\n./gen -n 100000 -type empty\n./gen -n 100000 -m 50000 -type random\n./gen -n 100000 -m 100000 -type random\n./gen -n 10000 -m 200000 -type random\n./gen -n 200000 -m 199999 -type random\n./gen -n 200000 -m 999 -type random\n./gen -n 100000 -type path\n./gen -n 50000 -type star\n./gen -n 50000 -m 100000 -type random\n./gen -n 200000 -m 150000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:56.262451",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/A",
      "title": "A. Declined Finalists",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains K (1 ≤ K ≤ 25), the number of onsite finalists you know. The second line of input contains r1, r2, ..., rK (1 ≤ ri ≤ 106), the qualifying ranks of the finalists you know. All these ranks are distinct.",
      "output_spec": "OutputPrint the minimum possible number of contestants that declined the invitation to compete onsite.",
      "sample_tests": "ExamplesInputCopy252 3 4 5 6 7 8 9 10 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 28OutputCopy3InputCopy516 23 8 15 4OutputCopy0InputCopy314 15 92OutputCopy67",
      "description": "A. Declined Finalists\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains K (1 ≤ K ≤ 25), the number of onsite finalists you know. The second line of input contains r1, r2, ..., rK (1 ≤ ri ≤ 106), the qualifying ranks of the finalists you know. All these ranks are distinct.\n\nOutputPrint the minimum possible number of contestants that declined the invitation to compete onsite.\n\nInputCopy252 3 4 5 6 7 8 9 10 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 28OutputCopy3InputCopy516 23 8 15 4OutputCopy0InputCopy314 15 92OutputCopy67\n\nInputCopy252 3 4 5 6 7 8 9 10 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 28\n\nOutputCopy3\n\nInputCopy516 23 8 15 4\n\nOutputCopy0\n\nInputCopy314 15 92\n\nOutputCopy67\n\nNoteIn the first example, you know all 25 onsite finalists. The contestants who ranked 1-st, 13-th, and 27-th must have declined, so the answer is 3.",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Lazy Security GuardLet's ask the problem a different way. For a fixed perimeter, what's the maximum number of city blocks we can fit in it? The maximum will always be achieved by a rectangle, because that's the only shape that doesn't contain any angles. A angle is not allowed because there would be a way to add another city block without affecting the perimeter. The problem is therefore equivalent to finding the minimum-perimeter rectangle with area at least N.A H × W rectangle has a perimeter of 2·(H + W). The constraints of the problem were low enough that one could loop through every possible value of H and find the smallest corresponding W such that H·W ≥ N. We can show that the best rectangle will always have . Consider what happens if W ≥ H + 2. Then (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1. In other words, the (W - 1) × (H + 1) rectangle has greater area than the W × H rectangle, but the same perimeter.A direct solution therefore sets and H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*A"
          },
          "content_length": 10958
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int K = inf.readInt(1,25,\"K\");\n    inf.readEoln();\n    vector<int> r = inf.readInts(K,1,1000000,\"r_i\");\n    inf.readEoln();\n    set<int> ranks(r.begin(), r.end());\n    ensuref((int)ranks.size() == K, \"All qualifying ranks must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int K = inf.readInt(1,25,\"K\");\n    inf.readEoln();\n    vector<int> r = inf.readInts(K,1,1000000,\"r_i\");\n    inf.readEoln();\n    set<int> ranks(r.begin(), r.end());\n    ensuref((int)ranks.size() == K, \"All qualifying ranks must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int K = inf.readInt(1,25,\"K\");\n    inf.readEoln();\n    vector<int> r = inf.readInts(K,1,1000000,\"r_i\");\n    inf.readEoln();\n    set<int> ranks(r.begin(), r.end());\n    ensuref((int)ranks.size() == K, \"All qualifying ranks must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n    int K = opt<int>(\"K\");\n    int MaxRank = opt<int>(\"MaxRank\", 1000000);\n    string Type = opt<string>(\"Type\", \"random\");\n\n    set<int> ranks;\n\n    if (Type == \"low\")\n    {\n        // Generate K distinct integers between 1 and 25\n        for (int i = 0; i < K; )\n        {\n            int ri = rnd.next(1, min(25, MaxRank));\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else if (Type == \"high\")\n    {\n        // Generate K distinct integers between MaxRank - 25 + 1 and MaxRank\n        int start = max(1, MaxRank - 25 + 1);\n        for (int i = 0; i < K; )\n        {\n            int ri = rnd.next(start, MaxRank);\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else if (Type == \"mixed\")\n    {\n        // Generate K / 2 low and K / 2 high ri values\n        int low_K = K / 2;\n        int high_K = K - low_K;\n        // Generate low ranks\n        for (int i = 0; i < low_K; )\n        {\n            int ri = rnd.next(1, min(25, MaxRank));\n            if (ranks.insert(ri).second)\n                i++;\n        }\n        // Generate high ranks\n        int start = max(1, MaxRank - 25 + 1);\n        for (int i = 0; i < high_K; )\n        {\n            int ri = rnd.next(start, MaxRank);\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else if (Type == \"all25\")\n    {\n        // Generate ri as 1 to K (up to 25)\n        K = min(K, 25);\n        for (int i = 1; i <= K; i++)\n            ranks.insert(i);\n    }\n    else if (Type == \"max\")\n    {\n        // Generate K distinct ri values starting from MaxRank downwards\n        for (int i = 0; i < K; )\n        {\n            int ri = MaxRank - i;\n            if (ri <= 0) break; // Ensure ri > 0\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else // default: random\n    {\n        // Generate K distinct integers between 1 and MaxRank\n        for (int i = 0; i < K; )\n        {\n            int ri = rnd.next(1, MaxRank);\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n\n    // Output K\n    printf(\"%d\\n\", K);\n\n    // Output ri values\n    vector<int> ri_values(ranks.begin(), ranks.end());\n    // Randomly shuffle ri_values\n    shuffle(ri_values.begin(), ri_values.end());\n\n    // Output ri_values\n    for (int i = 0; i < K; i++)\n    {\n        printf(\"%d\", ri_values[i]);\n        if (i + 1 < K)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n    int K = opt<int>(\"K\");\n    int MaxRank = opt<int>(\"MaxRank\", 1000000);\n    string Type = opt<string>(\"Type\", \"random\");\n\n    set<int> ranks;\n\n    if (Type == \"low\")\n    {\n        // Generate K distinct integers between 1 and 25\n        for (int i = 0; i < K; )\n        {\n            int ri = rnd.next(1, min(25, MaxRank));\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else if (Type == \"high\")\n    {\n        // Generate K distinct integers between MaxRank - 25 + 1 and MaxRank\n        int start = max(1, MaxRank - 25 + 1);\n        for (int i = 0; i < K; )\n        {\n            int ri = rnd.next(start, MaxRank);\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else if (Type == \"mixed\")\n    {\n        // Generate K / 2 low and K / 2 high ri values\n        int low_K = K / 2;\n        int high_K = K - low_K;\n        // Generate low ranks\n        for (int i = 0; i < low_K; )\n        {\n            int ri = rnd.next(1, min(25, MaxRank));\n            if (ranks.insert(ri).second)\n                i++;\n        }\n        // Generate high ranks\n        int start = max(1, MaxRank - 25 + 1);\n        for (int i = 0; i < high_K; )\n        {\n            int ri = rnd.next(start, MaxRank);\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else if (Type == \"all25\")\n    {\n        // Generate ri as 1 to K (up to 25)\n        K = min(K, 25);\n        for (int i = 1; i <= K; i++)\n            ranks.insert(i);\n    }\n    else if (Type == \"max\")\n    {\n        // Generate K distinct ri values starting from MaxRank downwards\n        for (int i = 0; i < K; )\n        {\n            int ri = MaxRank - i;\n            if (ri <= 0) break; // Ensure ri > 0\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n    else // default: random\n    {\n        // Generate K distinct integers between 1 and MaxRank\n        for (int i = 0; i < K; )\n        {\n            int ri = rnd.next(1, MaxRank);\n            if (ranks.insert(ri).second)\n                i++;\n        }\n    }\n\n    // Output K\n    printf(\"%d\\n\", K);\n\n    // Output ri values\n    vector<int> ri_values(ranks.begin(), ranks.end());\n    // Randomly shuffle ri_values\n    shuffle(ri_values.begin(), ri_values.end());\n\n    // Output ri_values\n    for (int i = 0; i < K; i++)\n    {\n        printf(\"%d\", ri_values[i]);\n        if (i + 1 < K)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -K 1 -MaxRank 100 -Type low\n./gen -K 1 -MaxRank 100 -Type high\n./gen -K 1 -MaxRank 1000 -Type random\n./gen -K 1 -MaxRank 1000000 -Type max\n\n./gen -K 25 -MaxRank 1000000 -Type all25\n./gen -K 25 -MaxRank 1000000 -Type mixed\n\n./gen -K 25 -MaxRank 1000000 -Type high\n./gen -K 25 -MaxRank 1000000 -Type low\n./gen -K 25 -MaxRank 1000000 -Type random\n./gen -K 25 -MaxRank 1000000 -Type max\n\n./gen -K 5 -MaxRank 25 -Type low\n./gen -K 5 -MaxRank 50 -Type high\n./gen -K 10 -MaxRank 100 -Type mixed\n\n./gen -K 15 -MaxRank 1000 -Type random\n./gen -K 20 -MaxRank 1000000 -Type mixed\n\n./gen -K 25 -MaxRank 30 -Type all25\n./gen -K 25 -MaxRank 30 -Type random\n\n./gen -K 3 -MaxRank 100 -Type max\n./gen -K 3 -MaxRank 92 -Type max\n\n./gen -K 2 -MaxRank 25 -Type low\n./gen -K 2 -MaxRank 26 -Type high\n\n./gen -K 25 -MaxRank 1000000 -Type max\n./gen -K 25 -MaxRank 1000000 -Type random\n\n./gen -K 25 -MaxRank 27 -Type mixed\n./gen -K 25 -MaxRank 50 -Type high\n./gen -K 25 -MaxRank 25 -Type random\n./gen -K 25 -MaxRank 1000 -Type random\n./gen -K 25 -MaxRank 1000000 -Type random\n\n./gen -K 10 -MaxRank 1000000 -Type mixed\n./gen -K 15 -MaxRank 1000000 -Type low\n./gen -K 15 -MaxRank 15 -Type all25\n\n./gen -K 1 -MaxRank 1 -Type low\n./gen -K 25 -MaxRank 25 -Type all25\n./gen -K 13 -MaxRank 13 -Type all25\n./gen -K 25 -MaxRank 50 -Type mixed\n./gen -K 25 -MaxRank 1000000 -Type low\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:40:58.213446",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/B",
      "title": "B. Lazy Security Guard",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will consist of a single integer N (1 ≤ N ≤ 106), the number of city blocks that must be enclosed by the route.",
      "output_spec": "OutputPrint the minimum perimeter that can be achieved.",
      "sample_tests": "ExamplesInputCopy4OutputCopy8InputCopy11OutputCopy14InputCopy22OutputCopy20",
      "description": "B. Lazy Security Guard\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will consist of a single integer N (1 ≤ N ≤ 106), the number of city blocks that must be enclosed by the route.\n\nOutputPrint the minimum perimeter that can be achieved.\n\nInputCopy4OutputCopy8InputCopy11OutputCopy14InputCopy22OutputCopy20\n\nOutputCopy8\n\nInputCopy11\n\nOutputCopy14\n\nInputCopy22\n\nOutputCopy20\n\nNoteHere are some possible shapes for the examples:",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Lazy Security GuardLet's ask the problem a different way. For a fixed perimeter, what's the maximum number of city blocks we can fit in it? The maximum will always be achieved by a rectangle, because that's the only shape that doesn't contain any angles. A angle is not allowed because there would be a way to add another city block without affecting the perimeter. The problem is therefore equivalent to finding the minimum-perimeter rectangle with area at least N.A H × W rectangle has a perimeter of 2·(H + W). The constraints of the problem were low enough that one could loop through every possible value of H and find the smallest corresponding W such that H·W ≥ N. We can show that the best rectangle will always have . Consider what happens if W ≥ H + 2. Then (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1. In other words, the (W - 1) × (H + 1) rectangle has greater area than the W × H rectangle, but the same perimeter.A direct solution therefore sets and H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*B"
          },
          "content_length": 10958
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000000, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nvector<int> primes;\nvoid generatePrimes() {\n    vector<bool> is_prime(MAX_N + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i * i <= MAX_N; ++i)\n        if(is_prime[i])\n            for(int j = i * i; j <= MAX_N; j += i)\n                is_prime[j] = false;\n    for(int i = 2; i <= MAX_N; ++i)\n        if(is_prime[i])\n            primes.push_back(i);\n}\n\nvector<int> squares;\nvoid generateSquares() {\n    for(int i = 1; i * i <= MAX_N; ++i)\n        squares.push_back(i * i);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", MAX_N);\n    string type = opt<string>(\"type\", \"random\");\n    int N;\n\n    if (type == \"prime\") {\n        generatePrimes();\n        auto lower = lower_bound(primes.begin(), primes.end(), minN);\n        auto upper = upper_bound(primes.begin(), primes.end(), maxN);\n        vector<int> valid_primes(lower, upper);\n        if (valid_primes.empty()) {\n            // No primes in the range, default to minN\n            N = minN;\n        } else {\n            N = rnd.any(valid_primes);\n        }\n    } else if (type == \"square\") {\n        generateSquares();\n        auto lower = lower_bound(squares.begin(), squares.end(), minN);\n        auto upper = upper_bound(squares.begin(), squares.end(), maxN);\n        vector<int> valid_squares(lower, upper);\n        if (valid_squares.empty()) {\n            // If no squares in range, default to nearest square\n            int k = int(sqrt((minN + maxN) / 2));\n            N = k * k;\n        } else {\n            N = rnd.any(valid_squares);\n        }\n    } else if (type == \"one_less_square\") {\n        // Generate k^2 - 1 between minN and maxN\n        vector<int> candidates;\n        for(int k = 1; k * k - 1 <= maxN; ++k) {\n            int val = k * k - 1;\n            if(val >= minN)\n                candidates.push_back(val);\n        }\n        if(candidates.empty()) {\n            N = minN;\n        } else {\n            N = rnd.any(candidates);\n        }\n    } else if (type == \"one_more_square\") {\n        // Generate k^2 + 1 between minN and maxN\n        vector<int> candidates;\n        for(int k = 1; k * k + 1 <= maxN; ++k) {\n            int val = k * k + 1;\n            if(val >= minN)\n                candidates.push_back(val);\n        }\n        if(candidates.empty()) {\n            N = maxN;\n        } else {\n            N = rnd.any(candidates);\n        }\n    } else if (type == \"small\") {\n        N = rnd.next(minN, min(maxN, 100));\n    } else if (type == \"large\") {\n        N = rnd.next(max(minN, MAX_N - 1000), maxN);\n    } else if (type == \"max\") {\n        N = maxN;\n    } else {\n        // Default: random N between minN and maxN\n        N = rnd.next(minN, maxN);\n    }\n\n    // Ensure N is within [minN, maxN]\n    N = max(minN, min(N, maxN));\n\n    // Output N\n    printf(\"%d\\n\", N);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nvector<int> primes;\nvoid generatePrimes() {\n    vector<bool> is_prime(MAX_N + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i * i <= MAX_N; ++i)\n        if(is_prime[i])\n            for(int j = i * i; j <= MAX_N; j += i)\n                is_prime[j] = false;\n    for(int i = 2; i <= MAX_N; ++i)\n        if(is_prime[i])\n            primes.push_back(i);\n}\n\nvector<int> squares;\nvoid generateSquares() {\n    for(int i = 1; i * i <= MAX_N; ++i)\n        squares.push_back(i * i);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", MAX_N);\n    string type = opt<string>(\"type\", \"random\");\n    int N;\n\n    if (type == \"prime\") {\n        generatePrimes();\n        auto lower = lower_bound(primes.begin(), primes.end(), minN);\n        auto upper = upper_bound(primes.begin(), primes.end(), maxN);\n        vector<int> valid_primes(lower, upper);\n        if (valid_primes.empty()) {\n            // No primes in the range, default to minN\n            N = minN;\n        } else {\n            N = rnd.any(valid_primes);\n        }\n    } else if (type == \"square\") {\n        generateSquares();\n        auto lower = lower_bound(squares.begin(), squares.end(), minN);\n        auto upper = upper_bound(squares.begin(), squares.end(), maxN);\n        vector<int> valid_squares(lower, upper);\n        if (valid_squares.empty()) {\n            // If no squares in range, default to nearest square\n            int k = int(sqrt((minN + maxN) / 2));\n            N = k * k;\n        } else {\n            N = rnd.any(valid_squares);\n        }\n    } else if (type == \"one_less_square\") {\n        // Generate k^2 - 1 between minN and maxN\n        vector<int> candidates;\n        for(int k = 1; k * k - 1 <= maxN; ++k) {\n            int val = k * k - 1;\n            if(val >= minN)\n                candidates.push_back(val);\n        }\n        if(candidates.empty()) {\n            N = minN;\n        } else {\n            N = rnd.any(candidates);\n        }\n    } else if (type == \"one_more_square\") {\n        // Generate k^2 + 1 between minN and maxN\n        vector<int> candidates;\n        for(int k = 1; k * k + 1 <= maxN; ++k) {\n            int val = k * k + 1;\n            if(val >= minN)\n                candidates.push_back(val);\n        }\n        if(candidates.empty()) {\n            N = maxN;\n        } else {\n            N = rnd.any(candidates);\n        }\n    } else if (type == \"small\") {\n        N = rnd.next(minN, min(maxN, 100));\n    } else if (type == \"large\") {\n        N = rnd.next(max(minN, MAX_N - 1000), maxN);\n    } else if (type == \"max\") {\n        N = maxN;\n    } else {\n        // Default: random N between minN and maxN\n        N = rnd.next(minN, maxN);\n    }\n\n    // Ensure N is within [minN, maxN]\n    N = max(minN, min(N, maxN));\n\n    // Output N\n    printf(\"%d\\n\", N);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -minN 1 -maxN 10 -type small\n./gen -minN 1 -maxN 10 -type prime\n./gen -minN 1 -maxN 10 -type square\n./gen -minN 1 -maxN 10 -type one_less_square\n./gen -minN 1 -maxN 10 -type one_more_square\n\n./gen -minN 1 -maxN 1 -type random\n./gen -minN 1 -maxN 1 -type square\n\n./gen -minN 1 -maxN 1000000 -type random\n./gen -minN 1 -maxN 1000000 -type random\n./gen -minN 1 -maxN 1000000 -type random\n\n./gen -type small\n./gen -type large\n./gen -type max\n\n./gen -type prime\n./gen -type square\n./gen -type one_less_square\n./gen -type one_more_square\n\n./gen -minN 999990 -maxN 1000000 -type large\n./gen -minN 999990 -maxN 1000000 -type prime\n./gen -minN 999990 -maxN 1000000 -type square\n./gen -minN 999990 -maxN 1000000 -type one_less_square\n./gen -minN 999990 -maxN 1000000 -type one_more_square\n\n./gen -minN 500000 -maxN 500000 -type random\n./gen -minN 1000 -maxN 100000 -type random\n\n./gen -minN 80000 -maxN 90000 -type square\n./gen -minN 80000 -maxN 90000 -type one_less_square\n./gen -minN 80000 -maxN 90000 -type one_more_square\n\n./gen -minN 29 -maxN 29 -type prime\n./gen -minN 9973 -maxN 9973 -type prime\n\n./gen -minN 1024 -maxN 1024 -type square\n./gen -minN 1025 -maxN 1025 -type one_more_square\n./gen -minN 1023 -maxN 1023 -type one_less_square\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:00.385379",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/C",
      "title": "C. Pie Rules",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will begin with an integer N (1 ≤ N ≤ 50), the number of slices of pie. Following this is a line with N integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.",
      "output_spec": "OutputPrint two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.",
      "sample_tests": "ExamplesInputCopy3141 592 653OutputCopy653 733InputCopy510 21 10 21 10OutputCopy31 41",
      "description": "C. Pie Rules\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will begin with an integer N (1 ≤ N ≤ 50), the number of slices of pie. Following this is a line with N integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.\n\nOutputPrint two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.\n\nInputCopy3141 592 653OutputCopy653 733InputCopy510 21 10 21 10OutputCopy31 41\n\nInputCopy3141 592 653\n\nOutputCopy653 733\n\nInputCopy510 21 10 21 10\n\nOutputCopy31 41\n\nNoteIn the first example, Bob takes the size 141 slice for himself and gives the decider token to Alice. Then Alice gives the size 592 slice to Bob and keeps the decider token for herself, so that she can then give the size 653 slice to herself.",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Lazy Security GuardLet's ask the problem a different way. For a fixed perimeter, what's the maximum number of city blocks we can fit in it? The maximum will always be achieved by a rectangle, because that's the only shape that doesn't contain any angles. A angle is not allowed because there would be a way to add another city block without affecting the perimeter. The problem is therefore equivalent to finding the minimum-perimeter rectangle with area at least N.A H × W rectangle has a perimeter of 2·(H + W). The constraints of the problem were low enough that one could loop through every possible value of H and find the smallest corresponding W such that H·W ≥ N. We can show that the best rectangle will always have . Consider what happens if W ≥ H + 2. Then (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1. In other words, the (W - 1) × (H + 1) rectangle has greater area than the W × H rectangle, but the same perimeter.A direct solution therefore sets and H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*C"
          },
          "content_length": 10958
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read N\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readEoln();\n\n    // Read sizes\n    vector<int> sizes = inf.readInts(N, 1, 100000, \"sizes\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read N\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readEoln();\n\n    // Read sizes\n    vector<int> sizes = inf.readInts(N, 1, 100000, \"sizes\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read N\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readEoln();\n\n    // Read sizes\n    vector<int> sizes = inf.readInts(N, 1, 100000, \"sizes\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> slices(n);\n\n    if (type == \"random\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = rnd.next(min_size, max_size);\n        }\n    }\n    else if (type == \"all_same\") {\n        int size = opt<int>(\"size\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = size;\n        }\n    }\n    else if (type == \"increasing\") {\n        int start = opt<int>(\"start\", 1);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = start + i * step;\n            if (slices[i] > 100000) slices[i] = 100000;\n        }\n    }\n    else if (type == \"decreasing\") {\n        int start = opt<int>(\"start\", 100000);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = start - i * step;\n            if (slices[i] < 1) slices[i] = 1;\n        }\n    }\n    else if (type == \"alternating_big_small\") {\n        int big = opt<int>(\"big\", 100000);\n        int small = opt<int>(\"small\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = (i % 2 == 0) ? big : small;\n        }\n    }\n    else if (type == \"alternating_small_big\") {\n        int big = opt<int>(\"big\", 100000);\n        int small = opt<int>(\"small\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = (i % 2 == 0) ? small : big;\n        }\n    }\n    else if (type == \"maximal_first_minimal_rest\") {\n        slices[0] = 100000;\n        for (int i = 1; i < n; ++i) {\n            slices[i] = 1;\n        }\n    }\n    else if (type == \"minimal_first_maximal_rest\") {\n        slices[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            slices[i] = 100000;\n        }\n    }\n    else if (type == \"maximal_last_minimal_rest\") {\n        for (int i = 0; i < n - 1; ++i) {\n            slices[i] = 1;\n        }\n        slices[n - 1] = 100000;\n    }\n    else if (type == \"minimal_last_maximal_rest\") {\n        for (int i = 0; i < n - 1; ++i) {\n            slices[i] = 100000;\n        }\n        slices[n - 1] = 1;\n    }\n    else if (type == \"maximal_middle_minimal_rest\") {\n        for (int i = 0; i < n; ++i) {\n            slices[i] = 1;\n        }\n        slices[n / 2] = 100000;\n    }\n    else if (type == \"minimal_middle_maximal_rest\") {\n        for (int i = 0; i < n; ++i) {\n            slices[i] = 100000;\n        }\n        slices[n / 2] = 1;\n    }\n    else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output N\n    printf(\"%d\\n\", n);\n    // Output slices\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", slices[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> slices(n);\n\n    if (type == \"random\") {\n        int min_size = opt<int>(\"min_size\", 1);\n        int max_size = opt<int>(\"max_size\", 100000);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = rnd.next(min_size, max_size);\n        }\n    }\n    else if (type == \"all_same\") {\n        int size = opt<int>(\"size\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = size;\n        }\n    }\n    else if (type == \"increasing\") {\n        int start = opt<int>(\"start\", 1);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = start + i * step;\n            if (slices[i] > 100000) slices[i] = 100000;\n        }\n    }\n    else if (type == \"decreasing\") {\n        int start = opt<int>(\"start\", 100000);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = start - i * step;\n            if (slices[i] < 1) slices[i] = 1;\n        }\n    }\n    else if (type == \"alternating_big_small\") {\n        int big = opt<int>(\"big\", 100000);\n        int small = opt<int>(\"small\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = (i % 2 == 0) ? big : small;\n        }\n    }\n    else if (type == \"alternating_small_big\") {\n        int big = opt<int>(\"big\", 100000);\n        int small = opt<int>(\"small\", 1);\n        for (int i = 0; i < n; ++i) {\n            slices[i] = (i % 2 == 0) ? small : big;\n        }\n    }\n    else if (type == \"maximal_first_minimal_rest\") {\n        slices[0] = 100000;\n        for (int i = 1; i < n; ++i) {\n            slices[i] = 1;\n        }\n    }\n    else if (type == \"minimal_first_maximal_rest\") {\n        slices[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            slices[i] = 100000;\n        }\n    }\n    else if (type == \"maximal_last_minimal_rest\") {\n        for (int i = 0; i < n - 1; ++i) {\n            slices[i] = 1;\n        }\n        slices[n - 1] = 100000;\n    }\n    else if (type == \"minimal_last_maximal_rest\") {\n        for (int i = 0; i < n - 1; ++i) {\n            slices[i] = 100000;\n        }\n        slices[n - 1] = 1;\n    }\n    else if (type == \"maximal_middle_minimal_rest\") {\n        for (int i = 0; i < n; ++i) {\n            slices[i] = 1;\n        }\n        slices[n / 2] = 100000;\n    }\n    else if (type == \"minimal_middle_maximal_rest\") {\n        for (int i = 0; i < n; ++i) {\n            slices[i] = 100000;\n        }\n        slices[n / 2] = 1;\n    }\n    else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output N\n    printf(\"%d\\n\", n);\n    // Output slices\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", slices[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_same -size 1\n./gen -n 1 -type all_same -size 100000\n\n./gen -n 2 -type random\n./gen -n 2 -type alternating_big_small -big 100000 -small 1\n./gen -n 2 -type alternating_small_big -big 100000 -small 1\n\n./gen -n 3 -type maximal_first_minimal_rest\n./gen -n 3 -type minimal_first_maximal_rest\n./gen -n 3 -type maximal_last_minimal_rest\n./gen -n 3 -type minimal_last_maximal_rest\n\n./gen -n 5 -type increasing -start 1 -step 100\n./gen -n 5 -type decreasing -start 100000 -step 100\n\n./gen -n 10 -type random\n./gen -n 10 -type all_same -size 50\n./gen -n 10 -type alternating_big_small -big 100000 -small 1\n./gen -n 10 -type alternating_small_big -big 100000 -small 1\n\n./gen -n 25 -type maximal_middle_minimal_rest\n./gen -n 25 -type minimal_middle_maximal_rest\n\n./gen -n 30 -type increasing -start 1 -step 1000\n./gen -n 30 -type decreasing -start 100000 -step 1000\n\n./gen -n 40 -type alternating_big_small -big 100000 -small 1\n\n./gen -n 45 -type increasing -start 1000 -step 1000\n\n./gen -n 50 -type random\n./gen -n 50 -type random -min_size 1 -max_size 100\n./gen -n 50 -type random -min_size 50000 -max_size 60000\n./gen -n 50 -type random -min_size 90000 -max_size 100000\n./gen -n 50 -type all_same -size 100000\n./gen -n 50 -type all_same -size 1\n./gen -n 50 -type maximal_first_minimal_rest\n./gen -n 50 -type minimal_first_maximal_rest\n./gen -n 50 -type maximal_last_minimal_rest\n./gen -n 50 -type minimal_last_maximal_rest\n./gen -n 50 -type maximal_middle_minimal_rest\n./gen -n 50 -type minimal_middle_maximal_rest\n./gen -n 50 -type alternating_big_small -big 100000 -small 1\n./gen -n 50 -type alternating_small_big -big 100000 -small 1\n./gen -n 50 -type increasing -start 1 -step 2000\n./gen -n 50 -type decreasing -start 100000 -step 2000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:02.486299",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/D",
      "title": "D. Third Month Insanity",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will begin with a line containing N (2 ≤ N ≤ 6).2N lines follow, each with 2N integers. The j-th column of the i-th row indicates the percentage chance that team i will defeat team j, unless i = j, in which case the value will be 0. It is guaranteed that the i-th column of the j-th row plus the j-th column of the i-th row will add to exactly 100.",
      "output_spec": "OutputPrint the maximum possible expected score over all possible brackets. Your answer must be correct to within an absolute or relative error of 10 - 9.Formally, let your answer be a, and the jury's answer be b. Your answer will be considered correct, if .",
      "sample_tests": "ExamplesInputCopy20 40 100 10060 0 40 400 60 0 450 60 55 0OutputCopy1.75InputCopy30 0 100 0 100 0 0 0100 0 100 0 0 0 100 1000 0 0 100 100 0 0 0100 100 0 0 0 0 100 1000 100 0 100 0 0 100 0100 100 100 100 100 0 0 0100 0 100 0 0 100 0 0100 0 100 0 100 100 100 0OutputCopy12InputCopy20 21 41 2679 0 97 3359 3 0 9174 67 9 0OutputCopy3.141592",
      "description": "D. Third Month Insanity\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will begin with a line containing N (2 ≤ N ≤ 6).2N lines follow, each with 2N integers. The j-th column of the i-th row indicates the percentage chance that team i will defeat team j, unless i = j, in which case the value will be 0. It is guaranteed that the i-th column of the j-th row plus the j-th column of the i-th row will add to exactly 100.\n\nOutputPrint the maximum possible expected score over all possible brackets. Your answer must be correct to within an absolute or relative error of 10 - 9.Formally, let your answer be a, and the jury's answer be b. Your answer will be considered correct, if .\n\nInputCopy20 40 100 10060 0 40 400 60 0 450 60 55 0OutputCopy1.75InputCopy30 0 100 0 100 0 0 0100 0 100 0 0 0 100 1000 0 0 100 100 0 0 0100 100 0 0 0 0 100 1000 100 0 100 0 0 100 0100 100 100 100 100 0 0 0100 0 100 0 0 100 0 0100 0 100 0 100 100 100 0OutputCopy12InputCopy20 21 41 2679 0 97 3359 3 0 9174 67 9 0OutputCopy3.141592\n\nInputCopy20 40 100 10060 0 40 400 60 0 450 60 55 0\n\nOutputCopy1.75\n\nInputCopy30 0 100 0 100 0 0 0100 0 100 0 0 0 100 1000 0 0 100 100 0 0 0100 100 0 0 0 0 100 1000 100 0 100 0 0 100 0100 100 100 100 100 0 0 0100 0 100 0 0 100 0 0100 0 100 0 100 100 100 0\n\nOutputCopy12\n\nInputCopy20 21 41 2679 0 97 3359 3 0 9174 67 9 0\n\nOutputCopy3.141592\n\nNoteIn the first example, you should predict teams 1 and 4 to win in round 1, and team 1 to win in round 2. Recall that the winner you predict in round 2 must also be predicted as a winner in round 1.",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Lazy Security GuardLet's ask the problem a different way. For a fixed perimeter, what's the maximum number of city blocks we can fit in it? The maximum will always be achieved by a rectangle, because that's the only shape that doesn't contain any angles. A angle is not allowed because there would be a way to add another city block without affecting the perimeter. The problem is therefore equivalent to finding the minimum-perimeter rectangle with area at least N.A H × W rectangle has a perimeter of 2·(H + W). The constraints of the problem were low enough that one could loop through every possible value of H and find the smallest corresponding W such that H·W ≥ N. We can show that the best rectangle will always have . Consider what happens if W ≥ H + 2. Then (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1. In other words, the (W - 1) × (H + 1) rectangle has greater area than the W × H rectangle, but the same perimeter.A direct solution therefore sets and H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*D"
          },
          "content_length": 10958
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(2, 6, \"N\");\n    inf.readEoln();\n\n    int M = 1 << N;\n\n    vector< vector<int> > p(M + 1, vector<int>(M + 1));\n\n    for (int i = 1; i <= M; ++i) {\n        vector<int> row = inf.readInts(M, 0, 100);\n        inf.readEoln();\n        for (int j = 1; j <= M; ++j) {\n            p[i][j] = row[j - 1];\n            if (i == j) {\n                ensuref(p[i][j] == 0, \"p[%d][%d] should be 0\", i, j);\n            }\n        }\n    }\n\n    for (int i = 1; i <= M; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (i != j) {\n                ensuref(p[i][j] + p[j][i] == 100, \"p[%d][%d] + p[%d][%d] != 100\", i, j, j, i);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(2, 6, \"N\");\n    inf.readEoln();\n\n    int M = 1 << N;\n\n    vector< vector<int> > p(M + 1, vector<int>(M + 1));\n\n    for (int i = 1; i <= M; ++i) {\n        vector<int> row = inf.readInts(M, 0, 100);\n        inf.readEoln();\n        for (int j = 1; j <= M; ++j) {\n            p[i][j] = row[j - 1];\n            if (i == j) {\n                ensuref(p[i][j] == 0, \"p[%d][%d] should be 0\", i, j);\n            }\n        }\n    }\n\n    for (int i = 1; i <= M; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (i != j) {\n                ensuref(p[i][j] + p[j][i] == 100, \"p[%d][%d] + p[%d][%d] != 100\", i, j, j, i);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(2, 6, \"N\");\n    inf.readEoln();\n\n    int M = 1 << N;\n\n    vector< vector<int> > p(M + 1, vector<int>(M + 1));\n\n    for (int i = 1; i <= M; ++i) {\n        vector<int> row = inf.readInts(M, 0, 100);\n        inf.readEoln();\n        for (int j = 1; j <= M; ++j) {\n            p[i][j] = row[j - 1];\n            if (i == j) {\n                ensuref(p[i][j] == 0, \"p[%d][%d] should be 0\", i, j);\n            }\n        }\n    }\n\n    for (int i = 1; i <= M; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (i != j) {\n                ensuref(p[i][j] + p[j][i] == 100, \"p[%d][%d] + p[%d][%d] != 100\", i, j, j, i);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"N\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int num_teams = 1 << N; // 2^N teams\n\n    vector<vector<int>> P(num_teams, vector<int>(num_teams, 0));\n\n    if (type == \"equal\") {\n        // All probabilities are 50% except P[i][i] = 0\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else {\n                    P[i][j] = 50;\n                }\n            }\n        }\n    } else if (type == \"dominant\") {\n        // Teams sorted by strength, P[i][j] = 100 if i < j, 0 if i > j\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else if (i < j) {\n                    P[i][j] = 100;\n                } else {\n                    P[i][j] = 0;\n                }\n            }\n        }\n    } else if (type == \"reverse_dominant\") {\n        // Reverse order of dominant\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else if (i > j) {\n                    P[i][j] = 100;\n                } else {\n                    P[i][j] = 0;\n                }\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Create a cyclic dominance among teams\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else if ((i + 1) % num_teams == j) {\n                    P[i][j] = 100; // i beats (i+1)%num_teams\n                } else {\n                    P[i][j] = 50; // others have 50% chance\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Random probabilities satisfying the constraints\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = i + 1; j < num_teams; ++j) {\n                P[i][j] = rnd.next(0, 100);\n                P[j][i] = 100 - P[i][j];\n            }\n            P[i][i] = 0;\n        }\n    } else if (type == \"superstar\") {\n        // Team 0 always wins\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) continue;\n                if (i == 0) P[i][j] = 100;\n                else if (j == 0) P[i][j] = 0;\n                else P[i][j] = 50;\n            }\n        }\n    } else if (type == \"weakling\") {\n        // Team 0 always loses\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) continue;\n                if (i == 0) P[i][j] = 0;\n                else if (j == 0) P[i][j] = 100;\n                else P[i][j] = 50;\n            }\n        }\n    } else if (type == \"mostly100\") {\n        // Most probabilities are 0 or 100\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = i + 1; j < num_teams; ++j) {\n                if (rnd.next(0, 10) < 9) {\n                    P[i][j] = 100 * rnd.next(0, 1);\n                } else {\n                    P[i][j] = rnd.next(1, 99);\n                }\n                P[j][i] = 100 - P[i][j];\n            }\n        }\n    } else if (type == \"single50\") {\n        // All probabilities are 0 or 100 except for one pair which is 50/50\n        int a = rnd.next(0, num_teams - 1);\n        int b;\n        do {\n            b = rnd.next(0, num_teams - 1);\n        } while (b == a);\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = i + 1; j < num_teams; ++j) {\n                if ((i == a && j == b) || (i == b && j == a)) {\n                    P[i][j] = 50;\n                } else {\n                    P[i][j] = 100 * rnd.next(0, 1);\n                }\n                P[j][i] = 100 - P[i][j];\n            }\n        }\n    } else {\n        // Default to random if type is not recognized\n        // Random probabilities satisfying the constraints\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = i + 1; j < num_teams; ++j) {\n                P[i][j] = rnd.next(0, 100);\n                P[j][i] = 100 - P[i][j];\n            }\n        }\n    }\n\n    // Output N\n    printf(\"%d\\n\", N);\n    // Output probabilities\n    for (int i = 0; i < num_teams; ++i) {\n        for (int j = 0; j < num_teams; ++j) {\n            printf(\"%d\", P[i][j]);\n            if (j + 1 < num_teams)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"N\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int num_teams = 1 << N; // 2^N teams\n\n    vector<vector<int>> P(num_teams, vector<int>(num_teams, 0));\n\n    if (type == \"equal\") {\n        // All probabilities are 50% except P[i][i] = 0\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else {\n                    P[i][j] = 50;\n                }\n            }\n        }\n    } else if (type == \"dominant\") {\n        // Teams sorted by strength, P[i][j] = 100 if i < j, 0 if i > j\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else if (i < j) {\n                    P[i][j] = 100;\n                } else {\n                    P[i][j] = 0;\n                }\n            }\n        }\n    } else if (type == \"reverse_dominant\") {\n        // Reverse order of dominant\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else if (i > j) {\n                    P[i][j] = 100;\n                } else {\n                    P[i][j] = 0;\n                }\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Create a cyclic dominance among teams\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) {\n                    P[i][j] = 0;\n                } else if ((i + 1) % num_teams == j) {\n                    P[i][j] = 100; // i beats (i+1)%num_teams\n                } else {\n                    P[i][j] = 50; // others have 50% chance\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Random probabilities satisfying the constraints\n        for (int i = 0; i < num_teams; ++i) {\n            for (int j = i + 1; j < num_teams; ++j) {\n                P[i][j] = rnd.next(0, 100);\n                P[j][i] = 100 - P[i][j];\n            }\n            P[i][i] = 0;\n        }\n    } else if (type == \"superstar\") {\n        // Team 0 always wins\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) continue;\n                if (i == 0) P[i][j] = 100;\n                else if (j == 0) P[i][j] = 0;\n                else P[i][j] = 50;\n            }\n        }\n    } else if (type == \"weakling\") {\n        // Team 0 always loses\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = 0; j < num_teams; ++j) {\n                if (i == j) continue;\n                if (i == 0) P[i][j] = 0;\n                else if (j == 0) P[i][j] = 100;\n                else P[i][j] = 50;\n            }\n        }\n    } else if (type == \"mostly100\") {\n        // Most probabilities are 0 or 100\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = i + 1; j < num_teams; ++j) {\n                if (rnd.next(0, 10) < 9) {\n                    P[i][j] = 100 * rnd.next(0, 1);\n                } else {\n                    P[i][j] = rnd.next(1, 99);\n                }\n                P[j][i] = 100 - P[i][j];\n            }\n        }\n    } else if (type == \"single50\") {\n        // All probabilities are 0 or 100 except for one pair which is 50/50\n        int a = rnd.next(0, num_teams - 1);\n        int b;\n        do {\n            b = rnd.next(0, num_teams - 1);\n        } while (b == a);\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = i + 1; j < num_teams; ++j) {\n                if ((i == a && j == b) || (i == b && j == a)) {\n                    P[i][j] = 50;\n                } else {\n                    P[i][j] = 100 * rnd.next(0, 1);\n                }\n                P[j][i] = 100 - P[i][j];\n            }\n        }\n    } else {\n        // Default to random if type is not recognized\n        // Random probabilities satisfying the constraints\n        for (int i = 0; i < num_teams; ++i) {\n            P[i][i] = 0;\n            for (int j = i + 1; j < num_teams; ++j) {\n                P[i][j] = rnd.next(0, 100);\n                P[j][i] = 100 - P[i][j];\n            }\n        }\n    }\n\n    // Output N\n    printf(\"%d\\n\", N);\n    // Output probabilities\n    for (int i = 0; i < num_teams; ++i) {\n        for (int j = 0; j < num_teams; ++j) {\n            printf(\"%d\", P[i][j]);\n            if (j + 1 < num_teams)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# N = 2\n./gen -N 2 -type equal\n./gen -N 2 -type dominant\n./gen -N 2 -type reverse_dominant\n./gen -N 2 -type cycle\n./gen -N 2 -type random\n./gen -N 2 -type superstar\n./gen -N 2 -type weakling\n./gen -N 2 -type mostly100\n./gen -N 2 -type single50\n\n# N = 3\n./gen -N 3 -type equal\n./gen -N 3 -type dominant\n./gen -N 3 -type random\n./gen -N 3 -type cycle\n./gen -N 3 -type superstar\n\n# N = 4\n./gen -N 4 -type cycle\n./gen -N 4 -type superstar\n./gen -N 4 -type random\n\n# N = 5\n./gen -N 5 -type weakling\n./gen -N 5 -type mostly100\n./gen -N 5 -type random\n\n# N = 6\n./gen -N 6 -type equal\n./gen -N 6 -type cycle\n./gen -N 6 -type random\n./gen -N 6 -type single50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:04.399387",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/E",
      "title": "E. Desk Disorder",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will begin with a line containing N (1 ≤ N ≤ 100000), the number of engineers. N lines follow, each containing exactly two integers. The i-th line contains the number of the current desk of the i-th engineer and the number of the desk the i-th engineer wants to move to. Desks are numbered from 1 to 2·N. It is guaranteed that no two engineers sit at the same desk.",
      "output_spec": "OutputPrint the number of possible assignments, modulo 1000000007 = 109 + 7.",
      "sample_tests": "ExamplesInputCopy41 55 23 77 3OutputCopy6InputCopy51 102 103 104 105 5OutputCopy5",
      "description": "E. Desk Disorder\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will begin with a line containing N (1 ≤ N ≤ 100000), the number of engineers. N lines follow, each containing exactly two integers. The i-th line contains the number of the current desk of the i-th engineer and the number of the desk the i-th engineer wants to move to. Desks are numbered from 1 to 2·N. It is guaranteed that no two engineers sit at the same desk.\n\nOutputPrint the number of possible assignments, modulo 1000000007 = 109 + 7.\n\nInputCopy41 55 23 77 3OutputCopy6InputCopy51 102 103 104 105 5OutputCopy5\n\nInputCopy41 55 23 77 3\n\nOutputCopy6\n\nInputCopy51 102 103 104 105 5\n\nOutputCopy5\n\nNoteThese are the possible assignments for the first example:   1 5 3 7  1 2 3 7  5 2 3 7  1 5 7 3  1 2 7 3  5 2 7 3",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Lazy Security GuardLet's ask the problem a different way. For a fixed perimeter, what's the maximum number of city blocks we can fit in it? The maximum will always be achieved by a rectangle, because that's the only shape that doesn't contain any angles. A angle is not allowed because there would be a way to add another city block without affecting the perimeter. The problem is therefore equivalent to finding the minimum-perimeter rectangle with area at least N.A H × W rectangle has a perimeter of 2·(H + W). The constraints of the problem were low enough that one could loop through every possible value of H and find the smallest corresponding W such that H·W ≥ N. We can show that the best rectangle will always have . Consider what happens if W ≥ H + 2. Then (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1. In other words, the (W - 1) × (H + 1) rectangle has greater area than the W × H rectangle, but the same perimeter.A direct solution therefore sets and H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*E"
          },
          "content_length": 10958
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    set<int> currentDesks;\n    for (int i = 0; i < N; ++i) {\n        int a = inf.readInt(1, 2*N, \"currentDesk_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, 2*N, \"desiredDesk_i\");\n        inf.readEoln();\n        \n        ensuref(currentDesks.insert(a).second, \"Duplicate current desk %d\", a);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    set<int> currentDesks;\n    for (int i = 0; i < N; ++i) {\n        int a = inf.readInt(1, 2*N, \"currentDesk_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, 2*N, \"desiredDesk_i\");\n        inf.readEoln();\n        \n        ensuref(currentDesks.insert(a).second, \"Duplicate current desk %d\", a);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    set<int> currentDesks;\n    for (int i = 0; i < N; ++i) {\n        int a = inf.readInt(1, 2*N, \"currentDesk_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, 2*N, \"desiredDesk_i\");\n        inf.readEoln();\n        \n        ensuref(currentDesks.insert(a).second, \"Duplicate current desk %d\", a);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Prepare current desks\n    vector<int> all_desks(2 * n);\n    iota(all_desks.begin(), all_desks.end(), 1);\n\n    shuffle(all_desks.begin(), all_desks.end());\n\n    vector<int> current(n);\n    for (int i = 0; i < n; ++i) {\n        current[i] = all_desks[i];\n    }\n\n    vector<int> desired(n);\n\n    if (type == \"desired_equals_current\") {\n        desired = current; // Desired desks equal current desks\n    } else if (type == \"all_same_desired\") {\n        // All engineers desire the same desk\n        int d = 1 + rnd.next(2 * n - 1); // Desired desk between 1 and 2n\n        for (int i = 0; i < n; ++i) {\n            desired[i] = d;\n        }\n    } else if (type == \"cyclic_desireds\") {\n        // Desired desk of engineer i is current desk of engineer (i+1)%n\n        for (int i = 0; i < n; ++i) {\n            desired[i] = current[(i + 1) % n];\n        }\n    } else if (type == \"chain_desireds\") {\n        // Desired desk of engineer i is current desk of engineer i+1 (i < n-1)\n        // Last engineer's desired desk is arbitrary\n        for (int i = 0; i < n - 1; ++i) {\n            desired[i] = current[i + 1];\n        }\n        desired[n - 1] = 1 + rnd.next(2 * n - 1);\n    } else if (type == \"multiple_cycles\") {\n        // Break into multiple cycles\n        int num_cycles = rnd.next(1, n / 2);\n        vector<int> cycle_sizes;\n        int remaining = n;\n        for (int i = 0; i < num_cycles; ++i) {\n            int sz = remaining / (num_cycles - i);\n            if (sz == 0) sz = 1;\n            cycle_sizes.push_back(sz);\n            remaining -= sz;\n        }\n        int idx = 0;\n        for (int sz : cycle_sizes) {\n            for (int i = idx; i < idx + sz; ++i) {\n                desired[i] = current[i + 1 < idx + sz ? i + 1 : idx];\n            }\n            idx += sz;\n        }\n    } else if (type == \"random\") {\n        // Random desired desks between 1 and 2n\n        for (int i = 0; i < n; ++i) {\n            desired[i] = 1 + rnd.next(2 * n - 1);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", current[i], desired[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Prepare current desks\n    vector<int> all_desks(2 * n);\n    iota(all_desks.begin(), all_desks.end(), 1);\n\n    shuffle(all_desks.begin(), all_desks.end());\n\n    vector<int> current(n);\n    for (int i = 0; i < n; ++i) {\n        current[i] = all_desks[i];\n    }\n\n    vector<int> desired(n);\n\n    if (type == \"desired_equals_current\") {\n        desired = current; // Desired desks equal current desks\n    } else if (type == \"all_same_desired\") {\n        // All engineers desire the same desk\n        int d = 1 + rnd.next(2 * n - 1); // Desired desk between 1 and 2n\n        for (int i = 0; i < n; ++i) {\n            desired[i] = d;\n        }\n    } else if (type == \"cyclic_desireds\") {\n        // Desired desk of engineer i is current desk of engineer (i+1)%n\n        for (int i = 0; i < n; ++i) {\n            desired[i] = current[(i + 1) % n];\n        }\n    } else if (type == \"chain_desireds\") {\n        // Desired desk of engineer i is current desk of engineer i+1 (i < n-1)\n        // Last engineer's desired desk is arbitrary\n        for (int i = 0; i < n - 1; ++i) {\n            desired[i] = current[i + 1];\n        }\n        desired[n - 1] = 1 + rnd.next(2 * n - 1);\n    } else if (type == \"multiple_cycles\") {\n        // Break into multiple cycles\n        int num_cycles = rnd.next(1, n / 2);\n        vector<int> cycle_sizes;\n        int remaining = n;\n        for (int i = 0; i < num_cycles; ++i) {\n            int sz = remaining / (num_cycles - i);\n            if (sz == 0) sz = 1;\n            cycle_sizes.push_back(sz);\n            remaining -= sz;\n        }\n        int idx = 0;\n        for (int sz : cycle_sizes) {\n            for (int i = idx; i < idx + sz; ++i) {\n                desired[i] = current[i + 1 < idx + sz ? i + 1 : idx];\n            }\n            idx += sz;\n        }\n    } else if (type == \"random\") {\n        // Random desired desks between 1 and 2n\n        for (int i = 0; i < n; ++i) {\n            desired[i] = 1 + rnd.next(2 * n - 1);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", current[i], desired[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type desired_equals_current\n./gen -n 4 -type all_same_desired\n./gen -n 4 -type cyclic_desireds\n./gen -n 4 -type chain_desireds\n./gen -n 4 -type multiple_cycles\n./gen -n 4 -type random\n./gen -n 10 -type desired_equals_current\n./gen -n 10 -type all_same_desired\n./gen -n 10 -type cyclic_desireds\n./gen -n 10 -type chain_desireds\n./gen -n 10 -type multiple_cycles\n./gen -n 10 -type random\n./gen -n 100 -type desired_equals_current\n./gen -n 100 -type all_same_desired\n./gen -n 100 -type cyclic_desireds\n./gen -n 100 -type chain_desireds\n./gen -n 100 -type multiple_cycles\n./gen -n 100 -type random\n./gen -n 1000 -type desired_equals_current\n./gen -n 1000 -type all_same_desired\n./gen -n 1000 -type cyclic_desireds\n./gen -n 1000 -type chain_desireds\n./gen -n 1000 -type multiple_cycles\n./gen -n 1000 -type random\n./gen -n 10000 -type desired_equals_current\n./gen -n 10000 -type all_same_desired\n./gen -n 10000 -type cyclic_desireds\n./gen -n 10000 -type chain_desireds\n./gen -n 10000 -type multiple_cycles\n./gen -n 10000 -type random\n./gen -n 100000 -type desired_equals_current\n./gen -n 100000 -type all_same_desired\n./gen -n 100000 -type cyclic_desireds\n./gen -n 100000 -type chain_desireds\n./gen -n 100000 -type multiple_cycles\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:06.330448",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/F",
      "title": "F. Заказ футболок",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа N и C (1 ≤ N ≤ 2·105, 1 ≤ C) — количество размеров футболок и количество участников, которые будут награждены.Вторая строка содержит 2·N - 1 целых чисел с s1 по s2·N - 1 (0 ≤ si ≤ 108). Для нечетных i, si равно количеству участников, которые выбрали размер футболки ((i + 1) / 2). Для четных i, si равно количеству участников, которые согласны получить размер (i / 2) или размер (i / 2 + 1). Гарантируется, что C не превосходит полного числа участников.",
      "output_spec": "Выходные данныеВыведите, какое минимальное число футболок мы должны купить.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 200100 250 100Выходные данныеСкопировать200Входные данныеСкопировать4 16088 69 62 29 58 52 44Выходные данныеСкопировать314",
      "description": "F. Заказ футболок\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся два целых числа N и C (1 ≤ N ≤ 2·105, 1 ≤ C) — количество размеров футболок и количество участников, которые будут награждены.Вторая строка содержит 2·N - 1 целых чисел с s1 по s2·N - 1 (0 ≤ si ≤ 108). Для нечетных i, si равно количеству участников, которые выбрали размер футболки ((i + 1) / 2). Для четных i, si равно количеству участников, которые согласны получить размер (i / 2) или размер (i / 2 + 1). Гарантируется, что C не превосходит полного числа участников.\n\nВходные данные\n\nВыходные данныеВыведите, какое минимальное число футболок мы должны купить.\n\nВыходные данные\n\nВходные данныеСкопировать2 200100 250 100Выходные данныеСкопировать200Входные данныеСкопировать4 16088 69 62 29 58 52 44Выходные данныеСкопировать314\n\nВходные данныеСкопировать2 200100 250 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать200\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 16088 69 62 29 58 52 44\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать314\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере мы можем купить 100 футболок каждого размера.",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Ленивый охранникРассмотрим эквивалентную задачу - какое наибольшее число кварталов можно окружить, если периметр фиксирован? Заметим, что если область имеет угол в , то можно добавить еще один квартал, не увеличив периметр. Это значит, что максимум всегда будет достигаться для прямоугольника, поскольку только его граница не имеет углов в . Таким образом, наша задача сводится к поиску прямоугольника минимального периметра с площадью не меньше N.Периметр прямоугольника H × W равен 2·(H + W). Ограничения задачи позволяют перебирать все возможные значения H и искать минимальное W такое, что H·W ≥ N. Можно доказать, что для наилучшего прямоугольника выполняется : если допустить, что W ≥ H + 2, то (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1, то есть (W - 1) × (H + 1) имеет большую площадь при таком же периметре.Таким образом, прямой ответ на задачу - и H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*F"
          },
          "content_length": 10853
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 200000, \"N\");\n    inf.readSpace();\n    long long C = inf.readLong(1LL, 40000000000000LL, \"C\");\n    inf.readEoln();\n\n    int s_len = 2 * N - 1;\n    vector<long long> s = inf.readLongs(s_len, 0LL, 100000000LL, \"s_i\");\n    inf.readEoln();\n\n    long long total_contestants = accumulate(s.begin(), s.end(), 0LL);\n\n    ensuref(C <= total_contestants, \"C (%lld) cannot exceed total number of contestants (%lld)\", C, total_contestants);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 200000, \"N\");\n    inf.readSpace();\n    long long C = inf.readLong(1LL, 40000000000000LL, \"C\");\n    inf.readEoln();\n\n    int s_len = 2 * N - 1;\n    vector<long long> s = inf.readLongs(s_len, 0LL, 100000000LL, \"s_i\");\n    inf.readEoln();\n\n    long long total_contestants = accumulate(s.begin(), s.end(), 0LL);\n\n    ensuref(C <= total_contestants, \"C (%lld) cannot exceed total number of contestants (%lld)\", C, total_contestants);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 200000, \"N\");\n    inf.readSpace();\n    long long C = inf.readLong(1LL, 40000000000000LL, \"C\");\n    inf.readEoln();\n\n    int s_len = 2 * N - 1;\n    vector<long long> s = inf.readLongs(s_len, 0LL, 100000000LL, \"s_i\");\n    inf.readEoln();\n\n    long long total_contestants = accumulate(s.begin(), s.end(), 0LL);\n\n    ensuref(C <= total_contestants, \"C (%lld) cannot exceed total number of contestants (%lld)\", C, total_contestants);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register generator\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    int n = opt<int>(\"n\");\n    long long c = opt<long long>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // vectors to hold s_i's\n    vector<int> s;\n\n    // total number of s_i's is 2n - 1\n    int total_s = 2 * n - 1;\n\n    // Generate s_i's based on type\n    long long total_contestants = 0;\n\n    if (type == \"random\") {\n        // Generate random s_i's in range [0, 1e5]\n        s.resize(total_s);\n        for(int i=0; i < total_s; ++i) {\n            s[i] = rnd.next(0, 100000);\n            total_contestants += s[i];\n        }\n        // Ensure total_contestants ≥ c ≥ 1\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    } else if (type == \"max_sizes\") {\n        // Set s_i's to maximum value 1e8\n        s.resize(total_s, 100000000);\n        total_contestants = 1LL * s.size() * 100000000;\n        if (c < 1) c = 1;\n        if (c > total_contestants) c = total_contestants;\n    } else if (type == \"min_sizes\") {\n        // Set s_i's to zeros except for one s_i\n        s.resize(total_s, 0);\n        s[rnd.next(0, total_s - 1)] = c;\n        total_contestants = c;\n    } else if (type == \"single_size\") {\n        // All contestants prefer one size\n        s.resize(total_s, 0);\n        s[0] = c;\n        total_contestants = c;\n    } else if (type == \"double_sizes\") {\n        // All contestants are okay with two sizes\n        s.resize(total_s, 0);\n        int idx;\n        if (n >= 2) {\n            idx = 1; // s_2 is even, so contestants okay with sizes 1 and 2\n        } else {\n            idx = 0; // n == 1, only size 1 exists\n        }\n        s[idx] = c;\n        total_contestants = c;\n    } else if (type == \"skewed\") {\n        // Preferences are skewed towards certain sizes\n        s.resize(total_s, 0);\n        for(int i = 0; i < total_s; ++i) {\n            int weight = n - (i / 2);\n            s[i] = rnd.next(0, weight * 1000);\n            total_contestants += s[i];\n        }\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    } else if (type == \"max_c\") {\n        // C is as large as possible (C == total contestants)\n        s.resize(total_s);\n        total_contestants = 0;\n        for(int i=0; i < total_s; ++i) {\n            s[i] = rnd.next(0, 100000);\n            total_contestants += s[i];\n        }\n        if (total_contestants < 1) { s[0] += 1; total_contestants +=1; }\n        c = total_contestants; // Set c to total number of contestants\n    } else if (type == \"large_s_i\") {\n        // Some s_i's are at max\n        s.resize(total_s, 0);\n        int num_large = rnd.next(1, total_s);\n        total_contestants = 0;\n        for(int i = 0; i < num_large; ++i) {\n            int idx = rnd.next(0, total_s - 1);\n            if (s[idx] == 0) {\n                s[idx] = 100000000;\n                total_contestants += 100000000;\n            }\n        }\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    } else {\n        // default to random\n        s.resize(total_s);\n        for(int i=0; i < total_s; ++i) {\n            s[i] = rnd.next(0, 100000);\n            total_contestants += s[i];\n        }\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    }\n\n    // Ensure that C ≤ total_contestants\n    if (c > total_contestants) {\n        c = total_contestants;\n    }\n\n    // Ensure that total_contestants ≥ 1\n    if (total_contestants < 1) {\n        s[0] += 1;\n        total_contestants += 1;\n        if (c < 1) c = 1;\n    }\n\n    // Output N and C\n    printf(\"%d %lld\\n\", n, c);\n\n    // Output s_i's\n    for(int i=0; i < total_s; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", s[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register generator\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    int n = opt<int>(\"n\");\n    long long c = opt<long long>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // vectors to hold s_i's\n    vector<int> s;\n\n    // total number of s_i's is 2n - 1\n    int total_s = 2 * n - 1;\n\n    // Generate s_i's based on type\n    long long total_contestants = 0;\n\n    if (type == \"random\") {\n        // Generate random s_i's in range [0, 1e5]\n        s.resize(total_s);\n        for(int i=0; i < total_s; ++i) {\n            s[i] = rnd.next(0, 100000);\n            total_contestants += s[i];\n        }\n        // Ensure total_contestants ≥ c ≥ 1\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    } else if (type == \"max_sizes\") {\n        // Set s_i's to maximum value 1e8\n        s.resize(total_s, 100000000);\n        total_contestants = 1LL * s.size() * 100000000;\n        if (c < 1) c = 1;\n        if (c > total_contestants) c = total_contestants;\n    } else if (type == \"min_sizes\") {\n        // Set s_i's to zeros except for one s_i\n        s.resize(total_s, 0);\n        s[rnd.next(0, total_s - 1)] = c;\n        total_contestants = c;\n    } else if (type == \"single_size\") {\n        // All contestants prefer one size\n        s.resize(total_s, 0);\n        s[0] = c;\n        total_contestants = c;\n    } else if (type == \"double_sizes\") {\n        // All contestants are okay with two sizes\n        s.resize(total_s, 0);\n        int idx;\n        if (n >= 2) {\n            idx = 1; // s_2 is even, so contestants okay with sizes 1 and 2\n        } else {\n            idx = 0; // n == 1, only size 1 exists\n        }\n        s[idx] = c;\n        total_contestants = c;\n    } else if (type == \"skewed\") {\n        // Preferences are skewed towards certain sizes\n        s.resize(total_s, 0);\n        for(int i = 0; i < total_s; ++i) {\n            int weight = n - (i / 2);\n            s[i] = rnd.next(0, weight * 1000);\n            total_contestants += s[i];\n        }\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    } else if (type == \"max_c\") {\n        // C is as large as possible (C == total contestants)\n        s.resize(total_s);\n        total_contestants = 0;\n        for(int i=0; i < total_s; ++i) {\n            s[i] = rnd.next(0, 100000);\n            total_contestants += s[i];\n        }\n        if (total_contestants < 1) { s[0] += 1; total_contestants +=1; }\n        c = total_contestants; // Set c to total number of contestants\n    } else if (type == \"large_s_i\") {\n        // Some s_i's are at max\n        s.resize(total_s, 0);\n        int num_large = rnd.next(1, total_s);\n        total_contestants = 0;\n        for(int i = 0; i < num_large; ++i) {\n            int idx = rnd.next(0, total_s - 1);\n            if (s[idx] == 0) {\n                s[idx] = 100000000;\n                total_contestants += 100000000;\n            }\n        }\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    } else {\n        // default to random\n        s.resize(total_s);\n        for(int i=0; i < total_s; ++i) {\n            s[i] = rnd.next(0, 100000);\n            total_contestants += s[i];\n        }\n        if (total_contestants < c) {\n            long long diff = c - total_contestants;\n            s[0] += diff;\n            total_contestants += diff;\n        }\n        if (c < 1) c = 1;\n    }\n\n    // Ensure that C ≤ total_contestants\n    if (c > total_contestants) {\n        c = total_contestants;\n    }\n\n    // Ensure that total_contestants ≥ 1\n    if (total_contestants < 1) {\n        s[0] += 1;\n        total_contestants += 1;\n        if (c < 1) c = 1;\n    }\n\n    // Output N and C\n    printf(\"%d %lld\\n\", n, c);\n\n    // Output s_i's\n    for(int i=0; i < total_s; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", s[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small N, random s_i's\n./gen -n 1 -c 1 -type random\n./gen -n 2 -c 1 -type random\n./gen -n 5 -c 3 -type random\n\n# Medium N, random s_i's\n./gen -n 1000 -c 500 -type random\n./gen -n 10000 -c 7000 -type random\n\n# Large N, random s_i's\n./gen -n 100000 -c 50000 -type random\n./gen -n 200000 -c 100000 -type random\n\n# Max N, Max C\n./gen -n 200000 -c 4000000000000 -type max_sizes\n\n# Min N, Min C\n./gen -n 1 -c 1 -type min_sizes\n\n# Single size preference\n./gen -n 10 -c 100 -type single_size\n./gen -n 10000 -c 20000 -type single_size\n\n# Double size preference\n./gen -n 2 -c 1000 -type double_sizes\n./gen -n 50000 -c 100000 -type double_sizes\n\n# Skewed size preferences\n./gen -n 100 -c 5000 -type skewed\n./gen -n 200000 -c 1000000 -type skewed\n\n# C equals total contestants\n./gen -n 1000 -c 0 -type max_c\n./gen -n 200000 -c 0 -type max_c\n\n# Large s_i values\n./gen -n 100 -c 1000000 -type large_s_i\n./gen -n 200000 -c 100000000 -type large_s_i\n\n# Edge cases\n./gen -n 1 -c 1 -type single_size\n./gen -n 2 -c 1 -type double_sizes\n./gen -n 1 -c 1 -type skewed\n\n# Default type parameter\n./gen -n 100 -c 50\n./gen -n 10000 -c 5000\n./gen -n 200000 -c 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:08.111277",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "859/G",
      "title": "G. Circle of Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (3 ≤ n ≤ 100000), the number of points along the circle.The following line contains a string s with exactly n digits, indicating the numbers initially present at each of the points, in clockwise order.",
      "output_spec": "OutputPrint \"YES\" (without quotes) if there is some sequence of operations that results in all numbers being 0, otherwise \"NO\" (without quotes).You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy30000100000100000110000000001100OutputCopyYESInputCopy6314159OutputCopyNO",
      "description": "G. Circle of Numbers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains an integer n (3 ≤ n ≤ 100000), the number of points along the circle.The following line contains a string s with exactly n digits, indicating the numbers initially present at each of the points, in clockwise order.\n\nOutputPrint \"YES\" (without quotes) if there is some sequence of operations that results in all numbers being 0, otherwise \"NO\" (without quotes).You can print each letter in any case (upper or lower).\n\nInputCopy30000100000100000110000000001100OutputCopyYESInputCopy6314159OutputCopyNO\n\nInputCopy30000100000100000110000000001100\n\nOutputCopyYES\n\nInputCopy6314159\n\nOutputCopyNO\n\nNoteIf we label the points from 1 to n, then for the first test case we can set k = 1. Then we increase the numbers at points 7 and 22 by 1, then decrease the numbers at points 7, 17, and 27 by 1, then decrease the numbers at points 4, 10, 16, 22, and 28 by 1.",
      "solutions": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces",
          "content": "MemSQL is excited to announce Start[c]UP 3.0 – the third iteration of the programming competition hosted by Codeforces with an onsite at MemSQL HQ in San Francisco, California.Start[c]UP 3.0 consists of two rounds. Round 1 is online and takes place on September 16th at 10:35 AM PST. Round 1 follows regular Codeforces rules and consists of at least 5 problems. For this round, the complexity of the problems will be comparable to a regular Codeforces round. There are no eligibility restrictions to participate in the round. The round will be 2.5 hours long, and will be rated.Round 2 takes place on September 30th at 10:30 AM PST and uses regular Codeforces rules. The complexity of the problems is higher than a regular Codeforces round, the round will be 3 hours long, and will be rated. Only people who finished in the top 500 in Round 1 can participate. The top 100 in round 2 will receive a Start[c]UP 3.0 T-shirt.For Silicon Valley residents, MemSQL will be hosting up to 25 people on-site during the second round. The winner of the on-site round will be awarded a special prize.If you are interested in job opportunities/intern positions in MemSQL (San Francisco and Seattle) please fill in the form http://codeforces.com/memsql2017/apply or you can do it during the registration on the round.Round 1 has started!There are 7 problems scored as 500-750-1000-1500-2000-2750-3000. The problems were prepared by pieguy with help from cerealguy and nika. Big thanks to KAN for helping with the contest and cyand1317, vintage_Vlad_Makeev, Arpa for testing.",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1559
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces",
          "content": "MemSQL Start[c]UP 3.0 Round 1 is over!Congratulations to jqdai0815, Petr, eatmore and tourist on solving all the problems!Here are our solutions: 859A - Отказавшиеся финалистыIf all ranks are 25 or less, then the answer is 0, since it's possible that all of the top 25 accepted the invitation. Otherwise, notice that the highest invited rank is initially 25, and increases by 1 every time a contestant declines. Therefore the answer is simply the highest rank minus 25. 859B - Lazy Security GuardLet's ask the problem a different way. For a fixed perimeter, what's the maximum number of city blocks we can fit in it? The maximum will always be achieved by a rectangle, because that's the only shape that doesn't contain any angles. A angle is not allowed because there would be a way to add another city block without affecting the perimeter. The problem is therefore equivalent to finding the minimum-perimeter rectangle with area at least N.A H × W rectangle has a perimeter of 2·(H + W). The constraints of the problem were low enough that one could loop through every possible value of H and find the smallest corresponding W such that H·W ≥ N. We can show that the best rectangle will always have . Consider what happens if W ≥ H + 2. Then (W - 1)·(H + 1) = W·H + (W - H) - 1 ≥ W·H + (2) - 1 = W·H + 1. In other words, the (W - 1) × (H + 1) rectangle has greater area than the W × H rectangle, but the same perimeter.A direct solution therefore sets and H = ⌈ N / W⌉. 859C - Правило тортаDenote Score(L) as the total sizes of slices that will be eaten by whoever holds the decider token, for a list of pies L, and denote Total(L) as the total size of all slices, and Rest(L) as the list of pies formed by removing the first pie. Note that the total sizes of slices eaten by whoever doesn't hold the decider token is given by Total(L) - Score(L).Let's consider the options available to the participant with the decider token. If they choose to take the pie for themselves, they end up with L[0] + Total(Rest(L)) - Score(Rest(L)) total pie. If they let the other participant have the slice, they end up with Score(Rest(L)) total pie. They will choose whichever option is larger. To compute the answer, we simply start from the end of the game and work backwards to the beginning.Challenge: Try to solve the variant of this game where instead of handing out slices in a fixed order, the participant who doesn't currently hold the decider token gets to select which slice is handed out next. The optimal strategy is not difficult to discover, but proving it is very difficult. 859D - Сумасшествие третьего месяцаDenote opp(r, t) as the set of teams that could play against team t in round r, and w[t][u] is the probability that team t defeats team u. We would first like to compute the probability that team t wins a game in round r, and call this p[r][t]. Set p[0][t] = 1 for all teams for convenience. Then for r ≥ 1 we have that the probability t wins a game in round r is equal to the probability that they won a game in round r - 1, times the sum, over all opponents, of the probability of facing that opponent times the probability of defeating that opponent. In mathematical terms, .Now let us denote S[r][t] as the maximum expected score that can be achieved after r rounds, choosing team t as a winner in round r, and only counting points scored in games played between teams that could play in the game that t would play in in round r. In other words, consider the sub-bracket which contains t but only goes for r rounds. Our desired result is .Begin by setting S[0][t] = 0 for all t. Then for each round and team compute . 859E - Беспорядок на рабочих местахConsider an undirected graph where the desks are vertices and the engineers are edges. For each engineer an edge connects their current desk to their desired desk. Each connected component of this graph can be assigned independently, with the final result being the product of the number of assignments over the individual components.What type of graphs are the connected components? We know because it's connected that E ≥ V - 1, where E and V are number of edges and vertices, respectively. Also note that E ≤ V due to the condition that no two engineers currently sit at the same desk. It follows that there are only 2 cases to consider.Case 1: E = V - 1. In this case the component is a tree. We claim that the number of assignments is equal to V in this case. To see why this is true, consider that after we choose which of the V desks to leave empty, there's always exactly 1 way to assign engineers to the remaining desks.Case 2: E = V. In this case the component has exactly one cycle. Engineers currently sitting at a desk on the cycle can either all stay at their current desk, or all move to their desired desk. Engineers currently sitting at a desk not on the cycle must remain at their current desks. Therefore there will be exactly 2 assignments, unless the cycle was a self-loop (an engineer whose desired desk is equal to their current desk), in which case there is only 1 assignment.To compute the result, we can use a Disjoint-set data structure. For each connected component, we keep track of its size and what type of cycle (if any) is present. Initially each desk is in a component by itself. For each engineer, we merge the components containing their current and desired desks, or mark the component as containing a cycle if the current and desired desks were already in the same component. Finally we multiply together the numbers of assignments of the components. 859F - Заказ футболокLet us first describe how to tell if a given set of T-shirts is sufficient to award the competitors. For any set of T-shirt sizes, it clearly must be the case that the total number of T-shirts ordered of sizes in the set must be at least as large as the maximum number of competitors that could require a T-shirt size from the set. We claim that this is sufficient as well, and will prove it using the max-flow min-cut theorem.Construct a flow graph with a source, one node for each type of survey response, one node for each T-shirt size, and a sink. Add an edge from the source to each survey response node with capacity equal to the number of winners with that response. Add an edge from each survey response to the corresponding T-shirt size(s) with unlimited capacity. Add an edge from each T-shirt size to the sink with capacity equal to the number of T-shirts ordered. Find a minimum cut in this graph. Then for any maximal contiguous range of T-shirt sizes in the cut, we can remove those T-shirt sizes from the cut and instead cut the corresponding survey responses. It follows that the cut consisting only of survey responses is minimal, and by the max-flow min-cut theorem, an assignment exists that awards all winners T-shirts.Note that we don't need to consider all sets of T-shirt sizes - only contiguous sets of T-shirts sizes are relevant. If a non-contiguous set of T-shirt sizes violates the constraint, then one of its contiguous subsections must also violate the constraint.In other words, if we order ti shirts of size i, we only need to satisfy .We now will show that the algorithm that greedily orders as few of each T-shirt as possible, starting from the smallest size, produces an optimal result. Suppose, to the contrary, that a better solution exists, and consider the lexicographically smallest such solution. At the first point where the solutions differ, the optimal solution must order more T-shirts (due to the greedy nature of the algorithm). If we change the optimal solution by ordering one fewer of that size and one more of the next size up, the solution will remain valid. However this violates the lexicographical minimality of the solution, a contradiction.Our solution is for each index j from 1 to n, to set . This can easily be done in O(n2) time if we compute cumulative sums of t and s.In order to solve it faster, we need to be able to quickly find the index i that maximizes the above expression. First lets consider the indexes where c < s2i - 1 + ... + s2j - 1. Because all t terms are non-negative, we only need to consider the largest such i for which this is true, which can be found in amortized constant time.Now consider indexes where c ≥ s2i - 1 + ... + s2j - 1. Denote r[i][j] = (s2i - 1 + ... + s2j - 1) - (ti + ... + tj - 1). Notice that for indexes i1, i2 < j, we have r[i1][j] - r[i2][j] = r[i1][j - 1] - r[i2][j - 1]. This implies that if r[i1][j] > r[i2][j] for some index j, it is true for all valid indexes j. Create a list of indexes l maintaining invariants . Delete entries from the front of l whenever they no longer satisfy c ≥ s2i - 1 + ... + s2j - 1. Insert j at the end of the list on every iteration, deleting other indexes from the back of the list as necessary in order to maintain the invariants. At each step, the index that maximizes r[i][j] can be found at the front of the list. Using a doubly-ended queue for l makes all of these operations amortized constant time, for a total runtime of O(n). 859G - Круг чиселConstruct polynomial P(x) = si·xi. For p|n denote Qp(x) = 1 + xn / p + x2n / p + ... + x(p - 1)n / p = (xn - 1) / (xn / p - 1). Our task is to determine if P(x) can be written as a linear combination of Qi(x) polynomials. Bézout's Identity tells us that a solution exists if the greatest common divisor of the Qi(x) polynomials also divides P(x), and the familiar Extended Euclidean Algorithm could be used to construct a solution if needed.Let's compute the GCD of the Qi(x) polynomials, and call it G(x). Let ω = e2π i / n. Then . Therefore . This is equal to the Cyclotomic Polynomial Φn(x).Directly testing P(x) for divisibility by G(x) is quite expensive. Instead, denote F as the set of prime factors of n and let . Note that for each i, . It follows that . The latter can be easily computed.Alternate solution: Note that a necessary condition is that if we place weights on each point equal in magnitude to the number, then the center of gravity must be at exactly the center of the circle. Attempting to compute the center of gravity numerically isn't guaranteed to work because it could be extremely close to the center (we were able to construct test cases where it was within 10 - 500 of the center). However, if we choose some integer m relatively prime to n, and for each point i move its number to point m·i, then the answer does not change, but the center of gravity might. We can check the center of gravity numerically for several random m, and if it's ever not within the margin of numerical error then the answer must be no. In theory this could still fail but in practice it was always easy to find a value of m where the center of gravity is quite far from the actual center. Another way to probabilistically test if the center of gravity is at the center is to choose a random prime p such that n|p - 1, and a random r such that . Then it must be the case that .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54572",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 859\\s*G"
          },
          "content_length": 10958
        }
      ],
      "code_examples": [
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 1",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 2",
          "code": "g++ -std=c++11 a.cpp",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 3",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "Announcing MemSQL Start[c]UP 3.0 - Codeforces - Code 4",
          "code": "g++ -std=c++11 a.cpp -D_GLIBCXX_DEBUG",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54496",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 1",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 2",
          "code": "5\n1 2\n2 3\n3 4\n4 5\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 3",
          "code": "[1, 3, 4, 5, 2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 4",
          "code": "s[r][t] = s[r-1][t] + p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 1 Editorial - Codeforces - Code 5",
          "code": "p[r][t] * 2^(r-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54572",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine(format(\"[0-9]{%d}\", n), \"s\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine(format(\"[0-9]{%d}\", n), \"s\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine(format(\"[0-9]{%d}\", n), \"s\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator produces a single test case of the following form:\n\n   1) First line: n (3 ≤ n ≤ 100000)\n   2) Second line: a string s of length n, each character between '0' and '9'.\n\n   The \"type\" argument controls the structure of the test case. We do not set\n   any random seed nor allow it as an input parameter. \"n\" is mandatory; \"type\"\n   is optional (defaults to \"random\").\n\n   Possible \"type\" values in this generator:\n   1) allzero         => All digits in s are '0'.\n   2) allnine         => All digits in s are '9'.\n   3) onedigit        => All digits in s are the same randomly chosen digit (0..9).\n   4) onepos          => Exactly one randomly chosen position is a non-zero digit, others are '0'.\n   5) palindrome      => s is a palindrome of random digits.\n   6) repeating       => s is formed by repeating a shorter random block.\n   7) random          => Random digits for all positions.\n   8) alternating01   => s is an alternating sequence of '0' and '1'.\n\n   You can extend or modify these types as needed for more corner and special cases.\n*/\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Mandatory parameter: n, with default to 10 if not provided (but usually you specify it).\n    int n = opt<int>(\"n\", 10);\n    // Optional parameter: \"type\", with default \"random\".\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll generate the string s according to the selected type.\n    // s must have exactly n characters, each in [0..9].\n    string s(n, '0');\n\n    if (type == \"allzero\") {\n        // Everything is '0'.\n        // s is already filled with '0'.\n    }\n    else if (type == \"allnine\") {\n        // Everything is '9'.\n        for (int i = 0; i < n; i++) {\n            s[i] = '9';\n        }\n    }\n    else if (type == \"onedigit\") {\n        // Pick a random digit from 0..9, fill s with that.\n        int d = rnd.next(10);\n        for (int i = 0; i < n; i++) {\n            s[i] = char('0' + d);\n        }\n    }\n    else if (type == \"onepos\") {\n        // Exactly one position is non-zero digit, others are zero.\n        int pos = rnd.next(n);\n        int d = rnd.next(1, 9); // non-zero\n        s[pos] = char('0' + d);\n    }\n    else if (type == \"palindrome\") {\n        // Generate half of the string randomly, then mirror it.\n        // If n is odd, the middle character can be anything.\n        for (int i = 0; i < (n+1)/2; i++) {\n            s[i] = char('0' + rnd.next(10));\n        }\n        // Mirror\n        for (int i = 0; i < n/2; i++) {\n            s[n - 1 - i] = s[i];\n        }\n    }\n    else if (type == \"repeating\") {\n        // Repeat a shorter random block to fill length n.\n        // Let block size be in [1..min(n, 10)] to keep it interesting, but small.\n        int blockSize = rnd.next(1, min(n, 10));\n        // generate the block\n        string block(blockSize, '0');\n        for (int i = 0; i < blockSize; i++) {\n            block[i] = char('0' + rnd.next(10));\n        }\n        // fill s by repeating block\n        for (int i = 0; i < n; i++) {\n            s[i] = block[i % blockSize];\n        }\n    }\n    else if (type == \"alternating01\") {\n        // Fill s with \"010101...\"\n        for (int i = 0; i < n; i++) {\n            s[i] = char('0' + (i % 2));\n        }\n    }\n    else {\n        // Default or unrecognized \"type\" => random digits from 0..9\n        for (int i = 0; i < n; i++) {\n            s[i] = char('0' + rnd.next(10));\n        }\n    }\n\n    // Output\n    // First line: n\n    // Second line: s (length n)\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator produces a single test case of the following form:\n\n   1) First line: n (3 ≤ n ≤ 100000)\n   2) Second line: a string s of length n, each character between '0' and '9'.\n\n   The \"type\" argument controls the structure of the test case. We do not set\n   any random seed nor allow it as an input parameter. \"n\" is mandatory; \"type\"\n   is optional (defaults to \"random\").\n\n   Possible \"type\" values in this generator:\n   1) allzero         => All digits in s are '0'.\n   2) allnine         => All digits in s are '9'.\n   3) onedigit        => All digits in s are the same randomly chosen digit (0..9).\n   4) onepos          => Exactly one randomly chosen position is a non-zero digit, others are '0'.\n   5) palindrome      => s is a palindrome of random digits.\n   6) repeating       => s is formed by repeating a shorter random block.\n   7) random          => Random digits for all positions.\n   8) alternating01   => s is an alternating sequence of '0' and '1'.\n\n   You can extend or modify these types as needed for more corner and special cases.\n*/\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Mandatory parameter: n, with default to 10 if not provided (but usually you specify it).\n    int n = opt<int>(\"n\", 10);\n    // Optional parameter: \"type\", with default \"random\".\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll generate the string s according to the selected type.\n    // s must have exactly n characters, each in [0..9].\n    string s(n, '0');\n\n    if (type == \"allzero\") {\n        // Everything is '0'.\n        // s is already filled with '0'.\n    }\n    else if (type == \"allnine\") {\n        // Everything is '9'.\n        for (int i = 0; i < n; i++) {\n            s[i] = '9';\n        }\n    }\n    else if (type == \"onedigit\") {\n        // Pick a random digit from 0..9, fill s with that.\n        int d = rnd.next(10);\n        for (int i = 0; i < n; i++) {\n            s[i] = char('0' + d);\n        }\n    }\n    else if (type == \"onepos\") {\n        // Exactly one position is non-zero digit, others are zero.\n        int pos = rnd.next(n);\n        int d = rnd.next(1, 9); // non-zero\n        s[pos] = char('0' + d);\n    }\n    else if (type == \"palindrome\") {\n        // Generate half of the string randomly, then mirror it.\n        // If n is odd, the middle character can be anything.\n        for (int i = 0; i < (n+1)/2; i++) {\n            s[i] = char('0' + rnd.next(10));\n        }\n        // Mirror\n        for (int i = 0; i < n/2; i++) {\n            s[n - 1 - i] = s[i];\n        }\n    }\n    else if (type == \"repeating\") {\n        // Repeat a shorter random block to fill length n.\n        // Let block size be in [1..min(n, 10)] to keep it interesting, but small.\n        int blockSize = rnd.next(1, min(n, 10));\n        // generate the block\n        string block(blockSize, '0');\n        for (int i = 0; i < blockSize; i++) {\n            block[i] = char('0' + rnd.next(10));\n        }\n        // fill s by repeating block\n        for (int i = 0; i < n; i++) {\n            s[i] = block[i % blockSize];\n        }\n    }\n    else if (type == \"alternating01\") {\n        // Fill s with \"010101...\"\n        for (int i = 0; i < n; i++) {\n            s[i] = char('0' + (i % 2));\n        }\n    }\n    else {\n        // Default or unrecognized \"type\" => random digits from 0..9\n        for (int i = 0; i < n; i++) {\n            s[i] = char('0' + rnd.next(10));\n        }\n    }\n\n    // Output\n    // First line: n\n    // Second line: s (length n)\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct examples of how to run this generator.\n# Each command prints one test case to standard output.\n\n# Smallest n and a few different types\n./gen -n 3 -type allzero\n./gen -n 3 -type onepos\n./gen -n 3 -type palindrome\n./gen -n 3 -type random\n\n# Small n with interesting patterns\n./gen -n 5 -type palindrome\n./gen -n 5 -type repeating\n./gen -n 5 -type onedigit\n./gen -n 5 -type alternating01\n\n# Medium n with various types\n./gen -n 12 -type allnine\n./gen -n 12 -type onedigit\n./gen -n 12 -type repeating\n./gen -n 12 -type random\n\n# Larger n with different patterns\n./gen -n 30 -type palindrome\n./gen -n 30 -type onepos\n./gen -n 30 -type random\n./gen -n 30 -type allzero\n\n# Even larger boundary-like n\n./gen -n 99 -type random\n./gen -n 100 -type alternating01\n./gen -n 101 -type palindrome\n\n# Very large n\n./gen -n 99999 -type allnine\n./gen -n 100000 -type repeating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:10.090381",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "86/A",
      "title": "A. Reflection",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput contains two space-separated integers l and r (1 ≤ l ≤ r ≤ 109) — bounds of the range.",
      "output_spec": "OutputOutput should contain single integer number: maximum value of the product n·ψ(n), where l ≤ n ≤ r.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy3 7OutputCopy20InputCopy1 1OutputCopy8InputCopy8 10OutputCopy890",
      "description": "A. Reflection\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput contains two space-separated integers l and r (1 ≤ l ≤ r ≤ 109) — bounds of the range.\n\nOutputOutput should contain single integer number: maximum value of the product n·ψ(n), where l ≤ n ≤ r.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).\n\nInputCopy3 7OutputCopy20InputCopy1 1OutputCopy8InputCopy8 10OutputCopy890\n\nInputCopy3 7\n\nOutputCopy20\n\nInputCopy1 1\n\nOutputCopy8\n\nInputCopy8 10\n\nOutputCopy890\n\nNoteIn the third sample weight of 8 equals 8·1 = 8, weight of 9 equals 9·0 = 0, weight of 10 equals 890.Thus, maximum value of the product is equal to 890.",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round 2 - Codeforces",
          "content": "Hello, dear participants and spectators!Let me remind you that the elimination phase of the open programming competition \"Yandex.Algorithm\" comes to an end. With it this means that the time for the most important event of the phase has come: the elimination round for the finals (finals will be held at the Yandex Summer School)! This means that today two hundred best participants of the tournament (based on the results of the previous qualification rounds) will compete to get into the top-15 of the world olympiad programming community.We hope that the round will be appreciated not only by the participants but also by the spectators, who will have the opportinity to watch the events developing for at least two hours.Please, pay attention to the problems' costs: 500, 1000, 2000, 2500, 2500. I also advise you to read all the statements, as the choice of the costs and the order is certainly subjective.Round will be rated for all the participants (including those competing hors concours).Good luck to the participants. The problems are going to be rather hard, so you'll have to do your best!I also wish a spectacular round to the rest!Round is over. According to the results, 20 participants solved at least three problems, and just one (the winner) was able to solve the fourth. The first three places were taken by Petr Mitrichev, Gennady Korotkevich and Sergey Kopeliovich. Congratulations!In addition to this, 15 leaders advanced to the finals: Petr, tourist, Burunduk1, ivan.metelsky, dzhulgakov, e-maxx, LayCurse, rng_58, pieguy, zeliboba, ktuan, levlam, wata, dolphinigle, Progger . Problems proved to be rather tough. Here's the full analysis.",
          "author": "yaro",
          "url": "https://codeforces.com/blog/entry/2026",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1661
        },
        {
          "title": "Problemset analysis (Yandex, Round 2) - Codeforces",
          "content": "A. Mirror-number. First note that if the interval contains a number with a digits and a number with b digits (where a > b) then there is no need to consider the number with b digits (as the weight of 10k is greater then the weights of the numbers less than 10k). If we consider only numbers with fixed number of digits (s + 1), then the sum of a and its reflection is constant. Thus, as product grows as multipliers with fixed sum get closer, the picture is the following: the weight grows from 10s to 5· 10s - 1, then it stays the same for 5· 10s and then it goes down, and reaches its minimum (zero) value at 10s + 1 - 1. This is the proof, and the solution is: the maximum weight is reached at either l, r or 5· 10s (we may check all the s such that 5· 10s belongs to the interval, for example). B. Tetris revisitedIt's easy to see that the field may be filled with such figures if and only if there is no isolated cell.There are many different ways to do that, we will show some of them.1. Domino filling.We construct greedy matching on the cells of our field combining them in domino-like figures (rectangles 1  ×  2).Passing through the array that represents our field (from left to right, from top to bottom) we combine the still free horizontal pairs of connected cells into the horizontal dominoes. Then we do the same thing with the still free vertical pairs. Naturally, some cells may be still free. But such cells should be adjoined with some of the dominoes (if they were not isolated). We may attach each of these cells to any of the adjoint dominoes. All resulting figures will contain no more than 5 cells, because the cells still empty after matching can not be neighbour cells and can not be adjacent to the left side of dominoes (by the virtue of the order of our matching).The last thing that has to be done is the coloring of the figures in accordance with the output format. For example, we may color them like that: color all the cells in the plane in 9 colors  (i, j) -> (i % 3) * 3 + j % 3. Then paint each domino in the color of its black cell (according to chess coloring). Each figure will have the color of the domino it grows from.2. Greedy.We pass through the array representing the field, again in the same order. Figure for any still free cell may be constructed greedily, but we have to be accurate in order to avoid appearance of new isolated cells. So we just add all the cells that do become isolated when we fill the current figure. Acting in such a fashion we will eventually get the covering by the figures of no more than 5 cells (and at least two, of course).It is possible to color the figure immediately after its formation. We only need to check the colors of all already colored adjacent figures and to take any color, different from all of them. It is not hard to see that 10 colors are enough.C. Genetic engineering.Suppose we've built a string wp of length k < n and want to know how many ways there exist to complement wp to the suitable string of length n. What parameters do we need to know in order to build it further? First of all, we need to know the index wp is covered up to (we denote it by ci and call it covering index). Also we want to have some information about what the string ends with. Here comes rather standard idea: let's find all the prefixes ALLP of the {si} and add to our state the largest prefix such that wp ends with pk (as an alternative, you may consider a vertex in a trie constructed with the collection's strings). Now I'll try to convince you that it's enough to set the things going. First of all, when we add a symbol c to wp we can easily get pk + 1 and it will be equal to the largest string in ALLP such that the string pk + c ends with (we can precalculate all the transitions in advance). So the only thing we want to know how to calculate (in order to use dynamic programming approach) is the new covering index. But we notice that it can be changed only by some string from the collection that wp + c ends with. Now we observe that it is sufficient to check only the largest from all such strings (denote it fs), and that it necessarily contains in pk + 1 (so it also can we easily precalculated for all strings in ALLP). We observe further that the new covering index depends only on the length of fs: it either equals the old one if fs doesn't cover the symbol ci + 1, or equals to (k + 1) if the fs covers that symbol. After calculating all the quantities d[k][k - cov.index][max. prefix] the required number of strings equals the sum of d[n][0][mp] for all mp.D. Powerful array.Let's solve the problem offline in O(n sqrt(t)) time and O(n) memory. For the simplicity of the reasoning let t = n.Assume we know the answer to the problem for some interval and want to find it to another one. Let us move the left end of the first one towards the left end of the second, similarly dealing with the right ends. By moving the end by one and for every value in the array maintaining the number of its appearances in the current interval, we will be able to calculate the answer and maintain the numbers of appearances at the same time in O(1). From now on we call the procedure of movement by 1 a step.Going through the queries in such a fashion, evidently, will cost us O(n^2) steps.Let p = sqrt(n). Divide the array into p equal parts Q_1, ..., Q_p. Now consider the queries of the form (Q_i, Q_j) for all i and j (there will be approx. n such queries). Clearly, there doesn't exist an order in which we can go through the queries in o(n sqrt(n)) time as the transition from any interval to the other one is done in no less than sqrt(n) steps.Nevertheless, there exists a traversal order that guarantees O(n sqrt(n)) steps in the worst case.Let's sort the query intervals according to the following rule: first come the intervals with the left ends in Q_1, then the intervals with the left ends in Q_2, and so on. And if the left ends of the two queries belong to the same part, then the interval with the more left right end is assumed to be smaller.In order to prove the stated asymptotic behavior we will follow the steps of the left and the right ends independently. We note that the left ends that belong to the same Q_i make <= n / p steps, and transition to Q_{i+1} costs no more than 2 * n / p steps. Therefore the left ends make <= n/p * n + 2*n steps (the second summand is O(n), and it's negligible).The right ends in the common group move only to the right, and this proves <= n * p steps (during the whole process) estimate. We will estimate the transition to the next Q_i at no more than n steps, so overall we get <= 2 * n * p steps.Thus, the total number of steps is no more than (n / p * n + 2 * n * p). Now we choose p = sqrt(n) which proves the statement.Solution: let us sort the queries by this rule, then make transitions from a query to the next one according to the obtained order. Note 1. There is nothing special (except for nonadditivity) with the function in the statement.Note 2. In the case of distinct n and t we can similarly prove the nice estimate 2 * n * sqrt(t), mostly nice because of its exactness (if you follow the proof carefully, you will easily construct the maximal test).E. Long sequence.Firstly let's note that there are only 49 different possible inputs. So any solution that works finite time at all tests (even if does not pass timelimit) is enough, because we can memorize all the answers. It is not necessary, of course, but may help with slow solutions.Then, let's answer a more particular question. Assume that c1, c2, ..., ck and a0, a1, ..., ak - 1 are already given and we need to check whether the sequence {ai} generated by them is long or not. We know that if it is periodic, then it is possible to find any non-zero k-tuple among k-tuples as, as + 1, ..., as + k - 1. So initial k-tuple has no real matter if only it is not zero. Thus the property of sequence \"to be long\" depends only on coefficients ci, and we may choose any convenient a0, a1, ..., ak - 1. We will now think that a0, a1, ..., ak - 2 are zeros and ak - 1 = 1.Consider the transition matrix A of our sequence: for i < k the i-th row of A is equal to (0, 0, ... 0, 1, 0, ..., 0) with 1 at (i + 1)-th position and last row of A is equal to (ck, ck - 1, ..., c2, c1).Denote by xs vector (as, as + 1, ..., as + k - 1)T.Then for any integer s we have: A· xs = xs + 1.Last is just a reformulation of the recurrent formula: an = c1 * an - 1 + c2 * an - 2 + ... + ck * an - k.Then by obvious induction we have: Ap· xs = xs + p for any p ≥ 0. Hence p is a period iff for any vector x that appears in our sequence: Ap· x = x. If the sequence is not long then it is not self-evident still that Ap is an identity matrix, because x does not take all possible values. But we have chosen x0 = (0, 0, ..., 0, 1) before, so it is obvious that vectors x0, x1, x2, ..., xk - 1 form a basis. Hence if Ap· xi = xi for any i then Ap is the identity matrix.So we just need to do the following: 1) Construct the matrix A from the coefficients ci.2) Check that A2k - 1 is the identity matrix. (If not, then 2k - 1 is not a period.)If 2k - 1 is a period, then we have to check that it is minimal. Minimal period divides any period so we only need to check the divisors of 2k - 1.3) Generate all maximal divisors of 2k - 1 and check that they are not periods (using A again).(By maximal divisor of n we mean divisors of the type n/q where q is a prime number.)Last thing we need to notice that such a sequence always exists. Moreover, amount of appropriate sets of ci is pretty large. One may prove that there are such sets (because they correspond to the coefficients of the irreducible factors of the cyclotomic polynomial over ). So we can just take them at random and check.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/2028",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9770
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    ensuref(l <= r, \"l (%d) should be less than or equal to r (%d)\", l, r);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    ensuref(l <= r, \"l (%d) should be less than or equal to r (%d)\", l, r);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    ensuref(l <= r, \"l (%d) should be less than or equal to r (%d)\", l, r);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long l = opt<long long>(\"l\", 1);\n    long long r = opt<long long>(\"r\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random l and r within [1,1e9] with l ≤ r\n        l = rnd.next(1LL, 1000000000LL);\n        r = rnd.next(1LL, 1000000000LL);\n        if (l > r) swap(l, r);\n    } else if (type == \"single_value\") {\n        // l = r = a random number in [1,1e9]\n        l = r = rnd.next(1LL, 1000000000LL);\n    } else if (type == \"edge_cases\") {\n        // Edge cases at the boundaries\n        l = 1;\n        r = 1000000000;\n        if (rnd.next(0, 1) == 0) l = rnd.next(1, 10);\n        if (rnd.next(0, 1) == 0) r = rnd.next(1000000000 - 10, 1000000000);\n        if (l > r) swap(l, r);\n    } else if (type == \"max_weight\") {\n        // n = 10^k, where k is from 1 to 9\n        int k = rnd.next(1, 9);\n        long long pow10 = 1;\n        for(int i = 0; i < k; i++) pow10 *= 10;\n        l = r = pow10;\n    } else if (type == \"leading_zero\") {\n        // Numbers where ψ(n) might have leading zeros (but zeros are omitted)\n        l = r = 9;\n    } else if (type == \"zeros\") {\n        // Numbers that contain zeros\n        l = r = 1000 * rnd.next(1, 999);\n    } else if (type == \"nines\") {\n        // Numbers with nines\n        l = rnd.next(900000000LL, 1000000000LL);\n        // Ensure l contains at least one '9'\n        while (to_string(l).find('9') == string::npos) {\n            l = rnd.next(900000000LL, 1000000000LL);\n        }\n        r = l;\n    } else if (type == \"large_range\") {\n        l = 1;\n        r = 1000000000;\n    }\n\n    // Ensure l and r are within [1,1e9]\n    l = max(1LL, min(1000000000LL, l));\n    r = max(1LL, min(1000000000LL, r));\n\n    printf(\"%lld %lld\\n\", l, r);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long l = opt<long long>(\"l\", 1);\n    long long r = opt<long long>(\"r\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random l and r within [1,1e9] with l ≤ r\n        l = rnd.next(1LL, 1000000000LL);\n        r = rnd.next(1LL, 1000000000LL);\n        if (l > r) swap(l, r);\n    } else if (type == \"single_value\") {\n        // l = r = a random number in [1,1e9]\n        l = r = rnd.next(1LL, 1000000000LL);\n    } else if (type == \"edge_cases\") {\n        // Edge cases at the boundaries\n        l = 1;\n        r = 1000000000;\n        if (rnd.next(0, 1) == 0) l = rnd.next(1, 10);\n        if (rnd.next(0, 1) == 0) r = rnd.next(1000000000 - 10, 1000000000);\n        if (l > r) swap(l, r);\n    } else if (type == \"max_weight\") {\n        // n = 10^k, where k is from 1 to 9\n        int k = rnd.next(1, 9);\n        long long pow10 = 1;\n        for(int i = 0; i < k; i++) pow10 *= 10;\n        l = r = pow10;\n    } else if (type == \"leading_zero\") {\n        // Numbers where ψ(n) might have leading zeros (but zeros are omitted)\n        l = r = 9;\n    } else if (type == \"zeros\") {\n        // Numbers that contain zeros\n        l = r = 1000 * rnd.next(1, 999);\n    } else if (type == \"nines\") {\n        // Numbers with nines\n        l = rnd.next(900000000LL, 1000000000LL);\n        // Ensure l contains at least one '9'\n        while (to_string(l).find('9') == string::npos) {\n            l = rnd.next(900000000LL, 1000000000LL);\n        }\n        r = l;\n    } else if (type == \"large_range\") {\n        l = 1;\n        r = 1000000000;\n    }\n\n    // Ensure l and r are within [1,1e9]\n    l = max(1LL, min(1000000000LL, l));\n    r = max(1LL, min(1000000000LL, r));\n\n    printf(\"%lld %lld\\n\", l, r);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type=random\n./gen -type=random\n./gen -type=random\n./gen -type=random\n./gen -type=random\n./gen -type=single_value\n./gen -type=single_value\n./gen -type=single_value\n./gen -type=single_value\n./gen -type=edge_cases\n./gen -type=edge_cases\n./gen -type=edge_cases\n./gen -type=max_weight\n./gen -type=max_weight\n./gen -type=max_weight\n./gen -type=leading_zero\n./gen -type=zeros\n./gen -type=nines\n./gen -type=large_range\n./gen -l=1 -r=1\n./gen -l=1000000000 -r=1000000000\n./gen -l=9 -r=9\n./gen -l=1 -r=1e2\n./gen -l=1e2 -r=1e3\n./gen -l=1e5 -r=1e6\n./gen -l=999999999 -r=1000000000\n./gen -l=123456789 -r=123456789\n./gen -l=987654321 -r=987654321\n./gen -l=888888888 -r=999999999\n./gen -type=random\n./gen -type=random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:12.218221",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "86/B",
      "title": "B. Tetris revisited",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains integers n and m (1 ≤ n, m ≤ 1000) — the height and the width of the field correspondingly. Next n lines contain m symbols each. They represent the field in a natural way: j-th character of the i-th line is \"#\" if the corresponding cell is filled, and \".\" if it is empty.",
      "output_spec": "OutputIf there is no chance to win the game output the only number \"-1\" (without the quotes). Otherwise output any filling of the field by the figures in the following format: each figure should be represented by some digit and figures that touch each other by side should be represented by distinct digits. Every initially filled cell should be represented by \"#\".",
      "sample_tests": "ExamplesInputCopy2 3...#.#OutputCopy000#0#InputCopy3 3.#......#OutputCopy5#151155#InputCopy3 3....##.#.OutputCopy-1InputCopy1 2##OutputCopy##",
      "description": "B. Tetris revisited\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line contains integers n and m (1 ≤ n, m ≤ 1000) — the height and the width of the field correspondingly. Next n lines contain m symbols each. They represent the field in a natural way: j-th character of the i-th line is \"#\" if the corresponding cell is filled, and \".\" if it is empty.\n\nOutputIf there is no chance to win the game output the only number \"-1\" (without the quotes). Otherwise output any filling of the field by the figures in the following format: each figure should be represented by some digit and figures that touch each other by side should be represented by distinct digits. Every initially filled cell should be represented by \"#\".\n\nInputCopy2 3...#.#OutputCopy000#0#InputCopy3 3.#......#OutputCopy5#151155#InputCopy3 3....##.#.OutputCopy-1InputCopy1 2##OutputCopy##\n\nInputCopy2 3...#.#\n\nOutputCopy000#0#\n\nInputCopy3 3.#......#\n\nOutputCopy5#151155#\n\nInputCopy3 3....##.#.\n\nOutputCopy-1\n\nInputCopy1 2##\n\nOutputCopy##\n\nNoteIn the third sample, there is no way to fill a cell with no empty neighbours.In the forth sample, Woll does not have to fill anything, so we should output the field from the input.",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round 2 - Codeforces",
          "content": "Hello, dear participants and spectators!Let me remind you that the elimination phase of the open programming competition \"Yandex.Algorithm\" comes to an end. With it this means that the time for the most important event of the phase has come: the elimination round for the finals (finals will be held at the Yandex Summer School)! This means that today two hundred best participants of the tournament (based on the results of the previous qualification rounds) will compete to get into the top-15 of the world olympiad programming community.We hope that the round will be appreciated not only by the participants but also by the spectators, who will have the opportinity to watch the events developing for at least two hours.Please, pay attention to the problems' costs: 500, 1000, 2000, 2500, 2500. I also advise you to read all the statements, as the choice of the costs and the order is certainly subjective.Round will be rated for all the participants (including those competing hors concours).Good luck to the participants. The problems are going to be rather hard, so you'll have to do your best!I also wish a spectacular round to the rest!Round is over. According to the results, 20 participants solved at least three problems, and just one (the winner) was able to solve the fourth. The first three places were taken by Petr Mitrichev, Gennady Korotkevich and Sergey Kopeliovich. Congratulations!In addition to this, 15 leaders advanced to the finals: Petr, tourist, Burunduk1, ivan.metelsky, dzhulgakov, e-maxx, LayCurse, rng_58, pieguy, zeliboba, ktuan, levlam, wata, dolphinigle, Progger . Problems proved to be rather tough. Here's the full analysis.",
          "author": "yaro",
          "url": "https://codeforces.com/blog/entry/2026",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1661
        },
        {
          "title": "Problemset analysis (Yandex, Round 2) - Codeforces",
          "content": "A. Mirror-number. First note that if the interval contains a number with a digits and a number with b digits (where a > b) then there is no need to consider the number with b digits (as the weight of 10k is greater then the weights of the numbers less than 10k). If we consider only numbers with fixed number of digits (s + 1), then the sum of a and its reflection is constant. Thus, as product grows as multipliers with fixed sum get closer, the picture is the following: the weight grows from 10s to 5· 10s - 1, then it stays the same for 5· 10s and then it goes down, and reaches its minimum (zero) value at 10s + 1 - 1. This is the proof, and the solution is: the maximum weight is reached at either l, r or 5· 10s (we may check all the s such that 5· 10s belongs to the interval, for example). B. Tetris revisitedIt's easy to see that the field may be filled with such figures if and only if there is no isolated cell.There are many different ways to do that, we will show some of them.1. Domino filling.We construct greedy matching on the cells of our field combining them in domino-like figures (rectangles 1  ×  2).Passing through the array that represents our field (from left to right, from top to bottom) we combine the still free horizontal pairs of connected cells into the horizontal dominoes. Then we do the same thing with the still free vertical pairs. Naturally, some cells may be still free. But such cells should be adjoined with some of the dominoes (if they were not isolated). We may attach each of these cells to any of the adjoint dominoes. All resulting figures will contain no more than 5 cells, because the cells still empty after matching can not be neighbour cells and can not be adjacent to the left side of dominoes (by the virtue of the order of our matching).The last thing that has to be done is the coloring of the figures in accordance with the output format. For example, we may color them like that: color all the cells in the plane in 9 colors  (i, j) -> (i % 3) * 3 + j % 3. Then paint each domino in the color of its black cell (according to chess coloring). Each figure will have the color of the domino it grows from.2. Greedy.We pass through the array representing the field, again in the same order. Figure for any still free cell may be constructed greedily, but we have to be accurate in order to avoid appearance of new isolated cells. So we just add all the cells that do become isolated when we fill the current figure. Acting in such a fashion we will eventually get the covering by the figures of no more than 5 cells (and at least two, of course).It is possible to color the figure immediately after its formation. We only need to check the colors of all already colored adjacent figures and to take any color, different from all of them. It is not hard to see that 10 colors are enough.C. Genetic engineering.Suppose we've built a string wp of length k < n and want to know how many ways there exist to complement wp to the suitable string of length n. What parameters do we need to know in order to build it further? First of all, we need to know the index wp is covered up to (we denote it by ci and call it covering index). Also we want to have some information about what the string ends with. Here comes rather standard idea: let's find all the prefixes ALLP of the {si} and add to our state the largest prefix such that wp ends with pk (as an alternative, you may consider a vertex in a trie constructed with the collection's strings). Now I'll try to convince you that it's enough to set the things going. First of all, when we add a symbol c to wp we can easily get pk + 1 and it will be equal to the largest string in ALLP such that the string pk + c ends with (we can precalculate all the transitions in advance). So the only thing we want to know how to calculate (in order to use dynamic programming approach) is the new covering index. But we notice that it can be changed only by some string from the collection that wp + c ends with. Now we observe that it is sufficient to check only the largest from all such strings (denote it fs), and that it necessarily contains in pk + 1 (so it also can we easily precalculated for all strings in ALLP). We observe further that the new covering index depends only on the length of fs: it either equals the old one if fs doesn't cover the symbol ci + 1, or equals to (k + 1) if the fs covers that symbol. After calculating all the quantities d[k][k - cov.index][max. prefix] the required number of strings equals the sum of d[n][0][mp] for all mp.D. Powerful array.Let's solve the problem offline in O(n sqrt(t)) time and O(n) memory. For the simplicity of the reasoning let t = n.Assume we know the answer to the problem for some interval and want to find it to another one. Let us move the left end of the first one towards the left end of the second, similarly dealing with the right ends. By moving the end by one and for every value in the array maintaining the number of its appearances in the current interval, we will be able to calculate the answer and maintain the numbers of appearances at the same time in O(1). From now on we call the procedure of movement by 1 a step.Going through the queries in such a fashion, evidently, will cost us O(n^2) steps.Let p = sqrt(n). Divide the array into p equal parts Q_1, ..., Q_p. Now consider the queries of the form (Q_i, Q_j) for all i and j (there will be approx. n such queries). Clearly, there doesn't exist an order in which we can go through the queries in o(n sqrt(n)) time as the transition from any interval to the other one is done in no less than sqrt(n) steps.Nevertheless, there exists a traversal order that guarantees O(n sqrt(n)) steps in the worst case.Let's sort the query intervals according to the following rule: first come the intervals with the left ends in Q_1, then the intervals with the left ends in Q_2, and so on. And if the left ends of the two queries belong to the same part, then the interval with the more left right end is assumed to be smaller.In order to prove the stated asymptotic behavior we will follow the steps of the left and the right ends independently. We note that the left ends that belong to the same Q_i make <= n / p steps, and transition to Q_{i+1} costs no more than 2 * n / p steps. Therefore the left ends make <= n/p * n + 2*n steps (the second summand is O(n), and it's negligible).The right ends in the common group move only to the right, and this proves <= n * p steps (during the whole process) estimate. We will estimate the transition to the next Q_i at no more than n steps, so overall we get <= 2 * n * p steps.Thus, the total number of steps is no more than (n / p * n + 2 * n * p). Now we choose p = sqrt(n) which proves the statement.Solution: let us sort the queries by this rule, then make transitions from a query to the next one according to the obtained order. Note 1. There is nothing special (except for nonadditivity) with the function in the statement.Note 2. In the case of distinct n and t we can similarly prove the nice estimate 2 * n * sqrt(t), mostly nice because of its exactness (if you follow the proof carefully, you will easily construct the maximal test).E. Long sequence.Firstly let's note that there are only 49 different possible inputs. So any solution that works finite time at all tests (even if does not pass timelimit) is enough, because we can memorize all the answers. It is not necessary, of course, but may help with slow solutions.Then, let's answer a more particular question. Assume that c1, c2, ..., ck and a0, a1, ..., ak - 1 are already given and we need to check whether the sequence {ai} generated by them is long or not. We know that if it is periodic, then it is possible to find any non-zero k-tuple among k-tuples as, as + 1, ..., as + k - 1. So initial k-tuple has no real matter if only it is not zero. Thus the property of sequence \"to be long\" depends only on coefficients ci, and we may choose any convenient a0, a1, ..., ak - 1. We will now think that a0, a1, ..., ak - 2 are zeros and ak - 1 = 1.Consider the transition matrix A of our sequence: for i < k the i-th row of A is equal to (0, 0, ... 0, 1, 0, ..., 0) with 1 at (i + 1)-th position and last row of A is equal to (ck, ck - 1, ..., c2, c1).Denote by xs vector (as, as + 1, ..., as + k - 1)T.Then for any integer s we have: A· xs = xs + 1.Last is just a reformulation of the recurrent formula: an = c1 * an - 1 + c2 * an - 2 + ... + ck * an - k.Then by obvious induction we have: Ap· xs = xs + p for any p ≥ 0. Hence p is a period iff for any vector x that appears in our sequence: Ap· x = x. If the sequence is not long then it is not self-evident still that Ap is an identity matrix, because x does not take all possible values. But we have chosen x0 = (0, 0, ..., 0, 1) before, so it is obvious that vectors x0, x1, x2, ..., xk - 1 form a basis. Hence if Ap· xi = xi for any i then Ap is the identity matrix.So we just need to do the following: 1) Construct the matrix A from the coefficients ci.2) Check that A2k - 1 is the identity matrix. (If not, then 2k - 1 is not a period.)If 2k - 1 is a period, then we have to check that it is minimal. Minimal period divides any period so we only need to check the divisors of 2k - 1.3) Generate all maximal divisors of 2k - 1 and check that they are not periods (using A again).(By maximal divisor of n we mean divisors of the type n/q where q is a prime number.)Last thing we need to notice that such a sequence always exists. Moreover, amount of appropriate sets of ci is pretty large. One may prove that there are such sets (because they correspond to the coefficients of the irreducible factors of the cyclotomic polynomial over ). So we can just take them at random and check.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2028",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9770
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d must have exactly %d characters, but has %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '#' || s[j] == '.', \"Invalid character '%c' at line %d, position %d\", s[j], i + 1, j + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d must have exactly %d characters, but has %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '#' || s[j] == '.', \"Invalid character '%c' at line %d, position %d\", s[j], i + 1, j + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d must have exactly %d characters, but has %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '#' || s[j] == '.', \"Invalid character '%c' at line %d, position %d\", s[j], i + 1, j + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<string> field;\nvector<string> ansField;\n\nvoid readInput() {\n    n = inf.readInt(); // no need to validate it in the checker\n    m = inf.readInt();\n    field.resize(n);\n    for (int i = 0; i < n; i++) {\n        field[i] = inf.readToken();\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    readInput();\n\n    // Read jury's answer\n    bool juryNoSolution = false;\n    string juryFirstLine = ans.readLine();\n    if (juryFirstLine == \"-1\") {\n        juryNoSolution = true;\n    } else {\n        ansField.push_back(juryFirstLine);\n        for (int i = 1; i < n; i++) {\n            ansField.push_back(ans.readLine());\n        }\n    }\n\n    // Read participant's answer\n    bool participantNoSolution = false;\n    string participantFirstLine = ouf.readLine();\n    if (participantFirstLine == \"-1\") {\n        participantNoSolution = true;\n    } else {\n        // Read the rest of the participant's output\n        vector<string> participantField;\n        participantField.push_back(participantFirstLine);\n        for (int i = 1; i < n; i++) {\n            participantField.push_back(ouf.readLine());\n        }\n\n        // Validate participant's output\n        if ((int)participantField.size() != n)\n            quitf(_wa, \"Incorrect number of lines in output\");\n\n        for (int i = 0; i < n; i++) {\n            if ((int)participantField[i].length() != m)\n                quitf(_wa, \"Line %d has incorrect length\", i + 1);\n        }\n\n        // Check the characters and build components\n        vector<vector<int>> compId(n, vector<int>(m, -1));\n        int compCount = 0;\n        map<int, char> compDigit;\n        map<int, vector<pair<int, int>>> compCells;\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char inputCell = field[i][j];\n                char outputCell = participantField[i][j];\n\n                // Check that '#' cells are preserved\n                if (inputCell == '#') {\n                    if (outputCell != '#')\n                        quitf(_wa, \"Filled cell at (%d, %d) should be '#'\", i + 1, j + 1);\n                    continue;\n                }\n\n                // Check that output cell is a digit '0'-'9'\n                if (!(outputCell >= '0' && outputCell <= '9'))\n                    quitf(_wa, \"Invalid character '%c' at (%d, %d)\", outputCell, i + 1, j + 1);\n            }\n        }\n\n        // Build connected components\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (participantField[i][j] >= '0' && participantField[i][j] <= '9' && !visited[i][j]) {\n                    // Start a BFS/DFS\n                    char digit = participantField[i][j];\n                    queue<pair<int, int>> q;\n                    q.push({i, j});\n                    visited[i][j] = true;\n                    compId[i][j] = compCount;\n                    compDigit[compCount] = digit;\n                    compCells[compCount].push_back({i, j});\n                    while (!q.empty()) {\n                        auto [x, y] = q.front();\n                        q.pop();\n                        for (int d = 0; d < 4; d++) {\n                            int nx = x + dx[d];\n                            int ny = y + dy[d];\n                            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                                if (participantField[nx][ny] == digit && !visited[nx][ny]) {\n                                    visited[nx][ny] = true;\n                                    compId[nx][ny] = compCount;\n                                    compCells[compCount].push_back({nx, ny});\n                                    q.push({nx, ny});\n                                }\n                            }\n                        }\n                    }\n                    compCount++;\n                }\n            }\n        }\n\n        // Check component sizes\n        for (auto& [id, cells] : compCells) {\n            int size = cells.size();\n            if (size < 2 || size > 5)\n                quitf(_wa, \"Figure with digit '%c' has invalid size %d\", compDigit[id], size);\n        }\n\n        // Check for touching figures with same digits\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char currentDigit = participantField[i][j];\n                if (!(currentDigit >= '0' && currentDigit <= '9'))\n                    continue;\n                int currentCompId = compId[i][j];\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                        char neighborDigit = participantField[ni][nj];\n                        if (!(neighborDigit >= '0' && neighborDigit <= '9'))\n                            continue;\n                        int neighborCompId = compId[ni][nj];\n                        if (currentCompId != neighborCompId) {\n                            // Different components\n                            if (currentDigit == neighborDigit) {\n                                quitf(_wa, \"Adjacent figures with digit '%c' at (%d, %d) and (%d, %d)\", currentDigit, i + 1, j + 1, ni + 1, nj + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // All checks passed\n        quitf(_ok, \"Solution is correct\");\n    }\n\n    // Handling \"-1\" cases\n    if (juryNoSolution) {\n        if (participantNoSolution) {\n            quitf(_ok, \"Correctly reported no solution\");\n        } else {\n            quitf(_fail, \"Participant found a solution while jury says there is none\");\n        }\n    } else {\n        if (participantNoSolution) {\n            quitf(_wa, \"Participant reported no solution while a solution exists\");\n        } else {\n            // Already handled above\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // Used in some types\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // All cells are empty ('.')\n        // Nothing to do since grid is initialized with '.'\n    } \n    else if (type == \"full\") {\n        // All cells are filled ('#')\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    } \n    else if (type == \"random\") {\n        // Randomly fill cells with '#' or '.'\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (rnd.next(2) ? '#' : '.');\n    } \n    else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0 ? '#' : '.');\n    }\n    else if (type == \"impossible_single\") {\n        // All cells filled except one\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '.';\n    }\n    else if (type == \"impossible_isolated\") {\n        // Place k isolated empty cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n        set<pair<int,int>> positions;\n        while (positions.size() < k) {\n            int x = rnd.next(n);\n            int y = rnd.next(m);\n            positions.insert({x, y});\n        }\n        for (auto pos : positions) {\n            int x = pos.first;\n            int y = pos.second;\n            grid[x][y] = '.';\n        }\n    }\n    else if (type == \"impossible_odd\") {\n        // Create grid with total empty cells that cannot be fully covered by figures of size 2-5\n        int maxEmpty = n * m / 2;\n        int emptyCells = rnd.next(1, maxEmpty);\n        while (emptyCells % 2 == 0 || emptyCells % 3 == 0 || emptyCells % 4 == 0 || emptyCells % 5 == 0)\n            emptyCells = rnd.next(1, maxEmpty);\n        vector<pair<int,int>> positions;\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                positions.push_back({i,j});\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n        for(int i = 0; i < emptyCells; ++i){\n            int x = positions[i].first;\n            int y = positions[i].second;\n            grid[x][y] = '.';\n        }\n    }\n    else if (type == \"stripes\") {\n        // Vertical stripes\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (j % 2 == 0 ? '#' : '.');\n    }\n    else if (type == \"hstripes\") {\n        // Horizontal stripes\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i % 2 == 0 ? '#' : '.');\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // Used in some types\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // All cells are empty ('.')\n        // Nothing to do since grid is initialized with '.'\n    } \n    else if (type == \"full\") {\n        // All cells are filled ('#')\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    } \n    else if (type == \"random\") {\n        // Randomly fill cells with '#' or '.'\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (rnd.next(2) ? '#' : '.');\n    } \n    else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0 ? '#' : '.');\n    }\n    else if (type == \"impossible_single\") {\n        // All cells filled except one\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '.';\n    }\n    else if (type == \"impossible_isolated\") {\n        // Place k isolated empty cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n        set<pair<int,int>> positions;\n        while (positions.size() < k) {\n            int x = rnd.next(n);\n            int y = rnd.next(m);\n            positions.insert({x, y});\n        }\n        for (auto pos : positions) {\n            int x = pos.first;\n            int y = pos.second;\n            grid[x][y] = '.';\n        }\n    }\n    else if (type == \"impossible_odd\") {\n        // Create grid with total empty cells that cannot be fully covered by figures of size 2-5\n        int maxEmpty = n * m / 2;\n        int emptyCells = rnd.next(1, maxEmpty);\n        while (emptyCells % 2 == 0 || emptyCells % 3 == 0 || emptyCells % 4 == 0 || emptyCells % 5 == 0)\n            emptyCells = rnd.next(1, maxEmpty);\n        vector<pair<int,int>> positions;\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                positions.push_back({i,j});\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n        for(int i = 0; i < emptyCells; ++i){\n            int x = positions[i].first;\n            int y = positions[i].second;\n            grid[x][y] = '.';\n        }\n    }\n    else if (type == \"stripes\") {\n        // Vertical stripes\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (j % 2 == 0 ? '#' : '.');\n    }\n    else if (type == \"hstripes\") {\n        // Horizontal stripes\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i % 2 == 0 ? '#' : '.');\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type empty\n./gen -n 1 -m 1 -type full\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type full\n./gen -n 2 -m 2 -type random\n\n./gen -n 3 -m 3 -type empty\n./gen -n 3 -m 3 -type random\n\n./gen -n 5 -m 5 -type impossible_odd\n\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type random\n\n./gen -n 10 -m 10 -type impossible_single\n\n./gen -n 10 -m 10 -type impossible_isolated -k 2\n\n./gen -n 10 -m 10 -type stripes\n./gen -n 10 -m 10 -type hstripes\n\n./gen -n 50 -m 50 -type random\n\n./gen -n 100 -m 100 -type full\n\n./gen -n 100 -m 100 -type empty\n\n./gen -n 100 -m 100 -type impossible_isolated -k 5\n\n./gen -n 100 -m 100 -type impossible_odd\n\n./gen -n 100 -m 100 -type stripes\n\n./gen -n 100 -m 100 -type hstripes\n\n./gen -n 500 -m 500 -type random\n\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 1000 -m 1000 -type full\n\n./gen -n 1000 -m 1000 -type empty\n\n./gen -n 1000 -m 1000 -type checkerboard\n\n./gen -n 1000 -m 1000 -type impossible_single\n\n./gen -n 1000 -m 1000 -type impossible_isolated -k 100\n\n./gen -n 1000 -m 1000 -type impossible_odd\n\n./gen -n 1000 -m 1000 -type stripes\n\n./gen -n 1000 -m 1000 -type hstripes\n\n./gen -n 1 -m 1000 -type random\n\n./gen -n 1000 -m 1 -type random\n\n./gen -n 1000 -m 1000 -type impossible_isolated -k 1\n\n./gen -n 1000 -m 1000 -type impossible_isolated -k 500\n\n./gen -n 999 -m 997 -type random\n\n./gen -n 1000 -m 999 -type random\n\n./gen -n 500 -m 1000 -type random\n\n./gen -n 1000 -m 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:13.844645",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "86/C",
      "title": "C. Genetic engineering",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains two integer numbers n and m (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10) — the length of the string and the number of sequences in the collection correspondently. Next m lines contain the collection sequences si, one per line. Each si is a nonempty string of length not greater than 10. All the strings consist of uppercase letters \"A\", \"C\", \"G\", \"T\". The collection may contain identical strings.",
      "output_spec": "OutputOutput should contain a single integer — the number of strings filtered by the collection modulo 1000000009 (109 + 9).",
      "sample_tests": "ExamplesInputCopy2 1AOutputCopy1InputCopy6 2CATTACTOutputCopy2",
      "description": "C. Genetic engineering\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line contains two integer numbers n and m (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10) — the length of the string and the number of sequences in the collection correspondently. Next m lines contain the collection sequences si, one per line. Each si is a nonempty string of length not greater than 10. All the strings consist of uppercase letters \"A\", \"C\", \"G\", \"T\". The collection may contain identical strings.\n\nOutputOutput should contain a single integer — the number of strings filtered by the collection modulo 1000000009 (109 + 9).\n\nInputCopy2 1AOutputCopy1InputCopy6 2CATTACTOutputCopy2\n\nInputCopy2 1A\n\nOutputCopy1\n\nInputCopy6 2CATTACT\n\nOutputCopy2\n\nNoteIn the first sample, a string has to be filtered by \"A\". Clearly, there is only one such string: \"AA\".In the second sample, there exist exactly two different strings satisfying the condition (see the pictures below).",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round 2 - Codeforces",
          "content": "Hello, dear participants and spectators!Let me remind you that the elimination phase of the open programming competition \"Yandex.Algorithm\" comes to an end. With it this means that the time for the most important event of the phase has come: the elimination round for the finals (finals will be held at the Yandex Summer School)! This means that today two hundred best participants of the tournament (based on the results of the previous qualification rounds) will compete to get into the top-15 of the world olympiad programming community.We hope that the round will be appreciated not only by the participants but also by the spectators, who will have the opportinity to watch the events developing for at least two hours.Please, pay attention to the problems' costs: 500, 1000, 2000, 2500, 2500. I also advise you to read all the statements, as the choice of the costs and the order is certainly subjective.Round will be rated for all the participants (including those competing hors concours).Good luck to the participants. The problems are going to be rather hard, so you'll have to do your best!I also wish a spectacular round to the rest!Round is over. According to the results, 20 participants solved at least three problems, and just one (the winner) was able to solve the fourth. The first three places were taken by Petr Mitrichev, Gennady Korotkevich and Sergey Kopeliovich. Congratulations!In addition to this, 15 leaders advanced to the finals: Petr, tourist, Burunduk1, ivan.metelsky, dzhulgakov, e-maxx, LayCurse, rng_58, pieguy, zeliboba, ktuan, levlam, wata, dolphinigle, Progger . Problems proved to be rather tough. Here's the full analysis.",
          "author": "yaro",
          "url": "https://codeforces.com/blog/entry/2026",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1661
        },
        {
          "title": "Problemset analysis (Yandex, Round 2) - Codeforces",
          "content": "A. Mirror-number. First note that if the interval contains a number with a digits and a number with b digits (where a > b) then there is no need to consider the number with b digits (as the weight of 10k is greater then the weights of the numbers less than 10k). If we consider only numbers with fixed number of digits (s + 1), then the sum of a and its reflection is constant. Thus, as product grows as multipliers with fixed sum get closer, the picture is the following: the weight grows from 10s to 5· 10s - 1, then it stays the same for 5· 10s and then it goes down, and reaches its minimum (zero) value at 10s + 1 - 1. This is the proof, and the solution is: the maximum weight is reached at either l, r or 5· 10s (we may check all the s such that 5· 10s belongs to the interval, for example). B. Tetris revisitedIt's easy to see that the field may be filled with such figures if and only if there is no isolated cell.There are many different ways to do that, we will show some of them.1. Domino filling.We construct greedy matching on the cells of our field combining them in domino-like figures (rectangles 1  ×  2).Passing through the array that represents our field (from left to right, from top to bottom) we combine the still free horizontal pairs of connected cells into the horizontal dominoes. Then we do the same thing with the still free vertical pairs. Naturally, some cells may be still free. But such cells should be adjoined with some of the dominoes (if they were not isolated). We may attach each of these cells to any of the adjoint dominoes. All resulting figures will contain no more than 5 cells, because the cells still empty after matching can not be neighbour cells and can not be adjacent to the left side of dominoes (by the virtue of the order of our matching).The last thing that has to be done is the coloring of the figures in accordance with the output format. For example, we may color them like that: color all the cells in the plane in 9 colors  (i, j) -> (i % 3) * 3 + j % 3. Then paint each domino in the color of its black cell (according to chess coloring). Each figure will have the color of the domino it grows from.2. Greedy.We pass through the array representing the field, again in the same order. Figure for any still free cell may be constructed greedily, but we have to be accurate in order to avoid appearance of new isolated cells. So we just add all the cells that do become isolated when we fill the current figure. Acting in such a fashion we will eventually get the covering by the figures of no more than 5 cells (and at least two, of course).It is possible to color the figure immediately after its formation. We only need to check the colors of all already colored adjacent figures and to take any color, different from all of them. It is not hard to see that 10 colors are enough.C. Genetic engineering.Suppose we've built a string wp of length k < n and want to know how many ways there exist to complement wp to the suitable string of length n. What parameters do we need to know in order to build it further? First of all, we need to know the index wp is covered up to (we denote it by ci and call it covering index). Also we want to have some information about what the string ends with. Here comes rather standard idea: let's find all the prefixes ALLP of the {si} and add to our state the largest prefix such that wp ends with pk (as an alternative, you may consider a vertex in a trie constructed with the collection's strings). Now I'll try to convince you that it's enough to set the things going. First of all, when we add a symbol c to wp we can easily get pk + 1 and it will be equal to the largest string in ALLP such that the string pk + c ends with (we can precalculate all the transitions in advance). So the only thing we want to know how to calculate (in order to use dynamic programming approach) is the new covering index. But we notice that it can be changed only by some string from the collection that wp + c ends with. Now we observe that it is sufficient to check only the largest from all such strings (denote it fs), and that it necessarily contains in pk + 1 (so it also can we easily precalculated for all strings in ALLP). We observe further that the new covering index depends only on the length of fs: it either equals the old one if fs doesn't cover the symbol ci + 1, or equals to (k + 1) if the fs covers that symbol. After calculating all the quantities d[k][k - cov.index][max. prefix] the required number of strings equals the sum of d[n][0][mp] for all mp.D. Powerful array.Let's solve the problem offline in O(n sqrt(t)) time and O(n) memory. For the simplicity of the reasoning let t = n.Assume we know the answer to the problem for some interval and want to find it to another one. Let us move the left end of the first one towards the left end of the second, similarly dealing with the right ends. By moving the end by one and for every value in the array maintaining the number of its appearances in the current interval, we will be able to calculate the answer and maintain the numbers of appearances at the same time in O(1). From now on we call the procedure of movement by 1 a step.Going through the queries in such a fashion, evidently, will cost us O(n^2) steps.Let p = sqrt(n). Divide the array into p equal parts Q_1, ..., Q_p. Now consider the queries of the form (Q_i, Q_j) for all i and j (there will be approx. n such queries). Clearly, there doesn't exist an order in which we can go through the queries in o(n sqrt(n)) time as the transition from any interval to the other one is done in no less than sqrt(n) steps.Nevertheless, there exists a traversal order that guarantees O(n sqrt(n)) steps in the worst case.Let's sort the query intervals according to the following rule: first come the intervals with the left ends in Q_1, then the intervals with the left ends in Q_2, and so on. And if the left ends of the two queries belong to the same part, then the interval with the more left right end is assumed to be smaller.In order to prove the stated asymptotic behavior we will follow the steps of the left and the right ends independently. We note that the left ends that belong to the same Q_i make <= n / p steps, and transition to Q_{i+1} costs no more than 2 * n / p steps. Therefore the left ends make <= n/p * n + 2*n steps (the second summand is O(n), and it's negligible).The right ends in the common group move only to the right, and this proves <= n * p steps (during the whole process) estimate. We will estimate the transition to the next Q_i at no more than n steps, so overall we get <= 2 * n * p steps.Thus, the total number of steps is no more than (n / p * n + 2 * n * p). Now we choose p = sqrt(n) which proves the statement.Solution: let us sort the queries by this rule, then make transitions from a query to the next one according to the obtained order. Note 1. There is nothing special (except for nonadditivity) with the function in the statement.Note 2. In the case of distinct n and t we can similarly prove the nice estimate 2 * n * sqrt(t), mostly nice because of its exactness (if you follow the proof carefully, you will easily construct the maximal test).E. Long sequence.Firstly let's note that there are only 49 different possible inputs. So any solution that works finite time at all tests (even if does not pass timelimit) is enough, because we can memorize all the answers. It is not necessary, of course, but may help with slow solutions.Then, let's answer a more particular question. Assume that c1, c2, ..., ck and a0, a1, ..., ak - 1 are already given and we need to check whether the sequence {ai} generated by them is long or not. We know that if it is periodic, then it is possible to find any non-zero k-tuple among k-tuples as, as + 1, ..., as + k - 1. So initial k-tuple has no real matter if only it is not zero. Thus the property of sequence \"to be long\" depends only on coefficients ci, and we may choose any convenient a0, a1, ..., ak - 1. We will now think that a0, a1, ..., ak - 2 are zeros and ak - 1 = 1.Consider the transition matrix A of our sequence: for i < k the i-th row of A is equal to (0, 0, ... 0, 1, 0, ..., 0) with 1 at (i + 1)-th position and last row of A is equal to (ck, ck - 1, ..., c2, c1).Denote by xs vector (as, as + 1, ..., as + k - 1)T.Then for any integer s we have: A· xs = xs + 1.Last is just a reformulation of the recurrent formula: an = c1 * an - 1 + c2 * an - 2 + ... + ck * an - k.Then by obvious induction we have: Ap· xs = xs + p for any p ≥ 0. Hence p is a period iff for any vector x that appears in our sequence: Ap· x = x. If the sequence is not long then it is not self-evident still that Ap is an identity matrix, because x does not take all possible values. But we have chosen x0 = (0, 0, ..., 0, 1) before, so it is obvious that vectors x0, x1, x2, ..., xk - 1 form a basis. Hence if Ap· xi = xi for any i then Ap is the identity matrix.So we just need to do the following: 1) Construct the matrix A from the coefficients ci.2) Check that A2k - 1 is the identity matrix. (If not, then 2k - 1 is not a period.)If 2k - 1 is a period, then we have to check that it is minimal. Minimal period divides any period so we only need to check the divisors of 2k - 1.3) Generate all maximal divisors of 2k - 1 and check that they are not periods (using A again).(By maximal divisor of n we mean divisors of the type n/q where q is a prime number.)Last thing we need to notice that such a sequence always exists. Moreover, amount of appropriate sets of ci is pretty large. One may prove that there are such sets (because they correspond to the coefficients of the irreducible factors of the cyclotomic polynomial over ). So we can just take them at random and check.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/2028",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9770
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= m; ++i) {\n        string si = inf.readLine(\"[ACGT]{1,10}\", format(\"s[%d]\", i));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= m; ++i) {\n        string si = inf.readLine(\"[ACGT]{1,10}\", format(\"s[%d]\", i));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= m; ++i) {\n        string si = inf.readLine(\"[ACGT]{1,10}\", format(\"s[%d]\", i));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string DNA = \"ACGT\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> sequences;\n\n    if (type == \"random\") {\n        // Generate m random sequences of length between 1 and 10\n        for (int i = 0; i < m; i++) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; j++) {\n                s += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s);\n        }\n    } else if (type == \"same\") {\n        // Generate one random sequence of length between 1 and 10\n        int len = rnd.next(1, 10);\n        string s;\n        for (int j = 0; j < len; j++) {\n            s += DNA[rnd.next(4)];\n        }\n        for (int i = 0; i < m; i++) {\n            sequences.push_back(s);\n        }\n    } else if (type == \"all_length_one\") {\n        // Generate m random sequences of length 1\n        for (int i = 0; i < m; i++) {\n            string s;\n            s += DNA[rnd.next(4)];\n            sequences.push_back(s);\n        }\n    } else if (type == \"max_length\") {\n        // Generate m random sequences of length 10\n        for (int i = 0; i < m; i++) {\n            string s;\n            for (int j = 0; j < 10; j++) {\n                s += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s);\n        }\n    } else if (type == \"overlapping\") {\n        // Generate overlapping sequences (prefixes/suffixes)\n        int len = rnd.next(2, 10);\n        string s;\n        for (int j = 0; j < len; j++) {\n            s += DNA[rnd.next(4)];\n        }\n        // Generate prefixes and suffixes\n        set<string> seq_set;\n        seq_set.insert(s);\n        for (int i = 1; i < len; i++) {\n            seq_set.insert(s.substr(0, i)); // prefixes\n            seq_set.insert(s.substr(i));    // suffixes\n        }\n\n        // We need exactly m sequences\n        vector<string> seq_vec(seq_set.begin(), seq_set.end());\n        shuffle(seq_vec.begin(), seq_vec.end());\n        if ((int)seq_vec.size() > m) {\n            seq_vec.resize(m);\n        }\n        sequences = seq_vec;\n\n        // If sequences.size() < m, add random sequences\n        while ((int)sequences.size() < m) {\n            int len2 = rnd.next(1, 10);\n            string s2;\n            for (int j = 0; j < len2; j++) {\n                s2 += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s2);\n        }\n    } else if (type == \"palindromes\") {\n        // Generate m palindromic sequences\n        for (int i = 0; i < m; i++) {\n            int len = rnd.next(1, 10);\n            string half;\n            for (int j = 0; j < (len + 1) / 2; j++) {\n                half += DNA[rnd.next(4)];\n            }\n            string s = half;\n            if (len % 2 == 1) half.pop_back();\n            reverse(half.begin(), half.end());\n            s += half;\n            sequences.push_back(s);\n        }\n    } else if (type == \"min_length\") {\n        // Generate m random sequences of length 1\n        for (int i = 0; i < m; i++) {\n            string s;\n            s += DNA[rnd.next(4)];\n            sequences.push_back(s);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; i++) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; j++) {\n                s += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output sequences\n    for (int i = 0; i < m; i++) {\n        printf(\"%s\\n\", sequences[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string DNA = \"ACGT\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> sequences;\n\n    if (type == \"random\") {\n        // Generate m random sequences of length between 1 and 10\n        for (int i = 0; i < m; i++) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; j++) {\n                s += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s);\n        }\n    } else if (type == \"same\") {\n        // Generate one random sequence of length between 1 and 10\n        int len = rnd.next(1, 10);\n        string s;\n        for (int j = 0; j < len; j++) {\n            s += DNA[rnd.next(4)];\n        }\n        for (int i = 0; i < m; i++) {\n            sequences.push_back(s);\n        }\n    } else if (type == \"all_length_one\") {\n        // Generate m random sequences of length 1\n        for (int i = 0; i < m; i++) {\n            string s;\n            s += DNA[rnd.next(4)];\n            sequences.push_back(s);\n        }\n    } else if (type == \"max_length\") {\n        // Generate m random sequences of length 10\n        for (int i = 0; i < m; i++) {\n            string s;\n            for (int j = 0; j < 10; j++) {\n                s += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s);\n        }\n    } else if (type == \"overlapping\") {\n        // Generate overlapping sequences (prefixes/suffixes)\n        int len = rnd.next(2, 10);\n        string s;\n        for (int j = 0; j < len; j++) {\n            s += DNA[rnd.next(4)];\n        }\n        // Generate prefixes and suffixes\n        set<string> seq_set;\n        seq_set.insert(s);\n        for (int i = 1; i < len; i++) {\n            seq_set.insert(s.substr(0, i)); // prefixes\n            seq_set.insert(s.substr(i));    // suffixes\n        }\n\n        // We need exactly m sequences\n        vector<string> seq_vec(seq_set.begin(), seq_set.end());\n        shuffle(seq_vec.begin(), seq_vec.end());\n        if ((int)seq_vec.size() > m) {\n            seq_vec.resize(m);\n        }\n        sequences = seq_vec;\n\n        // If sequences.size() < m, add random sequences\n        while ((int)sequences.size() < m) {\n            int len2 = rnd.next(1, 10);\n            string s2;\n            for (int j = 0; j < len2; j++) {\n                s2 += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s2);\n        }\n    } else if (type == \"palindromes\") {\n        // Generate m palindromic sequences\n        for (int i = 0; i < m; i++) {\n            int len = rnd.next(1, 10);\n            string half;\n            for (int j = 0; j < (len + 1) / 2; j++) {\n                half += DNA[rnd.next(4)];\n            }\n            string s = half;\n            if (len % 2 == 1) half.pop_back();\n            reverse(half.begin(), half.end());\n            s += half;\n            sequences.push_back(s);\n        }\n    } else if (type == \"min_length\") {\n        // Generate m random sequences of length 1\n        for (int i = 0; i < m; i++) {\n            string s;\n            s += DNA[rnd.next(4)];\n            sequences.push_back(s);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; i++) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; j++) {\n                s += DNA[rnd.next(4)];\n            }\n            sequences.push_back(s);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output sequences\n    for (int i = 0; i < m; i++) {\n        printf(\"%s\\n\", sequences[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 10 -type random\n\n./gen -n 10 -m 1 -type random\n./gen -n 10 -m 10 -type random\n\n./gen -n 100 -m 10 -type random\n./gen -n 1000 -m 10 -type random\n\n./gen -n 1000 -m 10 -type same\n\n./gen -n 1 -m 4 -type all_length_one\n./gen -n 1000 -m 4 -type all_length_one\n\n./gen -n 1 -m 10 -type max_length\n./gen -n 1000 -m 10 -type max_length\n\n./gen -n 1000 -m 10 -type overlapping\n\n./gen -n 1000 -m 10 -type palindromes\n\n./gen -n 2 -m 1 -type random\n\n./gen -n 999 -m 10 -type overlapping\n\n./gen -n 500 -m 10 -type palindromes\n\n./gen -n 1000 -m 10 -type min_length\n\n./gen -n 1000 -m 10 -type random\n\n./gen -n 1000 -m 1 -type random\n\n./gen -n 999 -m 1 -type same\n\n./gen -n 1000 -m 3 -type overlapping\n\n./gen -n 999 -m 4 -type palindromes\n\n./gen -n 1000 -m 4 -type all_length_one\n\n./gen -n 1000 -m 10 -type random\n\n./gen -n 500 -m 5 -type same\n\n./gen -n 1000 -m 5 -type max_length\n\n./gen -n 500 -m 5 -type min_length\n\n./gen -n 1000 -m 6 -type overlapping\n\n./gen -n 700 -m 7 -type palindromes\n\n./gen -n 800 -m 2 -type random\n\n./gen -n 900 -m 8 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:15.556209",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "86/D",
      "title": "D. Powerful array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains two integers n and t (1 ≤ n, t ≤ 200000) — the array length and the number of queries correspondingly.Second line contains n positive integers ai (1 ≤ ai ≤ 106) — the elements of the array.Next t lines contain two positive integers l, r (1 ≤ l ≤ r ≤ n) each — the indices of the left and the right ends of the corresponding subarray.",
      "output_spec": "OutputOutput t lines, the i-th line of the output should contain single positive integer — the power of the i-th query subarray.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout stream (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy3 21 2 11 21 3OutputCopy36InputCopy8 31 1 2 2 1 3 1 12 71 62 7OutputCopy202020",
      "description": "D. Powerful array\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line contains two integers n and t (1 ≤ n, t ≤ 200000) — the array length and the number of queries correspondingly.Second line contains n positive integers ai (1 ≤ ai ≤ 106) — the elements of the array.Next t lines contain two positive integers l, r (1 ≤ l ≤ r ≤ n) each — the indices of the left and the right ends of the corresponding subarray.\n\nOutputOutput t lines, the i-th line of the output should contain single positive integer — the power of the i-th query subarray.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout stream (also you may use %I64d).\n\nInputCopy3 21 2 11 21 3OutputCopy36InputCopy8 31 1 2 2 1 3 1 12 71 62 7OutputCopy202020\n\nInputCopy3 21 2 11 21 3\n\nOutputCopy36\n\nInputCopy8 31 1 2 2 1 3 1 12 71 62 7\n\nOutputCopy202020\n\nNoteConsider the following array (see the second sample) and its [2, 7] subarray (elements of the subarray are colored):  Then K1 = 3, K2 = 2, K3 = 1, so the power is equal to 32·1 + 22·2 + 12·3 = 20.",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round 2 - Codeforces",
          "content": "Hello, dear participants and spectators!Let me remind you that the elimination phase of the open programming competition \"Yandex.Algorithm\" comes to an end. With it this means that the time for the most important event of the phase has come: the elimination round for the finals (finals will be held at the Yandex Summer School)! This means that today two hundred best participants of the tournament (based on the results of the previous qualification rounds) will compete to get into the top-15 of the world olympiad programming community.We hope that the round will be appreciated not only by the participants but also by the spectators, who will have the opportinity to watch the events developing for at least two hours.Please, pay attention to the problems' costs: 500, 1000, 2000, 2500, 2500. I also advise you to read all the statements, as the choice of the costs and the order is certainly subjective.Round will be rated for all the participants (including those competing hors concours).Good luck to the participants. The problems are going to be rather hard, so you'll have to do your best!I also wish a spectacular round to the rest!Round is over. According to the results, 20 participants solved at least three problems, and just one (the winner) was able to solve the fourth. The first three places were taken by Petr Mitrichev, Gennady Korotkevich and Sergey Kopeliovich. Congratulations!In addition to this, 15 leaders advanced to the finals: Petr, tourist, Burunduk1, ivan.metelsky, dzhulgakov, e-maxx, LayCurse, rng_58, pieguy, zeliboba, ktuan, levlam, wata, dolphinigle, Progger . Problems proved to be rather tough. Here's the full analysis.",
          "author": "yaro",
          "url": "https://codeforces.com/blog/entry/2026",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1661
        },
        {
          "title": "Problemset analysis (Yandex, Round 2) - Codeforces",
          "content": "A. Mirror-number. First note that if the interval contains a number with a digits and a number with b digits (where a > b) then there is no need to consider the number with b digits (as the weight of 10k is greater then the weights of the numbers less than 10k). If we consider only numbers with fixed number of digits (s + 1), then the sum of a and its reflection is constant. Thus, as product grows as multipliers with fixed sum get closer, the picture is the following: the weight grows from 10s to 5· 10s - 1, then it stays the same for 5· 10s and then it goes down, and reaches its minimum (zero) value at 10s + 1 - 1. This is the proof, and the solution is: the maximum weight is reached at either l, r or 5· 10s (we may check all the s such that 5· 10s belongs to the interval, for example). B. Tetris revisitedIt's easy to see that the field may be filled with such figures if and only if there is no isolated cell.There are many different ways to do that, we will show some of them.1. Domino filling.We construct greedy matching on the cells of our field combining them in domino-like figures (rectangles 1  ×  2).Passing through the array that represents our field (from left to right, from top to bottom) we combine the still free horizontal pairs of connected cells into the horizontal dominoes. Then we do the same thing with the still free vertical pairs. Naturally, some cells may be still free. But such cells should be adjoined with some of the dominoes (if they were not isolated). We may attach each of these cells to any of the adjoint dominoes. All resulting figures will contain no more than 5 cells, because the cells still empty after matching can not be neighbour cells and can not be adjacent to the left side of dominoes (by the virtue of the order of our matching).The last thing that has to be done is the coloring of the figures in accordance with the output format. For example, we may color them like that: color all the cells in the plane in 9 colors  (i, j) -> (i % 3) * 3 + j % 3. Then paint each domino in the color of its black cell (according to chess coloring). Each figure will have the color of the domino it grows from.2. Greedy.We pass through the array representing the field, again in the same order. Figure for any still free cell may be constructed greedily, but we have to be accurate in order to avoid appearance of new isolated cells. So we just add all the cells that do become isolated when we fill the current figure. Acting in such a fashion we will eventually get the covering by the figures of no more than 5 cells (and at least two, of course).It is possible to color the figure immediately after its formation. We only need to check the colors of all already colored adjacent figures and to take any color, different from all of them. It is not hard to see that 10 colors are enough.C. Genetic engineering.Suppose we've built a string wp of length k < n and want to know how many ways there exist to complement wp to the suitable string of length n. What parameters do we need to know in order to build it further? First of all, we need to know the index wp is covered up to (we denote it by ci and call it covering index). Also we want to have some information about what the string ends with. Here comes rather standard idea: let's find all the prefixes ALLP of the {si} and add to our state the largest prefix such that wp ends with pk (as an alternative, you may consider a vertex in a trie constructed with the collection's strings). Now I'll try to convince you that it's enough to set the things going. First of all, when we add a symbol c to wp we can easily get pk + 1 and it will be equal to the largest string in ALLP such that the string pk + c ends with (we can precalculate all the transitions in advance). So the only thing we want to know how to calculate (in order to use dynamic programming approach) is the new covering index. But we notice that it can be changed only by some string from the collection that wp + c ends with. Now we observe that it is sufficient to check only the largest from all such strings (denote it fs), and that it necessarily contains in pk + 1 (so it also can we easily precalculated for all strings in ALLP). We observe further that the new covering index depends only on the length of fs: it either equals the old one if fs doesn't cover the symbol ci + 1, or equals to (k + 1) if the fs covers that symbol. After calculating all the quantities d[k][k - cov.index][max. prefix] the required number of strings equals the sum of d[n][0][mp] for all mp.D. Powerful array.Let's solve the problem offline in O(n sqrt(t)) time and O(n) memory. For the simplicity of the reasoning let t = n.Assume we know the answer to the problem for some interval and want to find it to another one. Let us move the left end of the first one towards the left end of the second, similarly dealing with the right ends. By moving the end by one and for every value in the array maintaining the number of its appearances in the current interval, we will be able to calculate the answer and maintain the numbers of appearances at the same time in O(1). From now on we call the procedure of movement by 1 a step.Going through the queries in such a fashion, evidently, will cost us O(n^2) steps.Let p = sqrt(n). Divide the array into p equal parts Q_1, ..., Q_p. Now consider the queries of the form (Q_i, Q_j) for all i and j (there will be approx. n such queries). Clearly, there doesn't exist an order in which we can go through the queries in o(n sqrt(n)) time as the transition from any interval to the other one is done in no less than sqrt(n) steps.Nevertheless, there exists a traversal order that guarantees O(n sqrt(n)) steps in the worst case.Let's sort the query intervals according to the following rule: first come the intervals with the left ends in Q_1, then the intervals with the left ends in Q_2, and so on. And if the left ends of the two queries belong to the same part, then the interval with the more left right end is assumed to be smaller.In order to prove the stated asymptotic behavior we will follow the steps of the left and the right ends independently. We note that the left ends that belong to the same Q_i make <= n / p steps, and transition to Q_{i+1} costs no more than 2 * n / p steps. Therefore the left ends make <= n/p * n + 2*n steps (the second summand is O(n), and it's negligible).The right ends in the common group move only to the right, and this proves <= n * p steps (during the whole process) estimate. We will estimate the transition to the next Q_i at no more than n steps, so overall we get <= 2 * n * p steps.Thus, the total number of steps is no more than (n / p * n + 2 * n * p). Now we choose p = sqrt(n) which proves the statement.Solution: let us sort the queries by this rule, then make transitions from a query to the next one according to the obtained order. Note 1. There is nothing special (except for nonadditivity) with the function in the statement.Note 2. In the case of distinct n and t we can similarly prove the nice estimate 2 * n * sqrt(t), mostly nice because of its exactness (if you follow the proof carefully, you will easily construct the maximal test).E. Long sequence.Firstly let's note that there are only 49 different possible inputs. So any solution that works finite time at all tests (even if does not pass timelimit) is enough, because we can memorize all the answers. It is not necessary, of course, but may help with slow solutions.Then, let's answer a more particular question. Assume that c1, c2, ..., ck and a0, a1, ..., ak - 1 are already given and we need to check whether the sequence {ai} generated by them is long or not. We know that if it is periodic, then it is possible to find any non-zero k-tuple among k-tuples as, as + 1, ..., as + k - 1. So initial k-tuple has no real matter if only it is not zero. Thus the property of sequence \"to be long\" depends only on coefficients ci, and we may choose any convenient a0, a1, ..., ak - 1. We will now think that a0, a1, ..., ak - 2 are zeros and ak - 1 = 1.Consider the transition matrix A of our sequence: for i < k the i-th row of A is equal to (0, 0, ... 0, 1, 0, ..., 0) with 1 at (i + 1)-th position and last row of A is equal to (ck, ck - 1, ..., c2, c1).Denote by xs vector (as, as + 1, ..., as + k - 1)T.Then for any integer s we have: A· xs = xs + 1.Last is just a reformulation of the recurrent formula: an = c1 * an - 1 + c2 * an - 2 + ... + ck * an - k.Then by obvious induction we have: Ap· xs = xs + p for any p ≥ 0. Hence p is a period iff for any vector x that appears in our sequence: Ap· x = x. If the sequence is not long then it is not self-evident still that Ap is an identity matrix, because x does not take all possible values. But we have chosen x0 = (0, 0, ..., 0, 1) before, so it is obvious that vectors x0, x1, x2, ..., xk - 1 form a basis. Hence if Ap· xi = xi for any i then Ap is the identity matrix.So we just need to do the following: 1) Construct the matrix A from the coefficients ci.2) Check that A2k - 1 is the identity matrix. (If not, then 2k - 1 is not a period.)If 2k - 1 is a period, then we have to check that it is minimal. Minimal period divides any period so we only need to check the divisors of 2k - 1.3) Generate all maximal divisors of 2k - 1 and check that they are not periods (using A again).(By maximal divisor of n we mean divisors of the type n/q where q is a prime number.)Last thing we need to notice that such a sequence always exists. Moreover, amount of appropriate sets of ci is pretty large. One may prove that there are such sets (because they correspond to the coefficients of the irreducible factors of the cyclotomic polynomial over ). So we can just take them at random and check.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2028",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9770
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and t\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    // Read t queries\n    for (int i = 0; i < t; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and t\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    // Read t queries\n    for (int i = 0; i < t; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and t\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    // Read t queries\n    for (int i = 0; i < t; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    int maxAi = opt<int>(\"maxAi\", 1000000); // default maximum ai is 1e6\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // Generate array a\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } else if (type == \"same\") {\n        int val = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1, max(1, maxAi - n + 1));\n        int step = 0;\n        if (n > 1)\n            step = rnd.next(0, (maxAi - start) / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + step * i;\n            if (a[i] > maxAi) a[i] = maxAi;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(min(maxAi, n), maxAi);\n        int step = 0;\n        if (n > 1)\n            step = rnd.next(0, (start - 1) / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - step * i;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    }\n\n    // Output n and t\n    printf(\"%d %d\\n\", n, t);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate queries\n    vector<pair<int, int>> queries(t);\n\n    if (qtype == \"full\") {\n        for (int i = 0; i < t; ++i) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (qtype == \"single\") {\n        for (int i = 0; i < t; ++i) {\n            int pos = rnd.next(1, n);\n            queries[i] = make_pair(pos, pos);\n        }\n    } else if (qtype == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (qtype == \"front\") {\n        int maxLen = min(n, 10); // small subarrays at the front\n        for (int i = 0; i < t; ++i) {\n            int l = 1;\n            int r = rnd.next(l, l + maxLen - 1);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (qtype == \"back\") {\n        int maxLen = min(n, 10); // small subarrays at the back\n        for (int i = 0; i < t; ++i) {\n            int r = n;\n            int l = rnd.next(max(1, r - maxLen + 1), r);\n            queries[i] = make_pair(l, r);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < t; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    int maxAi = opt<int>(\"maxAi\", 1000000); // default maximum ai is 1e6\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // Generate array a\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    } else if (type == \"same\") {\n        int val = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1, max(1, maxAi - n + 1));\n        int step = 0;\n        if (n > 1)\n            step = rnd.next(0, (maxAi - start) / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + step * i;\n            if (a[i] > maxAi) a[i] = maxAi;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(min(maxAi, n), maxAi);\n        int step = 0;\n        if (n > 1)\n            step = rnd.next(0, (start - 1) / (n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - step * i;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxAi);\n        }\n    }\n\n    // Output n and t\n    printf(\"%d %d\\n\", n, t);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate queries\n    vector<pair<int, int>> queries(t);\n\n    if (qtype == \"full\") {\n        for (int i = 0; i < t; ++i) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (qtype == \"single\") {\n        for (int i = 0; i < t; ++i) {\n            int pos = rnd.next(1, n);\n            queries[i] = make_pair(pos, pos);\n        }\n    } else if (qtype == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (qtype == \"front\") {\n        int maxLen = min(n, 10); // small subarrays at the front\n        for (int i = 0; i < t; ++i) {\n            int l = 1;\n            int r = rnd.next(l, l + maxLen - 1);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (qtype == \"back\") {\n        int maxLen = min(n, 10); // small subarrays at the back\n        for (int i = 0; i < t; ++i) {\n            int r = n;\n            int l = rnd.next(max(1, r - maxLen + 1), r);\n            queries[i] = make_pair(l, r);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < t; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and t\n./gen -n 1 -t 1 -type random -qtype random\n./gen -n 10 -t 10 -type random -qtype random\n./gen -n 100 -t 100 -type random -qtype random\n\n# Medium n and t\n./gen -n 1000 -t 1000 -type random -qtype random\n./gen -n 5000 -t 5000 -type random -qtype random\n./gen -n 10000 -t 10000 -type random -qtype random\n\n# Max n and t with random data\n./gen -n 200000 -t 200000 -type random -qtype random\n\n# Max n and t with all same elements\n./gen -n 200000 -t 200000 -type same -maxAi 1 -qtype random\n./gen -n 200000 -t 200000 -type same -maxAi 1000000 -qtype random\n\n# Max n and t with increasing elements\n./gen -n 200000 -t 200000 -type increasing -qtype random\n\n# Max n and t with decreasing elements\n./gen -n 200000 -t 200000 -type decreasing -qtype random\n\n# Max n and t with small ai values\n./gen -n 200000 -t 200000 -maxAi 5 -type random -qtype random\n\n# Max n and t with maximum ai values\n./gen -n 200000 -t 200000 -maxAi 1000000 -type random -qtype random\n\n# Max n and t with full queries\n./gen -n 200000 -t 200000 -type random -qtype full\n\n# Max n and t with single element queries\n./gen -n 200000 -t 200000 -type random -qtype single\n\n# Max n and t with front queries (queries near beginning)\n./gen -n 200000 -t 200000 -type random -qtype front\n\n# Max n and t with back queries (queries near end)\n./gen -n 200000 -t 200000 -type random -qtype back\n\n# Max n and t with same elements and full queries\n./gen -n 200000 -t 200000 -type same -maxAi 1 -qtype full\n\n# Max n and t with increasing elements and front queries\n./gen -n 200000 -t 200000 -type increasing -qtype front\n\n# Max n and t with decreasing elements and back queries\n./gen -n 200000 -t 200000 -type decreasing -qtype back\n\n# Small n and t with same elements\n./gen -n 100 -t 100 -type same -maxAi 42 -qtype random\n\n# Medium n and t with small ai values\n./gen -n 10000 -t 10000 -maxAi 10 -type random -qtype random\n\n# Max n and t with ai in small range and single element queries\n./gen -n 200000 -t 200000 -maxAi 2 -type random -qtype single\n\n# Max n and t with ai in small range and full queries\n./gen -n 200000 -t 200000 -maxAi 10 -type random -qtype full\n\n# Max n and t with mixture of small and large ai values\n./gen -n 200000 -t 200000 -type random -maxAi 1000000 -qtype random\n\n# Max n and t with ai being large numbers\n./gen -n 200000 -t 200000 -maxAi 1000000 -type random -qtype random\n\n# Max n and t with ai being minimum possible\n./gen -n 200000 -t 200000 -maxAi 1 -type random -qtype random\n\n# Max n and t with ai alternating small and large values\n./gen -n 200000 -t 200000 -type random -maxAi 1000000 -qtype random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:17.185984",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "86/E",
      "title": "E. Long sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput contains a single integer k (2 ≤ k ≤ 50).",
      "output_spec": "OutputIf there is no long sequence for a given k, output \"-1\" (without quotes). Otherwise the first line of the output should contain k integer numbers: c1, c2, ..., ck (coefficients). The second line should contain first k elements of the sequence: a0, a1, ..., ak - 1. All of them (elements and coefficients) should be equal to 0 or 1, and at least one ci has to be equal to 1.If there are several solutions, output any.",
      "sample_tests": "ExamplesInputCopy2OutputCopy1 11 0InputCopy3OutputCopy0 1 11 1 1",
      "description": "E. Long sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput contains a single integer k (2 ≤ k ≤ 50).\n\nOutputIf there is no long sequence for a given k, output \"-1\" (without quotes). Otherwise the first line of the output should contain k integer numbers: c1, c2, ..., ck (coefficients). The second line should contain first k elements of the sequence: a0, a1, ..., ak - 1. All of them (elements and coefficients) should be equal to 0 or 1, and at least one ci has to be equal to 1.If there are several solutions, output any.\n\nInputCopy2OutputCopy1 11 0InputCopy3OutputCopy0 1 11 1 1\n\nOutputCopy1 11 0\n\nOutputCopy0 1 11 1 1\n\nNote1. In the first sample: c1 = 1, c2 = 1, so an = an - 1 + an - 2  (mod 2). Thus the sequence will be:so its period equals 3 = 22 - 1.2. In the second sample: c1 = 0, c2 = 1, c3 = 1, so an = an - 2 + an - 3  (mod 2). Thus our sequence is:and its period equals 7 = 23 - 1.Periods are colored.",
      "solutions": [
        {
          "title": "Yandex.Algorithm 2011 - Round 2 - Codeforces",
          "content": "Hello, dear participants and spectators!Let me remind you that the elimination phase of the open programming competition \"Yandex.Algorithm\" comes to an end. With it this means that the time for the most important event of the phase has come: the elimination round for the finals (finals will be held at the Yandex Summer School)! This means that today two hundred best participants of the tournament (based on the results of the previous qualification rounds) will compete to get into the top-15 of the world olympiad programming community.We hope that the round will be appreciated not only by the participants but also by the spectators, who will have the opportinity to watch the events developing for at least two hours.Please, pay attention to the problems' costs: 500, 1000, 2000, 2500, 2500. I also advise you to read all the statements, as the choice of the costs and the order is certainly subjective.Round will be rated for all the participants (including those competing hors concours).Good luck to the participants. The problems are going to be rather hard, so you'll have to do your best!I also wish a spectacular round to the rest!Round is over. According to the results, 20 participants solved at least three problems, and just one (the winner) was able to solve the fourth. The first three places were taken by Petr Mitrichev, Gennady Korotkevich and Sergey Kopeliovich. Congratulations!In addition to this, 15 leaders advanced to the finals: Petr, tourist, Burunduk1, ivan.metelsky, dzhulgakov, e-maxx, LayCurse, rng_58, pieguy, zeliboba, ktuan, levlam, wata, dolphinigle, Progger . Problems proved to be rather tough. Here's the full analysis.",
          "author": "yaro",
          "url": "https://codeforces.com/blog/entry/2026",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1661
        },
        {
          "title": "Problemset analysis (Yandex, Round 2) - Codeforces",
          "content": "A. Mirror-number. First note that if the interval contains a number with a digits and a number with b digits (where a > b) then there is no need to consider the number with b digits (as the weight of 10k is greater then the weights of the numbers less than 10k). If we consider only numbers with fixed number of digits (s + 1), then the sum of a and its reflection is constant. Thus, as product grows as multipliers with fixed sum get closer, the picture is the following: the weight grows from 10s to 5· 10s - 1, then it stays the same for 5· 10s and then it goes down, and reaches its minimum (zero) value at 10s + 1 - 1. This is the proof, and the solution is: the maximum weight is reached at either l, r or 5· 10s (we may check all the s such that 5· 10s belongs to the interval, for example). B. Tetris revisitedIt's easy to see that the field may be filled with such figures if and only if there is no isolated cell.There are many different ways to do that, we will show some of them.1. Domino filling.We construct greedy matching on the cells of our field combining them in domino-like figures (rectangles 1  ×  2).Passing through the array that represents our field (from left to right, from top to bottom) we combine the still free horizontal pairs of connected cells into the horizontal dominoes. Then we do the same thing with the still free vertical pairs. Naturally, some cells may be still free. But such cells should be adjoined with some of the dominoes (if they were not isolated). We may attach each of these cells to any of the adjoint dominoes. All resulting figures will contain no more than 5 cells, because the cells still empty after matching can not be neighbour cells and can not be adjacent to the left side of dominoes (by the virtue of the order of our matching).The last thing that has to be done is the coloring of the figures in accordance with the output format. For example, we may color them like that: color all the cells in the plane in 9 colors  (i, j) -> (i % 3) * 3 + j % 3. Then paint each domino in the color of its black cell (according to chess coloring). Each figure will have the color of the domino it grows from.2. Greedy.We pass through the array representing the field, again in the same order. Figure for any still free cell may be constructed greedily, but we have to be accurate in order to avoid appearance of new isolated cells. So we just add all the cells that do become isolated when we fill the current figure. Acting in such a fashion we will eventually get the covering by the figures of no more than 5 cells (and at least two, of course).It is possible to color the figure immediately after its formation. We only need to check the colors of all already colored adjacent figures and to take any color, different from all of them. It is not hard to see that 10 colors are enough.C. Genetic engineering.Suppose we've built a string wp of length k < n and want to know how many ways there exist to complement wp to the suitable string of length n. What parameters do we need to know in order to build it further? First of all, we need to know the index wp is covered up to (we denote it by ci and call it covering index). Also we want to have some information about what the string ends with. Here comes rather standard idea: let's find all the prefixes ALLP of the {si} and add to our state the largest prefix such that wp ends with pk (as an alternative, you may consider a vertex in a trie constructed with the collection's strings). Now I'll try to convince you that it's enough to set the things going. First of all, when we add a symbol c to wp we can easily get pk + 1 and it will be equal to the largest string in ALLP such that the string pk + c ends with (we can precalculate all the transitions in advance). So the only thing we want to know how to calculate (in order to use dynamic programming approach) is the new covering index. But we notice that it can be changed only by some string from the collection that wp + c ends with. Now we observe that it is sufficient to check only the largest from all such strings (denote it fs), and that it necessarily contains in pk + 1 (so it also can we easily precalculated for all strings in ALLP). We observe further that the new covering index depends only on the length of fs: it either equals the old one if fs doesn't cover the symbol ci + 1, or equals to (k + 1) if the fs covers that symbol. After calculating all the quantities d[k][k - cov.index][max. prefix] the required number of strings equals the sum of d[n][0][mp] for all mp.D. Powerful array.Let's solve the problem offline in O(n sqrt(t)) time and O(n) memory. For the simplicity of the reasoning let t = n.Assume we know the answer to the problem for some interval and want to find it to another one. Let us move the left end of the first one towards the left end of the second, similarly dealing with the right ends. By moving the end by one and for every value in the array maintaining the number of its appearances in the current interval, we will be able to calculate the answer and maintain the numbers of appearances at the same time in O(1). From now on we call the procedure of movement by 1 a step.Going through the queries in such a fashion, evidently, will cost us O(n^2) steps.Let p = sqrt(n). Divide the array into p equal parts Q_1, ..., Q_p. Now consider the queries of the form (Q_i, Q_j) for all i and j (there will be approx. n such queries). Clearly, there doesn't exist an order in which we can go through the queries in o(n sqrt(n)) time as the transition from any interval to the other one is done in no less than sqrt(n) steps.Nevertheless, there exists a traversal order that guarantees O(n sqrt(n)) steps in the worst case.Let's sort the query intervals according to the following rule: first come the intervals with the left ends in Q_1, then the intervals with the left ends in Q_2, and so on. And if the left ends of the two queries belong to the same part, then the interval with the more left right end is assumed to be smaller.In order to prove the stated asymptotic behavior we will follow the steps of the left and the right ends independently. We note that the left ends that belong to the same Q_i make <= n / p steps, and transition to Q_{i+1} costs no more than 2 * n / p steps. Therefore the left ends make <= n/p * n + 2*n steps (the second summand is O(n), and it's negligible).The right ends in the common group move only to the right, and this proves <= n * p steps (during the whole process) estimate. We will estimate the transition to the next Q_i at no more than n steps, so overall we get <= 2 * n * p steps.Thus, the total number of steps is no more than (n / p * n + 2 * n * p). Now we choose p = sqrt(n) which proves the statement.Solution: let us sort the queries by this rule, then make transitions from a query to the next one according to the obtained order. Note 1. There is nothing special (except for nonadditivity) with the function in the statement.Note 2. In the case of distinct n and t we can similarly prove the nice estimate 2 * n * sqrt(t), mostly nice because of its exactness (if you follow the proof carefully, you will easily construct the maximal test).E. Long sequence.Firstly let's note that there are only 49 different possible inputs. So any solution that works finite time at all tests (even if does not pass timelimit) is enough, because we can memorize all the answers. It is not necessary, of course, but may help with slow solutions.Then, let's answer a more particular question. Assume that c1, c2, ..., ck and a0, a1, ..., ak - 1 are already given and we need to check whether the sequence {ai} generated by them is long or not. We know that if it is periodic, then it is possible to find any non-zero k-tuple among k-tuples as, as + 1, ..., as + k - 1. So initial k-tuple has no real matter if only it is not zero. Thus the property of sequence \"to be long\" depends only on coefficients ci, and we may choose any convenient a0, a1, ..., ak - 1. We will now think that a0, a1, ..., ak - 2 are zeros and ak - 1 = 1.Consider the transition matrix A of our sequence: for i < k the i-th row of A is equal to (0, 0, ... 0, 1, 0, ..., 0) with 1 at (i + 1)-th position and last row of A is equal to (ck, ck - 1, ..., c2, c1).Denote by xs vector (as, as + 1, ..., as + k - 1)T.Then for any integer s we have: A· xs = xs + 1.Last is just a reformulation of the recurrent formula: an = c1 * an - 1 + c2 * an - 2 + ... + ck * an - k.Then by obvious induction we have: Ap· xs = xs + p for any p ≥ 0. Hence p is a period iff for any vector x that appears in our sequence: Ap· x = x. If the sequence is not long then it is not self-evident still that Ap is an identity matrix, because x does not take all possible values. But we have chosen x0 = (0, 0, ..., 0, 1) before, so it is obvious that vectors x0, x1, x2, ..., xk - 1 form a basis. Hence if Ap· xi = xi for any i then Ap is the identity matrix.So we just need to do the following: 1) Construct the matrix A from the coefficients ci.2) Check that A2k - 1 is the identity matrix. (If not, then 2k - 1 is not a period.)If 2k - 1 is a period, then we have to check that it is minimal. Minimal period divides any period so we only need to check the divisors of 2k - 1.3) Generate all maximal divisors of 2k - 1 and check that they are not periods (using A again).(By maximal divisor of n we mean divisors of the type n/q where q is a prime number.)Last thing we need to notice that such a sequence always exists. Moreover, amount of appropriate sets of ci is pretty large. One may prove that there are such sets (because they correspond to the coefficients of the irreducible factors of the cyclotomic polynomial over ). So we can just take them at random and check.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/2028",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9770
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 50, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 50, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 50, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint k;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read k from the input file\n    k = inf.readInt(2, 50, \"k\");\n\n    // Read the participant's output\n    string line1 = ouf.readLine();\n    if (line1 == \"-1\") {\n        quitf(_wa, \"There is a solution for k=%d but participant output -1\", k);\n    }\n\n    // Read coefficients c1, c2, ..., ck\n    stringstream ss1(line1);\n    vector<int> c;\n    int coeff;\n    while (ss1 >> coeff) {\n        if (coeff != 0 && coeff != 1) {\n            quitf(_wa, \"Coefficient c_i is not 0 or 1\");\n        }\n        c.push_back(coeff);\n    }\n    if ((int)c.size() != k) {\n        quitf(_wa, \"The number of coefficients is not equal to k (%d != %d)\", (int)c.size(), k);\n    }\n    int sum_c = accumulate(c.begin(), c.end(), 0);\n    if (sum_c == 0) {\n        quitf(_wa, \"At least one c_i must be 1, but all c_i are 0\");\n    }\n\n    // Read initial values a0, a1, ..., ak-1\n    string line2 = ouf.readLine();\n    stringstream ss2(line2);\n    vector<int> a;\n    int val;\n    while (ss2 >> val) {\n        if (val != 0 && val != 1) {\n            quitf(_wa, \"Initial value a_i is not 0 or 1\");\n        }\n        a.push_back(val);\n    }\n    if ((int)a.size() != k) {\n        quitf(_wa, \"The number of initial values is not equal to k (%d != %d)\", (int)a.size(), k);\n    }\n\n    // All checks passed\n    quitf(_ok, \"Participant's output is accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int k;\n\n    if(type == \"min\") {\n        k = 2;\n    }\n    else if(type == \"max\") {\n        k = 50;\n    }\n    else if(type == \"random\") {\n        k = rnd.next(2, 50);\n    }\n    else if(type == \"specific\") {\n        k = opt<int>(\"k\");\n        ensuref(k >= 2 && k <= 50, \"Invalid value of k: %d\", k);\n    }\n    else if(type == \"special\") {\n        /* Generate special k values that may trigger corner cases */\n        vector<int> special_k = {2, 3, 5, 7, 13, 16, 17, 19, 23, 29, 31, 32, 47, 50};\n        k = special_k[rnd.next(0, (int)special_k.size() - 1)];\n    }\n    else {\n        ensuref(false, \"Invalid type: %s\", type.c_str());\n    }\n\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int k;\n\n    if(type == \"min\") {\n        k = 2;\n    }\n    else if(type == \"max\") {\n        k = 50;\n    }\n    else if(type == \"random\") {\n        k = rnd.next(2, 50);\n    }\n    else if(type == \"specific\") {\n        k = opt<int>(\"k\");\n        ensuref(k >= 2 && k <= 50, \"Invalid value of k: %d\", k);\n    }\n    else if(type == \"special\") {\n        /* Generate special k values that may trigger corner cases */\n        vector<int> special_k = {2, 3, 5, 7, 13, 16, 17, 19, 23, 29, 31, 32, 47, 50};\n        k = special_k[rnd.next(0, (int)special_k.size() - 1)];\n    }\n    else {\n        ensuref(false, \"Invalid type: %s\", type.c_str());\n    }\n\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type specific -k 2\n./gen -type specific -k 3\n./gen -type specific -k 4\n./gen -type specific -k 5\n./gen -type specific -k 7\n./gen -type specific -k 8\n./gen -type specific -k 10\n./gen -type specific -k 13\n./gen -type specific -k 16\n./gen -type specific -k 17\n./gen -type specific -k 19\n./gen -type specific -k 23\n./gen -type specific -k 29\n./gen -type specific -k 31\n./gen -type specific -k 32\n./gen -type specific -k 47\n./gen -type specific -k 50\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n./gen -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:19.261348",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "860/A",
      "title": "A. Did you mean...",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.",
      "output_spec": "OutputPrint the given word without any changes if there are no typos.If there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopyhellnoOutputCopyhell no InputCopyabacabaOutputCopyabacaba InputCopyasdfasdfOutputCopyasd fasd f",
      "description": "A. Did you mean...\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.\n\nOutputPrint the given word without any changes if there are no typos.If there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.\n\nInputCopyhellnoOutputCopyhell no InputCopyabacabaOutputCopyabacaba InputCopyasdfasdfOutputCopyasd fasd f\n\nInputCopyhellno\n\nOutputCopyhell no\n\nInputCopyabacaba\n\nOutputCopyabacaba\n\nInputCopyasdfasdf\n\nOutputCopyasd fasd f",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 860 和字母"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,3000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,3000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,3000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nbool has_typo(const string& w) {\n    int n = w.length();\n    int count_consecutive_consonants = 0;\n    set<char> consonants_in_block;\n    for (int i = 0; i < n; ++i) {\n        char c = w[i];\n        if (is_vowel(c)) {\n            count_consecutive_consonants = 0;\n            consonants_in_block.clear();\n        } else if (islower(c)) { // consonant\n            count_consecutive_consonants += 1;\n            consonants_in_block.insert(c);\n            if (count_consecutive_consonants >= 3 && consonants_in_block.size() >= 2) {\n                return true; // Has a typo\n            }\n        } else {\n            // Invalid character (should only contain lowercase letters a-z)\n            return true; // Treat as typo\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    string input_word = inf.readToken(); // Read input word\n    int n = input_word.length();\n    vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;\n\n    // Precompute minimal number of spaces needed using dynamic programming\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i - 1; j >= 0; --j) {\n            string substring = input_word.substr(j, i - j);\n            if (!has_typo(substring)) {\n                int spaces_needed = dp[j] + (j == 0 ? 0 : 1);\n                if (spaces_needed < dp[i]) {\n                    dp[i] = spaces_needed;\n                }\n            }\n        }\n    }\n    int minimal_spaces = dp[n];\n\n    // Read contestant's output\n    string contestant_output = ouf.readLine();\n    // Reconstruct the word by removing whitespaces\n    string reconstructed_word;\n    for (char c : contestant_output) {\n        if (!isspace(c)) {\n            if (!islower(c)) { // Invalid character\n                quitf(_wa, \"Output contains invalid character '%c'\", c);\n            }\n            reconstructed_word += c;\n        }\n    }\n    // Check that reconstructed word matches input word\n    if (reconstructed_word != input_word) {\n        quitf(_wa, \"The adjusted word in your output does not match the input word after removing spaces\");\n    }\n    // Split output into words\n    vector<string> words;\n    string current_word;\n    for (size_t i = 0; i <= contestant_output.size(); ++i) {\n        if (i < contestant_output.size() && !isspace(contestant_output[i])) {\n            current_word += contestant_output[i];\n        } else {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        }\n    }\n    if (words.empty()) {\n        quitf(_wa, \"Empty output after removing spaces\");\n    }\n    // Check that each word does not have a typo\n    for (const string& w : words) {\n        if (has_typo(w)) {\n            quitf(_wa, \"Found a typo in word '%s'\", w.c_str());\n        }\n    }\n    // Check if the number of spaces used is minimal\n    int number_of_spaces_inserted = words.size() - 1;\n    if (number_of_spaces_inserted > minimal_spaces) {\n        quitf(_wa, \"Your output uses more spaces (%d) than minimally required (%d)\", number_of_spaces_inserted, minimal_spaces);\n    }\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst string vowels = \"aeiou\";\nconst string consonants = \"bcdfghjklmnpqrstvwxyz\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    string word;\n\n    if (type == \"random\") {\n        // Generate a random word of length n\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"no_typos\") {\n        // Generate a word of length n with no typos\n        // Ensure no three consonants in a row unless same consonant\n        int i = 0;\n        while (i < n) {\n            if (rnd.next(2)) {\n                // Add a vowel\n                word += vowels[rnd.next(vowels.size())];\n                ++i;\n            } else {\n                // Add consonant(s), make sure not to create typo\n                if (n - i >= 3 && rnd.next(2)) {\n                    // Add triple of same consonant\n                    char c = consonants[rnd.next(consonants.size())];\n                    word += string(3, c);\n                    i += 3;\n                } else {\n                    // Add one consonant\n                    char c = consonants[rnd.next(consonants.size())];\n                    word += c;\n                    ++i;\n                }\n            }\n        }\n\n        word = word.substr(0, n); // Ensure length is exactly n\n    } else if (type == \"max_typos\") {\n        // Generate a word of length n with maximum typos\n        // Create as many blocks of 3 consonants with at least 2 different letters\n        int i = 0;\n        while (i < n) {\n            if (n - i >= 3) {\n                // Add a typo block\n                string block;\n                char c1 = consonants[rnd.next(consonants.size())];\n                char c2 = consonants[rnd.next(consonants.size())];\n                while (c2 == c1) c2 = consonants[rnd.next(consonants.size())];\n                block += c1;\n                block += c2;\n                block += c1;\n                word += block;\n                i += 3;\n            } else {\n                // Fill the rest with vowels\n                word += vowels[rnd.next(vowels.size())];\n                ++i;\n            }\n        }\n        word = word.substr(0, n);\n    } else if (type == \"only_vowels\") {\n        // Generate a word of length n with only vowels\n        for (int i = 0; i < n; ++i) {\n            word += vowels[rnd.next(vowels.size())];\n        }\n    } else if (type == \"only_consonants\") {\n        // Generate a word of length n with only consonants\n        // We need to be careful with the exception\n        int i = 0;\n        while (i < n) {\n            if (n - i >= 3) {\n                // Create a block of same consonant to avoid typos\n                char c = consonants[rnd.next(consonants.size())];\n                word += string(3, c);\n                i += 3;\n            } else {\n                // Add random consonants\n                word += consonants[rnd.next(consonants.size())];\n                ++i;\n            }\n        }\n        word = word.substr(0, n);\n    } else if (type == \"same_consonant_blocks\") {\n        // Generate word with blocks of same consonant letters (no typos)\n        int i = 0;\n        while (i < n) {\n            int block_size = rnd.next(1, min(5, n - i)); // Block size between 1 and 5\n            char c = consonants[rnd.next(consonants.size())];\n            word += string(block_size, c);\n            i += block_size;\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate specific edge case word\n        // For example, 'xyzxyzxyz...'\n        char c1 = consonants[rnd.next(consonants.size())];\n        char c2 = consonants[rnd.next(consonants.size())];\n        while (c2 == c1) c2 = consonants[rnd.next(consonants.size())];\n        char c3 = consonants[rnd.next(consonants.size())];\n        while (c3 == c1 || c3 == c2) c3 = consonants[rnd.next(consonants.size())];\n        string block = \"\";\n        block += c1;\n        block += c2;\n        block += c3;\n        while (word.size() < n) {\n            word += block;\n        }\n        word = word.substr(0, n);\n    } else if (type == \"y_included\") {\n        // Generate words including 'y' to see if contestants treat it as vowel\n        // Since 'y' is a consonant in this problem, but it is sometimes considered a vowel\n\n        string consonants_with_y = consonants + \"y\";\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                word += vowels[rnd.next(vowels.size())];\n            } else {\n                word += consonants_with_y[rnd.next(consonants_with_y.size())];\n            }\n        }\n    } else {\n        cerr << \"Invalid type specified.\" << endl;\n        return 1;\n    }\n\n    cout << word << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst string vowels = \"aeiou\";\nconst string consonants = \"bcdfghjklmnpqrstvwxyz\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    string word;\n\n    if (type == \"random\") {\n        // Generate a random word of length n\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            word += c;\n        }\n    } else if (type == \"no_typos\") {\n        // Generate a word of length n with no typos\n        // Ensure no three consonants in a row unless same consonant\n        int i = 0;\n        while (i < n) {\n            if (rnd.next(2)) {\n                // Add a vowel\n                word += vowels[rnd.next(vowels.size())];\n                ++i;\n            } else {\n                // Add consonant(s), make sure not to create typo\n                if (n - i >= 3 && rnd.next(2)) {\n                    // Add triple of same consonant\n                    char c = consonants[rnd.next(consonants.size())];\n                    word += string(3, c);\n                    i += 3;\n                } else {\n                    // Add one consonant\n                    char c = consonants[rnd.next(consonants.size())];\n                    word += c;\n                    ++i;\n                }\n            }\n        }\n\n        word = word.substr(0, n); // Ensure length is exactly n\n    } else if (type == \"max_typos\") {\n        // Generate a word of length n with maximum typos\n        // Create as many blocks of 3 consonants with at least 2 different letters\n        int i = 0;\n        while (i < n) {\n            if (n - i >= 3) {\n                // Add a typo block\n                string block;\n                char c1 = consonants[rnd.next(consonants.size())];\n                char c2 = consonants[rnd.next(consonants.size())];\n                while (c2 == c1) c2 = consonants[rnd.next(consonants.size())];\n                block += c1;\n                block += c2;\n                block += c1;\n                word += block;\n                i += 3;\n            } else {\n                // Fill the rest with vowels\n                word += vowels[rnd.next(vowels.size())];\n                ++i;\n            }\n        }\n        word = word.substr(0, n);\n    } else if (type == \"only_vowels\") {\n        // Generate a word of length n with only vowels\n        for (int i = 0; i < n; ++i) {\n            word += vowels[rnd.next(vowels.size())];\n        }\n    } else if (type == \"only_consonants\") {\n        // Generate a word of length n with only consonants\n        // We need to be careful with the exception\n        int i = 0;\n        while (i < n) {\n            if (n - i >= 3) {\n                // Create a block of same consonant to avoid typos\n                char c = consonants[rnd.next(consonants.size())];\n                word += string(3, c);\n                i += 3;\n            } else {\n                // Add random consonants\n                word += consonants[rnd.next(consonants.size())];\n                ++i;\n            }\n        }\n        word = word.substr(0, n);\n    } else if (type == \"same_consonant_blocks\") {\n        // Generate word with blocks of same consonant letters (no typos)\n        int i = 0;\n        while (i < n) {\n            int block_size = rnd.next(1, min(5, n - i)); // Block size between 1 and 5\n            char c = consonants[rnd.next(consonants.size())];\n            word += string(block_size, c);\n            i += block_size;\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate specific edge case word\n        // For example, 'xyzxyzxyz...'\n        char c1 = consonants[rnd.next(consonants.size())];\n        char c2 = consonants[rnd.next(consonants.size())];\n        while (c2 == c1) c2 = consonants[rnd.next(consonants.size())];\n        char c3 = consonants[rnd.next(consonants.size())];\n        while (c3 == c1 || c3 == c2) c3 = consonants[rnd.next(consonants.size())];\n        string block = \"\";\n        block += c1;\n        block += c2;\n        block += c3;\n        while (word.size() < n) {\n            word += block;\n        }\n        word = word.substr(0, n);\n    } else if (type == \"y_included\") {\n        // Generate words including 'y' to see if contestants treat it as vowel\n        // Since 'y' is a consonant in this problem, but it is sometimes considered a vowel\n\n        string consonants_with_y = consonants + \"y\";\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                word += vowels[rnd.next(vowels.size())];\n            } else {\n                word += consonants_with_y[rnd.next(consonants_with_y.size())];\n            }\n        }\n    } else {\n        cerr << \"Invalid type specified.\" << endl;\n        return 1;\n    }\n\n    cout << word << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type only_vowels\n./gen -n 1 -type only_consonants\n./gen -n 1 -type max_typos\n\n./gen -n 2 -type edge_cases\n./gen -n 3 -type edge_cases\n./gen -n 5 -type y_included\n\n./gen -n 10 -type random\n./gen -n 10 -type max_typos\n\n./gen -n 100 -type no_typos\n./gen -n 200 -type same_consonant_blocks\n./gen -n 500 -type edge_cases\n\n./gen -n 1000 -type max_typos\n./gen -n 1000 -type no_typos\n./gen -n 1000 -type only_consonants\n./gen -n 1000 -type only_vowels\n\n./gen -n 1234 -type y_included\n./gen -n 2345 -type random\n\n./gen -n 2500 -type random\n./gen -n 2999 -type random\n\n./gen -n 3000 -type random\n./gen -n 3000 -type no_typos\n./gen -n 3000 -type max_typos\n./gen -n 3000 -type only_vowels\n./gen -n 3000 -type only_consonants\n./gen -n 3000 -type same_consonant_blocks\n./gen -n 3000 -type edge_cases\n./gen -n 3000 -type y_included\n\n./gen -n 500 -type y_included\n./gen -n 100 -type y_included\n./gen -n 50 -type y_included\n\n./gen -n 1500 -type edge_cases\n./gen -n 1500 -type no_typos\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:21.375102",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "860/B",
      "title": "B. Polycarp's phone book",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 70000) — the total number of phone contacts in Polycarp's contacts.The phone numbers follow, one in each line. Each number is a positive 9-digit integer starting with a digit from 1 to 9. All the numbers are distinct.",
      "output_spec": "OutputPrint exactly n lines: the i-th of them should contain the shortest non-empty sequence of digits, such that if Polycarp enters it, the Berdroid OS shows up only the i-th number from the contacts. If there are several such sequences, print any of them.",
      "sample_tests": "ExamplesInputCopy3123456789100000000100123456OutputCopy900001InputCopy4123456789193456789134567819934567891OutputCopy21938191",
      "description": "B. Polycarp's phone book\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 70000) — the total number of phone contacts in Polycarp's contacts.The phone numbers follow, one in each line. Each number is a positive 9-digit integer starting with a digit from 1 to 9. All the numbers are distinct.\n\nOutputPrint exactly n lines: the i-th of them should contain the shortest non-empty sequence of digits, such that if Polycarp enters it, the Berdroid OS shows up only the i-th number from the contacts. If there are several such sequences, print any of them.\n\nInputCopy3123456789100000000100123456OutputCopy900001InputCopy4123456789193456789134567819934567891OutputCopy21938191\n\nInputCopy3123456789100000000100123456\n\nOutputCopy900001\n\nInputCopy4123456789193456789134567819934567891\n\nOutputCopy21938191",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 860 和字母"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readEoln();\n\n    set<string> phoneNumbers;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[1-9][0-9]{8}\", \"phone number\");\n        ensure(s.length() == 9);\n        ensuref(phoneNumbers.count(s) == 0, \"Phone number %s is duplicated\", s.c_str());\n        phoneNumbers.insert(s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readEoln();\n\n    set<string> phoneNumbers;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[1-9][0-9]{8}\", \"phone number\");\n        ensure(s.length() == 9);\n        ensuref(phoneNumbers.count(s) == 0, \"Phone number %s is duplicated\", s.c_str());\n        phoneNumbers.insert(s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 70000, \"n\");\n    inf.readEoln();\n\n    set<string> phoneNumbers;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[1-9][0-9]{8}\", \"phone number\");\n        ensure(s.length() == 9);\n        ensuref(phoneNumbers.count(s) == 0, \"Phone number %s is duplicated\", s.c_str());\n        phoneNumbers.insert(s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from input file\n    int n = inf.readInt();\n    vector<string> numbers(n);\n    for (int i = 0; i < n; ++i) {\n        numbers[i] = inf.readToken(\"[1-9][0-9]{8}\", format(\"number[%d]\", i+1).c_str());\n    }\n\n    // Build substrings map\n    unordered_map<string, unordered_set<int>> substr_to_numbers;\n\n    for (int idx = 0; idx < n; ++idx) {\n        const string& s = numbers[idx];\n        int len = s.length();\n        for (int i = 0; i < len; ++i) {\n            string substr = \"\";\n            for (int j = i; j < len; ++j) {\n                substr += s[j];\n                substr_to_numbers[substr].insert(idx);\n            }\n        }\n    }\n\n    // Read contestant's output\n    for (int i = 0; i < n; ++i) {\n        // Read the sequence and ensure it's a non-empty sequence of digits\n        string seq = ouf.readToken(\"[0-9]+\", format(\"Sequence at line %d\", i+1).c_str());\n        // Check that seq is a substring of the i-th number\n        if (numbers[i].find(seq) == string::npos) {\n            quitf(_wa, \"Sequence '%s' at line %d is not a substring of the %d-th number\", seq.c_str(), i+1, i+1);\n        }\n        // Check that seq does not appear in any other number\n        auto it = substr_to_numbers.find(seq);\n        if (it != substr_to_numbers.end()) {\n            const unordered_set<int>& indices = it->second;\n            if (indices.size() > 1 || indices.find(i) == indices.end()) {\n                quitf(_wa, \"Sequence '%s' at line %d appears in multiple numbers\", seq.c_str(), i+1);\n            }\n        } else {\n            // Should not happen since seq should appear in numbers[i]\n            quitf(_fail, \"Sequence '%s' at line %d does not appear in any number\", seq.c_str(), i+1);\n        }\n    }\n\n    quitf(_ok, \"Correct answer\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> numbers;\n\n    if (type == \"random\") {\n        // Generate n distinct random 9-digit numbers starting with 1-9\n        set<string> nums;\n        while ((int)nums.size() < n) {\n            string num = to_string(rnd.next(1, 9));\n            for (int i = 1; i < 9; ++i) {\n                num += to_string(rnd.next(0, 9));\n            }\n            nums.insert(num);\n        }\n        numbers.assign(nums.begin(), nums.end());\n    } else if (type == \"prefix\") {\n        // All numbers share a common prefix\n        string prefix;\n        int prefix_length = 8; // Long common prefix\n        for (int i = 0; i < prefix_length; ++i)\n            prefix += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            string num = to_string(rnd.next(1, 9)) + prefix.substr(1);\n            num += to_string(i % 10); // Differ at the last digit\n            numbers.push_back(num);\n        }\n    } else if (type == \"suffix\") {\n        // All numbers share a common suffix\n        string suffix;\n        int suffix_length = 8; // Long common suffix\n        for (int i = 0; i < suffix_length; ++i)\n            suffix += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            string num = to_string(rnd.next(1, 9));\n            num += suffix.substr(1);\n            numbers.push_back(num);\n        }\n    } else if (type == \"onemismatch\") {\n        // All numbers are the same except for one digit\n        string base_num;\n        base_num += to_string(rnd.next(1, 9));\n        for (int i = 1; i < 9; ++i)\n            base_num += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            string num = base_num;\n            int pos = rnd.next(0, 8);\n            num[pos] = '0' + (num[pos] - '0' + i) % 10;\n            numbers.push_back(num);\n        }\n    } else if (type == \"rotations\") {\n        // Cyclic rotations of a base number\n        string base_num;\n        base_num += to_string(rnd.next(1, 9));\n        for (int i = 1; i < 9; ++i)\n            base_num += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            int shift = i % 9;\n            string num = base_num.substr(shift) + base_num.substr(0, shift);\n            if (num[0] == '0') num[0] = '1'; // Ensure first digit is not '0'\n            numbers.push_back(num);\n        }\n    } else if (type == \"repeatsubstrings\") {\n        // Numbers that have a lot of repeated substrings\n        for (int i = 0; i < n; ++i) {\n            string num = \"\";\n            string substr = \"\";\n            for (int j = 0; j < 3; ++j) {\n                substr += to_string(rnd.next(0, 9));\n            }\n            num += substr + substr + substr; // repeat substring\n            while ((int)num.length() < 9) {\n                num += to_string(rnd.next(0, 9));\n            }\n            num = num.substr(0, 9);\n            if (num[0] == '0') num[0] = '1'; // Ensure first digit is not '0'\n            numbers.push_back(num);\n        }\n    } else if (type == \"maxn\") {\n        // Max size test case with random numbers\n        set<string> nums;\n        while ((int)nums.size() < n) {\n            string num = to_string(rnd.next(1, 9));\n            for (int i = 1; i < 9; ++i) {\n                num += to_string(rnd.next(0, 9));\n            }\n            nums.insert(num);\n        }\n        numbers.assign(nums.begin(), nums.end());\n    } else {\n        // default to random\n        set<string> nums;\n        while ((int)nums.size() < n) {\n            string num = to_string(rnd.next(1, 9));\n            for (int i = 1; i < 9; ++i) {\n                num += to_string(rnd.next(0, 9));\n            }\n            nums.insert(num);\n        }\n        numbers.assign(nums.begin(), nums.end());\n    }\n\n    // Shuffle the generated numbers\n    shuffle(numbers.begin(), numbers.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (const string& num : numbers) {\n        printf(\"%s\\n\", num.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> numbers;\n\n    if (type == \"random\") {\n        // Generate n distinct random 9-digit numbers starting with 1-9\n        set<string> nums;\n        while ((int)nums.size() < n) {\n            string num = to_string(rnd.next(1, 9));\n            for (int i = 1; i < 9; ++i) {\n                num += to_string(rnd.next(0, 9));\n            }\n            nums.insert(num);\n        }\n        numbers.assign(nums.begin(), nums.end());\n    } else if (type == \"prefix\") {\n        // All numbers share a common prefix\n        string prefix;\n        int prefix_length = 8; // Long common prefix\n        for (int i = 0; i < prefix_length; ++i)\n            prefix += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            string num = to_string(rnd.next(1, 9)) + prefix.substr(1);\n            num += to_string(i % 10); // Differ at the last digit\n            numbers.push_back(num);\n        }\n    } else if (type == \"suffix\") {\n        // All numbers share a common suffix\n        string suffix;\n        int suffix_length = 8; // Long common suffix\n        for (int i = 0; i < suffix_length; ++i)\n            suffix += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            string num = to_string(rnd.next(1, 9));\n            num += suffix.substr(1);\n            numbers.push_back(num);\n        }\n    } else if (type == \"onemismatch\") {\n        // All numbers are the same except for one digit\n        string base_num;\n        base_num += to_string(rnd.next(1, 9));\n        for (int i = 1; i < 9; ++i)\n            base_num += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            string num = base_num;\n            int pos = rnd.next(0, 8);\n            num[pos] = '0' + (num[pos] - '0' + i) % 10;\n            numbers.push_back(num);\n        }\n    } else if (type == \"rotations\") {\n        // Cyclic rotations of a base number\n        string base_num;\n        base_num += to_string(rnd.next(1, 9));\n        for (int i = 1; i < 9; ++i)\n            base_num += to_string(rnd.next(0, 9));\n        for (int i = 0; i < n; ++i) {\n            int shift = i % 9;\n            string num = base_num.substr(shift) + base_num.substr(0, shift);\n            if (num[0] == '0') num[0] = '1'; // Ensure first digit is not '0'\n            numbers.push_back(num);\n        }\n    } else if (type == \"repeatsubstrings\") {\n        // Numbers that have a lot of repeated substrings\n        for (int i = 0; i < n; ++i) {\n            string num = \"\";\n            string substr = \"\";\n            for (int j = 0; j < 3; ++j) {\n                substr += to_string(rnd.next(0, 9));\n            }\n            num += substr + substr + substr; // repeat substring\n            while ((int)num.length() < 9) {\n                num += to_string(rnd.next(0, 9));\n            }\n            num = num.substr(0, 9);\n            if (num[0] == '0') num[0] = '1'; // Ensure first digit is not '0'\n            numbers.push_back(num);\n        }\n    } else if (type == \"maxn\") {\n        // Max size test case with random numbers\n        set<string> nums;\n        while ((int)nums.size() < n) {\n            string num = to_string(rnd.next(1, 9));\n            for (int i = 1; i < 9; ++i) {\n                num += to_string(rnd.next(0, 9));\n            }\n            nums.insert(num);\n        }\n        numbers.assign(nums.begin(), nums.end());\n    } else {\n        // default to random\n        set<string> nums;\n        while ((int)nums.size() < n) {\n            string num = to_string(rnd.next(1, 9));\n            for (int i = 1; i < 9; ++i) {\n                num += to_string(rnd.next(0, 9));\n            }\n            nums.insert(num);\n        }\n        numbers.assign(nums.begin(), nums.end());\n    }\n\n    // Shuffle the generated numbers\n    shuffle(numbers.begin(), numbers.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (const string& num : numbers) {\n        printf(\"%s\\n\", num.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random numbers\n./gen -n 5 -type random\n\n# Small n, prefix numbers\n./gen -n 5 -type prefix\n\n# Small n, suffix numbers\n./gen -n 5 -type suffix\n\n# Small n, one mismatch numbers\n./gen -n 5 -type onemismatch\n\n# Small n, rotations\n./gen -n 5 -type rotations\n\n# Small n, repeat substrings\n./gen -n 5 -type repeatsubstrings\n\n# n = 100, random numbers\n./gen -n 100 -type random\n\n# n = 100, prefix numbers\n./gen -n 100 -type prefix\n\n# n = 100, suffix numbers\n./gen -n 100 -type suffix\n\n# n = 100, one mismatch numbers\n./gen -n 100 -type onemismatch\n\n# n = 100, rotations\n./gen -n 100 -type rotations\n\n# n = 100, repeat substrings\n./gen -n 100 -type repeatsubstrings\n\n# n = 1000, random numbers\n./gen -n 1000 -type random\n\n# n = 1000, prefix numbers\n./gen -n 1000 -type prefix\n\n# n = 1000, suffix numbers\n./gen -n 1000 -type suffix\n\n# n = 1000, one mismatch numbers\n./gen -n 1000 -type onemismatch\n\n# n = 1000, rotations\n./gen -n 1000 -type rotations\n\n# n = 1000, repeat substrings\n./gen -n 1000 -type repeatsubstrings\n\n# n = 70000, random numbers\n./gen -n 70000 -type random\n\n# n = 70000, prefix numbers\n./gen -n 70000 -type prefix\n\n# n = 70000, suffix numbers\n./gen -n 70000 -type suffix\n\n# n = 70000, one mismatch numbers\n./gen -n 70000 -type onemismatch\n\n# n = 70000, rotations\n./gen -n 70000 -type rotations\n\n# n = 70000, repeat substrings\n./gen -n 70000 -type repeatsubstrings\n\n# Max n test case\n./gen -n 70000 -type maxn\n\n# Edge cases with minimal n\n./gen -n 1 -type random\n\n# Edge cases with minimal n\n./gen -n 2 -type onemismatch\n\n# Random, default type\n./gen -n 50000\n\n# Big n, random\n./gen -n 69999 -type random\n\n# Big n, one mismatch\n./gen -n 69999 -type onemismatch\n\n# Direct default type with max n\n./gen -n 70000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:23.322213",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "860/C",
      "title": "C. Tests Renumeration",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (1 ≤ n ≤ 105) — the number of files with tests.n lines follow, each describing a file with test. Each line has a form of \"name_i type_i\", where \"name_i\" is the filename, and \"type_i\" equals \"1\", if the i-th file contains an example test, and \"0\" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.",
      "output_spec": "OutputIn the first line print the minimum number of lines in Vladimir's script file.After that print the script file, each line should be \"move file_1 file_2\", where \"file_1\" is an existing at the moment of this line being run filename, and \"file_2\" — is a string of digits and small English letters with length from 1 to 6.",
      "sample_tests": "ExamplesInputCopy501 02 12extra 03 199 0OutputCopy4move 3 1move 01 5move 2extra 4move 99 3InputCopy21 02 1OutputCopy3move 1 3move 2 1move 3 2InputCopy51 011 1111 01111 111111 0OutputCopy5move 1 5move 11 1move 1111 2move 111 4move 11111 3",
      "description": "C. Tests Renumeration\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains single integer n (1 ≤ n ≤ 105) — the number of files with tests.n lines follow, each describing a file with test. Each line has a form of \"name_i type_i\", where \"name_i\" is the filename, and \"type_i\" equals \"1\", if the i-th file contains an example test, and \"0\" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.\n\nOutputIn the first line print the minimum number of lines in Vladimir's script file.After that print the script file, each line should be \"move file_1 file_2\", where \"file_1\" is an existing at the moment of this line being run filename, and \"file_2\" — is a string of digits and small English letters with length from 1 to 6.\n\nInputCopy501 02 12extra 03 199 0OutputCopy4move 3 1move 01 5move 2extra 4move 99 3InputCopy21 02 1OutputCopy3move 1 3move 2 1move 3 2InputCopy51 011 1111 01111 111111 0OutputCopy5move 1 5move 11 1move 1111 2move 111 4move 11111 3\n\nInputCopy501 02 12extra 03 199 0\n\nOutputCopy4move 3 1move 01 5move 2extra 4move 99 3\n\nInputCopy21 02 1\n\nOutputCopy3move 1 3move 2 1move 3 2\n\nInputCopy51 011 1111 01111 111111 0\n\nOutputCopy5move 1 5move 11 1move 1111 2move 111 4move 11111 3",
      "solutions": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces",
          "content": "858A - k-roundingNotice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k. Let's calculate the maximal powers of 2 and 5 that are divisors of n. If any of the powers is less than k then multiply the number by appropriate number of 2 and 5.The answer is also LCM(n, 10k). 858B - Which floor?We will store our current answer in some variable ans. Initially it is -1.Let's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If for any then this quantity is incorrect.Now if then we can't determine on which floor flat n is situated. Print -1. In the other case set . 858C - Did you mean...We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si - 1, si and si + 1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i + 2, not i + 1. 858D - Polycarp's phone bookFind the shortest substring of each string such that it doesn't appear in any other string as a substring. For each substring let's store the index of the string which contains this substring or  - 1 if there are more than one such string. Iterate over all substrings which have values that are not  - 1 and update the answer for the corresponding string. 858E - Tests RenumerationFirstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".Let's denote \"free positions\" such indices such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.Let's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test — otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases — either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).It's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.This approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt + 1 operations. cnt + 1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).This number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position. 858F - Wizard's TourObviously the task can be solved independently for each component. Here is the algorithm that allows you to reach exactly tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.This algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 860 和字母"
          },
          "content_length": 6080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 434 Div.1+Div.2 (and Technocup 2018 — Elimination Round 1) Editorial - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<string> filenames;\n\n    for (int i = 0; i < n; i++) {\n        string name_i = inf.readToken(\"[a-z0-9]{1,6}\", \"name_i\");\n        ensuref(filenames.count(name_i) == 0, \"Filenames must be unique\");\n        filenames.insert(name_i);\n\n        inf.readSpace();\n\n        string type_i = inf.readToken(\"[01]\", \"type_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<string> filenames;\n\n    for (int i = 0; i < n; i++) {\n        string name_i = inf.readToken(\"[a-z0-9]{1,6}\", \"name_i\");\n        ensuref(filenames.count(name_i) == 0, \"Filenames must be unique\");\n        filenames.insert(name_i);\n\n        inf.readSpace();\n\n        string type_i = inf.readToken(\"[01]\", \"type_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<string> filenames;\n\n    for (int i = 0; i < n; i++) {\n        string name_i = inf.readToken(\"[a-z0-9]{1,6}\", \"name_i\");\n        ensuref(filenames.count(name_i) == 0, \"Filenames must be unique\");\n        filenames.insert(name_i);\n\n        inf.readSpace();\n\n        string type_i = inf.readToken(\"[01]\", \"type_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\"); // Read n\n    // Read initial file names and types\n    unordered_map<string, int> files; // filename -> type\n    int total_examples = 0;\n    for (int i = 0; i < n; i++) {\n        string filename = inf.readToken(\"[a-z0-9]{1,6}\", format(\"filename[%d]\", i + 1).c_str());\n        int type = inf.readInt(0, 1, format(\"type[%d]\", i + 1).c_str());\n        files[filename] = type;\n        if (type == 1) {\n            total_examples++;\n        }\n    }\n\n    // Now, read participant's output\n    int k = ouf.readInt(0, 1000000, \"k\"); // Maximum k can be large\n    // Process the script\n    for (int i = 0; i < k; i++) {\n        string cmd = ouf.readToken();\n        if (cmd != \"move\") {\n            quitf(_wa, \"Invalid command at line %d: expected 'move', got '%s'\", i + 2, cmd.c_str());\n        }\n        string file1 = ouf.readToken(\"[a-z0-9]{1,6}\", \"file1\");\n        string file2 = ouf.readToken(\"[a-z0-9]{1,6}\", \"file2\");\n        // Check that file1 exists\n        if (files.find(file1) == files.end()) {\n            quitf(_wa, \"Attempt to move non-existent file '%s' at line %d\", file1.c_str(), i + 2);\n        }\n        int content = files[file1];\n        files.erase(file1); // Remove file1\n        files[file2] = content; // Overwrite file2 with content\n    }\n\n    // After processing the script, check that files are as required\n    // Check that existing files are exactly \"1\" to \"n\"\n    set<string> required_filenames;\n    for (int i = 1; i <= n; i++) {\n        required_filenames.insert(to_string(i));\n    }\n    set<string> existing_filenames;\n    for (const auto &p : files) {\n        existing_filenames.insert(p.first);\n    }\n    if (existing_filenames != required_filenames) {\n        quitf(_wa, \"After script execution, files are not correctly named\");\n    }\n\n    // Now, check that files \"1\" to total_examples have type 1\n    for (int i = 1; i <= total_examples; i++) {\n        string filename = to_string(i);\n        if (files[filename] != 1) {\n            quitf(_wa, \"File '%s' should be an example file\", filename.c_str());\n        }\n    }\n    // Check that files from total_examples + 1 to n have type 0\n    for (int i = total_examples + 1; i <= n; i++) {\n        string filename = to_string(i);\n        if (files[filename] != 0) {\n            quitf(_wa, \"File '%s' should be a regular test\", filename.c_str());\n        }\n    }\n    // All checks passed\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // number of files\n    int e = opt<int>(\"e\", -1); // number of examples, default -1\n    string pattern = opt<string>(\"pattern\", \"random\");\n\n    if (e == -1) {\n        // If e is not provided, default to n/2\n        e = n / 2;\n    }\n\n    assert(1 <= n && n <= 100000);\n    assert(0 <= e && e <= n);\n\n    vector<string> filenames(n);\n    vector<int> types(n);\n    set<string> used_names;\n\n    // Generate filenames and types based on the specified pattern\n    if (pattern == \"random\") {\n        // Generate random filenames and types\n        for (int i = 0; i < n; ++i) {\n            // Generate a random filename of length 1 to 6, consisting of digits and lowercase letters\n            string name;\n            do {\n                int len = rnd.next(1, 6);\n                name = \"\";\n                for (int j = 0; j < len; ++j) {\n                    int c = rnd.next(0, 35);\n                    if (c < 10) {\n                        name += char('0' + c);\n                    } else {\n                        name += char('a' + c - 10);\n                    }\n                }\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n        }\n\n        // Assign types: e examples, n - e regular tests\n        vector<int> tmp_types(n);\n        for (int i = 0; i < e; ++i) tmp_types[i] = 1;\n        for (int i = e; i < n; ++i) tmp_types[i] = 0;\n        shuffle(tmp_types.begin(), tmp_types.end());\n\n        for (int i = 0; i < n; ++i) {\n            types[i] = tmp_types[i];\n        }\n\n    } else if (pattern == \"conflict\") {\n        // Filenames conflict with target names\n        for (int i = 0; i < n; ++i) {\n            filenames[i] = to_string(i + 1);\n            used_names.insert(filenames[i]);\n        }\n        // Assign types so that examples are at the end\n        for (int i = 0; i < e; ++i) {\n            types[n - i - 1] = 1;\n        }\n        for (int i = e; i < n; ++i) {\n            types[n - i - 1] = 0;\n        }\n    } else if (pattern == \"already_correct\") {\n        // Files are already named correctly and in the correct order\n        for (int i = 0; i < n; ++i) {\n            filenames[i] = to_string(i + 1);\n            used_names.insert(filenames[i]);\n            if (i < e) {\n                types[i] = 1;\n            } else {\n                types[i] = 0;\n            }\n        }\n    } else if (pattern == \"reverse\") {\n        // Examples and regular tests are swapped\n        for (int i = 0; i < n; ++i) {\n            filenames[i] = to_string(i + 1);\n            used_names.insert(filenames[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i < n - e) {\n                types[i] = 1; // Examples at the end\n            } else {\n                types[i] = 0; // Regular tests at the beginning\n            }\n        }\n    } else if (pattern == \"worst_case\") {\n        // Generate a worst-case scenario\n        for (int i = 0; i < n; ++i) {\n            int name_num = (i + 1) % n + 1;\n            filenames[i] = to_string(name_num);\n            used_names.insert(filenames[i]);\n        }\n        // Assign types randomly\n        vector<int> tmp_types(n);\n        for (int i = 0; i < e; ++i) tmp_types[i] = 1;\n        for (int i = e; i < n; ++i) tmp_types[i] = 0;\n        shuffle(tmp_types.begin(), tmp_types.end());\n\n        for (int i = 0; i < n; ++i) {\n            types[i] = tmp_types[i];\n        }\n    } else if (pattern == \"all_examples\") {\n        // All files are examples\n        e = n;\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int num = rnd.next(1, n * 10);\n                name = to_string(num);\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n            types[i] = 1;\n        }\n    } else if (pattern == \"no_examples\") {\n        // All files are regular tests\n        e = 0;\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int num = rnd.next(1, n * 10);\n                name = to_string(num);\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n            types[i] = 0;\n        }\n    } else {\n        // Default to random pattern\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int len = rnd.next(1, 6);\n                name = \"\";\n                for (int j = 0; j < len; ++j) {\n                    int c = rnd.next(0, 35);\n                    if (c < 10) {\n                        name += char('0' + c);\n                    } else {\n                        name += char('a' + c - 10);\n                    }\n                }\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n        }\n        // Assign types\n        vector<int> tmp_types(n);\n        for (int i = 0; i < e; ++i) tmp_types[i] = 1;\n        for (int i = e; i < n; ++i) tmp_types[i] = 0;\n        shuffle(tmp_types.begin(), tmp_types.end());\n\n        for (int i = 0; i < n; ++i) {\n            types[i] = tmp_types[i];\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s %d\\n\", filenames[i].c_str(), types[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // number of files\n    int e = opt<int>(\"e\", -1); // number of examples, default -1\n    string pattern = opt<string>(\"pattern\", \"random\");\n\n    if (e == -1) {\n        // If e is not provided, default to n/2\n        e = n / 2;\n    }\n\n    assert(1 <= n && n <= 100000);\n    assert(0 <= e && e <= n);\n\n    vector<string> filenames(n);\n    vector<int> types(n);\n    set<string> used_names;\n\n    // Generate filenames and types based on the specified pattern\n    if (pattern == \"random\") {\n        // Generate random filenames and types\n        for (int i = 0; i < n; ++i) {\n            // Generate a random filename of length 1 to 6, consisting of digits and lowercase letters\n            string name;\n            do {\n                int len = rnd.next(1, 6);\n                name = \"\";\n                for (int j = 0; j < len; ++j) {\n                    int c = rnd.next(0, 35);\n                    if (c < 10) {\n                        name += char('0' + c);\n                    } else {\n                        name += char('a' + c - 10);\n                    }\n                }\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n        }\n\n        // Assign types: e examples, n - e regular tests\n        vector<int> tmp_types(n);\n        for (int i = 0; i < e; ++i) tmp_types[i] = 1;\n        for (int i = e; i < n; ++i) tmp_types[i] = 0;\n        shuffle(tmp_types.begin(), tmp_types.end());\n\n        for (int i = 0; i < n; ++i) {\n            types[i] = tmp_types[i];\n        }\n\n    } else if (pattern == \"conflict\") {\n        // Filenames conflict with target names\n        for (int i = 0; i < n; ++i) {\n            filenames[i] = to_string(i + 1);\n            used_names.insert(filenames[i]);\n        }\n        // Assign types so that examples are at the end\n        for (int i = 0; i < e; ++i) {\n            types[n - i - 1] = 1;\n        }\n        for (int i = e; i < n; ++i) {\n            types[n - i - 1] = 0;\n        }\n    } else if (pattern == \"already_correct\") {\n        // Files are already named correctly and in the correct order\n        for (int i = 0; i < n; ++i) {\n            filenames[i] = to_string(i + 1);\n            used_names.insert(filenames[i]);\n            if (i < e) {\n                types[i] = 1;\n            } else {\n                types[i] = 0;\n            }\n        }\n    } else if (pattern == \"reverse\") {\n        // Examples and regular tests are swapped\n        for (int i = 0; i < n; ++i) {\n            filenames[i] = to_string(i + 1);\n            used_names.insert(filenames[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i < n - e) {\n                types[i] = 1; // Examples at the end\n            } else {\n                types[i] = 0; // Regular tests at the beginning\n            }\n        }\n    } else if (pattern == \"worst_case\") {\n        // Generate a worst-case scenario\n        for (int i = 0; i < n; ++i) {\n            int name_num = (i + 1) % n + 1;\n            filenames[i] = to_string(name_num);\n            used_names.insert(filenames[i]);\n        }\n        // Assign types randomly\n        vector<int> tmp_types(n);\n        for (int i = 0; i < e; ++i) tmp_types[i] = 1;\n        for (int i = e; i < n; ++i) tmp_types[i] = 0;\n        shuffle(tmp_types.begin(), tmp_types.end());\n\n        for (int i = 0; i < n; ++i) {\n            types[i] = tmp_types[i];\n        }\n    } else if (pattern == \"all_examples\") {\n        // All files are examples\n        e = n;\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int num = rnd.next(1, n * 10);\n                name = to_string(num);\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n            types[i] = 1;\n        }\n    } else if (pattern == \"no_examples\") {\n        // All files are regular tests\n        e = 0;\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int num = rnd.next(1, n * 10);\n                name = to_string(num);\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n            types[i] = 0;\n        }\n    } else {\n        // Default to random pattern\n        for (int i = 0; i < n; ++i) {\n            string name;\n            do {\n                int len = rnd.next(1, 6);\n                name = \"\";\n                for (int j = 0; j < len; ++j) {\n                    int c = rnd.next(0, 35);\n                    if (c < 10) {\n                        name += char('0' + c);\n                    } else {\n                        name += char('a' + c - 10);\n                    }\n                }\n            } while (used_names.count(name));\n            used_names.insert(name);\n            filenames[i] = name;\n        }\n        // Assign types\n        vector<int> tmp_types(n);\n        for (int i = 0; i < e; ++i) tmp_types[i] = 1;\n        for (int i = e; i < n; ++i) tmp_types[i] = 0;\n        shuffle(tmp_types.begin(), tmp_types.end());\n\n        for (int i = 0; i < n; ++i) {\n            types[i] = tmp_types[i];\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s %d\\n\", filenames[i].c_str(), types[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases of varying sizes\n\n./gen -n 1 -e 1 -pattern random\n./gen -n 1 -e 0 -pattern random\n./gen -n 2 -e 1 -pattern random\n./gen -n 2 -e 0 -pattern random\n\n./gen -n 10 -e 5 -pattern random\n./gen -n 10 -e 0 -pattern random\n./gen -n 10 -e 10 -pattern random\n\n./gen -n 100 -e 50 -pattern random\n./gen -n 100 -e 0 -pattern random\n./gen -n 100 -e 100 -pattern random\n\n./gen -n 1000 -e 500 -pattern random\n./gen -n 1000 -e 0 -pattern random\n./gen -n 1000 -e 1000 -pattern random\n\n./gen -n 10000 -e 5000 -pattern random\n./gen -n 10000 -e 0 -pattern random\n./gen -n 10000 -e 10000 -pattern random\n\n./gen -n 100000 -e 50000 -pattern random\n./gen -n 100000 -e 0 -pattern random\n./gen -n 100000 -e 100000 -pattern random\n\n# Conflict pattern\n\n./gen -n 10 -e 5 -pattern conflict\n./gen -n 100 -e 50 -pattern conflict\n./gen -n 1000 -e 500 -pattern conflict\n\n# Already correct\n\n./gen -n 10 -e 5 -pattern already_correct\n./gen -n 100 -e 50 -pattern already_correct\n./gen -n 1000 -e 500 -pattern already_correct\n\n# Reverse pattern\n\n./gen -n 10 -e 5 -pattern reverse\n./gen -n 100 -e 50 -pattern reverse\n./gen -n 1000 -e 500 -pattern reverse\n\n# Worst-case scenario\n\n./gen -n 10 -e 5 -pattern worst_case\n./gen -n 100 -e 50 -pattern worst_case\n./gen -n 1000 -e 500 -pattern worst_case\n\n# All examples\n\n./gen -n 10 -pattern all_examples\n./gen -n 100 -pattern all_examples\n./gen -n 1000 -pattern all_examples\n\n# No examples\n\n./gen -n 10 -pattern no_examples\n./gen -n 100 -pattern no_examples\n./gen -n 1000 -pattern no_examples\n\n# Edge case with maximum n\n\n./gen -n 100000 -e 0 -pattern conflict\n./gen -n 100000 -e 100000 -pattern conflict\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:25.588737",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "860/D",
      "title": "D. Турне волшебника",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n, m (1 ≤ n ≤ 2·105, 0 ≤ m ≤ 2·105) — количество городов и количество дорог в Берляндии соответственно.Далее следуют описания дорог, по одному описанию в строке. Каждое описание — это пара целых чисел ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), где ai и bi — номера городов, которые соединены i-й дорогой. Гарантируется, что нет двух дорог, соединяющих одну и ту же пару городов. Все дороги — двусторонние. Города пронумерованы от 1 до n.Возможно, что сеть дорог в Берляндии не является связной.",
      "output_spec": "Выходные данныеВ первую строку выведите w — максимальное количество туров волшебника. В следующих w строках выведите сами туры в формате x, y, z — три числа через пробел, номера посещенных за тур городов в порядке посещения.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 23 22 43 44 1Выходные данныеСкопировать21 4 24 3 2Входные данныеСкопировать5 85 31 24 55 12 54 31 43 2Выходные данныеСкопировать41 4 52 3 41 5 35 2 1",
      "description": "D. Турне волшебника\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записаны два целых числа n, m (1 ≤ n ≤ 2·105, 0 ≤ m ≤ 2·105) — количество городов и количество дорог в Берляндии соответственно.Далее следуют описания дорог, по одному описанию в строке. Каждое описание — это пара целых чисел ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), где ai и bi — номера городов, которые соединены i-й дорогой. Гарантируется, что нет двух дорог, соединяющих одну и ту же пару городов. Все дороги — двусторонние. Города пронумерованы от 1 до n.Возможно, что сеть дорог в Берляндии не является связной.\n\nВходные данные\n\nВыходные данныеВ первую строку выведите w — максимальное количество туров волшебника. В следующих w строках выведите сами туры в формате x, y, z — три числа через пробел, номера посещенных за тур городов в порядке посещения.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 23 22 43 44 1Выходные данныеСкопировать21 4 24 3 2Входные данныеСкопировать5 85 31 24 55 12 54 31 43 2Выходные данныеСкопировать41 4 52 3 41 5 35 2 1\n\nВходные данныеСкопировать4 51 23 22 43 44 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 4 24 3 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 85 31 24 55 12 54 31 43 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41 4 52 3 41 5 35 2 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces",
          "content": "858A - k-ОкруглениеЗаметим, что число x заканчивается хотя бы на k нулей, если максимальная степень 2, на которую делится число x, не менее k, и максимальная степень 5, на которую делится число, также не менее k. Тогда посчитаем максимальные степени 2 и 5, на которые делится заданное n. Если одна из степеней меньше чем k, домножим на нужное количество 2 и 5.Так же можно заметить, что ответ это НОК(n, 10k). 858B - Какой этаж?Сохраним переменную ans, отвечающую за ответ, которая изначально будет равна -1.Давайте переберём количество квартир на этаже от 1 до 100. Пусть эта величина равняется cf. Теперь мы должны проверить, что такое количество квартир является корректным для заданного набора входных данных. Если хотя бы для какого-нибудь , то это количество квартир некорректно, пропускаем его.Теперь же, если , то значит, мы не можем однозначно определить, на каком этаже располагается квартира n. Выводим -1. Иначе же просто присвоим . 858C - Возможно, вы имели в виду...Давайте решать задачу жадно. Посмотрим, где находится самая левая опечатка. Очевидно, это будут такие три последовательные буквы si - 1, si и si + 1 такие, что все они согласные и среди них есть хотя бы две различные. Очевидно, что выгоднее всего будет \"порезать\" строку после позиции i, потому что в таком случае наш префикс останется корректным, а в суффикс мы перенесём всего лишь одну букву. Таким образом, можно пройти слева направо по строке и резать её в позициях с некорректными тройками букв. Только необходимо не забывать, что после разреза строки в позиции i мы должны дальше рассматривать её с позиции i + 2, а не i + 1. 858D - Телефонная книга ПоликарпаДля каждой строки необходимо найти кратчайшую подстроку, которая не встречается как подстрока в других строках. Для этого для каждой подстроки будем хранить номер строки, в которой она встречается, или  - 1, если она встречается более чем в одной строке. После этого пройдемся по всем подстрокам, для которых значение не равно  - 1, и попробуем обновить ответ для той строки, которая записана как значение. 858E - Перенумерация тестовСразу выбросим все корректные тесты из рассмотрения. Будем называть тестами типа 1 примеры, а тестами типа 2 — обычные тесты.Далее назовём свободными все такие позиции , что в оставшемся наборе нет теста с названием, соответствующим номеру i. Если есть хотя бы одна свободная позиция — это хороший случай. Иначе, очевидно, мы не сможем за одну операцию move переместить какой-нибудь тест на своё место, потому что мы сначала должны освободить строку, соответствующую его номеру.Можно показать, что нам всегда достаточно иметь хотя бы одну свободную позицию. Если она есть, то давайте поставим тест, соответствующий типу этой позиции, на своё место. Очевидно, что такой тест найдётся, иначе бы это означало, что все тесты этого типа стоят на своих местах. Далее может возникнуть два случая — либо мы освободили какую-то другую позицию (когда мы перемещали тест с названием, соответствующим некоторой корректной позиции), либо же мы не освободили ничего (когда мы перемещали тест с названием, не соответствующим какой-то корректной позиции).Выгоднее в первую очередь перемещать тесты, соответствующие корректным позициям, потому что иначе у нас просто не будут появляться новые свободные позиции для тестов. Очевидно, что когда у нас закончатся тесты, которые имеют корректные номера, мы больше никогда не получим новой свободной позиции.Делая так, можно добиться оптимального ответа, потому что будет произведено либо cnt действий, где cnt — количество некорректных тестов в изначальном наборе, либо cnt + 1 действий. cnt + 1 может получиться только тогда, когда нам иногда необходимо совершить дополнительное действие, чтобы освободить какую-либо позицию.Очевидно, что это количество действий оптимально, потому что если у нас изначально было cnt некорректных тестов, то мы должны сделать хотя бы cnt операций, чтобы переместить каждый тест на своё место. Так как выше мы показали, что если есть свободная позиция, то ей точно соответствует какой-либо некорректный тест, то единственный плохой случай возникает тогда, когда у нас нет свободных позиций. Тогда нам необходимо сделать ещё одну операцию, чтобы освободить позицию. 858F - Турне волшебникаОчевидно, что задачу можно решать для каждой компоненты связности независимо. Опишем алгоритм, который позволит набирать ровно туров, где m — количество ребер в компоненте связности. Рассмотрим произвольное дерево обхода в глубину. Будем в процессе обхода, выходя из вершины v, обрабатывать все ребра, исходящие из этой вершины вниз по дереву, а также ребро, соединяющее v с ее родителем в дереве (если v — не корень). Если ребер, идущих вниз, четное количество, разобьем их на пары. Иначе добавим в разбиение ребро, выходящее из родителя, и не будем его рассматривать для родителя. Такой алгоритм для всех вершин, кроме корня, найдет пару для каждого ребра. Будет не более одного ребра без пары, поэтому ответ будет оптимальным. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 860 和字母"
          },
          "content_length": 6637
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai (%d) must not be equal to bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple roads between the same pair of cities (%d, %d)\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai (%d) must not be equal to bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple roads between the same pair of cities (%d, %d)\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai (%d) must not be equal to bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple roads between the same pair of cities (%d, %d)\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nset<pair<int, int>> edge_set;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input graph\n    n = inf.readInt(1, 200000, \"n\");\n    m = inf.readInt(0, 200000, \"m\");\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        int b = inf.readInt(1, n, \"bi\");\n        if (a == b) {\n            quitf(_fail, \"Self-loop detected in input between city %d and itself\", a);\n        }\n        if (a > b) swap(a, b);\n        if (!edge_set.insert(make_pair(a, b)).second) {\n            quitf(_fail, \"Duplicate edge between %d and %d in input\", a, b);\n        }\n    }\n\n    int w_jury = ans.readInt(0, m / 2, \"w_jury\");\n\n    int w_participant = ouf.readInt(0, m / 2, \"w_participant\");\n\n    if (w_participant > w_jury)\n        quitf(_fail, \"Participant's number of episodes %d is larger than jury's answer %d\", w_participant, w_jury);\n    else if (w_participant < w_jury)\n        quitf(_wa, \"Participant's number of episodes %d is less than the required maximum %d\", w_participant, w_jury);\n\n    set<pair<int, int>> used_edges;\n    for (int i = 0; i < w_participant; ++i) {\n        int x = ouf.readInt(1, n, \"x\");\n        int y = ouf.readInt(1, n, \"y\");\n        int z = ouf.readInt(1, n, \"z\");\n\n        pair<int, int> edge1 = make_pair(min(x, y), max(x, y));\n        pair<int, int> edge2 = make_pair(min(y, z), max(y, z));\n\n        if (edge_set.find(edge1) == edge_set.end())\n            quitf(_wa, \"Edge between %d and %d does not exist\", x, y);\n        if (edge_set.find(edge2) == edge_set.end())\n            quitf(_wa, \"Edge between %d and %d does not exist\", y, z);\n\n        if (!used_edges.insert(edge1).second)\n            quitf(_wa, \"Edge between %d and %d is used more than once\", x, y);\n        if (!used_edges.insert(edge2).second)\n            quitf(_wa, \"Edge between %d and %d is used more than once\", y, z);\n    }\n\n    quitf(_ok, \"Number of episodes = %d\", w_participant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Helper function to generate m unique random edges between nodes 1..n\nvector<pair<int, int> > generate_random_edges(int n, int m){\n    set<pair<int, int>> edges;\n    while ((int)edges.size() < m){\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        if (a == b) continue;\n        if (a > b) swap(a, b);\n        edges.insert(make_pair(a, b));\n    }\n    return vector<pair<int, int>>(edges.begin(), edges.end());\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m_param = opt<int>(\"m\", -1); // default -1, meaning set m according to the type\n    string type = opt<string>(\"type\", \"random\");\n\n    long long max_edges = (long long)n * (n - 1) / 2;\n    max_edges = min(max_edges, (long long)2e5);\n\n    int m;\n    if (m_param == -1){\n        // Set default m according to type\n        if (type == \"chain\" || type == \"star\"){\n            m = n - 1;\n        } else if (type == \"minimal\"){\n            m = 0;\n        } else if (type == \"maximal\" || type == \"full\"){\n            m = (int)max_edges;\n        } else {\n            m = rnd.next(0, (int)max_edges);  // For random type, m is random\n        }\n    } else {\n        m = min(m_param, (int)max_edges);\n    }\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\"){\n        // Build a chain\n        for (int i = 1; i < n; ++i){\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\"){\n        for (int i = 2; i <= n; ++i){\n            edges.push_back({1, i});\n        }\n    } else if (type == \"full\") {\n        // Complete graph\n        // But m should not exceed 2e5\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i){\n            for (int j = i+1; j <= n && (int)edges.size() < m; ++j){\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"disconnected\"){\n        // Produce a graph with multiple components\n        int c = 1000;  // Component size\n        int node = 1;\n        while (node <= n){\n            int size = min(c, n - node +1);\n            // Build a chain in this component\n            for (int i = node; i < node + size -1; ++i){\n                edges.push_back({i, i+1});\n                if ((int)edges.size() >= m)\n                    break;\n            }\n            node += size;\n            if ((int)edges.size() >= m)\n                break;\n        }\n    } else if (type == \"minimal\"){\n        // No edges\n    } else if (type == \"maximal\" || type == \"full\"){\n        // Complete or near-complete graph\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i){\n            for (int j = i+1; j <= n && (int)edges.size() < m; ++j){\n                edges.push_back({i, j});\n            }\n        }\n    } else { // type == \"random\"\n        // Generate random edges\n        edges = generate_random_edges(n, m);\n    }\n\n    if ((int)edges.size() > m){\n        edges.resize(m);\n    }\n    // Shuffle edges to randomize order\n    shuffle(edges.begin(), edges.end());\n\n    cout << n << \" \" << m << endl;\n\n    // Output edges\n    for (auto edge : edges){\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Helper function to generate m unique random edges between nodes 1..n\nvector<pair<int, int> > generate_random_edges(int n, int m){\n    set<pair<int, int>> edges;\n    while ((int)edges.size() < m){\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        if (a == b) continue;\n        if (a > b) swap(a, b);\n        edges.insert(make_pair(a, b));\n    }\n    return vector<pair<int, int>>(edges.begin(), edges.end());\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m_param = opt<int>(\"m\", -1); // default -1, meaning set m according to the type\n    string type = opt<string>(\"type\", \"random\");\n\n    long long max_edges = (long long)n * (n - 1) / 2;\n    max_edges = min(max_edges, (long long)2e5);\n\n    int m;\n    if (m_param == -1){\n        // Set default m according to type\n        if (type == \"chain\" || type == \"star\"){\n            m = n - 1;\n        } else if (type == \"minimal\"){\n            m = 0;\n        } else if (type == \"maximal\" || type == \"full\"){\n            m = (int)max_edges;\n        } else {\n            m = rnd.next(0, (int)max_edges);  // For random type, m is random\n        }\n    } else {\n        m = min(m_param, (int)max_edges);\n    }\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\"){\n        // Build a chain\n        for (int i = 1; i < n; ++i){\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\"){\n        for (int i = 2; i <= n; ++i){\n            edges.push_back({1, i});\n        }\n    } else if (type == \"full\") {\n        // Complete graph\n        // But m should not exceed 2e5\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i){\n            for (int j = i+1; j <= n && (int)edges.size() < m; ++j){\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"disconnected\"){\n        // Produce a graph with multiple components\n        int c = 1000;  // Component size\n        int node = 1;\n        while (node <= n){\n            int size = min(c, n - node +1);\n            // Build a chain in this component\n            for (int i = node; i < node + size -1; ++i){\n                edges.push_back({i, i+1});\n                if ((int)edges.size() >= m)\n                    break;\n            }\n            node += size;\n            if ((int)edges.size() >= m)\n                break;\n        }\n    } else if (type == \"minimal\"){\n        // No edges\n    } else if (type == \"maximal\" || type == \"full\"){\n        // Complete or near-complete graph\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i){\n            for (int j = i+1; j <= n && (int)edges.size() < m; ++j){\n                edges.push_back({i, j});\n            }\n        }\n    } else { // type == \"random\"\n        // Generate random edges\n        edges = generate_random_edges(n, m);\n    }\n\n    if ((int)edges.size() > m){\n        edges.resize(m);\n    }\n    // Shuffle edges to randomize order\n    shuffle(edges.begin(), edges.end());\n\n    cout << n << \" \" << m << endl;\n\n    // Output edges\n    for (auto edge : edges){\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type minimal\n./gen -n 2 -m 1 -type chain\n./gen -n 3 -m 2 -type chain\n./gen -n 4 -m 0 -type minimal\n./gen -n 5 -m 4 -type chain\n./gen -n 10 -m 9 -type chain\n./gen -n 10 -type star\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 20 -type full\n./gen -n 10 -m 15 -type random\n./gen -n 100 -m 0 -type minimal\n./gen -n 100 -m 99 -type chain\n./gen -n 100 -m 4950 -type full\n./gen -n 100 -m 200 -type random\n./gen -n 100 -m 1000 -type random\n./gen -n 200 -m 20000 -type random\n./gen -n 1000 -m 0 -type minimal\n./gen -n 1000 -m 999 -type chain\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -type full\n./gen -n 10000 -m 0 -type minimal\n./gen -n 10000 -m 9999 -type chain\n./gen -n 10000 -m 200000 -type random\n./gen -n 200000 -m 0 -type minimal\n./gen -n 200000 -m 199999 -type chain\n./gen -n 200000 -m 200000 -type random\n./gen -n 200000 -m 200000 -type disconnected\n./gen -n 200000 -m 200000 -type star\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:27.841039",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "860/E",
      "title": "E. Аркадий и человек-никто",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится одно целое число n (1 ≤ n ≤ 5·105) — количество сотрудников в компании.Во второй строке находится n целых чисел p1, p2, ..., pn (0 ≤ pi ≤ n), где pi = 0, если i-й сотрудник является директором, а иначе pi равно номеру сотрудника, являющегося непосредственным начальником сотрудника номер i. Сотрудники нумеруются от 1 до n. Гарантируется, что среди этих чисел встречается ровно один 0, а также то, что директор является начальником (не обязательно непосредственным) для всех остальных сотрудников.",
      "output_spec": "Выходные данныеВыведите n целых чисел — ничтожности всех сотрудников в порядке их нумерации: z1, z2, ..., zn.",
      "sample_tests": "ПримерыВходные данныеСкопировать40 1 2 1Выходные данныеСкопировать0 2 4 2 Входные данныеСкопировать52 3 4 5 0Выходные данныеСкопировать10 6 3 1 0 Входные данныеСкопировать50 1 1 1 3Выходные данныеСкопировать0 3 3 3 5",
      "description": "E. Аркадий и человек-никто\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится одно целое число n (1 ≤ n ≤ 5·105) — количество сотрудников в компании.Во второй строке находится n целых чисел p1, p2, ..., pn (0 ≤ pi ≤ n), где pi = 0, если i-й сотрудник является директором, а иначе pi равно номеру сотрудника, являющегося непосредственным начальником сотрудника номер i. Сотрудники нумеруются от 1 до n. Гарантируется, что среди этих чисел встречается ровно один 0, а также то, что директор является начальником (не обязательно непосредственным) для всех остальных сотрудников.\n\nВходные данные\n\nВыходные данныеВыведите n целых чисел — ничтожности всех сотрудников в порядке их нумерации: z1, z2, ..., zn.\n\nВыходные данные\n\nВходные данныеСкопировать40 1 2 1Выходные данныеСкопировать0 2 4 2 Входные данныеСкопировать52 3 4 5 0Выходные данныеСкопировать10 6 3 1 0 Входные данныеСкопировать50 1 1 1 3Выходные данныеСкопировать0 3 3 3 5\n\nВходные данныеСкопировать40 1 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 2 4 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать52 3 4 5 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10 6 3 1 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать50 1 1 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 3 3 3 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Тогда:   У директора нет начальников, поэтому z1 = 0.  r(2, 1) = 2 (сотрудники 2 и 4 подходят, сотрудник 3 имеет слишком большой ранг). Поэтому z2 = r(2, 1) = 2.  Аналогично, z4 = r(4, 1) = 2.  r(3, 2) = 1 (сотрудник 3 является подчиненным 2 и имеет необходимый ранг). r(3, 1) = 3 (подходят сотрудники 2, 3, 4). Поэтому z3 = r(3, 2) + r(3, 1) = 4.",
      "solutions": [
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces",
          "content": "858A - k-ОкруглениеЗаметим, что число x заканчивается хотя бы на k нулей, если максимальная степень 2, на которую делится число x, не менее k, и максимальная степень 5, на которую делится число, также не менее k. Тогда посчитаем максимальные степени 2 и 5, на которые делится заданное n. Если одна из степеней меньше чем k, домножим на нужное количество 2 и 5.Так же можно заметить, что ответ это НОК(n, 10k). 858B - Какой этаж?Сохраним переменную ans, отвечающую за ответ, которая изначально будет равна -1.Давайте переберём количество квартир на этаже от 1 до 100. Пусть эта величина равняется cf. Теперь мы должны проверить, что такое количество квартир является корректным для заданного набора входных данных. Если хотя бы для какого-нибудь , то это количество квартир некорректно, пропускаем его.Теперь же, если , то значит, мы не можем однозначно определить, на каком этаже располагается квартира n. Выводим -1. Иначе же просто присвоим . 858C - Возможно, вы имели в виду...Давайте решать задачу жадно. Посмотрим, где находится самая левая опечатка. Очевидно, это будут такие три последовательные буквы si - 1, si и si + 1 такие, что все они согласные и среди них есть хотя бы две различные. Очевидно, что выгоднее всего будет \"порезать\" строку после позиции i, потому что в таком случае наш префикс останется корректным, а в суффикс мы перенесём всего лишь одну букву. Таким образом, можно пройти слева направо по строке и резать её в позициях с некорректными тройками букв. Только необходимо не забывать, что после разреза строки в позиции i мы должны дальше рассматривать её с позиции i + 2, а не i + 1. 858D - Телефонная книга ПоликарпаДля каждой строки необходимо найти кратчайшую подстроку, которая не встречается как подстрока в других строках. Для этого для каждой подстроки будем хранить номер строки, в которой она встречается, или  - 1, если она встречается более чем в одной строке. После этого пройдемся по всем подстрокам, для которых значение не равно  - 1, и попробуем обновить ответ для той строки, которая записана как значение. 858E - Перенумерация тестовСразу выбросим все корректные тесты из рассмотрения. Будем называть тестами типа 1 примеры, а тестами типа 2 — обычные тесты.Далее назовём свободными все такие позиции , что в оставшемся наборе нет теста с названием, соответствующим номеру i. Если есть хотя бы одна свободная позиция — это хороший случай. Иначе, очевидно, мы не сможем за одну операцию move переместить какой-нибудь тест на своё место, потому что мы сначала должны освободить строку, соответствующую его номеру.Можно показать, что нам всегда достаточно иметь хотя бы одну свободную позицию. Если она есть, то давайте поставим тест, соответствующий типу этой позиции, на своё место. Очевидно, что такой тест найдётся, иначе бы это означало, что все тесты этого типа стоят на своих местах. Далее может возникнуть два случая — либо мы освободили какую-то другую позицию (когда мы перемещали тест с названием, соответствующим некоторой корректной позиции), либо же мы не освободили ничего (когда мы перемещали тест с названием, не соответствующим какой-то корректной позиции).Выгоднее в первую очередь перемещать тесты, соответствующие корректным позициям, потому что иначе у нас просто не будут появляться новые свободные позиции для тестов. Очевидно, что когда у нас закончатся тесты, которые имеют корректные номера, мы больше никогда не получим новой свободной позиции.Делая так, можно добиться оптимального ответа, потому что будет произведено либо cnt действий, где cnt — количество некорректных тестов в изначальном наборе, либо cnt + 1 действий. cnt + 1 может получиться только тогда, когда нам иногда необходимо совершить дополнительное действие, чтобы освободить какую-либо позицию.Очевидно, что это количество действий оптимально, потому что если у нас изначально было cnt некорректных тестов, то мы должны сделать хотя бы cnt операций, чтобы переместить каждый тест на своё место. Так как выше мы показали, что если есть свободная позиция, то ей точно соответствует какой-либо некорректный тест, то единственный плохой случай возникает тогда, когда у нас нет свободных позиций. Тогда нам необходимо сделать ещё одну операцию, чтобы освободить позицию. 858F - Турне волшебникаОчевидно, что задачу можно решать для каждой компоненты связности независимо. Опишем алгоритм, который позволит набирать ровно туров, где m — количество ребер в компоненте связности. Рассмотрим произвольное дерево обхода в глубину. Будем в процессе обхода, выходя из вершины v, обрабатывать все ребра, исходящие из этой вершины вниз по дереву, а также ребро, соединяющее v с ее родителем в дереве (если v — не корень). Если ребер, идущих вниз, четное количество, разобьем их на пары. Иначе добавим в разбиение ребро, выходящее из родителя, и не будем его рассматривать для родителя. Такой алгоритм для всех вершин, кроме корня, найдет пару для каждого ребра. Будет не более одного ребра без пары, поэтому ответ будет оптимальным. 860E - Аркадий и человек-никто First of all, ans[v] = ans[parent[v]] + depth[v] + ans'[v], where ans'[v] is the sum of (number of descendants of the rank depth[v]) for all predecessors of v. All we need is to compute ans'[v] now. Let's make a dfs in the graph. Let the dfs(v) return a vector ret[v] such that ret[v][d] is the following tuple: (number of vertices on depth d in subtree of v, some vertex x with depth d in the subtree of v, the ans'[x] if we consider only predecessors in the subtree of v). Also let's build some structure so that we can easily restore answers in this subtree if we know the final value of ans'[x]. We will see what is this structure later. To compute ret[v] we need to be able to merge two rets of its sons. Let's say we merge tuple (cnta, a, ans'[a]) with (cntb, b, ans'[b]). Then all we need to do is: ans'[b] +  = depth[v] * cnta, ans'[a] +  = depth[v] * cntb, return (cnta + cntb, a, ans'[a]) as the result. However, we must also be able to restore ans'[b] after the dfs is complete (remind the unknown structure). So after performing ans'[b] +  = depth[v] * cnta let's add an edge a → b to a new graph with weight ans'[a] - ans'[b]. Note that the difference between these values will be the same all the time after the tuples are merged, so using this edge we will be able to restore the answer ans'[b]. After the dfs is done, run another dfs on the new graph to restore the values ans'[v] and then ans[v]. To perform the second step fast, we need to note that we can always merge smaller rets into larger, and move them in O(1) into parents. Since each tuple is merged into a larger vector only once, this solution works in total in O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54604",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 860\\s*E"
          },
          "content_length": 6637
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 1",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Технокубок 2018 — Отборочный Раунд 1 (и открытые раунды Codeforces Round 434 Div.1+Div.2) - Codeforces - Code 2",
          "code": "while (par[cur] != -1 && child[par[cur]] == 1)\n\tpar[cur] = par[par[cur]];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54604",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 500000 + 5;\n\nvector<int> g[MAXN];\nint color[MAXN];\n\nvoid dfs(int u) {\n    color[u] = 1;\n    for (int v : g[u]) {\n        if (color[v] == 0) {\n            dfs(v);\n        } else if (color[v] == 1) {\n            ensuref(false, \"Cycle detected involving employees %d and %d\", u, v);\n        }\n    }\n    color[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n\n    int zero_p = 0;\n    int ceo = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (pi == 0) {\n            zero_p++;\n            ceo = i; // index of CEO\n        } else {\n            ensuref(pi >= 1 && pi <= n, \n                \"Manager id p[%d]=%d is out of range [1, n]\", i+1, pi);\n            ensuref(pi != i+1, \n                \"Employee %d cannot be their own manager\", i+1);\n        }\n    }\n\n    ensuref(zero_p == 1, \n        \"There must be exactly one CEO (p_i=0), found %d\", zero_p);\n\n    // Build the hierarchy\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        int u = pi;\n        int v = i + 1; // employee id\n\n        if (pi != 0) {\n            g[u].push_back(v); // u is the manager of v\n        }\n    }\n\n    memset(color, 0, sizeof(color));\n\n    int ceo_id = ceo + 1; // Employee IDs are from 1 to n\n\n    dfs(ceo_id);\n\n    // Check that all employees are connected to the CEO\n    for (int i = 1; i <= n; ++i) {\n        ensuref(color[i] == 2, \n            \"Employee %d is not connected to the CEO\", i);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 500000 + 5;\n\nvector<int> g[MAXN];\nint color[MAXN];\n\nvoid dfs(int u) {\n    color[u] = 1;\n    for (int v : g[u]) {\n        if (color[v] == 0) {\n            dfs(v);\n        } else if (color[v] == 1) {\n            ensuref(false, \"Cycle detected involving employees %d and %d\", u, v);\n        }\n    }\n    color[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n\n    int zero_p = 0;\n    int ceo = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (pi == 0) {\n            zero_p++;\n            ceo = i; // index of CEO\n        } else {\n            ensuref(pi >= 1 && pi <= n, \n                \"Manager id p[%d]=%d is out of range [1, n]\", i+1, pi);\n            ensuref(pi != i+1, \n                \"Employee %d cannot be their own manager\", i+1);\n        }\n    }\n\n    ensuref(zero_p == 1, \n        \"There must be exactly one CEO (p_i=0), found %d\", zero_p);\n\n    // Build the hierarchy\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        int u = pi;\n        int v = i + 1; // employee id\n\n        if (pi != 0) {\n            g[u].push_back(v); // u is the manager of v\n        }\n    }\n\n    memset(color, 0, sizeof(color));\n\n    int ceo_id = ceo + 1; // Employee IDs are from 1 to n\n\n    dfs(ceo_id);\n\n    // Check that all employees are connected to the CEO\n    for (int i = 1; i <= n; ++i) {\n        ensuref(color[i] == 2, \n            \"Employee %d is not connected to the CEO\", i);\n    }\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 500000 + 5;\n\nvector<int> g[MAXN];\nint color[MAXN];\n\nvoid dfs(int u) {\n    color[u] = 1;\n    for (int v : g[u]) {\n        if (color[v] == 0) {\n            dfs(v);\n        } else if (color[v] == 1) {\n            ensuref(false, \"Cycle detected involving employees %d and %d\", u, v);\n        }\n    }\n    color[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n\n    int zero_p = 0;\n    int ceo = -1;\n\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        if (pi == 0) {\n            zero_p++;\n            ceo = i; // index of CEO\n        } else {\n            ensuref(pi >= 1 && pi <= n, \n                \"Manager id p[%d]=%d is out of range [1, n]\", i+1, pi);\n            ensuref(pi != i+1, \n                \"Employee %d cannot be their own manager\", i+1);\n        }\n    }\n\n    ensuref(zero_p == 1, \n        \"There must be exactly one CEO (p_i=0), found %d\", zero_p);\n\n    // Build the hierarchy\n    for (int i = 0; i < n; ++i) {\n        int pi = p[i];\n        int u = pi;\n        int v = i + 1; // employee id\n\n        if (pi != 0) {\n            g[u].push_back(v); // u is the manager of v\n        }\n    }\n\n    memset(color, 0, sizeof(color));\n\n    int ceo_id = ceo + 1; // Employee IDs are from 1 to n\n\n    dfs(ceo_id);\n\n    // Check that all employees are connected to the CEO\n    for (int i = 1; i <= n; ++i) {\n        ensuref(color[i] == 2, \n            \"Employee %d is not connected to the CEO\", i);\n    }\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n + 1); // p[1..n], parents of nodes 1..n\n\n    if (type == \"chain\") {\n        /* A tree that has degenerated into a chain */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        /* A tree that has degenerated into a star */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        /* A balanced binary tree */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i / 2;\n        }\n    } else if (type == \"unbalanced\") {\n        /* An unbalanced tree */\n        p[1] = 0; // CEO\n        p[2] = 1;\n        for (int i = 3; i <= n; ++i) {\n            p[i] = 2;\n        }\n    } else if (type == \"deep\") {\n        /* A tree with a deep branch */\n        p[1] = 0; // CEO\n        int mid = n / 2;\n        for (int i = 2; i <= mid; ++i) {\n            p[i] = i - 1;\n        }\n        for (int i = mid + 1; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (type == \"random\") {\n        /* A random tree */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    /* Shuffle the node indices */\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    vector<int> new_p(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        int old_node = i;\n        int new_node = perm[i];\n\n        if (p[old_node] == 0)\n            new_p[new_node] = 0;\n        else\n            new_p[new_node] = perm[p[old_node]];\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output p[1..n] */\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", new_p[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n + 1); // p[1..n], parents of nodes 1..n\n\n    if (type == \"chain\") {\n        /* A tree that has degenerated into a chain */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        /* A tree that has degenerated into a star */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        /* A balanced binary tree */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i / 2;\n        }\n    } else if (type == \"unbalanced\") {\n        /* An unbalanced tree */\n        p[1] = 0; // CEO\n        p[2] = 1;\n        for (int i = 3; i <= n; ++i) {\n            p[i] = 2;\n        }\n    } else if (type == \"deep\") {\n        /* A tree with a deep branch */\n        p[1] = 0; // CEO\n        int mid = n / 2;\n        for (int i = 2; i <= mid; ++i) {\n            p[i] = i - 1;\n        }\n        for (int i = mid + 1; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (type == \"random\") {\n        /* A random tree */\n        p[1] = 0; // CEO\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    /* Shuffle the node indices */\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    vector<int> new_p(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        int old_node = i;\n        int new_node = perm[i];\n\n        if (p[old_node] == 0)\n            new_p[new_node] = 0;\n        else\n            new_p[new_node] = perm[p[old_node]];\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output p[1..n] */\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", new_p[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases for manual verification\n./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type binary\n./gen -n 1 -type random\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type random\n\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type binary\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type random\n\n# Medium-sized test cases\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type random\n./gen -n 1000 -type unbalanced\n./gen -n 1000 -type deep\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type random\n./gen -n 10000 -type unbalanced\n./gen -n 10000 -type deep\n\n# Large test cases\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type random\n./gen -n 100000 -type unbalanced\n./gen -n 100000 -type deep\n\n# Maximum size test cases\n./gen -n 500000 -type chain\n./gen -n 500000 -type star\n./gen -n 500000 -type binary\n./gen -n 500000 -type random\n./gen -n 500000 -type unbalanced\n./gen -n 500000 -type deep\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:29.822815",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "862/A",
      "title": "A. Mahmoud and Ehab and the MEX",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and x (1 ≤ n ≤ 100, 0 ≤ x ≤ 100) — the size of the set Dr. Evil owns, and the desired MEX.The second line contains n distinct non-negative integers not exceeding 100 that represent the set.",
      "output_spec": "OutputThe only line should contain one integer — the minimal number of operations Dr. Evil should perform.",
      "sample_tests": "ExamplesInputCopy5 30 4 5 6 7OutputCopy2InputCopy1 00OutputCopy1InputCopy5 01 2 3 4 5OutputCopy0",
      "description": "A. Mahmoud and Ehab and the MEX\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and x (1 ≤ n ≤ 100, 0 ≤ x ≤ 100) — the size of the set Dr. Evil owns, and the desired MEX.The second line contains n distinct non-negative integers not exceeding 100 that represent the set.\n\nOutputThe only line should contain one integer — the minimal number of operations Dr. Evil should perform.\n\nInputCopy5 30 4 5 6 7OutputCopy2InputCopy1 00OutputCopy1InputCopy5 01 2 3 4 5OutputCopy0\n\nInputCopy5 30 4 5 6 7\n\nOutputCopy2\n\nInputCopy1 00\n\nOutputCopy1\n\nInputCopy5 01 2 3 4 5\n\nOutputCopy0\n\nNoteFor the first test case Dr. Evil should add 1 and 2 to the set performing 2 operations.For the second test case Dr. Evil should erase 0 from the set. After that, the set becomes empty, so the MEX of it is 0.In the third test case the set is already evil.",
      "solutions": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'm glad to announce that on Sep/19/2017 15:05 UTC Codeforces Round #435 for the second division will take place. As usual, First division participants can take part out of competition.This round was prepared by me.I'd like to thank mohammedehab2002 for writing the statements and the editorials and testing the round, Livace,Alladdin,300iq and cdkrot for testing the round, vintage_Vlad_Makeev for helping us in contest preparation, translating the statements into Russian and making one of the problems more interesting, KAN and Ahmad_Elsagheer for giving their opinions and thoughts about the problems and MikeMirzayanov for the great Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them.The scoring distribution will be announced later.UPD. 500-1000-1500-1750-2000-2750**UPD Congratulations to the winners:Div1+Div2:1-Shik2-KassiJulgus3-I_love_Tanya_Romanova4-MrDindows5-scanhexDiv2:1-KassiJulgus2-scanhex3-qscqesze84-UpdateRatingOrRIOT5-NickRUPD editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54581",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1012
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces",
          "content": "862A - Mahmoud and Ehab and the MEXOne can see that in the final set all the elements less than x should exist, x shouldn't exist and any element greater than x doesn't matter, so we will count the number of elements less than x that don't exist in the initial set and add this to the answer, If x exists we'll add 1 to the answer because x should be removed .Time complexity : O(n + x) .Solution link (me) : https://pastebin.com/ALfcu8Ab .Solution link (mahmoudbadawy) : https://pastebin.com/yXLkmA5F .862B - Mahmoud and Ehab and the bipartitenessThe tree itself is bipartite so we can run a dfs to partition the tree into the 2 sets (called bicoloring), We can't add an edge between any 2 nodes in the same set and we can add an edge between every 2 nodes in different sets, so let the number of nodes in the left set be l and the number of nodes in the right set be r, The maximum number of edges that can exist is l * r, but n - 1 edges already exist so the maximum number of edges to be added is l * r - (n - 1).Time complexity : O(n) .Solution link (me) : https://pastebin.com/w3bF7gKS .Solution link (mahmoudbadawy) : https://pastebin.com/PMpte7nC .862C - Mahmoud and Ehab and the xorn = 2, x = 0 is the only case with answer \"NO\" .Let pw = 217 .First print 1, 2, ..., n - 3 (The first n - 3 positive integers), Let their bitwise-xor sum be y, If x = y You can add pw, pw * 2 and , Otherwise you can add 0, pw and , We handled the case x = y in a different way because if we add 0, pw and in this case, Then it's like adding 0, pw and pw, pw appears twice so we'll get wrong answer.Handle n = 1 (print x) and n = 2 (print 0 and x) .Solution link (mahmoudbadawy) : https://pastebin.com/w67KUY5u .862D - Mahmoud and Ehab and the binary stringIn the editorial we suppose that the answer of some query is the number of correct guessed positions which is equal to n minus hamming distance, The solutions in this editorial consider the answer of a query as n minus real answer, For convenience.Common things : Let zero(l, r) be a function that returns the number of zeros in the interval [l;r] minus the number of ones in it, We can find it in one query after a preprocessing query, The preprocessing query is 1111..., Let its answer be stored in all, If we made a query with a string full of ones except for the interval [l;r] which will be full of zeros, If this query's answer is cur, zero(l, r) = cur - all, That's because all is the number of ones in the interval [l;r] plus some trash and cur is the number of zeros in the interval plus the same trash .First solution by mahmoudbadawyLet's have a searching interval, initially this interval is [1;n] (The whole string), Let's repeat this until we reach our goal, Let mid = (l + r) / 2 Let's query to get zero(l, mid), If it's equal to r - l + 1, This interval is full of zeros so we can print any index in it as the index with value 0 and continue searching for an index with the value 1 in the interval [mid + 1;r], But if its value is equal to l - r - 1, This interval is full of ones so we can print any index in it as the index with value 1 and continue searching for a 0 in the interval [mid + 1;r], Otherwise the interval contains both values so we can continue searching for both in the interval [l;mid], Every time the searching interval length must be divided by 2 in any case so we perform O(log(n)) queries .Second solution by meLet's send 1111... and let the answer be ans1, Let's send 0111... and let the answer be ans0, We now know the value in the first index (1 if ans1 > ans0, 0 otherwise), We can binary search for the first index where the non-found value exists, which is to binary search on the first value x where zero(2, x) * sign(non - found bit value) ≠ x - 1 where sign(y) is 1 if y = 0,  - 1 otherwise .Solution link (me) : https://pastebin.com/Bc6q7TKv .Solution link (mahmoudbadawy) : https://pastebin.com/RMyLDMxw .862E - Mahmoud and Ehab and the functionLet's write f(j) in another way:-Now we have 2 sums, The first one is constant (doesn't depend on j), For the second sum we can calculate all its possible values using sliding window technique, Now we want a data-structure that takes the value of the first sum and chooses the best second sum from all the choices .observation: We don't have to try all the possible values of f(j) to minimize the expression, If the first sum is c, We can try only the least value greater than  - c and the greatest value less than  - c ( - c not c because we are minimizing c + second not c - second) because the absolute value means the distance between the two values on the number line, Any other value will be further than at least one of the chosen values, To do this we can keep all the values of f(j) sorted and try the elements numbered lower_bound(-c) and lower_bound(-c)-1 and choose the better (In short we're trying the values close to  - c only).Now we have a data-structure that can get us the minimum value of the expression once given the value of the first sum in O(log(n)), Now we want to keep track of the value of the first sum .Let the initial value be c, In each update, If the length of the updated interval is even, The sum won't change because x will be added as many times as it's subtracted, Otherwise x will be added to c or subtracted from c depending of the parity of l (the left-bound of the interval) .Time complexity : O(n + (m + q)log(m)) .Solution link (me) : https://pastebin.com/u828DjcS .Solution link (mahmoudbadawy) : https://pastebin.com/dA3K8nfK .862F - Mahmoud and Ehab and the final stageFirst, Let's get rid of the LCP part .observation: , That could make us transform the LCP part into a minimization part by making an array lcp where lcpi = LCP(si, si + 1), You could calculate it naively, And when an update happens at index a, You should update lcpa (If exists) and lcpa - 1 (If exists) naively .Now the problem reduces to finding a ≤ l ≤ r ≤ b that maximizes the value:-, If we have a histogram where the ith column has height lcpi, The the size of the largest rectangle that fits in the columns from l to r - 1 is , That's close to our formula not the same but it's not a problem (You'll see how to fix it later), so to get rid of finding the l and r part, We can make that histogram and the answer for a query will be the largest rectangle in the subhistogram that contains the columns from a to b - 1, One of the ways to solve it is to try some heights h and see the maximum width we can achieve if h was the height, call it w, and maximize with h * w, To solve the slight difference in formulas problem we'll just maximize with h * (w + 1)!!Let BU be a value the we'll choose later, We have 2 cases for our largest rectangle's height h, It could be either h ≤ BU or h > BU, We will solve both problems separately.For h ≤ BU we can maintain BU segment trees, Segment tree number i has 1 at index x if lcpx ≥ i and 0 otherwise, When we query, It should get us the longest subsegment of ones in the query range, Let's see what we need for our merging operation, If we want the answer for the longest subsegment of ones in a range [l;r], Let mid = (l + r) / 2, Then the answer is the maximum between the answer of [l;mid], The answer of [mid + 1;r], And the maximum suffix of ones in the range [l;mid] added to the maximum prefix of ones in the range [mid + 1;r] . So we need to keep all these information in our node and also the length of the interval, As it's a well-known problem I won't get into more detail. Back to our problem, We can loop over all h ≤ BU, Let the answer for the query on range [a;b - 1] in segment tree number h be w, The maximum width of a rectangle of height h in this range is w and we'll maximize our answer with h * (w + 1) .For h > BU, Let's call a column of height greater than BU big, The heights we'll try are the heights of the big columns in the range, We don't have to try all the heights greater the BU, There are at most big columns (Where tot is the total length of strings in input), Let's keep them in a set, When an update happens, You should add the column to the set or remove it depending on its new height, The set's size can't exceed now, Let's see how to answer a query, Let's loop over the big columns in range [a;b - 1] only, If 2 of them aren't consecutive then the column after the first can't be big and the column before the second either, That's because if it were big, It would be in our set, So we can use this observation by making a new histogram with the big columns in the range only, And put a column with height 0 between any non-consecutive two, And get the largest rectangle in this histogram by the stack way for example in , The stack way will get us the maximum width w we can achieve for a rectangle containing column number i, We'll maximize with lcpi * (w + 1).Also the answer for our main formula can be an interval of length one, All what I mentioned doesn't cover this, You should maintain another segment tree that gets the maximum length of a string in a range for this .Maximize all what we got, You have the answer, Now it's time to choose BU, It's optimal in time to choose BU near (Reason in tfg's comment below) .Optimization: The longest subsegment of ones problem is solved by BU segment trees and each one has 4 integers in each node, You can make them 2 integers (max prefix and suffix of ones) and make another only one segment tree that has the rest of the integers, That would divide the memory by 2 .Time complexity : Thanks to vintage_Vlad_Makeev for making it harder and more interesting .Solution link (vintage_Vlad_Makeev) : https://pastebin.com/vQ4RJqh0 .Solution link (mahmoudbadawy) : https://pastebin.com/t3Vetzwf .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 862\\s*A"
          },
          "content_length": 9689
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 1",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 2",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 3",
          "code": "(rand()<<15)|rand()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 4",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 5",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 6",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 10",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 11",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 12",
          "code": "if(fans[sizea]==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 1",
          "code": "lower_bound(-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 2",
          "code": "lower_bound(-c)-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 3",
          "code": "[100000+1, 1000000/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 4",
          "code": "{pw, pw*2, pw^(pw*2)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 5",
          "code": "{0, pw, pw^x^y}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 6",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 7",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 100, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100);\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All integers in the set must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 100, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100);\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All integers in the set must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 100, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100);\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(int(s.size()) == n, \"All integers in the set must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    set<int> S;\n    if(type == \"minimal\") {\n        /* Generate minimal test case */\n        S.insert(0);\n        n = 1;\n        x = 0;\n    } else if(type == \"maximal\") {\n        /* Generate maximal test case */\n        n = 100;\n        x = 100;\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"no_changes_needed\") {\n        /* Generate a set where MEX(S) == x */\n        for(int i = 0; i < x; i++)\n            S.insert(i);\n        /* Add extra random elements */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n    } else if(type == \"need_to_add\") {\n        /* Generate a set where MEX(S) < x, need to add elements */\n        vector<int> nums;\n        for(int i = 0; i < x; i++) nums.push_back(i);\n        /* Missing some numbers in [0, x-1] */\n        int missing = rnd.next(1, max(1,x));\n        shuffle(nums.begin(), nums.end());\n        for(int i = 0; i < x - missing; i++)\n            S.insert(nums[i]);\n        /* Add extra random elements */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n    } else if(type == \"need_to_remove\") {\n        /* Generate a set where MEX(S) > x, need to remove elements */\n        for(int i = 0; i <= x; i++)\n            S.insert(i);\n        /* Add extra elements less than or equal to x */\n        int extra = rnd.next(0, x);\n        for(int i = 0; i < extra; i++) {\n            int val = rnd.next(0,x);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n        /* Add extra random elements */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n    } else if(type == \"x_in_S\") {\n        /* Ensure x is in S */\n        S.insert(x);\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"x_not_in_S\") {\n        /* Ensure x is not in S */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(val == x) continue;\n            S.insert(val);\n        }\n    } else if(type == \"random\") {\n        /* Generate a random set */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"x_equals_0\") {\n        /* Set x = 0 */\n        x = 0;\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"x_equals_100\") {\n        /* Set x = 100 */\n        x = 100;\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"n_equals_1\") {\n        /* Set n = 1 */\n        n = 1;\n        int val = rnd.next(0,100);\n        S.insert(val);\n    } else {\n        /* Default random case */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    }\n\n    /* Output n and x */\n    printf(\"%d %d\\n\", n, x);\n\n    /* Output the set */\n    auto it = S.begin();\n    for(int i = 0; i < n; i++, ++it) {\n        printf(\"%d%c\", *it, (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    set<int> S;\n    if(type == \"minimal\") {\n        /* Generate minimal test case */\n        S.insert(0);\n        n = 1;\n        x = 0;\n    } else if(type == \"maximal\") {\n        /* Generate maximal test case */\n        n = 100;\n        x = 100;\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"no_changes_needed\") {\n        /* Generate a set where MEX(S) == x */\n        for(int i = 0; i < x; i++)\n            S.insert(i);\n        /* Add extra random elements */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n    } else if(type == \"need_to_add\") {\n        /* Generate a set where MEX(S) < x, need to add elements */\n        vector<int> nums;\n        for(int i = 0; i < x; i++) nums.push_back(i);\n        /* Missing some numbers in [0, x-1] */\n        int missing = rnd.next(1, max(1,x));\n        shuffle(nums.begin(), nums.end());\n        for(int i = 0; i < x - missing; i++)\n            S.insert(nums[i]);\n        /* Add extra random elements */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n    } else if(type == \"need_to_remove\") {\n        /* Generate a set where MEX(S) > x, need to remove elements */\n        for(int i = 0; i <= x; i++)\n            S.insert(i);\n        /* Add extra elements less than or equal to x */\n        int extra = rnd.next(0, x);\n        for(int i = 0; i < extra; i++) {\n            int val = rnd.next(0,x);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n        /* Add extra random elements */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(S.count(val)) continue;\n            S.insert(val);\n        }\n    } else if(type == \"x_in_S\") {\n        /* Ensure x is in S */\n        S.insert(x);\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"x_not_in_S\") {\n        /* Ensure x is not in S */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            if(val == x) continue;\n            S.insert(val);\n        }\n    } else if(type == \"random\") {\n        /* Generate a random set */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"x_equals_0\") {\n        /* Set x = 0 */\n        x = 0;\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"x_equals_100\") {\n        /* Set x = 100 */\n        x = 100;\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    } else if(type == \"n_equals_1\") {\n        /* Set n = 1 */\n        n = 1;\n        int val = rnd.next(0,100);\n        S.insert(val);\n    } else {\n        /* Default random case */\n        while(int(S.size()) < n) {\n            int val = rnd.next(0,100);\n            S.insert(val);\n        }\n    }\n\n    /* Output n and x */\n    printf(\"%d %d\\n\", n, x);\n\n    /* Output the set */\n    auto it = S.begin();\n    for(int i = 0; i < n; i++, ++it) {\n        printf(\"%d%c\", *it, (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -x 0 -type minimal\n./gen -n 100 -x 100 -type maximal\n./gen -n 10 -x 3 -type need_to_add\n./gen -n 10 -x 7 -type need_to_remove\n./gen -n 10 -x 5 -type no_changes_needed\n./gen -n 20 -x 10 -type x_in_S\n./gen -n 20 -x 15 -type x_not_in_S\n./gen -n 50 -x 25 -type random\n./gen -n 30 -x 0 -type x_equals_0\n./gen -n 30 -x 100 -type x_equals_100\n./gen -n 1 -x 50 -type n_equals_1\n./gen -n 100 -x 50 -type need_to_add\n./gen -n 100 -x 50 -type need_to_remove\n./gen -n 100 -x 0 -type no_changes_needed\n./gen -n 100 -x 100 -type need_to_add\n./gen -n 98 -x 49 -type x_in_S\n./gen -n 99 -x 99 -type x_not_in_S\n./gen -n 85 -x 42 -type need_to_add\n./gen -n 70 -x 70 -type need_to_remove\n./gen -n 60 -x 30 -type random\n./gen -n 15 -x 0 -type x_equals_0\n./gen -n 15 -x 100 -type x_equals_100\n./gen -n 20 -x 5 -type need_to_remove\n./gen -n 8 -x 8 -type need_to_add\n./gen -n 100 -x 1 -type x_equals_0\n./gen -n 100 -x 99 -type x_equals_100\n./gen -n 10 -x 90 -type need_to_add\n./gen -n 10 -x 1 -type need_to_remove\n./gen -n 50 -x 25 -type x_in_S\n./gen -n 50 -x 25 -type x_not_in_S\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:31.667343",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "862/B",
      "title": "B. Махмуд, Ехаб и двудольность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке дано целое число n — число вершин в дереве (1 ≤ n ≤ 105).В следующих n - 1 строках содержатся пары целых чисел u и v (1 ≤ u, v ≤ n, u ≠ v) — описание рёбер дерева.Гарантируется, что заданный граф является деревом.",
      "output_spec": "Выходные данныеВыведите одно число — максимальное число рёбер, которые Махмуд и Ехаб могут добавить в граф.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 21 3Выходные данныеСкопировать0Входные данныеСкопировать51 22 33 44 5Выходные данныеСкопировать2",
      "description": "B. Махмуд, Ехаб и двудольность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке дано целое число n — число вершин в дереве (1 ≤ n ≤ 105).В следующих n - 1 строках содержатся пары целых чисел u и v (1 ≤ u, v ≤ n, u ≠ v) — описание рёбер дерева.Гарантируется, что заданный граф является деревом.\n\nВходные данные\n\nВыходные данныеВыведите одно число — максимальное число рёбер, которые Махмуд и Ехаб могут добавить в граф.\n\nВыходные данные\n\nВходные данныеСкопировать31 21 3Выходные данныеСкопировать0Входные данныеСкопировать51 22 33 44 5Выходные данныеСкопировать2\n\nВходные данныеСкопировать31 21 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 22 33 44 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОпределение дерева: https://ru.wikipedia.org/wiki/Дерево_(теория_графов)Определение двудольного графа: https://ru.wikipedia.org/wiki/Двудольный_графВ первом тестовом примере единственное ребро, которое можно добавить в граф, чтобы избежать появления петель и кратных рёбер — это (2, 3), но его добавление сделает граф не двудольным. Во втором тестовом примере Махмуд и Ехаб могут добавить рёбра (1, 4) и (2, 5).",
      "solutions": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'm glad to announce that on Sep/19/2017 15:05 UTC Codeforces Round #435 for the second division will take place. As usual, First division participants can take part out of competition.This round was prepared by me.I'd like to thank mohammedehab2002 for writing the statements and the editorials and testing the round, Livace,Alladdin,300iq and cdkrot for testing the round, vintage_Vlad_Makeev for helping us in contest preparation, translating the statements into Russian and making one of the problems more interesting, KAN and Ahmad_Elsagheer for giving their opinions and thoughts about the problems and MikeMirzayanov for the great Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them.The scoring distribution will be announced later.UPD. 500-1000-1500-1750-2000-2750**UPD Congratulations to the winners:Div1+Div2:1-Shik2-KassiJulgus3-I_love_Tanya_Romanova4-MrDindows5-scanhexDiv2:1-KassiJulgus2-scanhex3-qscqesze84-UpdateRatingOrRIOT5-NickRUPD editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54581",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1012
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces",
          "content": "862A - Mahmoud and Ehab and the MEXOne can see that in the final set all the elements less than x should exist, x shouldn't exist and any element greater than x doesn't matter, so we will count the number of elements less than x that don't exist in the initial set and add this to the answer, If x exists we'll add 1 to the answer because x should be removed .Time complexity : O(n + x) .Solution link (me) : https://pastebin.com/ALfcu8Ab .Solution link (mahmoudbadawy) : https://pastebin.com/yXLkmA5F .862B - Mahmoud and Ehab and the bipartitenessThe tree itself is bipartite so we can run a dfs to partition the tree into the 2 sets (called bicoloring), We can't add an edge between any 2 nodes in the same set and we can add an edge between every 2 nodes in different sets, so let the number of nodes in the left set be l and the number of nodes in the right set be r, The maximum number of edges that can exist is l * r, but n - 1 edges already exist so the maximum number of edges to be added is l * r - (n - 1).Time complexity : O(n) .Solution link (me) : https://pastebin.com/w3bF7gKS .Solution link (mahmoudbadawy) : https://pastebin.com/PMpte7nC .862C - Mahmoud and Ehab and the xorn = 2, x = 0 is the only case with answer \"NO\" .Let pw = 217 .First print 1, 2, ..., n - 3 (The first n - 3 positive integers), Let their bitwise-xor sum be y, If x = y You can add pw, pw * 2 and , Otherwise you can add 0, pw and , We handled the case x = y in a different way because if we add 0, pw and in this case, Then it's like adding 0, pw and pw, pw appears twice so we'll get wrong answer.Handle n = 1 (print x) and n = 2 (print 0 and x) .Solution link (mahmoudbadawy) : https://pastebin.com/w67KUY5u .862D - Mahmoud and Ehab and the binary stringIn the editorial we suppose that the answer of some query is the number of correct guessed positions which is equal to n minus hamming distance, The solutions in this editorial consider the answer of a query as n minus real answer, For convenience.Common things : Let zero(l, r) be a function that returns the number of zeros in the interval [l;r] minus the number of ones in it, We can find it in one query after a preprocessing query, The preprocessing query is 1111..., Let its answer be stored in all, If we made a query with a string full of ones except for the interval [l;r] which will be full of zeros, If this query's answer is cur, zero(l, r) = cur - all, That's because all is the number of ones in the interval [l;r] plus some trash and cur is the number of zeros in the interval plus the same trash .First solution by mahmoudbadawyLet's have a searching interval, initially this interval is [1;n] (The whole string), Let's repeat this until we reach our goal, Let mid = (l + r) / 2 Let's query to get zero(l, mid), If it's equal to r - l + 1, This interval is full of zeros so we can print any index in it as the index with value 0 and continue searching for an index with the value 1 in the interval [mid + 1;r], But if its value is equal to l - r - 1, This interval is full of ones so we can print any index in it as the index with value 1 and continue searching for a 0 in the interval [mid + 1;r], Otherwise the interval contains both values so we can continue searching for both in the interval [l;mid], Every time the searching interval length must be divided by 2 in any case so we perform O(log(n)) queries .Second solution by meLet's send 1111... and let the answer be ans1, Let's send 0111... and let the answer be ans0, We now know the value in the first index (1 if ans1 > ans0, 0 otherwise), We can binary search for the first index where the non-found value exists, which is to binary search on the first value x where zero(2, x) * sign(non - found bit value) ≠ x - 1 where sign(y) is 1 if y = 0,  - 1 otherwise .Solution link (me) : https://pastebin.com/Bc6q7TKv .Solution link (mahmoudbadawy) : https://pastebin.com/RMyLDMxw .862E - Mahmoud and Ehab and the functionLet's write f(j) in another way:-Now we have 2 sums, The first one is constant (doesn't depend on j), For the second sum we can calculate all its possible values using sliding window technique, Now we want a data-structure that takes the value of the first sum and chooses the best second sum from all the choices .observation: We don't have to try all the possible values of f(j) to minimize the expression, If the first sum is c, We can try only the least value greater than  - c and the greatest value less than  - c ( - c not c because we are minimizing c + second not c - second) because the absolute value means the distance between the two values on the number line, Any other value will be further than at least one of the chosen values, To do this we can keep all the values of f(j) sorted and try the elements numbered lower_bound(-c) and lower_bound(-c)-1 and choose the better (In short we're trying the values close to  - c only).Now we have a data-structure that can get us the minimum value of the expression once given the value of the first sum in O(log(n)), Now we want to keep track of the value of the first sum .Let the initial value be c, In each update, If the length of the updated interval is even, The sum won't change because x will be added as many times as it's subtracted, Otherwise x will be added to c or subtracted from c depending of the parity of l (the left-bound of the interval) .Time complexity : O(n + (m + q)log(m)) .Solution link (me) : https://pastebin.com/u828DjcS .Solution link (mahmoudbadawy) : https://pastebin.com/dA3K8nfK .862F - Mahmoud and Ehab and the final stageFirst, Let's get rid of the LCP part .observation: , That could make us transform the LCP part into a minimization part by making an array lcp where lcpi = LCP(si, si + 1), You could calculate it naively, And when an update happens at index a, You should update lcpa (If exists) and lcpa - 1 (If exists) naively .Now the problem reduces to finding a ≤ l ≤ r ≤ b that maximizes the value:-, If we have a histogram where the ith column has height lcpi, The the size of the largest rectangle that fits in the columns from l to r - 1 is , That's close to our formula not the same but it's not a problem (You'll see how to fix it later), so to get rid of finding the l and r part, We can make that histogram and the answer for a query will be the largest rectangle in the subhistogram that contains the columns from a to b - 1, One of the ways to solve it is to try some heights h and see the maximum width we can achieve if h was the height, call it w, and maximize with h * w, To solve the slight difference in formulas problem we'll just maximize with h * (w + 1)!!Let BU be a value the we'll choose later, We have 2 cases for our largest rectangle's height h, It could be either h ≤ BU or h > BU, We will solve both problems separately.For h ≤ BU we can maintain BU segment trees, Segment tree number i has 1 at index x if lcpx ≥ i and 0 otherwise, When we query, It should get us the longest subsegment of ones in the query range, Let's see what we need for our merging operation, If we want the answer for the longest subsegment of ones in a range [l;r], Let mid = (l + r) / 2, Then the answer is the maximum between the answer of [l;mid], The answer of [mid + 1;r], And the maximum suffix of ones in the range [l;mid] added to the maximum prefix of ones in the range [mid + 1;r] . So we need to keep all these information in our node and also the length of the interval, As it's a well-known problem I won't get into more detail. Back to our problem, We can loop over all h ≤ BU, Let the answer for the query on range [a;b - 1] in segment tree number h be w, The maximum width of a rectangle of height h in this range is w and we'll maximize our answer with h * (w + 1) .For h > BU, Let's call a column of height greater than BU big, The heights we'll try are the heights of the big columns in the range, We don't have to try all the heights greater the BU, There are at most big columns (Where tot is the total length of strings in input), Let's keep them in a set, When an update happens, You should add the column to the set or remove it depending on its new height, The set's size can't exceed now, Let's see how to answer a query, Let's loop over the big columns in range [a;b - 1] only, If 2 of them aren't consecutive then the column after the first can't be big and the column before the second either, That's because if it were big, It would be in our set, So we can use this observation by making a new histogram with the big columns in the range only, And put a column with height 0 between any non-consecutive two, And get the largest rectangle in this histogram by the stack way for example in , The stack way will get us the maximum width w we can achieve for a rectangle containing column number i, We'll maximize with lcpi * (w + 1).Also the answer for our main formula can be an interval of length one, All what I mentioned doesn't cover this, You should maintain another segment tree that gets the maximum length of a string in a range for this .Maximize all what we got, You have the answer, Now it's time to choose BU, It's optimal in time to choose BU near (Reason in tfg's comment below) .Optimization: The longest subsegment of ones problem is solved by BU segment trees and each one has 4 integers in each node, You can make them 2 integers (max prefix and suffix of ones) and make another only one segment tree that has the rest of the integers, That would divide the memory by 2 .Time complexity : Thanks to vintage_Vlad_Makeev for making it harder and more interesting .Solution link (vintage_Vlad_Makeev) : https://pastebin.com/vQ4RJqh0 .Solution link (mahmoudbadawy) : https://pastebin.com/t3Vetzwf .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 862\\s*B"
          },
          "content_length": 9689
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 1",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 2",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 3",
          "code": "(rand()<<15)|rand()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 4",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 5",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 6",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 10",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 11",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 12",
          "code": "if(fans[sizea]==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 1",
          "code": "lower_bound(-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 2",
          "code": "lower_bound(-c)-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 3",
          "code": "[100000+1, 1000000/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 4",
          "code": "{pw, pw*2, pw^(pw*2)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 5",
          "code": "{0, pw, pw^x^y}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 6",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 7",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000; // As n can be up to 1e5\n\nint parent[MAX_N + 1];\nint rank_[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    int u_par = find(u);\n    int v_par = find(v);\n    if (u_par != v_par) {\n        if (rank_[u_par] < rank_[v_par]) {\n            parent[u_par] = v_par;\n        } else {\n            parent[v_par] = u_par;\n            if (rank_[u_par] == rank_[v_par]) {\n                rank_[u_par]++;\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank_[i] = 0;\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 1; i <= n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge can't be a loop (u_i != v_i) at line %d\", i + 1);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between same pair of nodes (edge between %d and %d appears multiple times) at line %d\", a, b, i + 1);\n        edges.insert(edge);\n\n        int u_par = find(u);\n        int v_par = find(v);\n        ensuref(u_par != v_par, \"Cycle detected when processing edge (%d, %d) at line %d\", u, v, i + 1);\n\n        unite(u, v);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000; // As n can be up to 1e5\n\nint parent[MAX_N + 1];\nint rank_[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    int u_par = find(u);\n    int v_par = find(v);\n    if (u_par != v_par) {\n        if (rank_[u_par] < rank_[v_par]) {\n            parent[u_par] = v_par;\n        } else {\n            parent[v_par] = u_par;\n            if (rank_[u_par] == rank_[v_par]) {\n                rank_[u_par]++;\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank_[i] = 0;\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 1; i <= n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge can't be a loop (u_i != v_i) at line %d\", i + 1);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between same pair of nodes (edge between %d and %d appears multiple times) at line %d\", a, b, i + 1);\n        edges.insert(edge);\n\n        int u_par = find(u);\n        int v_par = find(v);\n        ensuref(u_par != v_par, \"Cycle detected when processing edge (%d, %d) at line %d\", u, v, i + 1);\n\n        unite(u, v);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000; // As n can be up to 1e5\n\nint parent[MAX_N + 1];\nint rank_[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    int u_par = find(u);\n    int v_par = find(v);\n    if (u_par != v_par) {\n        if (rank_[u_par] < rank_[v_par]) {\n            parent[u_par] = v_par;\n        } else {\n            parent[v_par] = u_par;\n            if (rank_[u_par] == rank_[v_par]) {\n                rank_[u_par]++;\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank_[i] = 0;\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 1; i <= n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge can't be a loop (u_i != v_i) at line %d\", i + 1);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between same pair of nodes (edge between %d and %d appears multiple times) at line %d\", a, b, i + 1);\n        edges.insert(edge);\n\n        int u_par = find(u);\n        int v_par = find(v);\n        ensuref(u_par != v_par, \"Cycle detected when processing edge (%d, %d) at line %d\", u, v, i + 1);\n\n        unite(u, v);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pii> edges;\n    if (type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"skewed\") {\n        int parent = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({parent, i});\n            parent = i;\n        }\n    } else if (type == \"balanced\") {\n        // Generate a balanced binary tree\n        vector<int> nodes;\n        nodes.push_back(1);\n        int next_node = 2;\n        while (next_node <= n) {\n            vector<int> temp;\n            for (int u : nodes) {\n                if (next_node <= n) {\n                    edges.push_back({u, next_node});\n                    temp.push_back(next_node++);\n                }\n                if (next_node <= n) {\n                    edges.push_back({u, next_node});\n                    temp.push_back(next_node++);\n                }\n            }\n            nodes = temp;\n        }\n    } else {\n        // Default random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    for (pii &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n        if (rnd.next(2)) swap(e.first, e.second);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (pii e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pii> edges;\n    if (type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"skewed\") {\n        int parent = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({parent, i});\n            parent = i;\n        }\n    } else if (type == \"balanced\") {\n        // Generate a balanced binary tree\n        vector<int> nodes;\n        nodes.push_back(1);\n        int next_node = 2;\n        while (next_node <= n) {\n            vector<int> temp;\n            for (int u : nodes) {\n                if (next_node <= n) {\n                    edges.push_back({u, next_node});\n                    temp.push_back(next_node++);\n                }\n                if (next_node <= n) {\n                    edges.push_back({u, next_node});\n                    temp.push_back(next_node++);\n                }\n            }\n            nodes = temp;\n        }\n    } else {\n        // Default random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    for (pii &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n        if (rnd.next(2)) swap(e.first, e.second);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (pii e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n test cases\n./gen -n 1 -type chain\n./gen -n 2 -type chain\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type balanced\n./gen -n 5 -type skewed\n./gen -n 5 -type random\n\n# Medium n test cases\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type balanced\n./gen -n 50 -type skewed\n./gen -n 50 -type random\n\n# Large n test cases\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type balanced\n./gen -n 1000 -type skewed\n./gen -n 1000 -type random\n\n# Maximum n test cases\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type balanced\n./gen -n 100000 -type skewed\n./gen -n 100000 -type random\n\n# Edge cases near maximum n\n./gen -n 99999 -type chain\n./gen -n 99999 -type star\n./gen -n 99999 -type balanced\n./gen -n 99999 -type skewed\n./gen -n 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:33.623504",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "862/C",
      "title": "C. Махмуд, Ехаб и xor",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке содержатся два целых числа n и x (1 ≤ n ≤ 105, 0 ≤ x ≤ 105) — число элементов в множестве и требуемый xor, соответственно.",
      "output_spec": "Выходные данныеЕсли таких множеств не существует, выведите \"NO\" (без кавычек).Иначе выведите на первой строке \"YES\" (без кавычек) а на второй строке n целых неотрицательных различных чисел — элементы множества в любом порядке.Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 5Выходные данныеСкопироватьYES1 2 4 5 7Входные данныеСкопировать3 6Выходные данныеСкопироватьYES1 2 5",
      "description": "C. Махмуд, Ехаб и xor\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке содержатся два целых числа n и x (1 ≤ n ≤ 105, 0 ≤ x ≤ 105) — число элементов в множестве и требуемый xor, соответственно.\n\nВходные данные\n\nВыходные данныеЕсли таких множеств не существует, выведите \"NO\" (без кавычек).Иначе выведите на первой строке \"YES\" (без кавычек) а на второй строке n целых неотрицательных различных чисел — элементы множества в любом порядке.Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать5 5Выходные данныеСкопироватьYES1 2 4 5 7Входные данныеСкопировать3 6Выходные данныеСкопироватьYES1 2 5\n\nВходные данныеСкопировать5 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 2 4 5 7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 2 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВы можете узнать больше об операции побитовый xor здесь: https://ru.wikipedia.org/wiki/Сложение_по_модулю_2В первом тестовом примере . Во втором тестовом примере .",
      "solutions": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'm glad to announce that on Sep/19/2017 15:05 UTC Codeforces Round #435 for the second division will take place. As usual, First division participants can take part out of competition.This round was prepared by me.I'd like to thank mohammedehab2002 for writing the statements and the editorials and testing the round, Livace,Alladdin,300iq and cdkrot for testing the round, vintage_Vlad_Makeev for helping us in contest preparation, translating the statements into Russian and making one of the problems more interesting, KAN and Ahmad_Elsagheer for giving their opinions and thoughts about the problems and MikeMirzayanov for the great Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them.The scoring distribution will be announced later.UPD. 500-1000-1500-1750-2000-2750**UPD Congratulations to the winners:Div1+Div2:1-Shik2-KassiJulgus3-I_love_Tanya_Romanova4-MrDindows5-scanhexDiv2:1-KassiJulgus2-scanhex3-qscqesze84-UpdateRatingOrRIOT5-NickRUPD editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54581",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1012
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces",
          "content": "862A - Mahmoud and Ehab and the MEXOne can see that in the final set all the elements less than x should exist, x shouldn't exist and any element greater than x doesn't matter, so we will count the number of elements less than x that don't exist in the initial set and add this to the answer, If x exists we'll add 1 to the answer because x should be removed .Time complexity : O(n + x) .Solution link (me) : https://pastebin.com/ALfcu8Ab .Solution link (mahmoudbadawy) : https://pastebin.com/yXLkmA5F .862B - Mahmoud and Ehab and the bipartitenessThe tree itself is bipartite so we can run a dfs to partition the tree into the 2 sets (called bicoloring), We can't add an edge between any 2 nodes in the same set and we can add an edge between every 2 nodes in different sets, so let the number of nodes in the left set be l and the number of nodes in the right set be r, The maximum number of edges that can exist is l * r, but n - 1 edges already exist so the maximum number of edges to be added is l * r - (n - 1).Time complexity : O(n) .Solution link (me) : https://pastebin.com/w3bF7gKS .Solution link (mahmoudbadawy) : https://pastebin.com/PMpte7nC .862C - Mahmoud and Ehab and the xorn = 2, x = 0 is the only case with answer \"NO\" .Let pw = 217 .First print 1, 2, ..., n - 3 (The first n - 3 positive integers), Let their bitwise-xor sum be y, If x = y You can add pw, pw * 2 and , Otherwise you can add 0, pw and , We handled the case x = y in a different way because if we add 0, pw and in this case, Then it's like adding 0, pw and pw, pw appears twice so we'll get wrong answer.Handle n = 1 (print x) and n = 2 (print 0 and x) .Solution link (mahmoudbadawy) : https://pastebin.com/w67KUY5u .862D - Mahmoud and Ehab and the binary stringIn the editorial we suppose that the answer of some query is the number of correct guessed positions which is equal to n minus hamming distance, The solutions in this editorial consider the answer of a query as n minus real answer, For convenience.Common things : Let zero(l, r) be a function that returns the number of zeros in the interval [l;r] minus the number of ones in it, We can find it in one query after a preprocessing query, The preprocessing query is 1111..., Let its answer be stored in all, If we made a query with a string full of ones except for the interval [l;r] which will be full of zeros, If this query's answer is cur, zero(l, r) = cur - all, That's because all is the number of ones in the interval [l;r] plus some trash and cur is the number of zeros in the interval plus the same trash .First solution by mahmoudbadawyLet's have a searching interval, initially this interval is [1;n] (The whole string), Let's repeat this until we reach our goal, Let mid = (l + r) / 2 Let's query to get zero(l, mid), If it's equal to r - l + 1, This interval is full of zeros so we can print any index in it as the index with value 0 and continue searching for an index with the value 1 in the interval [mid + 1;r], But if its value is equal to l - r - 1, This interval is full of ones so we can print any index in it as the index with value 1 and continue searching for a 0 in the interval [mid + 1;r], Otherwise the interval contains both values so we can continue searching for both in the interval [l;mid], Every time the searching interval length must be divided by 2 in any case so we perform O(log(n)) queries .Second solution by meLet's send 1111... and let the answer be ans1, Let's send 0111... and let the answer be ans0, We now know the value in the first index (1 if ans1 > ans0, 0 otherwise), We can binary search for the first index where the non-found value exists, which is to binary search on the first value x where zero(2, x) * sign(non - found bit value) ≠ x - 1 where sign(y) is 1 if y = 0,  - 1 otherwise .Solution link (me) : https://pastebin.com/Bc6q7TKv .Solution link (mahmoudbadawy) : https://pastebin.com/RMyLDMxw .862E - Mahmoud and Ehab and the functionLet's write f(j) in another way:-Now we have 2 sums, The first one is constant (doesn't depend on j), For the second sum we can calculate all its possible values using sliding window technique, Now we want a data-structure that takes the value of the first sum and chooses the best second sum from all the choices .observation: We don't have to try all the possible values of f(j) to minimize the expression, If the first sum is c, We can try only the least value greater than  - c and the greatest value less than  - c ( - c not c because we are minimizing c + second not c - second) because the absolute value means the distance between the two values on the number line, Any other value will be further than at least one of the chosen values, To do this we can keep all the values of f(j) sorted and try the elements numbered lower_bound(-c) and lower_bound(-c)-1 and choose the better (In short we're trying the values close to  - c only).Now we have a data-structure that can get us the minimum value of the expression once given the value of the first sum in O(log(n)), Now we want to keep track of the value of the first sum .Let the initial value be c, In each update, If the length of the updated interval is even, The sum won't change because x will be added as many times as it's subtracted, Otherwise x will be added to c or subtracted from c depending of the parity of l (the left-bound of the interval) .Time complexity : O(n + (m + q)log(m)) .Solution link (me) : https://pastebin.com/u828DjcS .Solution link (mahmoudbadawy) : https://pastebin.com/dA3K8nfK .862F - Mahmoud and Ehab and the final stageFirst, Let's get rid of the LCP part .observation: , That could make us transform the LCP part into a minimization part by making an array lcp where lcpi = LCP(si, si + 1), You could calculate it naively, And when an update happens at index a, You should update lcpa (If exists) and lcpa - 1 (If exists) naively .Now the problem reduces to finding a ≤ l ≤ r ≤ b that maximizes the value:-, If we have a histogram where the ith column has height lcpi, The the size of the largest rectangle that fits in the columns from l to r - 1 is , That's close to our formula not the same but it's not a problem (You'll see how to fix it later), so to get rid of finding the l and r part, We can make that histogram and the answer for a query will be the largest rectangle in the subhistogram that contains the columns from a to b - 1, One of the ways to solve it is to try some heights h and see the maximum width we can achieve if h was the height, call it w, and maximize with h * w, To solve the slight difference in formulas problem we'll just maximize with h * (w + 1)!!Let BU be a value the we'll choose later, We have 2 cases for our largest rectangle's height h, It could be either h ≤ BU or h > BU, We will solve both problems separately.For h ≤ BU we can maintain BU segment trees, Segment tree number i has 1 at index x if lcpx ≥ i and 0 otherwise, When we query, It should get us the longest subsegment of ones in the query range, Let's see what we need for our merging operation, If we want the answer for the longest subsegment of ones in a range [l;r], Let mid = (l + r) / 2, Then the answer is the maximum between the answer of [l;mid], The answer of [mid + 1;r], And the maximum suffix of ones in the range [l;mid] added to the maximum prefix of ones in the range [mid + 1;r] . So we need to keep all these information in our node and also the length of the interval, As it's a well-known problem I won't get into more detail. Back to our problem, We can loop over all h ≤ BU, Let the answer for the query on range [a;b - 1] in segment tree number h be w, The maximum width of a rectangle of height h in this range is w and we'll maximize our answer with h * (w + 1) .For h > BU, Let's call a column of height greater than BU big, The heights we'll try are the heights of the big columns in the range, We don't have to try all the heights greater the BU, There are at most big columns (Where tot is the total length of strings in input), Let's keep them in a set, When an update happens, You should add the column to the set or remove it depending on its new height, The set's size can't exceed now, Let's see how to answer a query, Let's loop over the big columns in range [a;b - 1] only, If 2 of them aren't consecutive then the column after the first can't be big and the column before the second either, That's because if it were big, It would be in our set, So we can use this observation by making a new histogram with the big columns in the range only, And put a column with height 0 between any non-consecutive two, And get the largest rectangle in this histogram by the stack way for example in , The stack way will get us the maximum width w we can achieve for a rectangle containing column number i, We'll maximize with lcpi * (w + 1).Also the answer for our main formula can be an interval of length one, All what I mentioned doesn't cover this, You should maintain another segment tree that gets the maximum length of a string in a range for this .Maximize all what we got, You have the answer, Now it's time to choose BU, It's optimal in time to choose BU near (Reason in tfg's comment below) .Optimization: The longest subsegment of ones problem is solved by BU segment trees and each one has 4 integers in each node, You can make them 2 integers (max prefix and suffix of ones) and make another only one segment tree that has the rest of the integers, That would divide the memory by 2 .Time complexity : Thanks to vintage_Vlad_Makeev for making it harder and more interesting .Solution link (vintage_Vlad_Makeev) : https://pastebin.com/vQ4RJqh0 .Solution link (mahmoudbadawy) : https://pastebin.com/t3Vetzwf .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 862\\s*C"
          },
          "content_length": 9689
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 1",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 2",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 3",
          "code": "(rand()<<15)|rand()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 4",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 5",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 6",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 10",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 11",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 12",
          "code": "if(fans[sizea]==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 1",
          "code": "lower_bound(-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 2",
          "code": "lower_bound(-c)-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 3",
          "code": "[100000+1, 1000000/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 4",
          "code": "{pw, pw*2, pw^(pw*2)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 5",
          "code": "{0, pw, pw^x^y}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 6",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 7",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 100000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 100000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 100000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int x = inf.readInt();\n\n    bool solutionExists = !(n == 2 && x == 0);\n\n    string participantOutput = ouf.readToken();\n\n    if (participantOutput != \"YES\" && participantOutput != \"NO\") {\n        quitf(_wa, \"Expected \\\"YES\\\" or \\\"NO\\\", found \\\"%s\\\"\", participantOutput.c_str());\n    }\n    if (participantOutput == \"NO\") {\n        if (solutionExists) {\n            quitf(_wa, \"Solution exists but participant outputs \\\"NO\\\"\");\n        } else {\n            quitf(_ok, \"Correctly outputs \\\"NO\\\"\");\n        }\n    } else { // participantOutput == \"YES\"\n        if (!solutionExists) {\n            quitf(_wa, \"No solution exists but participant outputs \\\"YES\\\"\");\n        } else {\n            vector<int> nums = ouf.readInts(n, 0, 1000000);\n            if ((int)nums.size() != n) {\n                quitf(_wa, \"Expected %d numbers, but got %d\", n, (int)nums.size());\n            }\n            set<int> unique_nums(nums.begin(), nums.end());\n            if ((int)unique_nums.size() != n) {\n                quitf(_wa, \"Numbers are not distinct\");\n            }\n            int computed_xor = 0;\n            for (int num : nums) {\n                computed_xor ^= num;\n            }\n            if (computed_xor != x) {\n                quitf(_wa, \"XOR of numbers is %d, expected %d\", computed_xor, x);\n            }\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int x = opt<int>(\"x\", -1);\n    string type = opt<string>(\"type\", \"custom\");\n\n    if (type == \"impossible\") {\n        n = 2;\n        x = 0;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"n1\") {\n        n = 1;\n        x = rnd.next(0, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"n2_x0\") {\n        n = 2;\n        x = 0;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"n2_xnonzero\") {\n        n = 2;\n        x = rnd.next(1, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"max_n\") {\n        n = 100000;\n        x = rnd.next(0, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"max_x\") {\n        n = rnd.next(1, 100000);\n        x = 100000;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"zero_x\") {\n        n = rnd.next(1, 100000);\n        x = 0;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 100000);\n        x = rnd.next(0, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"max_n_max_x\") {\n        n = 100000;\n        x = 100000;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"custom\") {\n        // uses provided n and x\n        if (n == -1 || x == -1) {\n            printf(\"Error: For custom type, n and x must be provided\\n\");\n            return 1;\n        } else {\n            printf(\"%d %d\\n\", n, x);\n        }\n    } else {\n        printf(\"Error: Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int x = opt<int>(\"x\", -1);\n    string type = opt<string>(\"type\", \"custom\");\n\n    if (type == \"impossible\") {\n        n = 2;\n        x = 0;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"n1\") {\n        n = 1;\n        x = rnd.next(0, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"n2_x0\") {\n        n = 2;\n        x = 0;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"n2_xnonzero\") {\n        n = 2;\n        x = rnd.next(1, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"max_n\") {\n        n = 100000;\n        x = rnd.next(0, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"max_x\") {\n        n = rnd.next(1, 100000);\n        x = 100000;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"zero_x\") {\n        n = rnd.next(1, 100000);\n        x = 0;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 100000);\n        x = rnd.next(0, 100000);\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"max_n_max_x\") {\n        n = 100000;\n        x = 100000;\n        printf(\"%d %d\\n\", n, x);\n    } else if (type == \"custom\") {\n        // uses provided n and x\n        if (n == -1 || x == -1) {\n            printf(\"Error: For custom type, n and x must be provided\\n\");\n            return 1;\n        } else {\n            printf(\"%d %d\\n\", n, x);\n        }\n    } else {\n        printf(\"Error: Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type impossible\n\n./gen -type n1\n\n./gen -type n2_x0\n\n./gen -type n2_xnonzero\n\n./gen -type max_n\n\n./gen -type max_x\n\n./gen -type zero_x\n\n./gen -type random\n\n./gen -type max_n_max_x\n\n./gen -n 1 -x 0 -type custom\n\n./gen -n 1 -x 50000 -type custom\n\n./gen -n 2 -x 1 -type custom\n\n./gen -n 2 -x 100000 -type custom\n\n./gen -n 3 -x 0 -type custom\n\n./gen -n 3 -x 50000 -type custom\n\n./gen -n 1000 -x 12345 -type custom\n\n./gen -n 99999 -x 99999 -type custom\n\n./gen -n 100000 -x 0 -type custom\n\n./gen -n 100000 -x 100000 -type custom\n\n./gen -n 50000 -x 50000 -type custom\n\n# Additional random tests\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:35.422207",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "862/E",
      "title": "E. Mahmoud and Ehab and the function",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and q (1 ≤ n ≤ m ≤ 105, 1 ≤ q ≤ 105) — number of elements in a, number of elements in b and number of queries, respectively.The second line contains n integers a1, a2, ..., an. ( - 109 ≤ ai ≤ 109) — elements of a.The third line contains m integers b1, b2, ..., bm. ( - 109 ≤ bi ≤ 109) — elements of b.Then q lines follow describing the queries. Each of them contains three integers li ri xi (1 ≤ li ≤ ri ≤ n,  - 109 ≤ x ≤ 109) — range to be updated and added value.",
      "output_spec": "OutputThe first line should contain the minimum value of the function f before any update.Then output q lines, the i-th of them should contain the minimum value of the function f after performing the i-th update .",
      "sample_tests": "ExampleInputCopy5 6 31 2 3 4 51 2 3 4 5 61 1 101 1 -91 5 -1OutputCopy0900",
      "description": "E. Mahmoud and Ehab and the function\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, m and q (1 ≤ n ≤ m ≤ 105, 1 ≤ q ≤ 105) — number of elements in a, number of elements in b and number of queries, respectively.The second line contains n integers a1, a2, ..., an. ( - 109 ≤ ai ≤ 109) — elements of a.The third line contains m integers b1, b2, ..., bm. ( - 109 ≤ bi ≤ 109) — elements of b.Then q lines follow describing the queries. Each of them contains three integers li ri xi (1 ≤ li ≤ ri ≤ n,  - 109 ≤ x ≤ 109) — range to be updated and added value.\n\nOutputThe first line should contain the minimum value of the function f before any update.Then output q lines, the i-th of them should contain the minimum value of the function f after performing the i-th update .\n\nInputCopy5 6 31 2 3 4 51 2 3 4 5 61 1 101 1 -91 5 -1OutputCopy0900\n\nInputCopy5 6 31 2 3 4 51 2 3 4 5 61 1 101 1 -91 5 -1\n\nOutputCopy0900\n\nNoteFor the first example before any updates it's optimal to choose j = 0, f(0) = |(1 - 1) - (2 - 2) + (3 - 3) - (4 - 4) + (5 - 5)| = |0| = 0.After the first update a becomes {11, 2, 3, 4, 5} and it's optimal to choose j = 1, f(1) = |(11 - 2) - (2 - 3) + (3 - 4) - (4 - 5) + (5 - 6) = |9| = 9.After the second update a becomes {2, 2, 3, 4, 5} and it's optimal to choose j = 1, f(1) = |(2 - 2) - (2 - 3) + (3 - 4) - (4 - 5) + (5 - 6)| = |0| = 0.After the third update a becomes {1, 1, 2, 3, 4} and it's optimal to choose j = 0, f(0) = |(1 - 1) - (1 - 2) + (2 - 3) - (3 - 4) + (4 - 5)| = |0| = 0.",
      "solutions": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'm glad to announce that on Sep/19/2017 15:05 UTC Codeforces Round #435 for the second division will take place. As usual, First division participants can take part out of competition.This round was prepared by me.I'd like to thank mohammedehab2002 for writing the statements and the editorials and testing the round, Livace,Alladdin,300iq and cdkrot for testing the round, vintage_Vlad_Makeev for helping us in contest preparation, translating the statements into Russian and making one of the problems more interesting, KAN and Ahmad_Elsagheer for giving their opinions and thoughts about the problems and MikeMirzayanov for the great Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them.The scoring distribution will be announced later.UPD. 500-1000-1500-1750-2000-2750**UPD Congratulations to the winners:Div1+Div2:1-Shik2-KassiJulgus3-I_love_Tanya_Romanova4-MrDindows5-scanhexDiv2:1-KassiJulgus2-scanhex3-qscqesze84-UpdateRatingOrRIOT5-NickRUPD editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54581",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1012
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces",
          "content": "862A - Mahmoud and Ehab and the MEXOne can see that in the final set all the elements less than x should exist, x shouldn't exist and any element greater than x doesn't matter, so we will count the number of elements less than x that don't exist in the initial set and add this to the answer, If x exists we'll add 1 to the answer because x should be removed .Time complexity : O(n + x) .Solution link (me) : https://pastebin.com/ALfcu8Ab .Solution link (mahmoudbadawy) : https://pastebin.com/yXLkmA5F .862B - Mahmoud and Ehab and the bipartitenessThe tree itself is bipartite so we can run a dfs to partition the tree into the 2 sets (called bicoloring), We can't add an edge between any 2 nodes in the same set and we can add an edge between every 2 nodes in different sets, so let the number of nodes in the left set be l and the number of nodes in the right set be r, The maximum number of edges that can exist is l * r, but n - 1 edges already exist so the maximum number of edges to be added is l * r - (n - 1).Time complexity : O(n) .Solution link (me) : https://pastebin.com/w3bF7gKS .Solution link (mahmoudbadawy) : https://pastebin.com/PMpte7nC .862C - Mahmoud and Ehab and the xorn = 2, x = 0 is the only case with answer \"NO\" .Let pw = 217 .First print 1, 2, ..., n - 3 (The first n - 3 positive integers), Let their bitwise-xor sum be y, If x = y You can add pw, pw * 2 and , Otherwise you can add 0, pw and , We handled the case x = y in a different way because if we add 0, pw and in this case, Then it's like adding 0, pw and pw, pw appears twice so we'll get wrong answer.Handle n = 1 (print x) and n = 2 (print 0 and x) .Solution link (mahmoudbadawy) : https://pastebin.com/w67KUY5u .862D - Mahmoud and Ehab and the binary stringIn the editorial we suppose that the answer of some query is the number of correct guessed positions which is equal to n minus hamming distance, The solutions in this editorial consider the answer of a query as n minus real answer, For convenience.Common things : Let zero(l, r) be a function that returns the number of zeros in the interval [l;r] minus the number of ones in it, We can find it in one query after a preprocessing query, The preprocessing query is 1111..., Let its answer be stored in all, If we made a query with a string full of ones except for the interval [l;r] which will be full of zeros, If this query's answer is cur, zero(l, r) = cur - all, That's because all is the number of ones in the interval [l;r] plus some trash and cur is the number of zeros in the interval plus the same trash .First solution by mahmoudbadawyLet's have a searching interval, initially this interval is [1;n] (The whole string), Let's repeat this until we reach our goal, Let mid = (l + r) / 2 Let's query to get zero(l, mid), If it's equal to r - l + 1, This interval is full of zeros so we can print any index in it as the index with value 0 and continue searching for an index with the value 1 in the interval [mid + 1;r], But if its value is equal to l - r - 1, This interval is full of ones so we can print any index in it as the index with value 1 and continue searching for a 0 in the interval [mid + 1;r], Otherwise the interval contains both values so we can continue searching for both in the interval [l;mid], Every time the searching interval length must be divided by 2 in any case so we perform O(log(n)) queries .Second solution by meLet's send 1111... and let the answer be ans1, Let's send 0111... and let the answer be ans0, We now know the value in the first index (1 if ans1 > ans0, 0 otherwise), We can binary search for the first index where the non-found value exists, which is to binary search on the first value x where zero(2, x) * sign(non - found bit value) ≠ x - 1 where sign(y) is 1 if y = 0,  - 1 otherwise .Solution link (me) : https://pastebin.com/Bc6q7TKv .Solution link (mahmoudbadawy) : https://pastebin.com/RMyLDMxw .862E - Mahmoud and Ehab and the functionLet's write f(j) in another way:-Now we have 2 sums, The first one is constant (doesn't depend on j), For the second sum we can calculate all its possible values using sliding window technique, Now we want a data-structure that takes the value of the first sum and chooses the best second sum from all the choices .observation: We don't have to try all the possible values of f(j) to minimize the expression, If the first sum is c, We can try only the least value greater than  - c and the greatest value less than  - c ( - c not c because we are minimizing c + second not c - second) because the absolute value means the distance between the two values on the number line, Any other value will be further than at least one of the chosen values, To do this we can keep all the values of f(j) sorted and try the elements numbered lower_bound(-c) and lower_bound(-c)-1 and choose the better (In short we're trying the values close to  - c only).Now we have a data-structure that can get us the minimum value of the expression once given the value of the first sum in O(log(n)), Now we want to keep track of the value of the first sum .Let the initial value be c, In each update, If the length of the updated interval is even, The sum won't change because x will be added as many times as it's subtracted, Otherwise x will be added to c or subtracted from c depending of the parity of l (the left-bound of the interval) .Time complexity : O(n + (m + q)log(m)) .Solution link (me) : https://pastebin.com/u828DjcS .Solution link (mahmoudbadawy) : https://pastebin.com/dA3K8nfK .862F - Mahmoud and Ehab and the final stageFirst, Let's get rid of the LCP part .observation: , That could make us transform the LCP part into a minimization part by making an array lcp where lcpi = LCP(si, si + 1), You could calculate it naively, And when an update happens at index a, You should update lcpa (If exists) and lcpa - 1 (If exists) naively .Now the problem reduces to finding a ≤ l ≤ r ≤ b that maximizes the value:-, If we have a histogram where the ith column has height lcpi, The the size of the largest rectangle that fits in the columns from l to r - 1 is , That's close to our formula not the same but it's not a problem (You'll see how to fix it later), so to get rid of finding the l and r part, We can make that histogram and the answer for a query will be the largest rectangle in the subhistogram that contains the columns from a to b - 1, One of the ways to solve it is to try some heights h and see the maximum width we can achieve if h was the height, call it w, and maximize with h * w, To solve the slight difference in formulas problem we'll just maximize with h * (w + 1)!!Let BU be a value the we'll choose later, We have 2 cases for our largest rectangle's height h, It could be either h ≤ BU or h > BU, We will solve both problems separately.For h ≤ BU we can maintain BU segment trees, Segment tree number i has 1 at index x if lcpx ≥ i and 0 otherwise, When we query, It should get us the longest subsegment of ones in the query range, Let's see what we need for our merging operation, If we want the answer for the longest subsegment of ones in a range [l;r], Let mid = (l + r) / 2, Then the answer is the maximum between the answer of [l;mid], The answer of [mid + 1;r], And the maximum suffix of ones in the range [l;mid] added to the maximum prefix of ones in the range [mid + 1;r] . So we need to keep all these information in our node and also the length of the interval, As it's a well-known problem I won't get into more detail. Back to our problem, We can loop over all h ≤ BU, Let the answer for the query on range [a;b - 1] in segment tree number h be w, The maximum width of a rectangle of height h in this range is w and we'll maximize our answer with h * (w + 1) .For h > BU, Let's call a column of height greater than BU big, The heights we'll try are the heights of the big columns in the range, We don't have to try all the heights greater the BU, There are at most big columns (Where tot is the total length of strings in input), Let's keep them in a set, When an update happens, You should add the column to the set or remove it depending on its new height, The set's size can't exceed now, Let's see how to answer a query, Let's loop over the big columns in range [a;b - 1] only, If 2 of them aren't consecutive then the column after the first can't be big and the column before the second either, That's because if it were big, It would be in our set, So we can use this observation by making a new histogram with the big columns in the range only, And put a column with height 0 between any non-consecutive two, And get the largest rectangle in this histogram by the stack way for example in , The stack way will get us the maximum width w we can achieve for a rectangle containing column number i, We'll maximize with lcpi * (w + 1).Also the answer for our main formula can be an interval of length one, All what I mentioned doesn't cover this, You should maintain another segment tree that gets the maximum length of a string in a range for this .Maximize all what we got, You have the answer, Now it's time to choose BU, It's optimal in time to choose BU near (Reason in tfg's comment below) .Optimization: The longest subsegment of ones problem is solved by BU segment trees and each one has 4 integers in each node, You can make them 2 integers (max prefix and suffix of ones) and make another only one segment tree that has the rest of the integers, That would divide the memory by 2 .Time complexity : Thanks to vintage_Vlad_Makeev for making it harder and more interesting .Solution link (vintage_Vlad_Makeev) : https://pastebin.com/vQ4RJqh0 .Solution link (mahmoudbadawy) : https://pastebin.com/t3Vetzwf .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 862\\s*E"
          },
          "content_length": 9689
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 1",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 2",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 3",
          "code": "(rand()<<15)|rand()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 4",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 5",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 6",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 10",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 11",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 12",
          "code": "if(fans[sizea]==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 1",
          "code": "lower_bound(-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 2",
          "code": "lower_bound(-c)-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 3",
          "code": "[100000+1, 1000000/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 4",
          "code": "{pw, pw*2, pw^(pw*2)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 5",
          "code": "{0, pw, pw^x^y}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 6",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 7",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, -1000000000, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, -1000000000, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 100000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, -1000000000, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_array(int size, string type) {\n    vector<int> arr(size);\n    if (type == \"random\") {\n        for(int i = 0; i < size; ++i) {\n            arr[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < size; ++i) {\n            arr[i] = val;\n        }\n    } else if (type == \"max\") {\n        int max_val = 1000000000;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = max_val;\n        }\n    } else if (type == \"min\") {\n        int min_val = -1000000000;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = min_val;\n        }\n    } else if (type == \"increasing\") {\n        int val = rnd.next(-1000000000, 1000000000 - size);\n        for(int i = 0; i < size; ++i) {\n            arr[i] = val++;\n        }\n    } else if (type == \"decreasing\") {\n        int val = rnd.next(-1000000000 + size, 1000000000);\n        for(int i = 0; i < size; ++i) {\n            arr[i] = val--;\n        }\n    } else if (type == \"alternating\") {\n        int val1 = -1000000000;\n        int val2 = 1000000000;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"zeros\") {\n        for(int i = 0; i < size; ++i) {\n            arr[i] = 0;\n        }\n    }\n    return arr;\n}\n\nvector<tuple<int, int, int>> generate_queries(int n, int q, string type) {\n    vector<tuple<int, int, int>> queries(q);\n    if (type == \"random\") {\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int x = rnd.next(-1000000000, 1000000000);\n            queries[i] = make_tuple(l, r, x);\n        }\n    } else if (type == \"full\") {\n        for(int i = 0; i < q; ++i) {\n            int x = rnd.next(-1000000000, 1000000000);\n            queries[i] = make_tuple(1, n, x);\n        }\n    } else if (type == \"single\") {\n        for(int i = 0; i < q; ++i) {\n            int pos = rnd.next(1, n);\n            int x = rnd.next(-1000000000, 1000000000);\n            queries[i] = make_tuple(pos, pos, x);\n        }\n    } else if (type == \"front\") {\n        int r = rnd.next(1, n);\n        int x = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < q; ++i) {\n            queries[i] = make_tuple(1, r, x);\n        }\n    } else if (type == \"back\") {\n        int l = rnd.next(1, n);\n        int x = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < q; ++i) {\n            queries[i] = make_tuple(l, n, x);\n        }\n    } else if (type == \"zeros\") {\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int x = 0;\n            queries[i] = make_tuple(l, r, x);\n        }\n    }\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type_a = opt<string>(\"type_a\", \"random\");\n    string type_b = opt<string>(\"type_b\", \"random\");\n    string type_q = opt<string>(\"type_q\", \"random\");\n\n    vector<int> a = generate_array(n, type_a);\n    vector<int> b = generate_array(m, type_b);\n    vector<tuple<int,int,int>> queries = generate_queries(n, q, type_q);\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output array a\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output array b\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    // Output queries\n    for(int i = 0; i < q; ++i) {\n        int l, r, x;\n        tie(l, r, x) = queries[i];\n        printf(\"%d %d %d\\n\", l, r, x);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_array(int size, string type) {\n    vector<int> arr(size);\n    if (type == \"random\") {\n        for(int i = 0; i < size; ++i) {\n            arr[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < size; ++i) {\n            arr[i] = val;\n        }\n    } else if (type == \"max\") {\n        int max_val = 1000000000;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = max_val;\n        }\n    } else if (type == \"min\") {\n        int min_val = -1000000000;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = min_val;\n        }\n    } else if (type == \"increasing\") {\n        int val = rnd.next(-1000000000, 1000000000 - size);\n        for(int i = 0; i < size; ++i) {\n            arr[i] = val++;\n        }\n    } else if (type == \"decreasing\") {\n        int val = rnd.next(-1000000000 + size, 1000000000);\n        for(int i = 0; i < size; ++i) {\n            arr[i] = val--;\n        }\n    } else if (type == \"alternating\") {\n        int val1 = -1000000000;\n        int val2 = 1000000000;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"zeros\") {\n        for(int i = 0; i < size; ++i) {\n            arr[i] = 0;\n        }\n    }\n    return arr;\n}\n\nvector<tuple<int, int, int>> generate_queries(int n, int q, string type) {\n    vector<tuple<int, int, int>> queries(q);\n    if (type == \"random\") {\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int x = rnd.next(-1000000000, 1000000000);\n            queries[i] = make_tuple(l, r, x);\n        }\n    } else if (type == \"full\") {\n        for(int i = 0; i < q; ++i) {\n            int x = rnd.next(-1000000000, 1000000000);\n            queries[i] = make_tuple(1, n, x);\n        }\n    } else if (type == \"single\") {\n        for(int i = 0; i < q; ++i) {\n            int pos = rnd.next(1, n);\n            int x = rnd.next(-1000000000, 1000000000);\n            queries[i] = make_tuple(pos, pos, x);\n        }\n    } else if (type == \"front\") {\n        int r = rnd.next(1, n);\n        int x = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < q; ++i) {\n            queries[i] = make_tuple(1, r, x);\n        }\n    } else if (type == \"back\") {\n        int l = rnd.next(1, n);\n        int x = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < q; ++i) {\n            queries[i] = make_tuple(l, n, x);\n        }\n    } else if (type == \"zeros\") {\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int x = 0;\n            queries[i] = make_tuple(l, r, x);\n        }\n    }\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type_a = opt<string>(\"type_a\", \"random\");\n    string type_b = opt<string>(\"type_b\", \"random\");\n    string type_q = opt<string>(\"type_q\", \"random\");\n\n    vector<int> a = generate_array(n, type_a);\n    vector<int> b = generate_array(m, type_b);\n    vector<tuple<int,int,int>> queries = generate_queries(n, q, type_q);\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output array a\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output array b\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    // Output queries\n    for(int i = 0; i < q; ++i) {\n        int l, r, x;\n        tie(l, r, x) = queries[i];\n        printf(\"%d %d %d\\n\", l, r, x);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size test case\n./gen -n 1 -m 1 -q 1 -type_a zeros -type_b zeros -type_q zeros\n\n# Small random test cases\n./gen -n 5 -m 5 -q 5 -type_a random -type_b random -type_q random\n./gen -n 10 -m 15 -q 10 -type_a random -type_b random -type_q random\n\n# Maximum size test cases with random values\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q random\n\n# Maximum size test cases with maximum and minimum values\n./gen -n 100000 -m 100000 -q 100000 -type_a max -type_b min -type_q random\n./gen -n 100000 -m 100000 -q 100000 -type_a min -type_b max -type_q random\n\n# Test case with equal elements in arrays\n./gen -n 1000 -m 1000 -q 1000 -type_a equal -type_b equal -type_q random\n\n# Arrays with increasing and decreasing sequences\n./gen -n 100000 -m 100000 -q 100000 -type_a increasing -type_b decreasing -type_q random\n\n# Arrays with alternating maximum and minimum values\n./gen -n 99999 -m 99999 -q 99999 -type_a alternating -type_b alternating -type_q random\n\n# Test cases where n equals m\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q random\n\n# Test cases where m - n is maximum\n./gen -n 1 -m 100000 -q 100000 -type_a random -type_b random -type_q random\n\n# Test cases with small n and large m\n./gen -n 50 -m 100000 -q 100000 -type_a random -type_b random -type_q random\n\n# Queries updating the full range\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q full\n\n# Queries updating single elements\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q single\n\n# Queries with zero updates\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q zeros\n\n# Test case with arrays a and b being equal\n./gen -n 1000 -m 1000 -q 1000 -type_a equal -type_b equal -type_q random\n\n# Small n and m with random values\n./gen -n 2 -m 2 -q 2 -type_a random -type_b random -type_q random\n\n# Test cases with arrays of maximum and minimum values\n./gen -n 1000 -m 1000 -q 1000 -type_a max -type_b max -type_q random\n./gen -n 1000 -m 1000 -q 1000 -type_a min -type_b min -type_q random\n\n# Test case with zero elements in arrays and queries\n./gen -n 100 -m 100 -q 100 -type_a zeros -type_b zeros -type_q zeros\n\n# Test cases with large updates\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q full\n\n# Test case with n = m and minimal updates\n./gen -n 100000 -m 100000 -q 1 -type_a random -type_b random -type_q zeros\n\n# Test cases with arrays a and b as increasing sequences\n./gen -n 100000 -m 100000 -q 100000 -type_a increasing -type_b increasing -type_q random\n\n# Test cases with arrays a and b as decreasing sequences\n./gen -n 100000 -m 100000 -q 100000 -type_a decreasing -type_b decreasing -type_q random\n\n# Test case with maximum n, m and q but minimal updates\n./gen -n 100000 -m 100000 -q 1 -type_a random -type_b random -type_q single\n\n# Test cases with updates only at the front of the array\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q front\n\n# Test cases with updates only at the back of the array\n./gen -n 100000 -m 100000 -q 100000 -type_a random -type_b random -type_q back\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:37.300433",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "862/F",
      "title": "F. Mahmoud and Ehab and the final stage",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains 2 integers n and q (1 ≤ n ≤ 105, 1 ≤ q ≤ 105) – The number of strings and the number of queries, respectively.The second line contains n strings stri consisting of lowercase English letters.The next q lines describe the queries and may have one of the 2 forms:  1 a b (1 ≤ a ≤ b ≤ n). 2 x y (1 ≤ x ≤ n), where y is a string consisting of lowercase English letters.the total length of all strings in input won't exceed 105",
      "output_spec": "OutputFor each query of first type output its answer in a new line.",
      "sample_tests": "ExampleInputCopy5 9mahmoud mahmoudbadawy drmahmoud drevil mahmoud1 1 51 1 21 2 32 3 mahmoud2 4 mahmoud2 2 mahmouu1 1 51 2 31 1 1OutputCopy14141330127",
      "description": "F. Mahmoud and Ehab and the final stage\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains 2 integers n and q (1 ≤ n ≤ 105, 1 ≤ q ≤ 105) – The number of strings and the number of queries, respectively.The second line contains n strings stri consisting of lowercase English letters.The next q lines describe the queries and may have one of the 2 forms:  1 a b (1 ≤ a ≤ b ≤ n). 2 x y (1 ≤ x ≤ n), where y is a string consisting of lowercase English letters.the total length of all strings in input won't exceed 105\n\nOutputFor each query of first type output its answer in a new line.\n\nInputCopy5 9mahmoud mahmoudbadawy drmahmoud drevil mahmoud1 1 51 1 21 2 32 3 mahmoud2 4 mahmoud2 2 mahmouu1 1 51 2 31 1 1OutputCopy14141330127\n\nInputCopy5 9mahmoud mahmoudbadawy drmahmoud drevil mahmoud1 1 51 1 21 2 32 3 mahmoud2 4 mahmoud2 2 mahmouu1 1 51 2 31 1 1\n\nOutputCopy14141330127",
      "solutions": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'm glad to announce that on Sep/19/2017 15:05 UTC Codeforces Round #435 for the second division will take place. As usual, First division participants can take part out of competition.This round was prepared by me.I'd like to thank mohammedehab2002 for writing the statements and the editorials and testing the round, Livace,Alladdin,300iq and cdkrot for testing the round, vintage_Vlad_Makeev for helping us in contest preparation, translating the statements into Russian and making one of the problems more interesting, KAN and Ahmad_Elsagheer for giving their opinions and thoughts about the problems and MikeMirzayanov for the great Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them.The scoring distribution will be announced later.UPD. 500-1000-1500-1750-2000-2750**UPD Congratulations to the winners:Div1+Div2:1-Shik2-KassiJulgus3-I_love_Tanya_Romanova4-MrDindows5-scanhexDiv2:1-KassiJulgus2-scanhex3-qscqesze84-UpdateRatingOrRIOT5-NickRUPD editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54581",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1012
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces",
          "content": "862A - Mahmoud and Ehab and the MEXOne can see that in the final set all the elements less than x should exist, x shouldn't exist and any element greater than x doesn't matter, so we will count the number of elements less than x that don't exist in the initial set and add this to the answer, If x exists we'll add 1 to the answer because x should be removed .Time complexity : O(n + x) .Solution link (me) : https://pastebin.com/ALfcu8Ab .Solution link (mahmoudbadawy) : https://pastebin.com/yXLkmA5F .862B - Mahmoud and Ehab and the bipartitenessThe tree itself is bipartite so we can run a dfs to partition the tree into the 2 sets (called bicoloring), We can't add an edge between any 2 nodes in the same set and we can add an edge between every 2 nodes in different sets, so let the number of nodes in the left set be l and the number of nodes in the right set be r, The maximum number of edges that can exist is l * r, but n - 1 edges already exist so the maximum number of edges to be added is l * r - (n - 1).Time complexity : O(n) .Solution link (me) : https://pastebin.com/w3bF7gKS .Solution link (mahmoudbadawy) : https://pastebin.com/PMpte7nC .862C - Mahmoud and Ehab and the xorn = 2, x = 0 is the only case with answer \"NO\" .Let pw = 217 .First print 1, 2, ..., n - 3 (The first n - 3 positive integers), Let their bitwise-xor sum be y, If x = y You can add pw, pw * 2 and , Otherwise you can add 0, pw and , We handled the case x = y in a different way because if we add 0, pw and in this case, Then it's like adding 0, pw and pw, pw appears twice so we'll get wrong answer.Handle n = 1 (print x) and n = 2 (print 0 and x) .Solution link (mahmoudbadawy) : https://pastebin.com/w67KUY5u .862D - Mahmoud and Ehab and the binary stringIn the editorial we suppose that the answer of some query is the number of correct guessed positions which is equal to n minus hamming distance, The solutions in this editorial consider the answer of a query as n minus real answer, For convenience.Common things : Let zero(l, r) be a function that returns the number of zeros in the interval [l;r] minus the number of ones in it, We can find it in one query after a preprocessing query, The preprocessing query is 1111..., Let its answer be stored in all, If we made a query with a string full of ones except for the interval [l;r] which will be full of zeros, If this query's answer is cur, zero(l, r) = cur - all, That's because all is the number of ones in the interval [l;r] plus some trash and cur is the number of zeros in the interval plus the same trash .First solution by mahmoudbadawyLet's have a searching interval, initially this interval is [1;n] (The whole string), Let's repeat this until we reach our goal, Let mid = (l + r) / 2 Let's query to get zero(l, mid), If it's equal to r - l + 1, This interval is full of zeros so we can print any index in it as the index with value 0 and continue searching for an index with the value 1 in the interval [mid + 1;r], But if its value is equal to l - r - 1, This interval is full of ones so we can print any index in it as the index with value 1 and continue searching for a 0 in the interval [mid + 1;r], Otherwise the interval contains both values so we can continue searching for both in the interval [l;mid], Every time the searching interval length must be divided by 2 in any case so we perform O(log(n)) queries .Second solution by meLet's send 1111... and let the answer be ans1, Let's send 0111... and let the answer be ans0, We now know the value in the first index (1 if ans1 > ans0, 0 otherwise), We can binary search for the first index where the non-found value exists, which is to binary search on the first value x where zero(2, x) * sign(non - found bit value) ≠ x - 1 where sign(y) is 1 if y = 0,  - 1 otherwise .Solution link (me) : https://pastebin.com/Bc6q7TKv .Solution link (mahmoudbadawy) : https://pastebin.com/RMyLDMxw .862E - Mahmoud and Ehab and the functionLet's write f(j) in another way:-Now we have 2 sums, The first one is constant (doesn't depend on j), For the second sum we can calculate all its possible values using sliding window technique, Now we want a data-structure that takes the value of the first sum and chooses the best second sum from all the choices .observation: We don't have to try all the possible values of f(j) to minimize the expression, If the first sum is c, We can try only the least value greater than  - c and the greatest value less than  - c ( - c not c because we are minimizing c + second not c - second) because the absolute value means the distance between the two values on the number line, Any other value will be further than at least one of the chosen values, To do this we can keep all the values of f(j) sorted and try the elements numbered lower_bound(-c) and lower_bound(-c)-1 and choose the better (In short we're trying the values close to  - c only).Now we have a data-structure that can get us the minimum value of the expression once given the value of the first sum in O(log(n)), Now we want to keep track of the value of the first sum .Let the initial value be c, In each update, If the length of the updated interval is even, The sum won't change because x will be added as many times as it's subtracted, Otherwise x will be added to c or subtracted from c depending of the parity of l (the left-bound of the interval) .Time complexity : O(n + (m + q)log(m)) .Solution link (me) : https://pastebin.com/u828DjcS .Solution link (mahmoudbadawy) : https://pastebin.com/dA3K8nfK .862F - Mahmoud and Ehab and the final stageFirst, Let's get rid of the LCP part .observation: , That could make us transform the LCP part into a minimization part by making an array lcp where lcpi = LCP(si, si + 1), You could calculate it naively, And when an update happens at index a, You should update lcpa (If exists) and lcpa - 1 (If exists) naively .Now the problem reduces to finding a ≤ l ≤ r ≤ b that maximizes the value:-, If we have a histogram where the ith column has height lcpi, The the size of the largest rectangle that fits in the columns from l to r - 1 is , That's close to our formula not the same but it's not a problem (You'll see how to fix it later), so to get rid of finding the l and r part, We can make that histogram and the answer for a query will be the largest rectangle in the subhistogram that contains the columns from a to b - 1, One of the ways to solve it is to try some heights h and see the maximum width we can achieve if h was the height, call it w, and maximize with h * w, To solve the slight difference in formulas problem we'll just maximize with h * (w + 1)!!Let BU be a value the we'll choose later, We have 2 cases for our largest rectangle's height h, It could be either h ≤ BU or h > BU, We will solve both problems separately.For h ≤ BU we can maintain BU segment trees, Segment tree number i has 1 at index x if lcpx ≥ i and 0 otherwise, When we query, It should get us the longest subsegment of ones in the query range, Let's see what we need for our merging operation, If we want the answer for the longest subsegment of ones in a range [l;r], Let mid = (l + r) / 2, Then the answer is the maximum between the answer of [l;mid], The answer of [mid + 1;r], And the maximum suffix of ones in the range [l;mid] added to the maximum prefix of ones in the range [mid + 1;r] . So we need to keep all these information in our node and also the length of the interval, As it's a well-known problem I won't get into more detail. Back to our problem, We can loop over all h ≤ BU, Let the answer for the query on range [a;b - 1] in segment tree number h be w, The maximum width of a rectangle of height h in this range is w and we'll maximize our answer with h * (w + 1) .For h > BU, Let's call a column of height greater than BU big, The heights we'll try are the heights of the big columns in the range, We don't have to try all the heights greater the BU, There are at most big columns (Where tot is the total length of strings in input), Let's keep them in a set, When an update happens, You should add the column to the set or remove it depending on its new height, The set's size can't exceed now, Let's see how to answer a query, Let's loop over the big columns in range [a;b - 1] only, If 2 of them aren't consecutive then the column after the first can't be big and the column before the second either, That's because if it were big, It would be in our set, So we can use this observation by making a new histogram with the big columns in the range only, And put a column with height 0 between any non-consecutive two, And get the largest rectangle in this histogram by the stack way for example in , The stack way will get us the maximum width w we can achieve for a rectangle containing column number i, We'll maximize with lcpi * (w + 1).Also the answer for our main formula can be an interval of length one, All what I mentioned doesn't cover this, You should maintain another segment tree that gets the maximum length of a string in a range for this .Maximize all what we got, You have the answer, Now it's time to choose BU, It's optimal in time to choose BU near (Reason in tfg's comment below) .Optimization: The longest subsegment of ones problem is solved by BU segment trees and each one has 4 integers in each node, You can make them 2 integers (max prefix and suffix of ones) and make another only one segment tree that has the rest of the integers, That would divide the memory by 2 .Time complexity : Thanks to vintage_Vlad_Makeev for making it harder and more interesting .Solution link (vintage_Vlad_Makeev) : https://pastebin.com/vQ4RJqh0 .Solution link (mahmoudbadawy) : https://pastebin.com/t3Vetzwf .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54590",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 862\\s*F"
          },
          "content_length": 9689
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 1",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 2",
          "code": "int one = 0;\n    queue<int> q;\n    q.push(1);\n    v[1] = true;\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        if(v[u])\n        {\n            one++;\n        }\n        vector<int>::iterator iter;\n        for(iter = e[u].begin(); iter != e[u].end(); iter++)\n        {\n            v[*iter] = !v[u];\n            q.push(*iter);\n        }\n    }\n\n    int count = (one * (n-one)) - (n-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 3",
          "code": "(rand()<<15)|rand()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 4",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 5",
          "code": "if(RAND_MAX < 1<<16)\n    x = (rand()<<15)|rand();\nelse\n    x = rand();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 6",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 4 8 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+7;\nint a[maxn];\n\nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,x;cin>>n>>x;\n\tint sum=0;\n\tfor(int i=0;i<n;i++)a[i]=i,sum^=i;\n\tint nwx=x^sum;\n\ta[0]=nwx;\n\tif(nwx>0&&nwx<n)a[nwx]+=(1<<15),a[(nwx==1?2:nwx-1)]+=(1<<15);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \"\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 10",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 11",
          "code": "> 10^5 is ok, just <= 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 12",
          "code": "if(fans[sizea]==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #435 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> pref_l(n);\n  pref_l[0] = layers[0];\n  if (max_l > 0) pref_l[1] = layers[1];\n  for (int i = 2; i <= max_l; ++i) {\n    pref_l[i] = pref_l[i - 2] + layers[i];\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54581",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 1",
          "code": "lower_bound(-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 2",
          "code": "lower_bound(-c)-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 3",
          "code": "[100000+1, 1000000/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 4",
          "code": "{pw, pw*2, pw^(pw*2)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 5",
          "code": "{0, pw, pw^x^y}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 6",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        },
        {
          "title": "Codeforces round #435 editorial - Codeforces - Code 7",
          "code": "if (!tot<15)\n{\n     cout<<0<<\"\\n\";\n     cout<<flush;\n     exit(0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54590",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readToken(\"[a-z]+\", \"str_i\");\n        ensuref(s.size() >= 1, \"Each str_i must be non-empty\");\n        total_length += s.size();\n        if (i + 1 < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        if (t == 1) {\n            int a = inf.readInt(1, n, \"a\");\n            inf.readSpace();\n            int b = inf.readInt(a, n, \"b\");  // 1 ≤ a ≤ b ≤ n\n            inf.readEoln();\n        } else if (t == 2) {\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            string y = inf.readToken(\"[a-z]+\", \"y\");\n            ensuref(y.size() >= 1, \"The string y in query must be non-empty\");\n            total_length += y.size();\n            ensuref(total_length <= 100000, \"The total length of strings must not exceed 1e5\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readToken(\"[a-z]+\", \"str_i\");\n        ensuref(s.size() >= 1, \"Each str_i must be non-empty\");\n        total_length += s.size();\n        if (i + 1 < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        if (t == 1) {\n            int a = inf.readInt(1, n, \"a\");\n            inf.readSpace();\n            int b = inf.readInt(a, n, \"b\");  // 1 ≤ a ≤ b ≤ n\n            inf.readEoln();\n        } else if (t == 2) {\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            string y = inf.readToken(\"[a-z]+\", \"y\");\n            ensuref(y.size() >= 1, \"The string y in query must be non-empty\");\n            total_length += y.size();\n            ensuref(total_length <= 100000, \"The total length of strings must not exceed 1e5\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readToken(\"[a-z]+\", \"str_i\");\n        ensuref(s.size() >= 1, \"Each str_i must be non-empty\");\n        total_length += s.size();\n        if (i + 1 < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        if (t == 1) {\n            int a = inf.readInt(1, n, \"a\");\n            inf.readSpace();\n            int b = inf.readInt(a, n, \"b\");  // 1 ≤ a ≤ b ≤ n\n            inf.readEoln();\n        } else if (t == 2) {\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            string y = inf.readToken(\"[a-z]+\", \"y\");\n            ensuref(y.size() >= 1, \"The string y in query must be non-empty\");\n            total_length += y.size();\n            ensuref(total_length <= 100000, \"The total length of strings must not exceed 1e5\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"default\");\n\n    int maxTotalLength = 100000;\n    int totalLength = 0;\n\n    vector<string> strings(n);\n\n    // Generate initial strings\n    if (type == \"identicalStrings\") {\n        // All strings are the same\n        int l = maxTotalLength / (n + q + 1);\n        if (l == 0) l = 1;\n        string s = \"\";\n        for (int i = 0; i < l; ++i) s += (char)('a' + rnd.next(26));\n        totalLength += l * n;\n        for (int i = 0; i < n; ++i) strings[i] = s;\n    } else if (type == \"singleCharStrings\") {\n        totalLength += n;\n        for (int i = 0; i < n; ++i) strings[i] = string(1, (char)('a' + rnd.next(26)));\n    } else if (type == \"maxStrings\") {\n        // Maximize total length for initial strings\n        int l = maxTotalLength / (n + q + 1);\n        if (l == 0) l = 1;\n        totalLength += l * n;\n        for (int i = 0; i < n; ++i){\n            string s = \"\";\n            for(int j = 0; j < l; ++j) s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    } else if (type == \"randomStrings\") {\n        for (int i = 0; i < n; ++i) {\n            int maxLen = min(1000, maxTotalLength - totalLength - (n - i - 1));\n            int l = rnd.next(1, maxLen);\n            totalLength += l;\n            string s = \"\";\n            for(int j = 0; j < l; ++j) s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    } else if (type == \"smallStrings\"){\n        for (int i = 0; i < n; ++i){\n            int l = rnd.next(1,2);\n            totalLength += l;\n            string s = \"\";\n            for(int j = 0; j < l; ++j)\n                s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    } else {\n        // Default: random strings\n        for (int i = 0; i < n; ++i){\n            int maxLen = min(100, maxTotalLength - totalLength - (n - i - 1));\n            int l = rnd.next(1, maxLen);\n            totalLength += l;\n            string s = \"\";\n            for(int j = 0; j < l; ++j) s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i){\n        printf(\"%s%c\", strings[i].c_str(), i == n - 1 ? '\\n' : ' ');\n    }\n\n    int totalUpdateLength = 0;\n    int remainingQueries = q;\n    for (int i = 0; i < q; ++i){\n        int queryType;\n        if (type == \"allType1Queries\") {\n            queryType = 1;\n        } else if (type == \"allType2Queries\") {\n            queryType = 2;\n        } else if (type == \"alternatingQueries\") {\n            queryType = i % 2 + 1;\n        } else if (type == \"randomQueries\") {\n            queryType = rnd.next(1,2);\n        } else if (type == \"queryOverFullRange\") {\n            queryType = 1;\n        } else {\n            queryType = rnd.next(1,2);\n        }\n        if (queryType == 1){\n            // Query type 1\n            int a, b;\n            if (type == \"queryOverFullRange\") {\n                a = 1;\n                b = n;\n            } else {\n                a = rnd.next(1, n);\n                b = rnd.next(a, n);\n            }\n            printf(\"1 %d %d\\n\", a, b);\n        } else {\n            // Query type 2\n            if (totalLength + totalUpdateLength >= maxTotalLength) {\n                // Switch to type 1 query if we have exceeded total length\n                int a = rnd.next(1, n);\n                int b = rnd.next(a, n);\n                printf(\"1 %d %d\\n\", a, b);\n                continue;\n            }\n            int x = rnd.next(1, n);\n\n            int remainingUpdates = q - i - 1;\n            int availableLength = maxTotalLength - (totalLength + totalUpdateLength + remainingUpdates);\n            if (availableLength <= 0) availableLength = 1;\n            int l = rnd.next(1, min(availableLength, 1000));\n            string y = \"\";\n            for (int j = 0; j < l; ++j) y += (char)('a' + rnd.next(26));\n            totalUpdateLength += l;\n            printf(\"2 %d %s\\n\", x, y.c_str());\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"default\");\n\n    int maxTotalLength = 100000;\n    int totalLength = 0;\n\n    vector<string> strings(n);\n\n    // Generate initial strings\n    if (type == \"identicalStrings\") {\n        // All strings are the same\n        int l = maxTotalLength / (n + q + 1);\n        if (l == 0) l = 1;\n        string s = \"\";\n        for (int i = 0; i < l; ++i) s += (char)('a' + rnd.next(26));\n        totalLength += l * n;\n        for (int i = 0; i < n; ++i) strings[i] = s;\n    } else if (type == \"singleCharStrings\") {\n        totalLength += n;\n        for (int i = 0; i < n; ++i) strings[i] = string(1, (char)('a' + rnd.next(26)));\n    } else if (type == \"maxStrings\") {\n        // Maximize total length for initial strings\n        int l = maxTotalLength / (n + q + 1);\n        if (l == 0) l = 1;\n        totalLength += l * n;\n        for (int i = 0; i < n; ++i){\n            string s = \"\";\n            for(int j = 0; j < l; ++j) s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    } else if (type == \"randomStrings\") {\n        for (int i = 0; i < n; ++i) {\n            int maxLen = min(1000, maxTotalLength - totalLength - (n - i - 1));\n            int l = rnd.next(1, maxLen);\n            totalLength += l;\n            string s = \"\";\n            for(int j = 0; j < l; ++j) s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    } else if (type == \"smallStrings\"){\n        for (int i = 0; i < n; ++i){\n            int l = rnd.next(1,2);\n            totalLength += l;\n            string s = \"\";\n            for(int j = 0; j < l; ++j)\n                s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    } else {\n        // Default: random strings\n        for (int i = 0; i < n; ++i){\n            int maxLen = min(100, maxTotalLength - totalLength - (n - i - 1));\n            int l = rnd.next(1, maxLen);\n            totalLength += l;\n            string s = \"\";\n            for(int j = 0; j < l; ++j) s += (char)('a' + rnd.next(26));\n            strings[i] = s;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i){\n        printf(\"%s%c\", strings[i].c_str(), i == n - 1 ? '\\n' : ' ');\n    }\n\n    int totalUpdateLength = 0;\n    int remainingQueries = q;\n    for (int i = 0; i < q; ++i){\n        int queryType;\n        if (type == \"allType1Queries\") {\n            queryType = 1;\n        } else if (type == \"allType2Queries\") {\n            queryType = 2;\n        } else if (type == \"alternatingQueries\") {\n            queryType = i % 2 + 1;\n        } else if (type == \"randomQueries\") {\n            queryType = rnd.next(1,2);\n        } else if (type == \"queryOverFullRange\") {\n            queryType = 1;\n        } else {\n            queryType = rnd.next(1,2);\n        }\n        if (queryType == 1){\n            // Query type 1\n            int a, b;\n            if (type == \"queryOverFullRange\") {\n                a = 1;\n                b = n;\n            } else {\n                a = rnd.next(1, n);\n                b = rnd.next(a, n);\n            }\n            printf(\"1 %d %d\\n\", a, b);\n        } else {\n            // Query type 2\n            if (totalLength + totalUpdateLength >= maxTotalLength) {\n                // Switch to type 1 query if we have exceeded total length\n                int a = rnd.next(1, n);\n                int b = rnd.next(a, n);\n                printf(\"1 %d %d\\n\", a, b);\n                continue;\n            }\n            int x = rnd.next(1, n);\n\n            int remainingUpdates = q - i - 1;\n            int availableLength = maxTotalLength - (totalLength + totalUpdateLength + remainingUpdates);\n            if (availableLength <= 0) availableLength = 1;\n            int l = rnd.next(1, min(availableLength, 1000));\n            string y = \"\";\n            for (int j = 0; j < l; ++j) y += (char)('a' + rnd.next(26));\n            totalUpdateLength += l;\n            printf(\"2 %d %s\\n\", x, y.c_str());\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type smallStrings\n./gen -n 1 -q 1 -type maxStrings\n./gen -n 10 -q 1000 -type smallStrings\n./gen -n 10 -q 1000 -type identicalStrings\n./gen -n 100 -q 1000 -type randomStrings\n./gen -n 1000 -q 1000 -type randomStrings\n./gen -n 1000 -q 10000 -type maxStrings\n./gen -n 100000 -q 1 -type smallStrings\n./gen -n 100000 -q 1 -type identicalStrings\n./gen -n 100000 -q 100000 -type randomStrings\n./gen -n 100000 -q 100000 -type allType1Queries\n./gen -n 100000 -q 100000 -type allType2Queries\n./gen -n 100000 -q 100000 -type alternatingQueries\n./gen -n 50000 -q 100000 -type randomStrings\n./gen -n 100000 -q 100000 -type queryOverFullRange\n./gen -n 100000 -q 100000 -type randomQueries\n./gen -n 50000 -q 50000 -type maxStrings\n./gen -n 100 -q 100000 -type randomQueries\n./gen -n 1000 -q 100000 -type randomQueries\n./gen -n 50000 -q 50000 -type smallStrings\n./gen -n 100000 -q 100000 -type smallStrings\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:39.274410",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/A",
      "title": "A. Quasi-palindrome",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer number x (1 ≤ x ≤ 109). This number is given without any leading zeroes.",
      "output_spec": "OutputPrint \"YES\" if number x is quasi-palindromic. Otherwise, print \"NO\" (without quotes).",
      "sample_tests": "ExamplesInputCopy131OutputCopyYESInputCopy320OutputCopyNOInputCopy2010200OutputCopyYES",
      "description": "A. Quasi-palindrome\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer number x (1 ≤ x ≤ 109). This number is given without any leading zeroes.\n\nOutputPrint \"YES\" if number x is quasi-palindromic. Otherwise, print \"NO\" (without quotes).\n\nInputCopy131OutputCopyYESInputCopy320OutputCopyNOInputCopy2010200OutputCopyYES\n\nInputCopy131\n\nOutputCopyYES\n\nInputCopy320\n\nOutputCopyNO\n\nInputCopy2010200\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Hello Codeforces!On September 21, 18:05 MSK Educational Codeforces Round 29 will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.The round will be unrated for all users and will be held on extented ACM ICPC rules. After the end of the contest you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were prepared by Mikhail awoo Piklyaev, Mikhail MikeMirzayanov Mirzayanov, Vladimir vovuh Petrov and me.Good luck to all participants!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 720
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces",
          "content": "863A - Quasi-palindromeYou can check if the given is quasi-palindromic by removing all the trailing zeros and checking if resulting string is a palindrome. 863B - KayakingFirstly let's learn how to split persons in pairs as if there are no single kayaks. Let there be people with weights a, b, c and d (a ≤ b ≤ c ≤ d). Obviously, the lowest instability you can achieve is max(b - a, d - c). Swapping any two elements will only make the result greater. This greedy strategy can be used to distribute all the seats.Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest. The answer will be the minimun instabily over all pairs.Overall complexity: O(n3). 863C - 1-2-3Notice that there are only 9 possible patterns in this game. You can used in a following way. Simulate games till one of the patterns get repeated. Games between this pair of occurences will get you the same total outcome no matter when they are played. Let the distance between the games with the same pattern is dif and index of these games are idx1 and idx2 (zero-indexed). Total score of some interval is score(l, r). Then the answer will be score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Yet Another Array Queries ProblemOne can guess from the constraits that complexity of the algorithm should be either O(nm + q) or O(qm). And there is a solution with the second one.Let's try to solve the reversed problem — answer what position will some number be at after all the queries. Check the impact of some query on position pos. Let the query be on some segment [l, r]. If pos is outside this segment then you can skip it. Otherwise reverse will swap apos and ar - (pos - l), shift will swap apos and apos - 1 (if pos = l then it will be r instead of (pos - 1)).This task can be translated to the given one just by reversing the query list. Overall complexity: O(qm).Obviously, you can also solve it with Cartesian tree online in . 863E - Turn Off The TVFirstly let's compress the moments of time. Note that storing only l and r isn't enough (consider pairs ([1, 2], [3, 4]) and ([1, 2], [4, 5])), you also should take (l - 1).Now moments of time are up to 6·105. For every moment calculate the number of segments to cover it (make cntl +  = 1 and cntr + 1 -  = 1 for each segment and take prefix sums over this array). Then let prefi be the number of moments of time covered by only one segment on some prefix up to i-th moment. And finally if for some segment [l, r] from the input prefr - prefl - 1 is 0 then you can safely delete this segment.Overall complexity: . 863F - Almost PermutationThis problem can be solved with mincost maxflow approach.Let's construct a following network: Construct a vertex for every number from 1 to n. For each of these vertices add n directed edges from the source to this vertex, the capacity of each edge will be 1, and the costs will be 1, 3, 5, ..., 2n - 1 (so pushing k flow from the source to the vertex will cost exactly k2); Also construct a vertex for every index of the array. For each number make add a directed edge with capacity 1 and cost 0 to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity 1 and cost 0. Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network. 863G - Graphic SettingsIf m = 1, then everything is simple. Cycle exists if a[1] = 2, and path exists if b[1] = 1 or b[1] = a[1].Let's consider the case when m = 2. Let's call the combination odd if the sum of parameters is odd for this combination, and even otherwise. It's easy to see that if a[1] and a[2] are both odd, then it's impossible to construct a cycle because the number of even combinations is greater than the number of odd combinations. Furthermore, it's impossible to construct a path if our initial combination is an odd one.Let's show how to construct answer in all other cases. Constructing a cycle is easy if at least one of a[i] is even: And constructing a path can be divided into four cases.Starting point in corner: Start near the border: Both coordinates of starting point are even: Both coordinates are odd: So the case when m = 2 is solved.Now, if m = 3, then it can be reduced to m = 2 as follows:Suppose we have a[1] = 3, a[2] = 3, a[3] = 3. Then let's at first consider only combinations where the third parameter is equal to 1: Then, if we need to add the combinations with third parameter equal to 2, we mirror the \"layer\": And if we need to add the third \"layer\", we mirror it again: And so on.This way can also be used to reduce m > 3 to m = 2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*A"
          },
          "content_length": 4817
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-9][0-9]{0,9}\", \"x\");\n    long long x = atoll(s.c_str());\n    ensuref(x >= 1 && x <= 1000000000LL, \"x must be between 1 and 10^9, but x=%lld\", x);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-9][0-9]{0,9}\", \"x\");\n    long long x = atoll(s.c_str());\n    ensuref(x >= 1 && x <= 1000000000LL, \"x must be between 1 and 10^9, but x=%lld\", x);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-9][0-9]{0,9}\", \"x\");\n    long long x = atoll(s.c_str());\n    ensuref(x >= 1 && x <= 1000000000LL, \"x must be between 1 and 10^9, but x=%lld\", x);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int xmax = opt<int>(\"xmax\", 1000000000); // default to 1e9\n    int x;\n\n    if (type == \"palindrome\") {\n        // Generate a palindromic number x in [1, xmax]\n        while (true) {\n            // Randomly choose length l (number of digits)\n            int l = rnd.next(1, 9); // maximum 9 digits since xmax is up to 1e9\n            // Generate half of the digits\n            int half = (l + 1) / 2;\n            string s = \"\";\n            for (int i = 0; i < half; ++i) {\n                char d = '0' + rnd.next(0,9);\n                s += d;\n            }\n            // Mirror the digits to get full number\n            string rev_s = s;\n            if (l % 2 == 1) rev_s.pop_back();\n            reverse(rev_s.begin(), rev_s.end());\n            s += rev_s;\n            // Convert to integer\n            x = stoi(s);\n            if (x >= 1 && x <= xmax) {\n                break;\n            }\n            // Else try again\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"needs_leading_zeros\") {\n        // Generate a number x that is not palindromic as is,\n        // but will be palindromic after adding leading zeros\n        while (true) {\n            // Generate a palindrome string with leading zeros\n            int total_length = rnd.next(2,9);\n            int num_leading_zeros = rnd.next(1, total_length - 1);\n            int pal_length = total_length;\n            string s = \"\";\n            for (int i = 0; i < pal_length / 2; ++i) {\n                char d = '0' + rnd.next(0,9);\n                s += d;\n            }\n            // Mirror to get palindrome\n            string rev_s = s;\n            if (pal_length % 2 == 1) {\n                char d = '0' + rnd.next(0,9);\n                s += d;\n            }\n            reverse(rev_s.begin(), rev_s.end());\n            s += rev_s;\n            // Add leading zeros\n            string pal_with_leading_zeros = string(num_leading_zeros, '0') + s;\n            // Remove the leading zeros to get x\n            string x_str = s;\n            // Remove leading zeros from x_str\n            size_t first_non_zero = x_str.find_first_not_of('0');\n            if (first_non_zero == string::npos) continue;\n            x_str = x_str.substr(first_non_zero);\n            x = stoi(x_str);\n            if (x >= 1 && x <= xmax) {\n                // Ensure that x is not palindrome as is\n                string x_rev = x_str;\n                reverse(x_rev.begin(), x_rev.end());\n                if (x_str != x_rev) {\n                    break;\n                }\n            }\n            // Else try again\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"not_quasi_palindrome\") {\n        // Generate a number x that cannot become palindrome even after adding leading zeros\n        while (true) {\n            x = rnd.next(1, xmax);\n            string x_str = to_string(x);\n            // Attempt to make palindrome by adding leading zeros\n            // The maximum possible is to add leading zeros to make lengths up to 9\n            bool is_quasi_palindrome = false;\n            for (int len = x_str.length(); len <= 9; ++len) {\n                string s = string(len - x_str.length(), '0') + x_str;\n                string s_rev = s;\n                reverse(s_rev.begin(), s_rev.end());\n                if (s == s_rev) {\n                    is_quasi_palindrome = true;\n                    break;\n                }\n            }\n            if (!is_quasi_palindrome) {\n                break;\n            }\n            // Else try again\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"random\") {\n        x = rnd.next(1, xmax);\n        printf(\"%d\\n\", x);\n    } else if (type == \"trailing_zeros\") {\n        // Generate x with trailing zeros\n        while (true) {\n            int num_digits = rnd.next(2, 9);\n            int num_trailing_zeros = rnd.next(1, num_digits - 1); // At least 1 trailing zero\n            string s = \"\";\n            s += '1' + rnd.next(0,8); // first digit not zero\n            for (int i = 1; i < num_digits - num_trailing_zeros; ++i) {\n                s += '0' + rnd.next(0,9);\n            }\n            s += string(num_trailing_zeros, '0');\n            x = stoi(s);\n            if (x >= 1 && x <= xmax) {\n                break;\n            }\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"max\") {\n        x = xmax;\n        printf(\"%d\\n\", x);\n    } else if (type == \"minimal\") {\n        x = 1;\n        printf(\"%d\\n\", x);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int xmax = opt<int>(\"xmax\", 1000000000); // default to 1e9\n    int x;\n\n    if (type == \"palindrome\") {\n        // Generate a palindromic number x in [1, xmax]\n        while (true) {\n            // Randomly choose length l (number of digits)\n            int l = rnd.next(1, 9); // maximum 9 digits since xmax is up to 1e9\n            // Generate half of the digits\n            int half = (l + 1) / 2;\n            string s = \"\";\n            for (int i = 0; i < half; ++i) {\n                char d = '0' + rnd.next(0,9);\n                s += d;\n            }\n            // Mirror the digits to get full number\n            string rev_s = s;\n            if (l % 2 == 1) rev_s.pop_back();\n            reverse(rev_s.begin(), rev_s.end());\n            s += rev_s;\n            // Convert to integer\n            x = stoi(s);\n            if (x >= 1 && x <= xmax) {\n                break;\n            }\n            // Else try again\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"needs_leading_zeros\") {\n        // Generate a number x that is not palindromic as is,\n        // but will be palindromic after adding leading zeros\n        while (true) {\n            // Generate a palindrome string with leading zeros\n            int total_length = rnd.next(2,9);\n            int num_leading_zeros = rnd.next(1, total_length - 1);\n            int pal_length = total_length;\n            string s = \"\";\n            for (int i = 0; i < pal_length / 2; ++i) {\n                char d = '0' + rnd.next(0,9);\n                s += d;\n            }\n            // Mirror to get palindrome\n            string rev_s = s;\n            if (pal_length % 2 == 1) {\n                char d = '0' + rnd.next(0,9);\n                s += d;\n            }\n            reverse(rev_s.begin(), rev_s.end());\n            s += rev_s;\n            // Add leading zeros\n            string pal_with_leading_zeros = string(num_leading_zeros, '0') + s;\n            // Remove the leading zeros to get x\n            string x_str = s;\n            // Remove leading zeros from x_str\n            size_t first_non_zero = x_str.find_first_not_of('0');\n            if (first_non_zero == string::npos) continue;\n            x_str = x_str.substr(first_non_zero);\n            x = stoi(x_str);\n            if (x >= 1 && x <= xmax) {\n                // Ensure that x is not palindrome as is\n                string x_rev = x_str;\n                reverse(x_rev.begin(), x_rev.end());\n                if (x_str != x_rev) {\n                    break;\n                }\n            }\n            // Else try again\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"not_quasi_palindrome\") {\n        // Generate a number x that cannot become palindrome even after adding leading zeros\n        while (true) {\n            x = rnd.next(1, xmax);\n            string x_str = to_string(x);\n            // Attempt to make palindrome by adding leading zeros\n            // The maximum possible is to add leading zeros to make lengths up to 9\n            bool is_quasi_palindrome = false;\n            for (int len = x_str.length(); len <= 9; ++len) {\n                string s = string(len - x_str.length(), '0') + x_str;\n                string s_rev = s;\n                reverse(s_rev.begin(), s_rev.end());\n                if (s == s_rev) {\n                    is_quasi_palindrome = true;\n                    break;\n                }\n            }\n            if (!is_quasi_palindrome) {\n                break;\n            }\n            // Else try again\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"random\") {\n        x = rnd.next(1, xmax);\n        printf(\"%d\\n\", x);\n    } else if (type == \"trailing_zeros\") {\n        // Generate x with trailing zeros\n        while (true) {\n            int num_digits = rnd.next(2, 9);\n            int num_trailing_zeros = rnd.next(1, num_digits - 1); // At least 1 trailing zero\n            string s = \"\";\n            s += '1' + rnd.next(0,8); // first digit not zero\n            for (int i = 1; i < num_digits - num_trailing_zeros; ++i) {\n                s += '0' + rnd.next(0,9);\n            }\n            s += string(num_trailing_zeros, '0');\n            x = stoi(s);\n            if (x >= 1 && x <= xmax) {\n                break;\n            }\n        }\n        printf(\"%d\\n\", x);\n    } else if (type == \"max\") {\n        x = xmax;\n        printf(\"%d\\n\", x);\n    } else if (type == \"minimal\") {\n        x = 1;\n        printf(\"%d\\n\", x);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random numbers\n./gen\n\n# Generate random numbers with different maximum values\n./gen -type random -xmax 100\n./gen -type random -xmax 1000\n./gen -type random -xmax 1000000\n\n# Generate palindromic numbers\n./gen -type palindrome -xmax 10\n./gen -type palindrome -xmax 100\n./gen -type palindrome -xmax 1000\n./gen -type palindrome -xmax 1000000\n./gen -type palindrome -xmax 1000000000\n\n# Generate numbers that need leading zeros to become palindromic\n./gen -type needs_leading_zeros -xmax 100\n./gen -type needs_leading_zeros -xmax 1000\n./gen -type needs_leading_zeros -xmax 1000000\n./gen -type needs_leading_zeros -xmax 1000000000\n\n# Generate numbers that cannot be made palindromic even with leading zeros\n./gen -type not_quasi_palindrome -xmax 100\n./gen -type not_quasi_palindrome -xmax 1000\n./gen -type not_quasi_palindrome -xmax 1000000\n./gen -type not_quasi_palindrome -xmax 1000000000\n\n# Generate numbers with trailing zeros\n./gen -type trailing_zeros -xmax 1000000000\n\n# Generate maximum and minimal numbers\n./gen -type max -xmax 1000000000\n./gen -type minimal\n\n# Generate multiple palindromic numbers to ensure variety\n./gen -type palindrome -xmax 1000000000\n./gen -type palindrome -xmax 1000000000\n./gen -type palindrome -xmax 1000000000\n\n# Generate multiple numbers that need leading zeros\n./gen -type needs_leading_zeros -xmax 1000000000\n./gen -type needs_leading_zeros -xmax 1000000000\n\n# Generate multiple numbers that cannot be made palindromic\n./gen -type not_quasi_palindrome -xmax 1000000000\n./gen -type not_quasi_palindrome -xmax 1000000000\n\n# Generate random large numbers\n./gen -type random -xmax 1000000000\n./gen -type random -xmax 1000000000\n./gen -type random -xmax 1000000000\n\n# Edge cases\n./gen -type max -xmax 1\n./gen -type minimal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:41.513789",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/B",
      "title": "B. Kayaking",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one number n (2 ≤ n ≤ 50).The second line contains 2·n integer numbers w1, w2, ..., w2n, where wi is weight of person i (1 ≤ wi ≤ 1000).",
      "output_spec": "OutputPrint minimum possible total instability.",
      "sample_tests": "ExamplesInputCopy21 2 3 4OutputCopy1InputCopy41 3 4 6 3 4 100 200OutputCopy5",
      "description": "B. Kayaking\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one number n (2 ≤ n ≤ 50).The second line contains 2·n integer numbers w1, w2, ..., w2n, where wi is weight of person i (1 ≤ wi ≤ 1000).\n\nOutputPrint minimum possible total instability.\n\nInputCopy21 2 3 4OutputCopy1InputCopy41 3 4 6 3 4 100 200OutputCopy5\n\nInputCopy21 2 3 4\n\nOutputCopy1\n\nInputCopy41 3 4 6 3 4 100 200\n\nOutputCopy5",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Hello Codeforces!On September 21, 18:05 MSK Educational Codeforces Round 29 will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.The round will be unrated for all users and will be held on extented ACM ICPC rules. After the end of the contest you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were prepared by Mikhail awoo Piklyaev, Mikhail MikeMirzayanov Mirzayanov, Vladimir vovuh Petrov and me.Good luck to all participants!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 720
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces",
          "content": "863A - Quasi-palindromeYou can check if the given is quasi-palindromic by removing all the trailing zeros and checking if resulting string is a palindrome. 863B - KayakingFirstly let's learn how to split persons in pairs as if there are no single kayaks. Let there be people with weights a, b, c and d (a ≤ b ≤ c ≤ d). Obviously, the lowest instability you can achieve is max(b - a, d - c). Swapping any two elements will only make the result greater. This greedy strategy can be used to distribute all the seats.Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest. The answer will be the minimun instabily over all pairs.Overall complexity: O(n3). 863C - 1-2-3Notice that there are only 9 possible patterns in this game. You can used in a following way. Simulate games till one of the patterns get repeated. Games between this pair of occurences will get you the same total outcome no matter when they are played. Let the distance between the games with the same pattern is dif and index of these games are idx1 and idx2 (zero-indexed). Total score of some interval is score(l, r). Then the answer will be score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Yet Another Array Queries ProblemOne can guess from the constraits that complexity of the algorithm should be either O(nm + q) or O(qm). And there is a solution with the second one.Let's try to solve the reversed problem — answer what position will some number be at after all the queries. Check the impact of some query on position pos. Let the query be on some segment [l, r]. If pos is outside this segment then you can skip it. Otherwise reverse will swap apos and ar - (pos - l), shift will swap apos and apos - 1 (if pos = l then it will be r instead of (pos - 1)).This task can be translated to the given one just by reversing the query list. Overall complexity: O(qm).Obviously, you can also solve it with Cartesian tree online in . 863E - Turn Off The TVFirstly let's compress the moments of time. Note that storing only l and r isn't enough (consider pairs ([1, 2], [3, 4]) and ([1, 2], [4, 5])), you also should take (l - 1).Now moments of time are up to 6·105. For every moment calculate the number of segments to cover it (make cntl +  = 1 and cntr + 1 -  = 1 for each segment and take prefix sums over this array). Then let prefi be the number of moments of time covered by only one segment on some prefix up to i-th moment. And finally if for some segment [l, r] from the input prefr - prefl - 1 is 0 then you can safely delete this segment.Overall complexity: . 863F - Almost PermutationThis problem can be solved with mincost maxflow approach.Let's construct a following network: Construct a vertex for every number from 1 to n. For each of these vertices add n directed edges from the source to this vertex, the capacity of each edge will be 1, and the costs will be 1, 3, 5, ..., 2n - 1 (so pushing k flow from the source to the vertex will cost exactly k2); Also construct a vertex for every index of the array. For each number make add a directed edge with capacity 1 and cost 0 to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity 1 and cost 0. Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network. 863G - Graphic SettingsIf m = 1, then everything is simple. Cycle exists if a[1] = 2, and path exists if b[1] = 1 or b[1] = a[1].Let's consider the case when m = 2. Let's call the combination odd if the sum of parameters is odd for this combination, and even otherwise. It's easy to see that if a[1] and a[2] are both odd, then it's impossible to construct a cycle because the number of even combinations is greater than the number of odd combinations. Furthermore, it's impossible to construct a path if our initial combination is an odd one.Let's show how to construct answer in all other cases. Constructing a cycle is easy if at least one of a[i] is even: And constructing a path can be divided into four cases.Starting point in corner: Start near the border: Both coordinates of starting point are even: Both coordinates are odd: So the case when m = 2 is solved.Now, if m = 3, then it can be reduced to m = 2 as follows:Suppose we have a[1] = 3, a[2] = 3, a[3] = 3. Then let's at first consider only combinations where the third parameter is equal to 1: Then, if we need to add the combinations with third parameter equal to 2, we mirror the \"layer\": And if we need to add the third \"layer\", we mirror it again: And so on.This way can also be used to reduce m > 3 to m = 2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*B"
          },
          "content_length": 4817
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2,50,\"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(2*n, 1, 1000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2,50,\"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(2*n, 1, 1000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2,50,\"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(2*n, 1, 1000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> weights(2 * n);\n\n    if (type == \"random\") {\n        /* Random weights between 1 and 1000 */\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"equal\") {\n        /* All weights are equal */\n        int w = rnd.next(1, 1000);\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = w;\n        }\n    } else if (type == \"increasing\") {\n        /* Weights in increasing order */\n        int start = rnd.next(1, 1000 - 2 * n + 1);\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        /* Weights in decreasing order */\n        int start = rnd.next(2 * n, 1000);\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = start - i;\n        }\n    } else if (type == \"alternating\") {\n        /* Alternating low and high weights */\n        int low = rnd.next(1, 500);\n        int high = rnd.next(501, 1000);\n        for (int i = 0; i < 2 * n; ++i) {\n            if (i % 2 == 0) {\n                weights[i] = low;\n            } else {\n                weights[i] = high;\n            }\n        }\n    } else if (type == \"max_instability\") {\n        /* Maximize instability */\n        for (int i = 0; i < n; ++i) {\n            weights[i] = 1;\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            weights[i] = 1000;\n        }\n    } else if (type == \"min_instability\") {\n        /* Minimize instability by pairing similar weights */\n        for (int i = 0; i < n; ++i) {\n            int w = rnd.next(1, 1000);\n            weights[2 * i] = w;\n            weights[2 * i + 1] = w;\n        }\n    } else if (type == \"same_pairs\") {\n        /* Pairs with similar weights */\n        for (int i = 0; i < n; ++i) {\n            int w = rnd.next(1, 990);\n            int delta = rnd.next(0, 10);\n            weights[2 * i] = w;\n            weights[2 * i + 1] = w + delta;\n        }\n    } else {\n        /* Default to random weights */\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = rnd.next(1, 1000);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Shuffle the weights */\n    shuffle(weights.begin(), weights.end());\n\n    /* Output the weights */\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d\", weights[i]);\n        if (i + 1 < 2 * n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> weights(2 * n);\n\n    if (type == \"random\") {\n        /* Random weights between 1 and 1000 */\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"equal\") {\n        /* All weights are equal */\n        int w = rnd.next(1, 1000);\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = w;\n        }\n    } else if (type == \"increasing\") {\n        /* Weights in increasing order */\n        int start = rnd.next(1, 1000 - 2 * n + 1);\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        /* Weights in decreasing order */\n        int start = rnd.next(2 * n, 1000);\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = start - i;\n        }\n    } else if (type == \"alternating\") {\n        /* Alternating low and high weights */\n        int low = rnd.next(1, 500);\n        int high = rnd.next(501, 1000);\n        for (int i = 0; i < 2 * n; ++i) {\n            if (i % 2 == 0) {\n                weights[i] = low;\n            } else {\n                weights[i] = high;\n            }\n        }\n    } else if (type == \"max_instability\") {\n        /* Maximize instability */\n        for (int i = 0; i < n; ++i) {\n            weights[i] = 1;\n        }\n        for (int i = n; i < 2 * n; ++i) {\n            weights[i] = 1000;\n        }\n    } else if (type == \"min_instability\") {\n        /* Minimize instability by pairing similar weights */\n        for (int i = 0; i < n; ++i) {\n            int w = rnd.next(1, 1000);\n            weights[2 * i] = w;\n            weights[2 * i + 1] = w;\n        }\n    } else if (type == \"same_pairs\") {\n        /* Pairs with similar weights */\n        for (int i = 0; i < n; ++i) {\n            int w = rnd.next(1, 990);\n            int delta = rnd.next(0, 10);\n            weights[2 * i] = w;\n            weights[2 * i + 1] = w + delta;\n        }\n    } else {\n        /* Default to random weights */\n        for (int i = 0; i < 2 * n; ++i) {\n            weights[i] = rnd.next(1, 1000);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Shuffle the weights */\n    shuffle(weights.begin(), weights.end());\n\n    /* Output the weights */\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d\", weights[i]);\n        if (i + 1 < 2 * n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type equal\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n./gen -n 2 -type max_instability\n./gen -n 2 -type min_instability\n./gen -n 2 -type same_pairs\n\n./gen -n 3 -type random\n./gen -n 3 -type equal\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type alternating\n./gen -n 3 -type max_instability\n./gen -n 3 -type min_instability\n./gen -n 3 -type same_pairs\n\n./gen -n 10 -type random\n./gen -n 10 -type equal\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n./gen -n 10 -type max_instability\n./gen -n 10 -type min_instability\n./gen -n 10 -type same_pairs\n\n./gen -n 25 -type random\n./gen -n 25 -type equal\n./gen -n 25 -type increasing\n./gen -n 25 -type decreasing\n./gen -n 25 -type alternating\n./gen -n 25 -type max_instability\n./gen -n 25 -type min_instability\n./gen -n 25 -type same_pairs\n\n./gen -n 49 -type random\n./gen -n 49 -type equal\n./gen -n 49 -type increasing\n./gen -n 49 -type decreasing\n./gen -n 49 -type alternating\n./gen -n 49 -type max_instability\n./gen -n 49 -type min_instability\n./gen -n 49 -type same_pairs\n\n./gen -n 50 -type random\n./gen -n 50 -type equal\n./gen -n 50 -type increasing\n./gen -n 50 -type decreasing\n./gen -n 50 -type alternating\n./gen -n 50 -type max_instability\n./gen -n 50 -type min_instability\n./gen -n 50 -type same_pairs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:43.595417",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/C",
      "title": "C. 1-2-3",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three numbers k, a, b (1 ≤ k ≤ 1018, 1 ≤ a, b ≤ 3). Then 3 lines follow, i-th of them containing 3 numbers Ai, 1, Ai, 2, Ai, 3, where Ai, j represents Alice's choice in the game if Alice chose i in previous game and Bob chose j (1 ≤ Ai, j ≤ 3). Then 3 lines follow, i-th of them containing 3 numbers Bi, 1, Bi, 2, Bi, 3, where Bi, j represents Bob's choice in the game if Alice chose i in previous game and Bob chose j (1 ≤ Bi, j ≤ 3).",
      "output_spec": "OutputPrint two numbers. First of them has to be equal to the number of points Alice will have, and second of them must be Bob's score after k games.",
      "sample_tests": "ExamplesInputCopy10 2 11 1 11 1 11 1 12 2 22 2 22 2 2OutputCopy1 9InputCopy8 1 12 2 13 3 13 1 31 1 12 1 11 2 3OutputCopy5 2InputCopy5 1 11 2 22 2 22 2 21 2 22 2 22 2 2OutputCopy0 0",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three numbers k, a, b (1 ≤ k ≤ 1018, 1 ≤ a, b ≤ 3). Then 3 lines follow, i-th of them containing 3 numbers Ai, 1, Ai, 2, Ai, 3, where Ai, j represents Alice's choice in the game if Alice chose i in previous game and Bob chose j (1 ≤ Ai, j ≤ 3). Then 3 lines follow, i-th of them containing 3 numbers Bi, 1, Bi, 2, Bi, 3, where Bi, j represents Bob's choice in the game if Alice chose i in previous game and Bob chose j (1 ≤ Bi, j ≤ 3).\n\nOutputPrint two numbers. First of them has to be equal to the number of points Alice will have, and second of them must be Bob's score after k games.\n\nInputCopy10 2 11 1 11 1 11 1 12 2 22 2 22 2 2OutputCopy1 9InputCopy8 1 12 2 13 3 13 1 31 1 12 1 11 2 3OutputCopy5 2InputCopy5 1 11 2 22 2 22 2 21 2 22 2 22 2 2OutputCopy0 0\n\nInputCopy10 2 11 1 11 1 11 1 12 2 22 2 22 2 2\n\nOutputCopy1 9\n\nInputCopy8 1 12 2 13 3 13 1 31 1 12 1 11 2 3\n\nOutputCopy5 2\n\nInputCopy5 1 11 2 22 2 22 2 21 2 22 2 22 2 2\n\nOutputCopy0 0\n\nNoteIn the second example game goes like this:The fourth and the seventh game are won by Bob, the first game is draw and the rest are won by Alice.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Hello Codeforces!On September 21, 18:05 MSK Educational Codeforces Round 29 will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.The round will be unrated for all users and will be held on extented ACM ICPC rules. After the end of the contest you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were prepared by Mikhail awoo Piklyaev, Mikhail MikeMirzayanov Mirzayanov, Vladimir vovuh Petrov and me.Good luck to all participants!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 720
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces",
          "content": "863A - Quasi-palindromeYou can check if the given is quasi-palindromic by removing all the trailing zeros and checking if resulting string is a palindrome. 863B - KayakingFirstly let's learn how to split persons in pairs as if there are no single kayaks. Let there be people with weights a, b, c and d (a ≤ b ≤ c ≤ d). Obviously, the lowest instability you can achieve is max(b - a, d - c). Swapping any two elements will only make the result greater. This greedy strategy can be used to distribute all the seats.Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest. The answer will be the minimun instabily over all pairs.Overall complexity: O(n3). 863C - 1-2-3Notice that there are only 9 possible patterns in this game. You can used in a following way. Simulate games till one of the patterns get repeated. Games between this pair of occurences will get you the same total outcome no matter when they are played. Let the distance between the games with the same pattern is dif and index of these games are idx1 and idx2 (zero-indexed). Total score of some interval is score(l, r). Then the answer will be score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Yet Another Array Queries ProblemOne can guess from the constraits that complexity of the algorithm should be either O(nm + q) or O(qm). And there is a solution with the second one.Let's try to solve the reversed problem — answer what position will some number be at after all the queries. Check the impact of some query on position pos. Let the query be on some segment [l, r]. If pos is outside this segment then you can skip it. Otherwise reverse will swap apos and ar - (pos - l), shift will swap apos and apos - 1 (if pos = l then it will be r instead of (pos - 1)).This task can be translated to the given one just by reversing the query list. Overall complexity: O(qm).Obviously, you can also solve it with Cartesian tree online in . 863E - Turn Off The TVFirstly let's compress the moments of time. Note that storing only l and r isn't enough (consider pairs ([1, 2], [3, 4]) and ([1, 2], [4, 5])), you also should take (l - 1).Now moments of time are up to 6·105. For every moment calculate the number of segments to cover it (make cntl +  = 1 and cntr + 1 -  = 1 for each segment and take prefix sums over this array). Then let prefi be the number of moments of time covered by only one segment on some prefix up to i-th moment. And finally if for some segment [l, r] from the input prefr - prefl - 1 is 0 then you can safely delete this segment.Overall complexity: . 863F - Almost PermutationThis problem can be solved with mincost maxflow approach.Let's construct a following network: Construct a vertex for every number from 1 to n. For each of these vertices add n directed edges from the source to this vertex, the capacity of each edge will be 1, and the costs will be 1, 3, 5, ..., 2n - 1 (so pushing k flow from the source to the vertex will cost exactly k2); Also construct a vertex for every index of the array. For each number make add a directed edge with capacity 1 and cost 0 to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity 1 and cost 0. Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network. 863G - Graphic SettingsIf m = 1, then everything is simple. Cycle exists if a[1] = 2, and path exists if b[1] = 1 or b[1] = a[1].Let's consider the case when m = 2. Let's call the combination odd if the sum of parameters is odd for this combination, and even otherwise. It's easy to see that if a[1] and a[2] are both odd, then it's impossible to construct a cycle because the number of even combinations is greater than the number of odd combinations. Furthermore, it's impossible to construct a path if our initial combination is an odd one.Let's show how to construct answer in all other cases. Constructing a cycle is easy if at least one of a[i] is even: And constructing a path can be divided into four cases.Starting point in corner: Start near the border: Both coordinates of starting point are even: Both coordinates are odd: So the case when m = 2 is solved.Now, if m = 3, then it can be reduced to m = 2 as follows:Suppose we have a[1] = 3, a[2] = 3, a[3] = 3. Then let's at first consider only combinations where the third parameter is equal to 1: Then, if we need to add the combinations with third parameter equal to 2, we mirror the \"layer\": And if we need to add the third \"layer\", we mirror it again: And so on.This way can also be used to reduce m > 3 to m = 2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*C"
          },
          "content_length": 4817
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long k = inf.readLong(1LL, 1000000000000000000LL); // 1 ≤ k ≤ 1e18\n    inf.readSpace();\n    int a = inf.readInt(1, 3); // 1 ≤ a ≤ 3\n    inf.readSpace();\n    int b = inf.readInt(1, 3); // 1 ≤ b ≤ 3\n    inf.readEoln();\n\n    // Read Alice's Ai,j\n    for (int i = 0; i < 3; i++) {\n        int Ai1 = inf.readInt(1, 3); // 1 ≤ Ai1 ≤ 3\n        inf.readSpace();\n        int Ai2 = inf.readInt(1, 3); // 1 ≤ Ai2 ≤ 3\n        inf.readSpace();\n        int Ai3 = inf.readInt(1, 3); // 1 ≤ Ai3 ≤ 3\n        inf.readEoln();\n    }\n\n    // Read Bob's Bi,j\n    for (int i = 0; i < 3; i++) {\n        int Bi1 = inf.readInt(1, 3); // 1 ≤ Bi1 ≤ 3\n        inf.readSpace();\n        int Bi2 = inf.readInt(1, 3); // 1 ≤ Bi2 ≤ 3\n        inf.readSpace();\n        int Bi3 = inf.readInt(1, 3); // 1 ≤ Bi3 ≤ 3\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long k = inf.readLong(1LL, 1000000000000000000LL); // 1 ≤ k ≤ 1e18\n    inf.readSpace();\n    int a = inf.readInt(1, 3); // 1 ≤ a ≤ 3\n    inf.readSpace();\n    int b = inf.readInt(1, 3); // 1 ≤ b ≤ 3\n    inf.readEoln();\n\n    // Read Alice's Ai,j\n    for (int i = 0; i < 3; i++) {\n        int Ai1 = inf.readInt(1, 3); // 1 ≤ Ai1 ≤ 3\n        inf.readSpace();\n        int Ai2 = inf.readInt(1, 3); // 1 ≤ Ai2 ≤ 3\n        inf.readSpace();\n        int Ai3 = inf.readInt(1, 3); // 1 ≤ Ai3 ≤ 3\n        inf.readEoln();\n    }\n\n    // Read Bob's Bi,j\n    for (int i = 0; i < 3; i++) {\n        int Bi1 = inf.readInt(1, 3); // 1 ≤ Bi1 ≤ 3\n        inf.readSpace();\n        int Bi2 = inf.readInt(1, 3); // 1 ≤ Bi2 ≤ 3\n        inf.readSpace();\n        int Bi3 = inf.readInt(1, 3); // 1 ≤ Bi3 ≤ 3\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long k = inf.readLong(1LL, 1000000000000000000LL); // 1 ≤ k ≤ 1e18\n    inf.readSpace();\n    int a = inf.readInt(1, 3); // 1 ≤ a ≤ 3\n    inf.readSpace();\n    int b = inf.readInt(1, 3); // 1 ≤ b ≤ 3\n    inf.readEoln();\n\n    // Read Alice's Ai,j\n    for (int i = 0; i < 3; i++) {\n        int Ai1 = inf.readInt(1, 3); // 1 ≤ Ai1 ≤ 3\n        inf.readSpace();\n        int Ai2 = inf.readInt(1, 3); // 1 ≤ Ai2 ≤ 3\n        inf.readSpace();\n        int Ai3 = inf.readInt(1, 3); // 1 ≤ Ai3 ≤ 3\n        inf.readEoln();\n    }\n\n    // Read Bob's Bi,j\n    for (int i = 0; i < 3; i++) {\n        int Bi1 = inf.readInt(1, 3); // 1 ≤ Bi1 ≤ 3\n        inf.readSpace();\n        int Bi2 = inf.readInt(1, 3); // 1 ≤ Bi2 ≤ 3\n        inf.readSpace();\n        int Bi3 = inf.readInt(1, 3); // 1 ≤ Bi3 ≤ 3\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    ll k = opt<ll>(\"k\", rnd.next(1LL, 1000000000000000000LL));\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = rnd.next(1,3);\n    int b = rnd.next(1,3);\n\n    int A[4][4];\n    int B[4][4];\n\n    if (type == \"random\") {\n        // Randomly generate Ai,j and Bi,j\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = rnd.next(1,3);\n                B[i][j] = rnd.next(1,3);\n            }\n    } else if (type == \"same\") {\n        // All Ai,j and Bi,j are the same value\n        int valA = rnd.next(1,3);\n        int valB = rnd.next(1,3);\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = valA;\n                B[i][j] = valB;\n            }\n    } else if (type == \"fixedAB\") {\n        // Ai,j and Bi,j are designed to cause immediate draw\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = i;\n                B[i][j] = j;\n            }\n    } else if (type == \"maxCycle\") {\n        // Try to create maximal-length cycle\n        vector<pair<int,int>> states;\n        for(int i=1; i<=3;i++) {\n            for(int j=1;j<=3;j++) {\n                states.push_back({i,j});\n            }\n        }\n        shuffle(states.begin(), states.end());\n        for(int i=0; i<9; i++) {\n            int ai = states[i].first;\n            int bi = states[i].second;\n            int ai1 = states[(i+1)%9].first;\n            int bi1 = states[(i+1)%9].second;\n            A[ai][bi] = ai1;\n            B[ai][bi] = bi1;\n        }\n    } else if (type == \"longCycle\") {\n        // Build Ai,j and Bi,j to create a cycle of length 4\n        vector<pair<int,int>> states;\n        states.push_back({1,1});\n        states.push_back({1,2});\n        states.push_back({2,1});\n        states.push_back({2,2});\n        for(int i=0; i<4; i++) {\n            int ai = states[i].first;\n            int bi = states[i].second;\n            int ai1 = states[(i+1)%4].first;\n            int bi1 = states[(i+1)%4].second;\n            A[ai][bi] = ai1;\n            B[ai][bi] = bi1;\n        }\n        for (int ai=1; ai<=3; ai++) {\n            for (int bi=1; bi<=3; bi++) {\n                if ((ai == 1 || ai == 2) && (bi == 1 || bi == 2)) continue;\n                A[ai][bi] = rnd.next(1,3);\n                B[ai][bi] = rnd.next(1,3);\n            }\n        }\n    } else if (type == \"minimalK\") {\n        k = 1;\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = rnd.next(1,3);\n                B[i][j] = rnd.next(1,3);\n            }\n    } else if (type == \"fixedABLongK\") {\n        k = 1000000000000000000LL;\n        int valA = rnd.next(1,3);\n        int valB = rnd.next(1,3);\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = valA;\n                B[i][j] = valB;\n            }\n    } else {\n        // default to random\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = rnd.next(1,3);\n                B[i][j] = rnd.next(1,3);\n            }\n    }\n\n    // Output\n    printf(\"%lld %d %d\\n\", k, a, b);\n    for (int i=1; i<=3; i++) {\n        for (int j=1; j<=3; j++) {\n            printf(\"%d%c\", A[i][j], \" \\n\"[j==3]);\n        }\n    }\n    for (int i=1; i<=3; i++) {\n        for (int j=1; j<=3; j++) {\n            printf(\"%d%c\", B[i][j], \" \\n\"[j==3]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    ll k = opt<ll>(\"k\", rnd.next(1LL, 1000000000000000000LL));\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = rnd.next(1,3);\n    int b = rnd.next(1,3);\n\n    int A[4][4];\n    int B[4][4];\n\n    if (type == \"random\") {\n        // Randomly generate Ai,j and Bi,j\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = rnd.next(1,3);\n                B[i][j] = rnd.next(1,3);\n            }\n    } else if (type == \"same\") {\n        // All Ai,j and Bi,j are the same value\n        int valA = rnd.next(1,3);\n        int valB = rnd.next(1,3);\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = valA;\n                B[i][j] = valB;\n            }\n    } else if (type == \"fixedAB\") {\n        // Ai,j and Bi,j are designed to cause immediate draw\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = i;\n                B[i][j] = j;\n            }\n    } else if (type == \"maxCycle\") {\n        // Try to create maximal-length cycle\n        vector<pair<int,int>> states;\n        for(int i=1; i<=3;i++) {\n            for(int j=1;j<=3;j++) {\n                states.push_back({i,j});\n            }\n        }\n        shuffle(states.begin(), states.end());\n        for(int i=0; i<9; i++) {\n            int ai = states[i].first;\n            int bi = states[i].second;\n            int ai1 = states[(i+1)%9].first;\n            int bi1 = states[(i+1)%9].second;\n            A[ai][bi] = ai1;\n            B[ai][bi] = bi1;\n        }\n    } else if (type == \"longCycle\") {\n        // Build Ai,j and Bi,j to create a cycle of length 4\n        vector<pair<int,int>> states;\n        states.push_back({1,1});\n        states.push_back({1,2});\n        states.push_back({2,1});\n        states.push_back({2,2});\n        for(int i=0; i<4; i++) {\n            int ai = states[i].first;\n            int bi = states[i].second;\n            int ai1 = states[(i+1)%4].first;\n            int bi1 = states[(i+1)%4].second;\n            A[ai][bi] = ai1;\n            B[ai][bi] = bi1;\n        }\n        for (int ai=1; ai<=3; ai++) {\n            for (int bi=1; bi<=3; bi++) {\n                if ((ai == 1 || ai == 2) && (bi == 1 || bi == 2)) continue;\n                A[ai][bi] = rnd.next(1,3);\n                B[ai][bi] = rnd.next(1,3);\n            }\n        }\n    } else if (type == \"minimalK\") {\n        k = 1;\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = rnd.next(1,3);\n                B[i][j] = rnd.next(1,3);\n            }\n    } else if (type == \"fixedABLongK\") {\n        k = 1000000000000000000LL;\n        int valA = rnd.next(1,3);\n        int valB = rnd.next(1,3);\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = valA;\n                B[i][j] = valB;\n            }\n    } else {\n        // default to random\n        for (int i=1; i<=3; i++)\n            for (int j=1; j<=3; j++) {\n                A[i][j] = rnd.next(1,3);\n                B[i][j] = rnd.next(1,3);\n            }\n    }\n\n    // Output\n    printf(\"%lld %d %d\\n\", k, a, b);\n    for (int i=1; i<=3; i++) {\n        for (int j=1; j<=3; j++) {\n            printf(\"%d%c\", A[i][j], \" \\n\"[j==3]);\n        }\n    }\n    for (int i=1; i<=3; i++) {\n        for (int j=1; j<=3; j++) {\n            printf(\"%d%c\", B[i][j], \" \\n\"[j==3]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random choices with small k\n./gen -k 1 -type random\n./gen -k 2 -type random\n./gen -k 10 -type random\n./gen -k 100 -type random\n\n# Random choices with large k\n./gen -k 1000000 -type random\n./gen -k 1000000000000000000 -type random\n\n# Same Ai,j and Bi,j\n./gen -k 1 -type same\n./gen -k 2 -type same\n./gen -k 10 -type same\n./gen -k 10000 -type same\n./gen -k 1000000000000000000 -type same\n\n# Fixed Ai,j and Bi,j to create immediate draws\n./gen -k 1 -type fixedAB\n./gen -k 2 -type fixedAB\n./gen -k 10 -type fixedAB\n./gen -k 10000 -type fixedAB\n./gen -k 1000000000000000000 -type fixedAB\n\n# Long cycle test cases\n./gen -k 1 -type longCycle\n./gen -k 4 -type longCycle\n./gen -k 100 -type longCycle\n./gen -k 10000 -type longCycle\n./gen -k 1000000000000000000 -type longCycle\n\n# Max cycle test case\n./gen -k 1000000000000000000 -type maxCycle\n\n# Minimal k test cases\n./gen -type minimalK\n\n# Fixed Ai,j and Bi,j with maximal k\n./gen -type fixedABLongK\n\n# Random test cases without specifying k\n./gen -type random\n\n# Edge cases with k = maximum value\n./gen -k 1000000000000000000 -type random\n\n# Edge case with k = 1e18 - 1\n./gen -k 999999999999999999 -type random\n\n# Edge case where k is small and Ai,j and Bi,j are designed to cause a repeated state\n./gen -k 5 -type fixedAB\n\n# Edge case with k=5 and random Ai,j and Bi,j\n./gen -k 5 -type random\n\n# Edge case with k=2 and Ai,j and Bi,j are constants\n./gen -k 2 -type same\n\n# Edge case with k=3 and Ai,j and Bi,j are varying\n./gen -k 3 -type random\n\n# Edge case with k=1e5 and type longCycle\n./gen -k 100000 -type longCycle\n\n# Edge case with k=1e6 and random Ai,j and Bi,j\n./gen -k 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:45.660388",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/D",
      "title": "D. Yet Another Array Queries Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integer numbers n, q and m (1 ≤ n, q ≤ 2·105, 1 ≤ m ≤ 100). The second line contains n integer numbers a1, a2, ..., an (1 ≤ ai ≤ 109). Then q lines follow. i-th of them contains three integer numbers ti, li, ri, where ti is the type of i-th query, and [li, ri] is the segment where this query is performed (1 ≤ ti ≤ 2, 1 ≤ li ≤ ri ≤ n). The last line contains m integer numbers b1, b2, ..., bm (1 ≤ bi ≤ n) — important indices of the array.",
      "output_spec": "OutputPrint m numbers, i-th of which is equal to the number at index bi after all queries are done.",
      "sample_tests": "ExampleInputCopy6 3 51 2 3 4 5 62 1 32 3 61 1 62 2 1 5 3OutputCopy3 3 1 5 2",
      "description": "D. Yet Another Array Queries Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integer numbers n, q and m (1 ≤ n, q ≤ 2·105, 1 ≤ m ≤ 100). The second line contains n integer numbers a1, a2, ..., an (1 ≤ ai ≤ 109). Then q lines follow. i-th of them contains three integer numbers ti, li, ri, where ti is the type of i-th query, and [li, ri] is the segment where this query is performed (1 ≤ ti ≤ 2, 1 ≤ li ≤ ri ≤ n). The last line contains m integer numbers b1, b2, ..., bm (1 ≤ bi ≤ n) — important indices of the array.\n\nOutputPrint m numbers, i-th of which is equal to the number at index bi after all queries are done.\n\nInputCopy6 3 51 2 3 4 5 62 1 32 3 61 1 62 2 1 5 3OutputCopy3 3 1 5 2\n\nInputCopy6 3 51 2 3 4 5 62 1 32 3 61 1 62 2 1 5 3\n\nOutputCopy3 3 1 5 2",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Hello Codeforces!On September 21, 18:05 MSK Educational Codeforces Round 29 will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.The round will be unrated for all users and will be held on extented ACM ICPC rules. After the end of the contest you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were prepared by Mikhail awoo Piklyaev, Mikhail MikeMirzayanov Mirzayanov, Vladimir vovuh Petrov and me.Good luck to all participants!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 720
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces",
          "content": "863A - Quasi-palindromeYou can check if the given is quasi-palindromic by removing all the trailing zeros and checking if resulting string is a palindrome. 863B - KayakingFirstly let's learn how to split persons in pairs as if there are no single kayaks. Let there be people with weights a, b, c and d (a ≤ b ≤ c ≤ d). Obviously, the lowest instability you can achieve is max(b - a, d - c). Swapping any two elements will only make the result greater. This greedy strategy can be used to distribute all the seats.Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest. The answer will be the minimun instabily over all pairs.Overall complexity: O(n3). 863C - 1-2-3Notice that there are only 9 possible patterns in this game. You can used in a following way. Simulate games till one of the patterns get repeated. Games between this pair of occurences will get you the same total outcome no matter when they are played. Let the distance between the games with the same pattern is dif and index of these games are idx1 and idx2 (zero-indexed). Total score of some interval is score(l, r). Then the answer will be score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Yet Another Array Queries ProblemOne can guess from the constraits that complexity of the algorithm should be either O(nm + q) or O(qm). And there is a solution with the second one.Let's try to solve the reversed problem — answer what position will some number be at after all the queries. Check the impact of some query on position pos. Let the query be on some segment [l, r]. If pos is outside this segment then you can skip it. Otherwise reverse will swap apos and ar - (pos - l), shift will swap apos and apos - 1 (if pos = l then it will be r instead of (pos - 1)).This task can be translated to the given one just by reversing the query list. Overall complexity: O(qm).Obviously, you can also solve it with Cartesian tree online in . 863E - Turn Off The TVFirstly let's compress the moments of time. Note that storing only l and r isn't enough (consider pairs ([1, 2], [3, 4]) and ([1, 2], [4, 5])), you also should take (l - 1).Now moments of time are up to 6·105. For every moment calculate the number of segments to cover it (make cntl +  = 1 and cntr + 1 -  = 1 for each segment and take prefix sums over this array). Then let prefi be the number of moments of time covered by only one segment on some prefix up to i-th moment. And finally if for some segment [l, r] from the input prefr - prefl - 1 is 0 then you can safely delete this segment.Overall complexity: . 863F - Almost PermutationThis problem can be solved with mincost maxflow approach.Let's construct a following network: Construct a vertex for every number from 1 to n. For each of these vertices add n directed edges from the source to this vertex, the capacity of each edge will be 1, and the costs will be 1, 3, 5, ..., 2n - 1 (so pushing k flow from the source to the vertex will cost exactly k2); Also construct a vertex for every index of the array. For each number make add a directed edge with capacity 1 and cost 0 to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity 1 and cost 0. Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network. 863G - Graphic SettingsIf m = 1, then everything is simple. Cycle exists if a[1] = 2, and path exists if b[1] = 1 or b[1] = a[1].Let's consider the case when m = 2. Let's call the combination odd if the sum of parameters is odd for this combination, and even otherwise. It's easy to see that if a[1] and a[2] are both odd, then it's impossible to construct a cycle because the number of even combinations is greater than the number of odd combinations. Furthermore, it's impossible to construct a path if our initial combination is an odd one.Let's show how to construct answer in all other cases. Constructing a cycle is easy if at least one of a[i] is even: And constructing a path can be divided into four cases.Starting point in corner: Start near the border: Both coordinates of starting point are even: Both coordinates are odd: So the case when m = 2 is solved.Now, if m = 3, then it can be reduced to m = 2 as follows:Suppose we have a[1] = 3, a[2] = 3, a[3] = 3. Then let's at first consider only combinations where the third parameter is equal to 1: Then, if we need to add the combinations with third parameter equal to 2, we mirror the \"layer\": And if we need to add the third \"layer\", we mirror it again: And so on.This way can also be used to reduce m > 3 to m = 2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*D"
          },
          "content_length": 4817
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int m = opt<int>(\"m\", 100);\n    \n    if (m > n) m = n; // Ensure m <= n\n\n    string t = opt<string>(\"t\", \"random\"); // Type of queries: \"only1\", \"only2\", \"random\"\n    string ai_type = opt<string>(\"ai\", \"random\"); // Type of array elements: \"constant\", \"increasing\", \"decreasing\", \"random\"\n    string segment_type = opt<string>(\"segment\", \"random\"); // Type of segments: \"full\", \"single\", \"edges\", \"random\"\n    string index_type = opt<string>(\"indices\", \"random\"); // Type of important indices: \"edges\", \"full\", \"random\"\n\n    vector<int> a(n);\n\n    if (ai_type == \"constant\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) a[i] = val;\n    } else if (ai_type == \"increasing\") {\n        int start = rnd.next(1, max(1, 1000000000 - n));\n        for (int i = 0; i < n; ++i) a[i] = start + i;\n    } else if (ai_type == \"decreasing\") {\n        int start = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) a[i] = start - i;\n    } else {\n        // random\n        for (int i = 0; i < n; ++i) a[i] = rnd.next(1, 1000000000);\n    }\n    // Output n, q, m\n    printf(\"%d %d %d\\n\", n, q, m);\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Now generate q queries\n    vector<int> types(q);\n    vector<int> l(q);\n    vector<int> r(q);\n    if (t == \"only1\") {\n        fill(types.begin(), types.end(), 1);\n    } else if (t == \"only2\") {\n        fill(types.begin(), types.end(), 2);\n    } else {\n        // Random mix\n        for (int i = 0; i < q; ++i) {\n            types[i] = rnd.next(1, 2);\n        }\n    }\n    // Generate li and ri based on segment_type\n    for (int i = 0; i < q; ++i) {\n        int li, ri;\n        if (segment_type == \"full\") {\n            li = 1;\n            ri = n;\n        } else if (segment_type == \"single\") {\n            li = ri = rnd.next(1, n);\n        } else if (segment_type == \"edges\") {\n            // li or ri is at edge\n            li = rnd.next(1, 2); // li is 1 or 2\n            ri = rnd.next(n-1, n); // ri is n-1 or n\n            if (li > ri) swap(li, ri);\n        } else {\n            // Random\n            li = rnd.next(1, n);\n            ri = rnd.next(1, n);\n            if (li > ri) swap(li, ri);\n        }\n        l[i] = li;\n        r[i] = ri;\n    }\n\n    // Output q queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d %d\\n\", types[i], l[i], r[i]);\n    }\n\n    // Generate m indices bi based on index_type\n    vector<int> b(m);\n    if (index_type == \"edges\") {\n        // Include indices at 1 and n\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) b[i] = 1;\n            else b[i] = n;\n        }\n    } else if (index_type == \"full\") {\n        // Take m indices from 1 to n, evenly\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1 + i * n / m;\n            if (b[i] > n) b[i] = n;\n        }\n    } else if (index_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, n);\n        }\n    }\n    // Output m indices\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", b[i]);\n        if (i != m -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int m = opt<int>(\"m\", 100);\n    \n    if (m > n) m = n; // Ensure m <= n\n\n    string t = opt<string>(\"t\", \"random\"); // Type of queries: \"only1\", \"only2\", \"random\"\n    string ai_type = opt<string>(\"ai\", \"random\"); // Type of array elements: \"constant\", \"increasing\", \"decreasing\", \"random\"\n    string segment_type = opt<string>(\"segment\", \"random\"); // Type of segments: \"full\", \"single\", \"edges\", \"random\"\n    string index_type = opt<string>(\"indices\", \"random\"); // Type of important indices: \"edges\", \"full\", \"random\"\n\n    vector<int> a(n);\n\n    if (ai_type == \"constant\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) a[i] = val;\n    } else if (ai_type == \"increasing\") {\n        int start = rnd.next(1, max(1, 1000000000 - n));\n        for (int i = 0; i < n; ++i) a[i] = start + i;\n    } else if (ai_type == \"decreasing\") {\n        int start = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) a[i] = start - i;\n    } else {\n        // random\n        for (int i = 0; i < n; ++i) a[i] = rnd.next(1, 1000000000);\n    }\n    // Output n, q, m\n    printf(\"%d %d %d\\n\", n, q, m);\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Now generate q queries\n    vector<int> types(q);\n    vector<int> l(q);\n    vector<int> r(q);\n    if (t == \"only1\") {\n        fill(types.begin(), types.end(), 1);\n    } else if (t == \"only2\") {\n        fill(types.begin(), types.end(), 2);\n    } else {\n        // Random mix\n        for (int i = 0; i < q; ++i) {\n            types[i] = rnd.next(1, 2);\n        }\n    }\n    // Generate li and ri based on segment_type\n    for (int i = 0; i < q; ++i) {\n        int li, ri;\n        if (segment_type == \"full\") {\n            li = 1;\n            ri = n;\n        } else if (segment_type == \"single\") {\n            li = ri = rnd.next(1, n);\n        } else if (segment_type == \"edges\") {\n            // li or ri is at edge\n            li = rnd.next(1, 2); // li is 1 or 2\n            ri = rnd.next(n-1, n); // ri is n-1 or n\n            if (li > ri) swap(li, ri);\n        } else {\n            // Random\n            li = rnd.next(1, n);\n            ri = rnd.next(1, n);\n            if (li > ri) swap(li, ri);\n        }\n        l[i] = li;\n        r[i] = ri;\n    }\n\n    // Output q queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d %d\\n\", types[i], l[i], r[i]);\n    }\n\n    // Generate m indices bi based on index_type\n    vector<int> b(m);\n    if (index_type == \"edges\") {\n        // Include indices at 1 and n\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) b[i] = 1;\n            else b[i] = n;\n        }\n    } else if (index_type == \"full\") {\n        // Take m indices from 1 to n, evenly\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1 + i * n / m;\n            if (b[i] > n) b[i] = n;\n        }\n    } else if (index_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, n);\n        }\n    }\n    // Output m indices\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", b[i]);\n        if (i != m -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -q 5 -t only1 -ai constant -segment single -indices edges\n./gen -n 5 -q 5 -t only2 -ai increasing -segment full -indices full\n./gen -n 5 -q 5 -t random -ai decreasing -segment random -indices random\n\n./gen -n 10 -q 10 -t only1 -ai random -segment edges -indices edges\n./gen -n 10 -q 10 -t only2 -ai constant -segment single -indices full\n./gen -n 10 -q 10 -t random -ai random -segment random -indices random\n\n./gen -n 1000 -q 1000 -t only1 -ai increasing -segment full -indices edges\n./gen -n 1000 -q 1000 -t only2 -ai decreasing -segment single -indices random\n./gen -n 1000 -q 1000 -t random -ai constant -segment edges -indices full\n\n./gen -n 100000 -q 100000 -t only1 -ai random -segment random -indices random\n./gen -n 100000 -q 100000 -t only2 -ai random -segment random -indices random\n./gen -n 100000 -q 100000 -t random -ai random -segment random -indices random\n\n./gen -n 200000 -q 200000 -t only1 -ai constant -segment full -indices edges\n./gen -n 200000 -q 200000 -t only2 -ai constant -segment single -indices full\n./gen -n 200000 -q 200000 -t random -ai random -segment edges -indices random\n\n./gen -n 200000 -q 200000 -t random -ai random -segment random -indices random\n\n# Edge Test Cases\n./gen -n 200000 -q 200000 -t random -ai constant -segment single -indices full\n\n# All queries on the entire array\n./gen -n 200000 -q 200000 -t random -ai random -segment full -indices random\n\n# Small m = 1\n./gen -n 200000 -q 200000 -m 1 -t random -ai random -segment random -indices random\n\n# m = n up to 100\n./gen -n 200000 -q 200000 -m 100 -t random -ai random -segment random -indices random\n\n# m = n\n./gen -n 100 -q 100 -m 100 -t random -ai random -segment random -indices full\n\n# Reverse and reverse back\n# Alternate type 2 queries\n./gen -n 100000 -q 100000 -t only2 -ai random -segment random -indices random\n\n# Type 1 queries cyclically shifting the same segment multiple times\n./gen -n 100000 -q 100000 -t only1 -ai random -segment full -indices random\n\n# Mixed segments\n./gen -n 200000 -q 200000 -t random -ai random -segment random -indices random\n\n# All query types, all options random\n./gen -n 200000 -q 200000 -t random -ai random -segment random -indices random\n\n# Additional tests\n./gen -n 200000 -q 200000 -t random -ai increasing -segment random -indices random\n./gen -n 200000 -q 200000 -t random -ai decreasing -segment random -indices random\n./gen -n 200000 -q 200000 -t random -ai random -segment single -indices random\n./gen -n 200000 -q 200000 -t random -ai random -segment full -indices edges\n./gen -n 200000 -q 100000 -t only1 -ai random -segment edges -indices random\n./gen -n 200000 -q 100000 -t only2 -ai random -segment edges -indices random\n./gen -n 200000 -q 100000 -t random -ai constant -segment random -indices edges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:47.578439",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/E",
      "title": "E. Turn Off The TV",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer number n (1 ≤ n ≤ 2·105) — the number of TV sets.Then n lines follow, each of them containing two integer numbers li, ri (0 ≤ li ≤ ri ≤ 109) denoting the working time of i-th TV set.",
      "output_spec": "OutputIf there is no any redundant TV set, print -1. Otherwise print the index of any redundant TV set (TV sets are indexed from 1 to n).If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy31 34 61 7OutputCopy1InputCopy20 100 10OutputCopy1InputCopy31 23 46 8OutputCopy-1InputCopy31 22 33 4OutputCopy2",
      "description": "E. Turn Off The TV\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer number n (1 ≤ n ≤ 2·105) — the number of TV sets.Then n lines follow, each of them containing two integer numbers li, ri (0 ≤ li ≤ ri ≤ 109) denoting the working time of i-th TV set.\n\nOutputIf there is no any redundant TV set, print -1. Otherwise print the index of any redundant TV set (TV sets are indexed from 1 to n).If there are multiple answers, print any of them.\n\nInputCopy31 34 61 7OutputCopy1InputCopy20 100 10OutputCopy1InputCopy31 23 46 8OutputCopy-1InputCopy31 22 33 4OutputCopy2\n\nInputCopy31 34 61 7\n\nOutputCopy1\n\nInputCopy20 100 10\n\nOutputCopy1\n\nInputCopy31 23 46 8\n\nOutputCopy-1\n\nInputCopy31 22 33 4\n\nOutputCopy2\n\nNoteConsider the first sample. Initially all integer moments of time such that at least one TV set is working are from the segment [1;7]. It's easy to see that this segment won't change if we switch off the first TV set (or the second one).Note that in the fourth sample you can switch off the second TV set, since even without it all integer moments such that any of the TV sets is working denote the segment [1;4].",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Hello Codeforces!On September 21, 18:05 MSK Educational Codeforces Round 29 will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.The round will be unrated for all users and will be held on extented ACM ICPC rules. After the end of the contest you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were prepared by Mikhail awoo Piklyaev, Mikhail MikeMirzayanov Mirzayanov, Vladimir vovuh Petrov and me.Good luck to all participants!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 720
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces",
          "content": "863A - Quasi-palindromeYou can check if the given is quasi-palindromic by removing all the trailing zeros and checking if resulting string is a palindrome. 863B - KayakingFirstly let's learn how to split persons in pairs as if there are no single kayaks. Let there be people with weights a, b, c and d (a ≤ b ≤ c ≤ d). Obviously, the lowest instability you can achieve is max(b - a, d - c). Swapping any two elements will only make the result greater. This greedy strategy can be used to distribute all the seats.Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest. The answer will be the minimun instabily over all pairs.Overall complexity: O(n3). 863C - 1-2-3Notice that there are only 9 possible patterns in this game. You can used in a following way. Simulate games till one of the patterns get repeated. Games between this pair of occurences will get you the same total outcome no matter when they are played. Let the distance between the games with the same pattern is dif and index of these games are idx1 and idx2 (zero-indexed). Total score of some interval is score(l, r). Then the answer will be score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Yet Another Array Queries ProblemOne can guess from the constraits that complexity of the algorithm should be either O(nm + q) or O(qm). And there is a solution with the second one.Let's try to solve the reversed problem — answer what position will some number be at after all the queries. Check the impact of some query on position pos. Let the query be on some segment [l, r]. If pos is outside this segment then you can skip it. Otherwise reverse will swap apos and ar - (pos - l), shift will swap apos and apos - 1 (if pos = l then it will be r instead of (pos - 1)).This task can be translated to the given one just by reversing the query list. Overall complexity: O(qm).Obviously, you can also solve it with Cartesian tree online in . 863E - Turn Off The TVFirstly let's compress the moments of time. Note that storing only l and r isn't enough (consider pairs ([1, 2], [3, 4]) and ([1, 2], [4, 5])), you also should take (l - 1).Now moments of time are up to 6·105. For every moment calculate the number of segments to cover it (make cntl +  = 1 and cntr + 1 -  = 1 for each segment and take prefix sums over this array). Then let prefi be the number of moments of time covered by only one segment on some prefix up to i-th moment. And finally if for some segment [l, r] from the input prefr - prefl - 1 is 0 then you can safely delete this segment.Overall complexity: . 863F - Almost PermutationThis problem can be solved with mincost maxflow approach.Let's construct a following network: Construct a vertex for every number from 1 to n. For each of these vertices add n directed edges from the source to this vertex, the capacity of each edge will be 1, and the costs will be 1, 3, 5, ..., 2n - 1 (so pushing k flow from the source to the vertex will cost exactly k2); Also construct a vertex for every index of the array. For each number make add a directed edge with capacity 1 and cost 0 to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity 1 and cost 0. Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network. 863G - Graphic SettingsIf m = 1, then everything is simple. Cycle exists if a[1] = 2, and path exists if b[1] = 1 or b[1] = a[1].Let's consider the case when m = 2. Let's call the combination odd if the sum of parameters is odd for this combination, and even otherwise. It's easy to see that if a[1] and a[2] are both odd, then it's impossible to construct a cycle because the number of even combinations is greater than the number of odd combinations. Furthermore, it's impossible to construct a path if our initial combination is an odd one.Let's show how to construct answer in all other cases. Constructing a cycle is easy if at least one of a[i] is even: And constructing a path can be divided into four cases.Starting point in corner: Start near the border: Both coordinates of starting point are even: Both coordinates are odd: So the case when m = 2 is solved.Now, if m = 3, then it can be reduced to m = 2 as follows:Suppose we have a[1] = 3, a[2] = 3, a[3] = 3. Then let's at first consider only combinations where the third parameter is equal to 1: Then, if we need to add the combinations with third parameter equal to 2, we mirror the \"layer\": And if we need to add the third \"layer\", we mirror it again: And so on.This way can also be used to reduce m > 3 to m = 2.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*E"
          },
          "content_length": 4817
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 29 — Editorial - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(0, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(0, 1000000000, \"r_i\");\n        inf.readEoln();\n        \n        ensuref(l_i <= r_i, \"l_i should be <= r_i, but found l_i=%d > r_i=%d\", l_i, r_i);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(0, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(0, 1000000000, \"r_i\");\n        inf.readEoln();\n        \n        ensuref(l_i <= r_i, \"l_i should be <= r_i, but found l_i=%d > r_i=%d\", l_i, r_i);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(0, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(0, 1000000000, \"r_i\");\n        inf.readEoln();\n        \n        ensuref(l_i <= r_i, \"l_i should be <= r_i, but found l_i=%d > r_i=%d\", l_i, r_i);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This checker determines which intervals (TV sets) are redundant:\n  An interval i is \"redundant\" if removing it does *not* reduce\n  the set of integer times covered by at least one interval.\n\n  We do a standard line sweep (without coordinate compression):\n    - For interval [L, R], we create two events:\n        (+1 at L) and (-1 at R+1).\n      This means that the interval covers integer points x with L ≤ x ≤ R.\n    - We sort the events by their x-coordinate ascending. If two events\n      have the same x, we process all +1 (starts) before -1 (ends).\n    - As we move from one event coordinate to the next, we know how\n      many intervals are active between these coordinates. If exactly\n      one interval is active in [prevX, currX-1], then that single\n      interval is immediately non-redundant.\n\n  Complexity:\n    - Sorting 2n events costs O(n log n).\n    - Processing them in one pass is O(n log n) if we manage active intervals\n      in an O(log n) structure (e.g. a set).\n    - For n up to 2·10^5, this is acceptable.\n\n  After detecting which intervals are redundant, we compare the participant's\n  output:\n    - If output is -1, then we must have found no redundant interval.\n      If we did find at least one, that's WA.\n    - Otherwise, the output must be an integer in [1..n], and the corresponding\n      interval must actually be redundant. If not, WA.\n\n  For the test case:\n    3\n    1 2\n    3 4\n    6 8\n    Output: -1\n\n  Since [1,2], [3,4], [6,8] are all disjoint, each interval uniquely covers\n  its own segment, so all are non-redundant => the only correct answer is -1.\n  The line sweep below confirms that.\n*/\n\nstruct Event {\n    long long x;  // coordinate\n    int delta;    // +1 for start of interval, -1 for end (R+1)\n    int idx;      // which interval\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    vector<long long> L(n), R(n);\n    for(int i = 0; i < n; i++){\n        L[i] = inf.readLong();\n        R[i] = inf.readLong();\n    }\n\n    // Build events\n    // Interval [L[i], R[i]] => covers x = L[i]..R[i]\n    // We'll add (+1, L[i]) and (-1, R[i]+1).\n    // The coverage extends up to R[i], so ending event is at (R[i]+1) to\n    // indicate coverage stops just before that.\n    vector<Event> events;\n    events.reserve(2LL * n);\n    for(int i = 0; i < n; i++){\n        events.push_back({L[i], +1, i});\n        // R[i]+1 could be up to 1e9+1 (still within 64-bit)\n        // It does not cause an integer overflow in 64-bit.\n        events.push_back({R[i] + 1, -1, i});\n    }\n\n    // Sort events by x ascending; ties: +1 before -1\n    sort(events.begin(), events.end(), [&](auto &a, auto &b){\n        if (a.x != b.x) return a.x < b.x;\n        // if same x, put +1 before -1\n        return a.delta > b.delta;\n    });\n\n    // We'll track which intervals are currently active in a set<int>:\n    // if size=1, we know which interval is active.\n    // Mark all intervals as redundant = true initially.\n    vector<bool> isRedundant(n, true);\n    set<int> active; \n\n    // We'll sweep from one event to the next. The region of coverage is\n    // [prevX, currX - 1]. If active.size()==1 in that region, the single\n    // interval is not redundant.\n    long long prevX = 0;\n    if (!events.empty()) {\n        prevX = events[0].x;\n    }\n\n    // Process events in ascending x:\n    for (int i = 0; i < (int)events.size(); ) {\n        long long currX = events[i].x;\n\n        // The region [prevX, currX - 1] has length (currX - prevX).\n        // If that length > 0 and size(active) == 1, the single active interval\n        // is uniquely covering that entire range => not redundant.\n        if (currX > prevX && active.size() == 1) {\n            int onlyIdx = *active.begin(); \n            isRedundant[onlyIdx] = false;\n        }\n\n        // Now process all events with the same x coordinate\n        int j = i;\n        while (j < (int)events.size() && events[j].x == currX) {\n            const auto &ev = events[j];\n            if (ev.delta == +1) {\n                active.insert(ev.idx);\n            } else {\n                // delta == -1 => remove the interval from active\n                auto it = active.find(ev.idx);\n                if (it != active.end()) {\n                    active.erase(it);\n                }\n            }\n            j++;\n        }\n\n        // Move i to j, update prevX, and continue\n        i = j;\n        prevX = currX;\n    }\n\n    // Now we have isRedundant[] for each interval\n\n    // Read participant's single answer (an integer).\n    // Could be -1 or [1..n].\n    long long ansVal = ouf.readLong();\n\n    if (ansVal == -1) {\n        // If they say -1, that means no interval is redundant\n        // => check if there's at least one actually redundant\n        bool existsRedundant = false;\n        for (int i = 0; i < n; i++) {\n            if (isRedundant[i]) {\n                existsRedundant = true;\n                break;\n            }\n        }\n        if (existsRedundant) {\n            ouf.quitf(_wa, \"Output is -1 but a redundant interval exists.\");\n        } else {\n            ouf.quitf(_ok, \"Correct: no redundant intervals.\");\n        }\n    } else {\n        // Must be in [1..n]\n        if (ansVal < 1 || ansVal > n) {\n            ouf.quitf(_wa, \"Index %lld is out of valid range [1..%d].\", ansVal, n);\n        }\n        int idx = (int)ansVal - 1; // 0-based\n        if (isRedundant[idx]) {\n            ouf.quitf(_ok, \"Correct: interval %lld is indeed redundant.\", ansVal);\n        } else {\n            ouf.quitf(_wa, \"Interval %lld is not redundant.\", ansVal);\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> intervals(n);\n\n    if (type == \"full_overlap\") {\n        // All intervals are the same, covering the entire range\n        int l = 0;\n        int r = int(1e9);\n        for(int i = 0; i < n; ++i) {\n            intervals[i] = make_pair(l, r);\n        }\n    } else if (type == \"nested\") {\n        // Intervals are nested inside each other\n        int l = 0;\n        int r = int(1e9);\n        for(int i = 0; i < n; ++i) {\n            intervals[i] = make_pair(l, r);\n            if (l < r) l += rnd.next(0, min(1000000, r - l));\n            if (l < r) r -= rnd.next(0, min(1000000, r - l));\n            // Ensure l ≤ r and within bounds\n            if (l > r) l = r;\n            l = max(0, l);\n            r = min(int(1e9), r);\n        }\n    } else if (type == \"disjoint\") {\n        // Intervals are non-overlapping\n        int current = 0;\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 1000);\n            int l = current;\n            int r = current + len - 1;\n            intervals[i] = make_pair(l, r);\n            current = r + 1 + rnd.next(1, 1000);\n            if (current > int(1e9)) current = int(1e9);\n        }\n    } else if (type == \"adjacent\") {\n        // Intervals are adjacent\n        int current = 0;\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 1000);\n            int l = current;\n            int r = current + len - 1;\n            intervals[i] = make_pair(l, r);\n            current = r + 1;\n            if (current > int(1e9)) current = int(1e9);\n        }\n    } else if (type == \"random\") {\n        // Random intervals\n        for(int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            int r = rnd.next(l, int(1e9));\n            intervals[i] = make_pair(l, r);\n        }\n    } else if (type == \"zero_length\") {\n        // Intervals of length zero (li == ri)\n        for(int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            intervals[i] = make_pair(l, l);\n        }\n    } else if (type == \"max_coverage\") {\n        // One interval covers all others\n        intervals[0] = make_pair(0, int(1e9));\n        for (int i = 1; i < n; ++i) {\n            int l = rnd.next(1, int(1e9)-1);\n            int r = rnd.next(l, int(1e9)-1);\n            intervals[i] = make_pair(l, r);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            int r = rnd.next(l, int(1e9));\n            intervals[i] = make_pair(l, r);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output intervals\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> intervals(n);\n\n    if (type == \"full_overlap\") {\n        // All intervals are the same, covering the entire range\n        int l = 0;\n        int r = int(1e9);\n        for(int i = 0; i < n; ++i) {\n            intervals[i] = make_pair(l, r);\n        }\n    } else if (type == \"nested\") {\n        // Intervals are nested inside each other\n        int l = 0;\n        int r = int(1e9);\n        for(int i = 0; i < n; ++i) {\n            intervals[i] = make_pair(l, r);\n            if (l < r) l += rnd.next(0, min(1000000, r - l));\n            if (l < r) r -= rnd.next(0, min(1000000, r - l));\n            // Ensure l ≤ r and within bounds\n            if (l > r) l = r;\n            l = max(0, l);\n            r = min(int(1e9), r);\n        }\n    } else if (type == \"disjoint\") {\n        // Intervals are non-overlapping\n        int current = 0;\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 1000);\n            int l = current;\n            int r = current + len - 1;\n            intervals[i] = make_pair(l, r);\n            current = r + 1 + rnd.next(1, 1000);\n            if (current > int(1e9)) current = int(1e9);\n        }\n    } else if (type == \"adjacent\") {\n        // Intervals are adjacent\n        int current = 0;\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 1000);\n            int l = current;\n            int r = current + len - 1;\n            intervals[i] = make_pair(l, r);\n            current = r + 1;\n            if (current > int(1e9)) current = int(1e9);\n        }\n    } else if (type == \"random\") {\n        // Random intervals\n        for(int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            int r = rnd.next(l, int(1e9));\n            intervals[i] = make_pair(l, r);\n        }\n    } else if (type == \"zero_length\") {\n        // Intervals of length zero (li == ri)\n        for(int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            intervals[i] = make_pair(l, l);\n        }\n    } else if (type == \"max_coverage\") {\n        // One interval covers all others\n        intervals[0] = make_pair(0, int(1e9));\n        for (int i = 1; i < n; ++i) {\n            int l = rnd.next(1, int(1e9)-1);\n            int r = rnd.next(l, int(1e9)-1);\n            intervals[i] = make_pair(l, r);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            int r = rnd.next(l, int(1e9));\n            intervals[i] = make_pair(l, r);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output intervals\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type full_overlap\n./gen -n 1 -type zero_length\n\n./gen -n 2 -type random\n./gen -n 2 -type full_overlap\n./gen -n 2 -type disjoint\n./gen -n 2 -type nested\n./gen -n 2 -type zero_length\n\n./gen -n 3 -type random\n./gen -n 3 -type full_overlap\n./gen -n 3 -type disjoint\n./gen -n 3 -type nested\n./gen -n 3 -type max_coverage\n./gen -n 3 -type zero_length\n\n./gen -n 10 -type random\n./gen -n 10 -type adjacent\n./gen -n 10 -type disjoint\n\n./gen -n 1000 -type random\n./gen -n 1000 -type adjacent\n./gen -n 1000 -type full_overlap\n\n./gen -n 100000 -type random\n./gen -n 100000 -type nested\n./gen -n 100000 -type disjoint\n\n./gen -n 200000 -type random\n./gen -n 200000 -type zero_length\n./gen -n 200000 -type full_overlap\n./gen -n 200000 -type nested\n./gen -n 200000 -type disjoint\n./gen -n 200000 -type max_coverage\n./gen -n 200000 -type adjacent\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:49.560997",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/F",
      "title": "F. Почти перестановка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два числа n и q (1 ≤ n ≤ 50, 0 ≤ q ≤ 100).Затем следуют q строк, каждая из которых обозначает один из фактов о массиве. В i-й строке записаны четыре целых числа ti, li, ri и vi для i-го факта (1 ≤ ti ≤ 2, 1 ≤ li ≤ ri ≤ n, 1 ≤ vi ≤ n, ti обозначает тип факта).",
      "output_spec": "Выходные данныеЕсли факты противоречат друг другу и не существует массива, который бы им соответствовал, выведите -1. Иначе выведите минимально возможное значение величины cost.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 0Выходные данныеСкопировать3Входные данныеСкопировать3 11 1 3 2Выходные данныеСкопировать5Входные данныеСкопировать3 21 1 3 22 1 3 2Выходные данныеСкопировать9Входные данныеСкопировать3 21 1 3 22 1 3 1Выходные данныеСкопировать-1",
      "description": "F. Почти перестановка\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке заданы два числа n и q (1 ≤ n ≤ 50, 0 ≤ q ≤ 100).Затем следуют q строк, каждая из которых обозначает один из фактов о массиве. В i-й строке записаны четыре целых числа ti, li, ri и vi для i-го факта (1 ≤ ti ≤ 2, 1 ≤ li ≤ ri ≤ n, 1 ≤ vi ≤ n, ti обозначает тип факта).\n\nВходные данные\n\nВыходные данныеЕсли факты противоречат друг другу и не существует массива, который бы им соответствовал, выведите -1. Иначе выведите минимально возможное значение величины cost.\n\nВыходные данные\n\nВходные данныеСкопировать3 0Выходные данныеСкопировать3Входные данныеСкопировать3 11 1 3 2Выходные данныеСкопировать5Входные данныеСкопировать3 21 1 3 22 1 3 2Выходные данныеСкопировать9Входные данныеСкопировать3 21 1 3 22 1 3 1Выходные данныеСкопировать-1\n\nВходные данныеСкопировать3 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 11 1 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 21 1 3 22 1 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 21 1 3 22 1 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Привет, Codeforces!21 сентября в 18:05 по Москве начнётся Educational Codeforces Round 29. Продолжается серия образовательных раундов в рамках инициативы Harbour.Space University! Подробности о сотрудничестве Harbour.Space University и Codeforces можно прочитать в посте.Раунд будет нерейтинговый. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. После окончания раунда будет период времени длительностью в один день, в течение которого вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования.Вам будет предложено 7 задач на 2 часа. Мы надеемся, что вам они покажутся интересными.Задачи вместе со мной готовили Михаил awoo Пикляев, Владимир vovuh Петров и Михаил MikeMirzayanov Мирзаянов.Удачи в раунде! Успешных решений!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 846
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces",
          "content": "863A - Квази-палиндромЛегко можно проверить, что данное число является квази-палиндромным, если удалить все нули с конца числа и проверить, что полученная строка — палиндром. 863B - Сплав каякеровДля начала, научимся распределять людей на пары, как если бы не было одиночных каяков. Пусть есть люди с весами a, b, c и d (a ≤ b ≤ c ≤ d). Очевидно, минимальная неустойчивость, которую можно получить, — это max(b - a, d - c). Перестановка местами любой пары элементов не улучшит ответ. Такая жадная стратегия может быть применена для распределения всех мест.Теперь проверим все возможные пары людей в одиночных каяках и посчитаем для остальных их суммарную неустойчивость. Ответ — минимальная неустойчивость по всем парам.Асимптотика решения: O(n3). 863C - 1-2-3Заметим, что существует всего 9 расстановок в данной игре. Можно это использовать следующим образом. Будем проводить игры, пока какая-либо расстановка не поворится. Игры между этой парой вхождений выдадут один и тот же результат вне зависимости, когда будут проведены.Пусть расстояние между играми с одной и той же расстановкой будет dif и позиции этих игр — idx1 и idx2 (нумеруя с нуля). Сумма очков на отрезке — score(l, r).Тогда ответ будет score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Очередная задача про запросы в массивеИз ограничений можно догадаться, что асимптотика должна быть O(nm + q), либо же O(qm). И действительно существует решение со второй асимптотикой.Давайте решим противоположную задачу — ответить, на какой позиции окажется некоторое число после всех запросов. Найдем зависимость позиции pos от некоторого запроса. Пусть запрос производится над некоторым отрезком [l, r]. Если pos находится вне этого отрезка, то можно пропустить запрос. В противном случае поменяем местами apos и ar - (pos - l), сдвиг поменяет местами apos и apos - 1 (если pos = l, тогда будет r вместо (pos - 1)).Данная задача может быть переведена в нужную обработкой запросов в обратном порядке.Асимптотика решения: O(qm).Очевидно, эту задачу можно также решить декартовым деревом в онлайне за . 863E - Выключение телевизораДля начала сожмем моменты времени. Обратите внимание, что хранить только l и r недостаточно (например, пары ([1, 2], [3, 4]) и ([1, 2], [4, 5]))), надо еще взять (l - 1).Теперь все моменты времени не превышают 6·105. Для каждого момента насчитаем количество отрезков, которые его покрывают (делаем cntl +  = 1 и cntr + 1 -  = 1 для каждого отрезка и берем префиксные суммы по этому массиву). Теперь пусть prefi будет количеством моментов времени, покрытых ровно одним отрезком, на префиксе до i-го момента.Наконец, если для некоторого отрезка [l, r] из входных данных prefr - prefl - 1 равно 0, то можно удалить этот отрезок.Асимптотика решения: . 863F - Почти перестановкаЭту задачу можно решить при помощи максимального потока минимальной стоимости.Построим следующую сеть: Для каждого числа от 1 до n создадим отдельную вершину. Для каждой такой вершины добавим по n ориентированных рёбер из истока в эту вершину с пропускной способностью 1. Стоимости рёбер — 1, 3, 5, ..., 2n - 1 (то есть k единиц потока из истока в такую вершину будут стоить ровно k2); Также создадим по вершине для каждого индекса в массиве. Для каждого числа добавим по ориентированному ребру с пропускной способностью 1 и стоимостью 0 в каждый индекс массива, в который можно поставить это число, и для каждого индекса добавим одно ориентированное ребро в сток с пропускной способностью 1 и стоимостью 0. Построение максимального потока минимальной стоимости в такой сети позволит нам восстановить подходящий массив минимальной стоимости, поэтому ответ — это минимальная стоимость максимального потока. 863G - Настройки графикиЕсли m = 1, то всё просто. Цикл существует, если a[1] = 2, а путь существует, если b[1] = 1 или b[1] = a[1].Рассмотрим случай при m = 2. Давайте назовём комбинацию параметров нечётной, если сумма параметров нечётна, и чётной в ином случае. Можно увидеть, что если a[1] и a[2] нечётны, то цикл построить невозможно, так как кол-во чётных комбинаций больше, чем кол-во нечётных комбинаций. Более того, невозможно построить путь, если стартовая комбинация является нечётной.Покажем, как строить ответ для всех остальных случаев. Цикл строится легко, если хотя бы одно число из a[i] чётно: Построение пути можно разделить на четыре случая.Старт в углу: Старт на границе: Обе координаты старта чётны: Координаты старта нечётны: Таким образом, случай m = 2 решён.Случай m = 3 можно преобразовать в случай m = 2:Предположим, a[1] = 3, a[2] = 3, a[3] = 3. Рассмотрим сначала только те комбинации, в которых третий параметр равен 1: Теперь, если нам нужно добавить комбинации, в которых третий параметр равен 2, мы зеркально отражаем новый \"слой\": Третий слой надо ещё раз отразить относительно второго: И так далее.Таким же способом можно свести случай при m > 3 к случаю при m = 2.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*F"
          },
          "content_length": 4902
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, 100, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, 100, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(0, 100, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int, int> > constraints;\n\n    if (type == \"random\") {\n        if(q == 0) q = rnd.next(0,100);\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v);\n        }\n    } else if (type == \"max\") {\n        n = 50;\n        q = 100;\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v);\n        }\n    } else if (type == \"impossible\") {\n        // Generate conflicting constraints to make the test case impossible\n        if (n < 1) n = 1;\n        if(q == 0) q = 2;\n        int x = rnd.next(1,n);\n        int v1 = rnd.next(1,n-1);\n        int v2 = v1 + 1;\n        constraints.emplace_back(1, x, x, v2); // a_x ≥ v2\n        constraints.emplace_back(2, x, x, v1); // a_x ≤ v1\n        // Add more random constraints if q > 2\n        for(int i = 2; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v);\n        }\n    } else if (type == \"maxCost\" || type == \"singleValue\") {\n        // Constraints that force all elements to be the same value\n        if(q == 0) q = 2;\n        int v = rnd.next(1,n);\n        constraints.emplace_back(1, 1, n, v);\n        constraints.emplace_back(2, 1, n, v);\n        // Add more constraints if needed\n        for(int i = 2; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v2 = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v2);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)constraints.size());\n    for(auto& con : constraints) {\n        int t,l,r,v;\n        tie(t,l,r,v) = con;\n        printf(\"%d %d %d %d\\n\", t,l,r,v);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int, int> > constraints;\n\n    if (type == \"random\") {\n        if(q == 0) q = rnd.next(0,100);\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v);\n        }\n    } else if (type == \"max\") {\n        n = 50;\n        q = 100;\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v);\n        }\n    } else if (type == \"impossible\") {\n        // Generate conflicting constraints to make the test case impossible\n        if (n < 1) n = 1;\n        if(q == 0) q = 2;\n        int x = rnd.next(1,n);\n        int v1 = rnd.next(1,n-1);\n        int v2 = v1 + 1;\n        constraints.emplace_back(1, x, x, v2); // a_x ≥ v2\n        constraints.emplace_back(2, x, x, v1); // a_x ≤ v1\n        // Add more random constraints if q > 2\n        for(int i = 2; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v);\n        }\n    } else if (type == \"maxCost\" || type == \"singleValue\") {\n        // Constraints that force all elements to be the same value\n        if(q == 0) q = 2;\n        int v = rnd.next(1,n);\n        constraints.emplace_back(1, 1, n, v);\n        constraints.emplace_back(2, 1, n, v);\n        // Add more constraints if needed\n        for(int i = 2; i < q; ++i) {\n            int t = rnd.next(1,2);\n            int l = rnd.next(1,n);\n            int r = rnd.next(1,n);\n            if(l > r) swap(l,r);\n            int v2 = rnd.next(1,n);\n            constraints.emplace_back(t,l,r,v2);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, (int)constraints.size());\n    for(auto& con : constraints) {\n        int t,l,r,v;\n        tie(t,l,r,v) = con;\n        printf(\"%d %d %d %d\\n\", t,l,r,v);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 0 -type random\n./gen -n 1 -q 1 -type random\n\n./gen -n 2 -q 2 -type random\n./gen -n 2 -type impossible\n\n./gen -n 3 -q 3 -type random\n./gen -n 3 -q 4 -type impossible\n\n./gen -n 5 -q 0 -type random\n./gen -n 5 -q 5 -type random\n./gen -n 5 -q 10 -type random\n./gen -n 5 -type maxCost\n./gen -n 5 -type impossible\n\n./gen -n 10 -q 10 -type random\n./gen -n 10 -q 20 -type random\n./gen -n 10 -type maxCost\n./gen -n 10 -type impossible\n\n./gen -n 20 -q 50 -type random\n\n./gen -n 25 -q 50 -type random\n\n./gen -n 30 -q 60 -type random\n\n./gen -n 40 -q 80 -type random\n\n./gen -n 50 -q 0 -type random\n./gen -n 50 -q 100 -type random\n./gen -n 50 -q 100 -type max\n./gen -n 50 -q 100 -type maxCost\n./gen -n 50 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:51.420353",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "863/G",
      "title": "G. Настройки графики",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано одно целое число m (1 ≤ m ≤ 6).Во второй строке заданы m целых чисел a1, a2, ..., am (2 ≤ ai ≤ 1000). Гарантируется, что .В третьей строке заданы m целых чисел b1, b2, ..., bm (1 ≤ bi ≤ ai).",
      "output_spec": "Выходные данныеЕсли есть способ сделать ровно p изменений (каждое изменение снижает или повышает любой параметр на 1) так, чтобы попробовать все возможные комбинации и вернуться к изначальным значениям параметров, то выведите Cycle в первой строке. Затем выведите p строк, описывающих изменения. Каждая строка должна быть либо inc x (увеличить параметр x на 1), либо dec x (уменьшить этот параметр).В ином случае, если есть способ сделать ровно p - 1 изменений и попробовать все возможные комбинации (включая изначальную), то выведите Path в первой строке. Затем выведите p - 1 строк, описывающих изменения в том же формате.Если невозможно ни то, ни другое, выведите No.",
      "sample_tests": "ПримерыВходные данныеСкопировать131Выходные данныеСкопироватьPathinc 1inc 1Входные данныеСкопировать132Выходные данныеСкопироватьNoВходные данныеСкопировать23 21 1Выходные данныеСкопироватьCycleinc 1inc 1inc 2dec 1dec 1dec 2",
      "description": "G. Настройки графики\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано одно целое число m (1 ≤ m ≤ 6).Во второй строке заданы m целых чисел a1, a2, ..., am (2 ≤ ai ≤ 1000). Гарантируется, что .В третьей строке заданы m целых чисел b1, b2, ..., bm (1 ≤ bi ≤ ai).\n\nВходные данные\n\nВыходные данныеЕсли есть способ сделать ровно p изменений (каждое изменение снижает или повышает любой параметр на 1) так, чтобы попробовать все возможные комбинации и вернуться к изначальным значениям параметров, то выведите Cycle в первой строке. Затем выведите p строк, описывающих изменения. Каждая строка должна быть либо inc x (увеличить параметр x на 1), либо dec x (уменьшить этот параметр).В ином случае, если есть способ сделать ровно p - 1 изменений и попробовать все возможные комбинации (включая изначальную), то выведите Path в первой строке. Затем выведите p - 1 строк, описывающих изменения в том же формате.Если невозможно ни то, ни другое, выведите No.\n\nВыходные данные\n\nВходные данныеСкопировать131Выходные данныеСкопироватьPathinc 1inc 1Входные данныеСкопировать132Выходные данныеСкопироватьNoВходные данныеСкопировать23 21 1Выходные данныеСкопироватьCycleinc 1inc 1inc 2dec 1dec 1dec 2\n\nВходные данныеСкопировать131\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьPathinc 1inc 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать132\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать23 21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьCycleinc 1inc 1inc 2dec 1dec 1dec 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces",
          "content": "Привет, Codeforces!21 сентября в 18:05 по Москве начнётся Educational Codeforces Round 29. Продолжается серия образовательных раундов в рамках инициативы Harbour.Space University! Подробности о сотрудничестве Harbour.Space University и Codeforces можно прочитать в посте.Раунд будет нерейтинговый. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. После окончания раунда будет период времени длительностью в один день, в течение которого вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования.Вам будет предложено 7 задач на 2 часа. Мы надеемся, что вам они покажутся интересными.Задачи вместе со мной готовили Михаил awoo Пикляев, Владимир vovuh Петров и Михаил MikeMirzayanov Мирзаянов.Удачи в раунде! Успешных решений!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/54654",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 846
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces",
          "content": "863A - Квази-палиндромЛегко можно проверить, что данное число является квази-палиндромным, если удалить все нули с конца числа и проверить, что полученная строка — палиндром. 863B - Сплав каякеровДля начала, научимся распределять людей на пары, как если бы не было одиночных каяков. Пусть есть люди с весами a, b, c и d (a ≤ b ≤ c ≤ d). Очевидно, минимальная неустойчивость, которую можно получить, — это max(b - a, d - c). Перестановка местами любой пары элементов не улучшит ответ. Такая жадная стратегия может быть применена для распределения всех мест.Теперь проверим все возможные пары людей в одиночных каяках и посчитаем для остальных их суммарную неустойчивость. Ответ — минимальная неустойчивость по всем парам.Асимптотика решения: O(n3). 863C - 1-2-3Заметим, что существует всего 9 расстановок в данной игре. Можно это использовать следующим образом. Будем проводить игры, пока какая-либо расстановка не поворится. Игры между этой парой вхождений выдадут один и тот же результат вне зависимости, когда будут проведены.Пусть расстояние между играми с одной и той же расстановкой будет dif и позиции этих игр — idx1 и idx2 (нумеруя с нуля). Сумма очков на отрезке — score(l, r).Тогда ответ будет score(0, idx1) + + ((k - idx1) mod dif)·score(idx1 + 1, idx1 + (k - idx1) mod dif). 863D - Очередная задача про запросы в массивеИз ограничений можно догадаться, что асимптотика должна быть O(nm + q), либо же O(qm). И действительно существует решение со второй асимптотикой.Давайте решим противоположную задачу — ответить, на какой позиции окажется некоторое число после всех запросов. Найдем зависимость позиции pos от некоторого запроса. Пусть запрос производится над некоторым отрезком [l, r]. Если pos находится вне этого отрезка, то можно пропустить запрос. В противном случае поменяем местами apos и ar - (pos - l), сдвиг поменяет местами apos и apos - 1 (если pos = l, тогда будет r вместо (pos - 1)).Данная задача может быть переведена в нужную обработкой запросов в обратном порядке.Асимптотика решения: O(qm).Очевидно, эту задачу можно также решить декартовым деревом в онлайне за . 863E - Выключение телевизораДля начала сожмем моменты времени. Обратите внимание, что хранить только l и r недостаточно (например, пары ([1, 2], [3, 4]) и ([1, 2], [4, 5]))), надо еще взять (l - 1).Теперь все моменты времени не превышают 6·105. Для каждого момента насчитаем количество отрезков, которые его покрывают (делаем cntl +  = 1 и cntr + 1 -  = 1 для каждого отрезка и берем префиксные суммы по этому массиву). Теперь пусть prefi будет количеством моментов времени, покрытых ровно одним отрезком, на префиксе до i-го момента.Наконец, если для некоторого отрезка [l, r] из входных данных prefr - prefl - 1 равно 0, то можно удалить этот отрезок.Асимптотика решения: . 863F - Почти перестановкаЭту задачу можно решить при помощи максимального потока минимальной стоимости.Построим следующую сеть: Для каждого числа от 1 до n создадим отдельную вершину. Для каждой такой вершины добавим по n ориентированных рёбер из истока в эту вершину с пропускной способностью 1. Стоимости рёбер — 1, 3, 5, ..., 2n - 1 (то есть k единиц потока из истока в такую вершину будут стоить ровно k2); Также создадим по вершине для каждого индекса в массиве. Для каждого числа добавим по ориентированному ребру с пропускной способностью 1 и стоимостью 0 в каждый индекс массива, в который можно поставить это число, и для каждого индекса добавим одно ориентированное ребро в сток с пропускной способностью 1 и стоимостью 0. Построение максимального потока минимальной стоимости в такой сети позволит нам восстановить подходящий массив минимальной стоимости, поэтому ответ — это минимальная стоимость максимального потока. 863G - Настройки графикиЕсли m = 1, то всё просто. Цикл существует, если a[1] = 2, а путь существует, если b[1] = 1 или b[1] = a[1].Рассмотрим случай при m = 2. Давайте назовём комбинацию параметров нечётной, если сумма параметров нечётна, и чётной в ином случае. Можно увидеть, что если a[1] и a[2] нечётны, то цикл построить невозможно, так как кол-во чётных комбинаций больше, чем кол-во нечётных комбинаций. Более того, невозможно построить путь, если стартовая комбинация является нечётной.Покажем, как строить ответ для всех остальных случаев. Цикл строится легко, если хотя бы одно число из a[i] чётно: Построение пути можно разделить на четыре случая.Старт в углу: Старт на границе: Обе координаты старта чётны: Координаты старта нечётны: Таким образом, случай m = 2 решён.Случай m = 3 можно преобразовать в случай m = 2:Предположим, a[1] = 3, a[2] = 3, a[3] = 3. Рассмотрим сначала только те комбинации, в которых третий параметр равен 1: Теперь, если нам нужно добавить комбинации, в которых третий параметр равен 2, мы зеркально отражаем новый \"слой\": Третий слой надо ещё раз отразить относительно второго: И так далее.Таким же способом можно свести случай при m > 3 к случаю при m = 2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 863\\s*G"
          },
          "content_length": 4902
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "prefixSum[i] = prefixSum[i-1] + (tree.get(i)==1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "prefixSum[r] - prefixSum[l-1] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "package javaapplication7;\nimport java.util.Scanner;\npublic class JavaApplication7 {\n    public static void main(String[] args) {\n        //Reading user's number and adding leading zeros \n        Scanner s = new Scanner(System.in);\n        System.out.println(\"Enter the number please\");\n        Long in = s.nextLong();\n        String in_to_str = in+\"\";\n                \n        int in_last_index = in_to_str.length()-1;\n        String sub_str_to_add = \"\";\n        while(in_to_str.charAt(in_last_index)=='0'){\n            sub_str_to_add=sub_str_to_add+\"0\";\n            in_last_index--;\n        }\n        in_to_str = sub_str_to_add + in_to_str;\n       \n        //testing whether it's a palindromic or NOT\n        int in_len = in_to_str.length();\n        int ind_diff=-1;\n        for (int start=0,end=in_len-1;start<in_len/2&&end>in_len/2;end--,start++){\n            if(in_to_str.charAt(start)!=in_to_str.charAt(end))\n            {\n                ind_diff = start;\n                break; \n            }       \n        }\n           \n        /* the second part of the if condition [in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1)] \n        is to treat the case of a number composed of two digits which is not included in the previous test */\n        if(ind_diff<in_len/2&&ind_diff!=-1||in_len==2&&in_to_str.charAt(0)!=in_to_str.charAt(1))\n        System.out.println(\"The number \"+in+\" is NOT quasi-palindromic\");\n        else \n        System.out.println(\"The number \"+in+\" is quasi-palindromic\");            \n    }   \n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/54654",
          "author": "awoo"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 1",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 2",
          "code": "3\n1 3\n5 7\n2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 3",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 4",
          "code": "3\n1 3\n4 6\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 5",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 29 - Codeforces - Code 6",
          "code": "3\n1 2\n2 3\n3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 6, \"m\");\n    inf.readEoln();\n\n    vector<int> a(m);\n    for (int i = 0; i < m; i++) {\n        if (i > 0) inf.readSpace();\n        a[i] = inf.readInt(2, 1000, \"a_i\");\n    }\n    inf.readEoln();\n\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        if (i > 0) inf.readSpace();\n        b[i] = inf.readInt(1, a[i], \"b_i\");\n    }\n    inf.readEoln();\n\n    // Check that the product of ai ≤ 1e18\n    long long product = 1;\n    for (int i = 0; i < m; i++) {\n        if (product > (long long)1e18 / a[i]) {\n            ensuref(false, \"Product of a exceeds 1e18\");\n        }\n        product *= a[i];\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 6, \"m\");\n    inf.readEoln();\n\n    vector<int> a(m);\n    for (int i = 0; i < m; i++) {\n        if (i > 0) inf.readSpace();\n        a[i] = inf.readInt(2, 1000, \"a_i\");\n    }\n    inf.readEoln();\n\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        if (i > 0) inf.readSpace();\n        b[i] = inf.readInt(1, a[i], \"b_i\");\n    }\n    inf.readEoln();\n\n    // Check that the product of ai ≤ 1e18\n    long long product = 1;\n    for (int i = 0; i < m; i++) {\n        if (product > (long long)1e18 / a[i]) {\n            ensuref(false, \"Product of a exceeds 1e18\");\n        }\n        product *= a[i];\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 6, \"m\");\n    inf.readEoln();\n\n    vector<int> a(m);\n    for (int i = 0; i < m; i++) {\n        if (i > 0) inf.readSpace();\n        a[i] = inf.readInt(2, 1000, \"a_i\");\n    }\n    inf.readEoln();\n\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        if (i > 0) inf.readSpace();\n        b[i] = inf.readInt(1, a[i], \"b_i\");\n    }\n    inf.readEoln();\n\n    // Check that the product of ai ≤ 1e18\n    long long product = 1;\n    for (int i = 0; i < m; i++) {\n        if (product > (long long)1e18 / a[i]) {\n            ensuref(false, \"Product of a exceeds 1e18\");\n        }\n        product *= a[i];\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int CODE_NO = 0;\nstatic const int CODE_PATH = 1;\nstatic const int CODE_CYCLE = 2;\n\n// We'll store either \"No\", or (Path with p-1 changes), or (Cycle with p changes).\n// We represent a combination of parameters as a single integer in [0 .. p-1].\nstruct Solution {\n    int code;              // CODE_NO, CODE_PATH, or CODE_CYCLE\n    vector<int> changes;   // which parameter is changed on each step\n    vector<int> dir;       // +1 for inc, -1 for dec\n};\n\n// Converts a vector of current parameter values to an integer ID.\nint encodeState(const vector<int> &v, const vector<int> &a) {\n    // v[i] in [1..a[i]], all a[i] >= 2, product <= 1e6\n    // We'll do a standard base conversion: \n    // id = (((v[0]-1)*a[1] + (v[1]-1))*a[2] + (v[2]-1))*... etc.\n    int m = (int)a.size();\n    int id = 0;\n    for (int i = 0; i < m; i++) {\n        id = id * a[i] + (v[i] - 1);\n    }\n    return id;\n}\n\n// Reads the solution from stream.\n// Depending on whether it is \"No\", \"Path\", or \"Cycle\", we parse accordingly.\n// If \"Path\" or \"Cycle\", we also validate the sequence of changes (for the stream's perspective).\nSolution readSolution(InStream &stream,\n                      int m,                   // number of parameters\n                      const vector<int> &a,    // max setting for each parameter\n                      const vector<int> &b,    // initial combination\n                      int totalComb) {\n    // We read the first token: \"No\", \"Path\", or \"Cycle\"\n    string token = stream.readToken();\n    // Convert to uppercase for uniform comparison\n    for (char &c : token) c = (char)toupper(c);\n\n    Solution sol;\n    if (token == \"NO\") {\n        sol.code = CODE_NO;\n        return sol;\n    }\n    else if (token != \"PATH\" && token != \"CYCLE\") {\n        stream.quitf(_wa, \"expected 'No', 'Path' or 'Cycle', found '%s'\", token.c_str());\n    }\n\n    // We know either PATH or CYCLE\n    bool isCycle = (token == \"CYCLE\");\n    sol.code = isCycle ? CODE_CYCLE : CODE_PATH;\n\n    // number of lines/changes we expect\n    // \"Cycle\" => exactly totalComb changes\n    // \"Path\"  => exactly (totalComb - 1) changes\n    int needed = isCycle ? totalComb : (totalComb - 1);\n    if (needed < 0) {\n        // if totalComb == 0 or something contradictory\n        stream.quitf(_wa, \"bad totalComb or problem constraints\");\n    }\n\n    // read that many lines\n    sol.changes.resize(needed);\n    sol.dir.resize(needed);\n\n    // We'll track visited states in a boolean array (or vector<bool>).\n    // max totalComb <= 1e6\n    vector<bool> visited(totalComb, false);\n\n    // Current parameter settings\n    vector<int> cur = b;\n    int startID = encodeState(cur, a);\n    visited[startID] = true;\n    int visitedCount = 1;\n\n    for (int i = 0; i < needed; i++) {\n        string cmd = stream.readToken(); // \"inc\" or \"dec\"\n        for (char &c : cmd) c = (char)tolower(c);\n        if (cmd != \"inc\" && cmd != \"dec\") {\n            stream.quitf(_wa, \"expected 'inc' or 'dec', found '%s'\", cmd.c_str());\n        }\n        int x = stream.readInt(1, m, \"parameter_index\");\n        int d = (cmd == \"inc\") ? +1 : -1;\n\n        // Apply the change\n        // Remember indexing: x goes from 1..m, so 0-based is x-1\n        int idx = x - 1;\n        cur[idx] += d;\n\n        // Check out of bounds\n        if (cur[idx] < 1 || cur[idx] > a[idx]) {\n            stream.quitf(_wa,\n                         \"parameter %d out of bounds after '%s %d'\",\n                         x, cmd.c_str(), x);\n        }\n\n        sol.changes[i] = x;  // store which parameter was changed\n        sol.dir[i] = d;\n\n        int newID = encodeState(cur, a);\n        if (!visited[newID]) {\n            visited[newID] = true;\n            visitedCount++;\n        }\n    }\n\n    // If Path, we expect exactly totalComb distinct states visited.\n    // If Cycle, we also expect exactly totalComb distinct states visited,\n    // but we must end in the initial state again.\n    if (visitedCount != totalComb) {\n        stream.quitf(_wa,\n                     \"%s solution does not visit all %d distinct combinations (visited %d distinct)\",\n                     (isCycle ? \"Cycle\" : \"Path\"), totalComb, visitedCount);\n    }\n    if (isCycle) {\n        // Must end up in the initial combination\n        if (cur != b) {\n            stream.quitf(_wa,\n                         \"final combination does not match the initial combination in Cycle mode\");\n        }\n    }\n    else {\n        // Path: we do NOT require final combination == initial,\n        // so no extra condition here, as long as we visited everything exactly once.\n    }\n\n    return sol;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int m = inf.readInt(1, 6, \"m\");\n    vector<int> a(m), b(m);\n    long long product = 1;\n    for (int i = 0; i < m; i++) {\n        a[i] = inf.readInt(2, 1000, \"a[i]\");\n        product = product * a[i];\n        // We rely on the problem statement guarantee that product <= 1e6\n        // but let's still check to avoid unexpected overflows\n        if (product > 1000000LL) {\n            // If the problem statement guarantees product <= 1e6,\n            // but input is violating that, we can just quit fail.\n            quitf(_fail, \"the product of a[i] exceeds 1e6, input violated the constraints\");\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        b[i] = inf.readInt(1, a[i], \"b[i]\");\n    }\n    int totalComb = (int)product; // safe since <= 1e6\n\n    // Read the jury (correct) solution from ans\n    Solution jsol = readSolution(ans, m, a, b, totalComb);\n    // Read the participant solution from ouf\n    Solution psol = readSolution(ouf, m, a, b, totalComb);\n\n    // Now let's interpret the problem rules:\n    // 1) If a \"Cycle\" solution exists, we must output \"Cycle\".\n    // 2) If no \"Cycle\" solution but a \"Path\" solution exists, we output \"Path\".\n    // 3) Otherwise \"No\".\n    //\n    // We interpret the jury solution as the ground truth:\n    //  - If jury says \"Cycle\" => there is a cycle solution.\n    //  - If jury says \"Path\" => there is no cycle solution, but a path solution.\n    //  - If jury says \"No\"   => no solution.\n    //\n    // Compare participant's solution accordingly.\n\n    auto verdictJ = jsol.code;\n    auto verdictP = psol.code;\n\n    if (verdictJ == CODE_CYCLE) {\n        // Jury says there's a cycle solution\n        if (verdictP == CODE_NO || verdictP == CODE_PATH) {\n            quitf(_wa, \"a cycle solution exists, but participant did not provide a cycle\");\n        }\n        // verdictP == CODE_CYCLE\n        // If the participant's cycle is valid (already checked above), then accept\n        quitf(_ok, \"cycle solution accepted\");\n    }\n    else if (verdictJ == CODE_PATH) {\n        // Jury says there's no cycle, but a path solution\n        if (verdictP == CODE_NO) {\n            quitf(_wa, \"path solution exists, but participant answered No\");\n        }\n        else if (verdictP == CODE_CYCLE) {\n            // participant found a cycle solution where jury claims none exist => official error\n            quitf(_fail, \"the participant found a cycle solution but jury says only path is possible\");\n        }\n        // verdictP == CODE_PATH\n        // If the participant's path is valid, accept\n        quitf(_ok, \"path solution accepted\");\n    }\n    else {\n        // verdictJ == CODE_NO\n        // Jury says no solution\n        if (verdictP == CODE_NO) {\n            quitf(_ok, \"no solution accepted\");\n        }\n        else {\n            // participant found a path or cycle where the jury claims no solution => official error\n            if (verdictP == CODE_PATH) {\n                quitf(_fail, \"the participant found a path solution but jury says no solution\");\n            }\n            else { \n                quitf(_fail, \"the participant found a cycle solution but jury says no solution\");\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int max_ai = 1000;\n    const int min_ai = 2;\n    const ll max_p = 1000000;\n\n    vector<int> ai(m);\n    vector<int> bi(m);\n\n    ll p = 1; // Total number of combinations\n\n    if (type == \"path\") {\n        // Generate a test case where Path is expected\n\n        // Set m = 1\n        m = 1;\n        ai.resize(m);\n        bi.resize(m);\n\n        // ai is an odd number between 3 and 1000\n        ai[0] = rnd.next(3, max_ai / 2) * 2 + 1;\n        // bi = 1\n        bi[0] = 1;\n\n        p = ai[0];\n\n    } else if (type == \"no\") {\n        // Generate a test case where No is expected\n\n        // Set m = 1\n        m = 1;\n        ai.resize(m);\n        bi.resize(m);\n\n        // ai is even number between 2 and 1000\n        ai[0] = rnd.next(1, max_ai / 2 - 1) * 2 + 2;\n\n        // bi is middle value\n        bi[0] = ai[0] / 2;\n\n        p = ai[0];\n\n    } else if (type == \"cycle\") {\n        // Generate a test case where Cycle is expected\n\n        // Ensure m >= 2\n        if (m < 2) m = 2;\n        if (m > 6) m = 6;\n\n        ai.resize(m);\n        bi.resize(m);\n\n        p = 1;\n\n        // We need to ensure that product(ai) <= max_p\n        int max_ai_local = pow(max_p, 1.0 / m);\n        if (max_ai_local > max_ai) max_ai_local = max_ai;\n        if (max_ai_local < min_ai) max_ai_local = min_ai;\n\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai_local);\n            bi[i] = rnd.next(1, ai[i]);\n            p *= ai[i];\n        }\n\n        // If p exceeds max_p, adjust ai\n        while (p > max_p) {\n            int idx = rnd.next(0, m - 1);\n            if (ai[idx] > min_ai) {\n                p /= ai[idx];\n                ai[idx]--;\n                p *= ai[idx];\n                if (bi[idx] > ai[idx]) bi[idx] = ai[idx];\n            }\n        }\n\n    } else {\n        // type == \"random\"\n\n        // Random m between 1 and 6\n        m = rnd.next(1, 6);\n        ai.resize(m);\n        bi.resize(m);\n\n        p = 1;\n\n        // Generate ai and bi ensuring p <= max_p\n        for (int i = 0; i < m; ++i) {\n            int max_ai_local = max_ai;\n            if (p * max_ai_local > max_p) {\n                max_ai_local = max_p / p;\n                if (max_ai_local < min_ai) max_ai_local = min_ai;\n            }\n            ai[i] = rnd.next(min_ai, max_ai_local);\n            bi[i] = rnd.next(1, ai[i]);\n            p *= ai[i];\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", m);\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", ai[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", bi[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int max_ai = 1000;\n    const int min_ai = 2;\n    const ll max_p = 1000000;\n\n    vector<int> ai(m);\n    vector<int> bi(m);\n\n    ll p = 1; // Total number of combinations\n\n    if (type == \"path\") {\n        // Generate a test case where Path is expected\n\n        // Set m = 1\n        m = 1;\n        ai.resize(m);\n        bi.resize(m);\n\n        // ai is an odd number between 3 and 1000\n        ai[0] = rnd.next(3, max_ai / 2) * 2 + 1;\n        // bi = 1\n        bi[0] = 1;\n\n        p = ai[0];\n\n    } else if (type == \"no\") {\n        // Generate a test case where No is expected\n\n        // Set m = 1\n        m = 1;\n        ai.resize(m);\n        bi.resize(m);\n\n        // ai is even number between 2 and 1000\n        ai[0] = rnd.next(1, max_ai / 2 - 1) * 2 + 2;\n\n        // bi is middle value\n        bi[0] = ai[0] / 2;\n\n        p = ai[0];\n\n    } else if (type == \"cycle\") {\n        // Generate a test case where Cycle is expected\n\n        // Ensure m >= 2\n        if (m < 2) m = 2;\n        if (m > 6) m = 6;\n\n        ai.resize(m);\n        bi.resize(m);\n\n        p = 1;\n\n        // We need to ensure that product(ai) <= max_p\n        int max_ai_local = pow(max_p, 1.0 / m);\n        if (max_ai_local > max_ai) max_ai_local = max_ai;\n        if (max_ai_local < min_ai) max_ai_local = min_ai;\n\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai_local);\n            bi[i] = rnd.next(1, ai[i]);\n            p *= ai[i];\n        }\n\n        // If p exceeds max_p, adjust ai\n        while (p > max_p) {\n            int idx = rnd.next(0, m - 1);\n            if (ai[idx] > min_ai) {\n                p /= ai[idx];\n                ai[idx]--;\n                p *= ai[idx];\n                if (bi[idx] > ai[idx]) bi[idx] = ai[idx];\n            }\n        }\n\n    } else {\n        // type == \"random\"\n\n        // Random m between 1 and 6\n        m = rnd.next(1, 6);\n        ai.resize(m);\n        bi.resize(m);\n\n        p = 1;\n\n        // Generate ai and bi ensuring p <= max_p\n        for (int i = 0; i < m; ++i) {\n            int max_ai_local = max_ai;\n            if (p * max_ai_local > max_p) {\n                max_ai_local = max_p / p;\n                if (max_ai_local < min_ai) max_ai_local = min_ai;\n            }\n            ai[i] = rnd.next(min_ai, max_ai_local);\n            bi[i] = rnd.next(1, ai[i]);\n            p *= ai[i];\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", m);\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", ai[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", bi[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 1 -type path\n./gen -m 1 -type no\n./gen -m 1 -type random\n\n./gen -m 2 -type cycle\n./gen -m 2 -type random\n\n./gen -m 3 -type cycle\n./gen -m 3 -type random\n\n./gen -m 4 -type cycle\n./gen -m 4 -type random\n\n./gen -m 5 -type cycle\n./gen -m 5 -type random\n\n./gen -m 6 -type cycle\n./gen -m 6 -type random\n\n./gen -m 1 -type path\n./gen -m 1 -type no\n\n# Test cases with minimum values\n./gen -m 1 -type random\n./gen -m 2 -type random\n./gen -m 6 -type random\n\n# Test cases with maximum ai values under constraints\n./gen -m 6 -type cycle\n\n# Additional random test cases\n./gen -m 2 -type random\n./gen -m 3 -type random\n./gen -m 5 -type random\n\n# Repeated test cases to vary the randomness\n./gen -m 1 -type random\n./gen -m 2 -type random\n./gen -m 3 -type random\n./gen -m 4 -type random\n./gen -m 5 -type random\n./gen -m 6 -type random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:53.337560",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "864/A",
      "title": "A. Fair Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 100) — number of cards. It is guaranteed that n is an even number.The following n lines contain a sequence of integers a1, a2, ..., an (one integer per line, 1 ≤ ai ≤ 100) — numbers written on the n cards.",
      "output_spec": "OutputIf it is impossible for Petya and Vasya to choose numbers in such a way that the game will be fair, print \"NO\" (without quotes) in the first line. In this case you should not print anything more.In the other case print \"YES\" (without quotes) in the first line. In the second line print two distinct integers — number that Petya should choose and the number that Vasya should choose to make the game fair. If there are several solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy411272711OutputCopyYES11 27InputCopy266OutputCopyNOInputCopy6102030201020OutputCopyNOInputCopy6112233OutputCopyNO",
      "description": "A. Fair Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 100) — number of cards. It is guaranteed that n is an even number.The following n lines contain a sequence of integers a1, a2, ..., an (one integer per line, 1 ≤ ai ≤ 100) — numbers written on the n cards.\n\nOutputIf it is impossible for Petya and Vasya to choose numbers in such a way that the game will be fair, print \"NO\" (without quotes) in the first line. In this case you should not print anything more.In the other case print \"YES\" (without quotes) in the first line. In the second line print two distinct integers — number that Petya should choose and the number that Vasya should choose to make the game fair. If there are several solutions, print any of them.\n\nInputCopy411272711OutputCopyYES11 27InputCopy266OutputCopyNOInputCopy6102030201020OutputCopyNOInputCopy6112233OutputCopyNO\n\nInputCopy411272711\n\nOutputCopyYES11 27\n\nInputCopy266\n\nOutputCopyNO\n\nInputCopy6102030201020\n\nOutputCopyNO\n\nInputCopy6112233\n\nOutputCopyNO\n\nNoteIn the first example the game will be fair if, for example, Petya chooses number 11, and Vasya chooses number 27. Then the will take all cards — Petya will take cards 1 and 4, and Vasya will take cards 2 and 3. Thus, each of them will take exactly two cards.In the second example fair game is impossible because the numbers written on the cards are equal, but the numbers that Petya and Vasya should choose should be distinct.In the third example it is impossible to take all cards. Petya and Vasya can take at most five cards — for example, Petya can choose number 10 and Vasya can choose number 20. But for the game to be fair it is necessary to take 6 cards.",
      "solutions": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #436 (Div. 2). It'll be held on Monday, September 25 on 10:35 UTC and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2017/2018 year in city Saratov. They were prepared by Perforator, MikeMirzayanov and fcspartakm. Many thanks to the testers: sdya и BledDest, and coordinators KAN and vintage_Vlad_Makeev.It will be a little unusual round — you will be given six problems and two hours to solve them.Good luck and have fun!Congratulations to winners!Div. 2: zjt_ioi_2019_ak AngusRitossa Jha_The_ME_Coder cxh007 Alexxx Div. 1: Shik dreamoon_love_AA black_horse2014 orbitingflea KassiJulgus Analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54744",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 808
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*A"
          },
          "content_length": 4846
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*A"
          },
          "content_length": 4846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 1",
          "code": "**It will be a little unusual round** — you will be given six problems and two hours to solve them",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 2",
          "code": "It will be a little unusual round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 3",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 4",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 5",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 7",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 8",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 9",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 10",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 11",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 12",
          "code": "query(1, 4, 2) == 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 13",
          "code": "1-2-3-4 > 1-2-3-1-2-3-4 > ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 14",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 15",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 16",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 17",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 18",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 19",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 20",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 21",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 22",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 23",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> a(n);\n    map<int, int> freq;\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(1, 100, format(\"a[%d]\", i+1).c_str());\n        inf.readEoln();\n        freq[a[i]]++;\n    }\n\n    if (n % 2 != 0)\n        quitf(_fail, \"n is not even\");\n\n    // Determine the correct answer\n    bool correctAnswerIsYes = false;\n    if (freq.size() == 2) {\n        auto it = freq.begin();\n        int count1 = it->second;\n        ++it;\n        int count2 = it->second;\n        if (count1 == n / 2 && count2 == n / 2) {\n            correctAnswerIsYes = true;\n        }\n    }\n\n    // Read participant output\n    string firstLine = ouf.readLine();\n    trim(firstLine);\n    std::transform(firstLine.begin(), firstLine.end(), firstLine.begin(), ::toupper);\n\n    if (firstLine != \"YES\" && firstLine != \"NO\") {\n        quitf(_wa, \"First line must be YES or NO\");\n    }\n\n    if (firstLine == \"NO\") {\n        if (correctAnswerIsYes) {\n            quitf(_wa, \"Participant output NO, but correct answer is YES\");\n        } else {\n            quitf(_ok, \"Correct answer is NO\");\n        }\n    } else { // Participant output YES\n        if (!correctAnswerIsYes) {\n            quitf(_wa, \"Participant output YES, but correct answer is NO\");\n        }\n        // Read second line: two distinct integers\n        int p = ouf.readInt();\n        int v = ouf.readInt();\n\n        if (p == v)\n            quitf(_wa, \"The two numbers chosen must be distinct\");\n\n        // Check that p and v are among the numbers on the cards\n        if (freq.find(p) == freq.end() || freq.find(v) == freq.end())\n            quitf(_wa, \"The numbers chosen must be among the numbers on the cards\");\n\n        // Check that all cards have numbers equal to p or v\n        for (int i = 0; i < n; ++i) {\n            if (a[i] != p && a[i] != v)\n                quitf(_wa, \"Not all cards have numbers equal to the chosen numbers\");\n        }\n\n        // Check that counts of p and v are equal\n        if (freq[p] != n / 2 || freq[v] != n / 2)\n            quitf(_wa, \"Counts of chosen numbers must be equal to n/2 (%d)\", n / 2);\n\n        quitf(_ok, \"Correct answer\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"RANDOM\");\n\n    vector<int> a(n);\n\n    if (type == \"YES\") {\n        // Generate a test case where the answer is \"YES\"\n        // Two different numbers each appear n/2 times\n\n        int x = rnd.next(1, 100);\n        int y = rnd.next(1, 100);\n        while (y == x) {\n            y = rnd.next(1, 100);\n        }\n        for (int i = 0; i < n / 2; i++) a[i] = x;\n        for (int i = n / 2; i < n; i++) a[i] = y;\n\n    } else if (type == \"NO_ONE_NUMBER\") {\n        // Generate a test case where all numbers are the same\n        int x = rnd.next(1, 100);\n        for (int i = 0; i < n; i++) a[i] = x;\n\n    } else if (type == \"NO_UNBALANCED_COUNTS\") {\n        // Generate a test case where counts of two numbers are not equal to n/2\n        int x = rnd.next(1, 100);\n        int y = rnd.next(1, 100);\n        while (y == x) {\n            y = rnd.next(1, 100);\n        }\n        int cnt_x = n / 2 + 1;\n        int cnt_y = n / 2 - 1;\n        if (cnt_x + cnt_y > n) {\n            cnt_x = n / 2 + 1;\n            cnt_y = n / 2 - 2;\n            if (cnt_x + cnt_y > n)\n                cnt_x = n / 2;\n            cnt_y = n - cnt_x;\n        }\n        for (int i = 0; i < cnt_x; i++) a[i] = x;\n        for (int i = cnt_x; i < cnt_x + cnt_y; i++) a[i] = y;\n        for (int i = cnt_x + cnt_y; i < n; i++) a[i] = rnd.next(1, 100);\n\n    } else if (type == \"NO_NOT_SUM_N\") {\n        // Generate a test case where counts of any two numbers do not sum to n\n        if (n < 4) {\n            // Not possible, make all numbers random\n            for (int i = 0; i < n; i++) a[i] = rnd.next(1, 100);\n        } else {\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            while (y == x) {\n                y = rnd.next(1, 100);\n            }\n            int z = rnd.next(1, 100);\n            while (z == x || z == y) {\n                z = rnd.next(1, 100);\n            }\n            int cnt_x = n / 2 - 1;\n            int cnt_y = n / 2 - 1;\n            int cnt_z = n - cnt_x - cnt_y;\n            int idx = 0;\n            for (int i = 0; i < cnt_x; i++) a[idx++] = x;\n            for (int i = 0; i < cnt_y; i++) a[idx++] = y;\n            for (int i = 0; i < cnt_z; i++) a[idx++] = z;\n        }\n\n    } else if (type == \"YES_MULTIPLE_PAIRS\") {\n        // Generate a test case where multiple pairs can be chosen\n        if (n % 2 != 0) n += 1;  // Ensure n is even\n        if (n % 3 == 0) {\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            while (y == x) {\n                y = rnd.next(1, 100);\n            }\n            int z = rnd.next(1, 100);\n            while (z == x || z == y) {\n                z = rnd.next(1, 100);\n            }\n            int cnt = n / 3;\n            int idx = 0;\n            for (int i = 0; i < cnt; i++) a[idx++] = x;\n            for (int i = 0; i < cnt; i++) a[idx++] = y;\n            for (int i = idx; i < n; i++) a[idx++] = z;\n        } else {\n            // Fall back to YES type\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            while (y == x) {\n                y = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n / 2; i++) a[i] = x;\n            for (int i = n / 2; i < n; i++) a[i] = y;\n        }\n\n    } else {\n        // Random numbers\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Shuffle the array\n    shuffle(a.begin(), a.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the numbers\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"RANDOM\");\n\n    vector<int> a(n);\n\n    if (type == \"YES\") {\n        // Generate a test case where the answer is \"YES\"\n        // Two different numbers each appear n/2 times\n\n        int x = rnd.next(1, 100);\n        int y = rnd.next(1, 100);\n        while (y == x) {\n            y = rnd.next(1, 100);\n        }\n        for (int i = 0; i < n / 2; i++) a[i] = x;\n        for (int i = n / 2; i < n; i++) a[i] = y;\n\n    } else if (type == \"NO_ONE_NUMBER\") {\n        // Generate a test case where all numbers are the same\n        int x = rnd.next(1, 100);\n        for (int i = 0; i < n; i++) a[i] = x;\n\n    } else if (type == \"NO_UNBALANCED_COUNTS\") {\n        // Generate a test case where counts of two numbers are not equal to n/2\n        int x = rnd.next(1, 100);\n        int y = rnd.next(1, 100);\n        while (y == x) {\n            y = rnd.next(1, 100);\n        }\n        int cnt_x = n / 2 + 1;\n        int cnt_y = n / 2 - 1;\n        if (cnt_x + cnt_y > n) {\n            cnt_x = n / 2 + 1;\n            cnt_y = n / 2 - 2;\n            if (cnt_x + cnt_y > n)\n                cnt_x = n / 2;\n            cnt_y = n - cnt_x;\n        }\n        for (int i = 0; i < cnt_x; i++) a[i] = x;\n        for (int i = cnt_x; i < cnt_x + cnt_y; i++) a[i] = y;\n        for (int i = cnt_x + cnt_y; i < n; i++) a[i] = rnd.next(1, 100);\n\n    } else if (type == \"NO_NOT_SUM_N\") {\n        // Generate a test case where counts of any two numbers do not sum to n\n        if (n < 4) {\n            // Not possible, make all numbers random\n            for (int i = 0; i < n; i++) a[i] = rnd.next(1, 100);\n        } else {\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            while (y == x) {\n                y = rnd.next(1, 100);\n            }\n            int z = rnd.next(1, 100);\n            while (z == x || z == y) {\n                z = rnd.next(1, 100);\n            }\n            int cnt_x = n / 2 - 1;\n            int cnt_y = n / 2 - 1;\n            int cnt_z = n - cnt_x - cnt_y;\n            int idx = 0;\n            for (int i = 0; i < cnt_x; i++) a[idx++] = x;\n            for (int i = 0; i < cnt_y; i++) a[idx++] = y;\n            for (int i = 0; i < cnt_z; i++) a[idx++] = z;\n        }\n\n    } else if (type == \"YES_MULTIPLE_PAIRS\") {\n        // Generate a test case where multiple pairs can be chosen\n        if (n % 2 != 0) n += 1;  // Ensure n is even\n        if (n % 3 == 0) {\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            while (y == x) {\n                y = rnd.next(1, 100);\n            }\n            int z = rnd.next(1, 100);\n            while (z == x || z == y) {\n                z = rnd.next(1, 100);\n            }\n            int cnt = n / 3;\n            int idx = 0;\n            for (int i = 0; i < cnt; i++) a[idx++] = x;\n            for (int i = 0; i < cnt; i++) a[idx++] = y;\n            for (int i = idx; i < n; i++) a[idx++] = z;\n        } else {\n            // Fall back to YES type\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            while (y == x) {\n                y = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n / 2; i++) a[i] = x;\n            for (int i = n / 2; i < n; i++) a[i] = y;\n        }\n\n    } else {\n        // Random numbers\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Shuffle the array\n    shuffle(a.begin(), a.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the numbers\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type YES\n./gen -n 4 -type YES\n./gen -n 6 -type YES\n./gen -n 100 -type YES\n\n./gen -n 2 -type NO_ONE_NUMBER\n./gen -n 4 -type NO_ONE_NUMBER\n./gen -n 6 -type NO_ONE_NUMBER\n./gen -n 100 -type NO_ONE_NUMBER\n\n./gen -n 4 -type NO_UNBALANCED_COUNTS\n./gen -n 6 -type NO_UNBALANCED_COUNTS\n./gen -n 100 -type NO_UNBALANCED_COUNTS\n\n./gen -n 6 -type NO_NOT_SUM_N\n./gen -n 100 -type NO_NOT_SUM_N\n./gen -n 50 -type NO_NOT_SUM_N\n\n./gen -n 6 -type YES_MULTIPLE_PAIRS\n./gen -n 12 -type YES_MULTIPLE_PAIRS\n./gen -n 30 -type YES_MULTIPLE_PAIRS\n./gen -n 99 -type YES_MULTIPLE_PAIRS\n\n./gen -n 2 -type RANDOM\n./gen -n 10 -type RANDOM\n./gen -n 50 -type RANDOM\n./gen -n 100 -type RANDOM\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:55.320484",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "864/B",
      "title": "B. Polycarp and Letters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 200) — length of string s.The second line contains a string s consisting of lowercase and uppercase Latin letters.",
      "output_spec": "OutputPrint maximum number of elements in pretty set of positions for string s.",
      "sample_tests": "ExamplesInputCopy11aaaaBaabAbAOutputCopy2InputCopy12zACaAbbaazzCOutputCopy3InputCopy3ABCOutputCopy0",
      "description": "B. Polycarp and Letters\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 200) — length of string s.The second line contains a string s consisting of lowercase and uppercase Latin letters.\n\nOutputPrint maximum number of elements in pretty set of positions for string s.\n\nInputCopy11aaaaBaabAbAOutputCopy2InputCopy12zACaAbbaazzCOutputCopy3InputCopy3ABCOutputCopy0\n\nInputCopy11aaaaBaabAbA\n\nOutputCopy2\n\nInputCopy12zACaAbbaazzC\n\nOutputCopy3\n\nInputCopy3ABC\n\nOutputCopy0\n\nNoteIn the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.In the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.In the third example the given string s does not contain any lowercase letters, so the answer is 0.",
      "solutions": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #436 (Div. 2). It'll be held on Monday, September 25 on 10:35 UTC and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2017/2018 year in city Saratov. They were prepared by Perforator, MikeMirzayanov and fcspartakm. Many thanks to the testers: sdya и BledDest, and coordinators KAN and vintage_Vlad_Makeev.It will be a little unusual round — you will be given six problems and two hours to solve them.Good luck and have fun!Congratulations to winners!Div. 2: zjt_ioi_2019_ak AngusRitossa Jha_The_ME_Coder cxh007 Alexxx Div. 1: Shik dreamoon_love_AA black_horse2014 orbitingflea KassiJulgus Analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54744",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 808
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*B"
          },
          "content_length": 4846
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*B"
          },
          "content_length": 4846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 1",
          "code": "**It will be a little unusual round** — you will be given six problems and two hours to solve them",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 2",
          "code": "It will be a little unusual round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 3",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 4",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 5",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 7",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 8",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 9",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 10",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 11",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 12",
          "code": "query(1, 4, 2) == 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 13",
          "code": "1-2-3-4 > 1-2-3-1-2-3-4 > ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 14",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 15",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 16",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 17",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 18",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 19",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 20",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 21",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 22",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 23",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[a-zA-Z]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[a-zA-Z]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[a-zA-Z]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const string lower_letters = \"abcdefghijklmnopqrstuvwxyz\";\n    const string upper_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    string s;\n    if (type == \"all_lower\") {\n        for (int i = 0; i < n; ++i) {\n            char c = lower_letters[rnd.next(26)];\n            s += c;\n        }\n    } else if (type == \"all_upper\") {\n        for (int i = 0; i < n; ++i) {\n            char c = upper_letters[rnd.next(26)];\n            s += c;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                char c = lower_letters[rnd.next(26)];\n                s += c;\n            } else {\n                char c = upper_letters[rnd.next(26)];\n                s += c;\n            }\n        }\n    } else if (type == \"blocks\") {\n        int min_block_size = opt<int>(\"min_block_size\", 1);\n        int max_block_size = opt<int>(\"max_block_size\", 10);\n        int i = 0;\n        while (i < n) {\n            int block_size = rnd.next(min_block_size, max_block_size);\n            block_size = min(block_size, n - i);\n            for (int j = 0; j < block_size; ++j) {\n                char c = lower_letters[rnd.next(26)];\n                s += c;\n                ++i;\n            }\n            if (i >= n) break;\n            char c = upper_letters[rnd.next(26)];\n            s += c;\n            ++i;\n        }\n    } else if (type == \"duplicates\") {\n        int k = opt<int>(\"k\", 3);\n        ensuref(k >= 1 && k <=26, \"k must be between 1 and 26\");\n        vector<char> letters;\n        for (int i = 0; i < k; ++i) {\n            letters.push_back(lower_letters[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            char c = letters[rnd.next(k)];\n            s += c;\n        }\n        int num_upper = opt<int>(\"num_upper\", 0);\n        set<int> upper_positions;\n        while ((int)upper_positions.size() < num_upper) {\n            int pos = rnd.next(n);\n            upper_positions.insert(pos);\n        }\n        for (int pos : upper_positions) {\n            char c = upper_letters[rnd.next(26)];\n            s[pos] = c;\n        }\n    } else if (type == \"long_lowercase_with_upper_breaks\") {\n        int num_upper = opt<int>(\"num_upper\", 1);\n        for (int i = 0; i < n; ++i) {\n            char c = lower_letters[rnd.next(26)];\n            s += c;\n        }\n        set<int> upper_positions;\n        while ((int)upper_positions.size() < num_upper) {\n            int pos = rnd.next(n);\n            upper_positions.insert(pos);\n        }\n        for (int pos : upper_positions) {\n            char c = upper_letters[rnd.next(26)];\n            s[pos] = c;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int letter_case = rnd.next(2);\n            if (letter_case == 0) {\n                char c = lower_letters[rnd.next(26)];\n                s += c;\n            } else {\n                char c = upper_letters[rnd.next(26)];\n                s += c;\n            }\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    cout << n << endl;\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const string lower_letters = \"abcdefghijklmnopqrstuvwxyz\";\n    const string upper_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    string s;\n    if (type == \"all_lower\") {\n        for (int i = 0; i < n; ++i) {\n            char c = lower_letters[rnd.next(26)];\n            s += c;\n        }\n    } else if (type == \"all_upper\") {\n        for (int i = 0; i < n; ++i) {\n            char c = upper_letters[rnd.next(26)];\n            s += c;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                char c = lower_letters[rnd.next(26)];\n                s += c;\n            } else {\n                char c = upper_letters[rnd.next(26)];\n                s += c;\n            }\n        }\n    } else if (type == \"blocks\") {\n        int min_block_size = opt<int>(\"min_block_size\", 1);\n        int max_block_size = opt<int>(\"max_block_size\", 10);\n        int i = 0;\n        while (i < n) {\n            int block_size = rnd.next(min_block_size, max_block_size);\n            block_size = min(block_size, n - i);\n            for (int j = 0; j < block_size; ++j) {\n                char c = lower_letters[rnd.next(26)];\n                s += c;\n                ++i;\n            }\n            if (i >= n) break;\n            char c = upper_letters[rnd.next(26)];\n            s += c;\n            ++i;\n        }\n    } else if (type == \"duplicates\") {\n        int k = opt<int>(\"k\", 3);\n        ensuref(k >= 1 && k <=26, \"k must be between 1 and 26\");\n        vector<char> letters;\n        for (int i = 0; i < k; ++i) {\n            letters.push_back(lower_letters[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            char c = letters[rnd.next(k)];\n            s += c;\n        }\n        int num_upper = opt<int>(\"num_upper\", 0);\n        set<int> upper_positions;\n        while ((int)upper_positions.size() < num_upper) {\n            int pos = rnd.next(n);\n            upper_positions.insert(pos);\n        }\n        for (int pos : upper_positions) {\n            char c = upper_letters[rnd.next(26)];\n            s[pos] = c;\n        }\n    } else if (type == \"long_lowercase_with_upper_breaks\") {\n        int num_upper = opt<int>(\"num_upper\", 1);\n        for (int i = 0; i < n; ++i) {\n            char c = lower_letters[rnd.next(26)];\n            s += c;\n        }\n        set<int> upper_positions;\n        while ((int)upper_positions.size() < num_upper) {\n            int pos = rnd.next(n);\n            upper_positions.insert(pos);\n        }\n        for (int pos : upper_positions) {\n            char c = upper_letters[rnd.next(26)];\n            s[pos] = c;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int letter_case = rnd.next(2);\n            if (letter_case == 0) {\n                char c = lower_letters[rnd.next(26)];\n                s += c;\n            } else {\n                char c = upper_letters[rnd.next(26)];\n                s += c;\n            }\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    cout << n << endl;\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_lower\n./gen -n 1 -type all_upper\n./gen -n 1 -type random\n\n./gen -n 200 -type all_lower\n./gen -n 200 -type all_upper\n./gen -n 200 -type random\n\n./gen -n 200 -type alternating\n\n./gen -n 15 -type alternating\n\n./gen -n 20 -type blocks -min_block_size 1 -max_block_size 5\n\n./gen -n 200 -type blocks -min_block_size 1 -max_block_size 1\n\n./gen -n 200 -type blocks -min_block_size 10 -max_block_size 20\n\n./gen -n 200 -type duplicates -k 1 -num_upper 0\n\n./gen -n 200 -type duplicates -k 2 -num_upper 0\n\n./gen -n 200 -type duplicates -k 3 -num_upper 10\n\n./gen -n 200 -type long_lowercase_with_upper_breaks -num_upper 1\n\n./gen -n 200 -type long_lowercase_with_upper_breaks -num_upper 10\n\n./gen -n 200 -type long_lowercase_with_upper_breaks -num_upper 50\n\n./gen -n 200 -type random\n\n./gen -n 1 -type random\n\n./gen -n 1 -type long_lowercase_with_upper_breaks -num_upper 0\n\n./gen -n 50 -type duplicates -k 26 -num_upper 0\n\n./gen -n 50 -type duplicates -k 26 -num_upper 10\n\n./gen -n 50 -type duplicates -k 5 -num_upper 25\n\n./gen -n 199 -type duplicates -k 2 -num_upper 0\n\n./gen -n 199 -type duplicates -k 2 -num_upper 198\n\n./gen -n 200 -type blocks -min_block_size 1 -max_block_size 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:57.182640",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "864/C",
      "title": "C. Bus",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers a, b, f, k (0 < f < a ≤ 106, 1 ≤ b ≤ 109, 1 ≤ k ≤ 104) — the endpoint of the first bus journey, the capacity of the fuel tank of the bus, the point where the gas station is located, and the required number of journeys.",
      "output_spec": "OutputPrint the minimum number of times the bus needs to refuel to make k journeys. If it is impossible for the bus to make k journeys, print -1.",
      "sample_tests": "ExamplesInputCopy6 9 2 4OutputCopy4InputCopy6 10 2 4OutputCopy2InputCopy6 5 4 3OutputCopy-1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers a, b, f, k (0 < f < a ≤ 106, 1 ≤ b ≤ 109, 1 ≤ k ≤ 104) — the endpoint of the first bus journey, the capacity of the fuel tank of the bus, the point where the gas station is located, and the required number of journeys.\n\nOutputPrint the minimum number of times the bus needs to refuel to make k journeys. If it is impossible for the bus to make k journeys, print -1.\n\nInputCopy6 9 2 4OutputCopy4InputCopy6 10 2 4OutputCopy2InputCopy6 5 4 3OutputCopy-1\n\nInputCopy6 9 2 4\n\nOutputCopy4\n\nInputCopy6 10 2 4\n\nOutputCopy2\n\nInputCopy6 5 4 3\n\nOutputCopy-1\n\nNoteIn the first example the bus needs to refuel during each journey.In the second example the bus can pass 10 units of distance without refueling. So the bus makes the whole first journey, passes 4 units of the distance of the second journey and arrives at the point with the gas station. Then it can refuel its tank, finish the second journey and pass 2 units of distance from the third journey. In this case, it will again arrive at the point with the gas station. Further, he can refill the tank up to 10 liters to finish the third journey and ride all the way of the fourth journey. At the end of the journey the tank will be empty. In the third example the bus can not make all 3 journeys because if it refuels during the second journey, the tanks will contain only 5 liters of gasoline, but the bus needs to pass 8 units of distance until next refueling.",
      "solutions": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #436 (Div. 2). It'll be held on Monday, September 25 on 10:35 UTC and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2017/2018 year in city Saratov. They were prepared by Perforator, MikeMirzayanov and fcspartakm. Many thanks to the testers: sdya и BledDest, and coordinators KAN and vintage_Vlad_Makeev.It will be a little unusual round — you will be given six problems and two hours to solve them.Good luck and have fun!Congratulations to winners!Div. 2: zjt_ioi_2019_ak AngusRitossa Jha_The_ME_Coder cxh007 Alexxx Div. 1: Shik dreamoon_love_AA black_horse2014 orbitingflea KassiJulgus Analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54744",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 808
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*C"
          },
          "content_length": 4846
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*C"
          },
          "content_length": 4846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 1",
          "code": "**It will be a little unusual round** — you will be given six problems and two hours to solve them",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 2",
          "code": "It will be a little unusual round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 3",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 4",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 5",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 7",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 8",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 9",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 10",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 11",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 12",
          "code": "query(1, 4, 2) == 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 13",
          "code": "1-2-3-4 > 1-2-3-1-2-3-4 > ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 14",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 15",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 16",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 17",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 18",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 19",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 20",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 21",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 22",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 23",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int a = inf.readInt(2, 1000000, \"a\"); // a ∈ [2, 10^6]\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\"); // b ∈ [1, 10^9]\n    inf.readSpace();\n    int f = inf.readInt(1, a - 1, \"f\"); // f ∈ [1, a - 1]\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\"); // k ∈ [1, 10^4]\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int a = inf.readInt(2, 1000000, \"a\"); // a ∈ [2, 10^6]\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\"); // b ∈ [1, 10^9]\n    inf.readSpace();\n    int f = inf.readInt(1, a - 1, \"f\"); // f ∈ [1, a - 1]\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\"); // k ∈ [1, 10^4]\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int a = inf.readInt(2, 1000000, \"a\"); // a ∈ [2, 10^6]\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\"); // b ∈ [1, 10^9]\n    inf.readSpace();\n    int f = inf.readInt(1, a - 1, \"f\"); // f ∈ [1, a - 1]\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\"); // k ∈ [1, 10^4]\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, f, k;\n\n    if (type == \"min\") {\n        // Minimal values\n        a = 2;\n        f = 1;\n        b = 1;\n        k = 1;\n    } else if (type == \"max\") {\n        // Maximal values\n        a = 1000000;\n        b = 1000000000;\n        f = rnd.next(1, a - 1);\n        k = 10000;\n    } else if (type == \"edge1\") {\n        // b is exactly equal to f\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = f;\n        k = rnd.next(1, 10000);\n    } else if (type == \"edge2\") {\n        // b is less than f\n        a = rnd.next(3, 1000000);\n        f = rnd.next(2, a - 1);\n        b = f - 1;\n        k = rnd.next(1, 10000);\n    } else if (type == \"impossible\") {\n        // Impossible case where b is less than minimal required\n        a = rnd.next(3, 1000000);\n        f = rnd.next(2, a - 2);\n        int min_b = min(f, a - f);\n        if (min_b <= 1)\n            min_b = 2; // Ensure b >=1\n        b = min_b - 1;\n        k = rnd.next(1, 10000);\n    } else if (type == \"large_b\") {\n        // b is very large\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = 1000000000;\n        k = rnd.next(1, 10000);\n    } else if (type == \"tiny_b\") {\n        // b is 1\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = 1;\n        k = rnd.next(1, 10000);\n    } else if (type == \"k1\") {\n        // k is minimal (1)\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = rnd.next(1, 1000000000);\n        k = 1;\n    } else if (type == \"max_k\") {\n        // k is maximal (10000)\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = rnd.next(1, 1000000000);\n        k = 10000;\n    } else if (type == \"f_near_a\") {\n        // f is very close to a\n        a = rnd.next(2, 1000000);\n        f = a - 1;\n        b = rnd.next(1, 1000000000);\n        k = rnd.next(1, 10000);\n    } else if (type == \"f_near_0\") {\n        // f is very close to 0\n        a = rnd.next(2, 1000000);\n        f = 1;\n        b = rnd.next(1, 1000000000);\n        k = rnd.next(1, 10000);\n    } else {\n        // Random test case\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = rnd.next(1, 1000000000);\n        k = rnd.next(1, 10000);\n    }\n\n    printf(\"%d %d %d %d\\n\", a, b, f, k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, f, k;\n\n    if (type == \"min\") {\n        // Minimal values\n        a = 2;\n        f = 1;\n        b = 1;\n        k = 1;\n    } else if (type == \"max\") {\n        // Maximal values\n        a = 1000000;\n        b = 1000000000;\n        f = rnd.next(1, a - 1);\n        k = 10000;\n    } else if (type == \"edge1\") {\n        // b is exactly equal to f\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = f;\n        k = rnd.next(1, 10000);\n    } else if (type == \"edge2\") {\n        // b is less than f\n        a = rnd.next(3, 1000000);\n        f = rnd.next(2, a - 1);\n        b = f - 1;\n        k = rnd.next(1, 10000);\n    } else if (type == \"impossible\") {\n        // Impossible case where b is less than minimal required\n        a = rnd.next(3, 1000000);\n        f = rnd.next(2, a - 2);\n        int min_b = min(f, a - f);\n        if (min_b <= 1)\n            min_b = 2; // Ensure b >=1\n        b = min_b - 1;\n        k = rnd.next(1, 10000);\n    } else if (type == \"large_b\") {\n        // b is very large\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = 1000000000;\n        k = rnd.next(1, 10000);\n    } else if (type == \"tiny_b\") {\n        // b is 1\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = 1;\n        k = rnd.next(1, 10000);\n    } else if (type == \"k1\") {\n        // k is minimal (1)\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = rnd.next(1, 1000000000);\n        k = 1;\n    } else if (type == \"max_k\") {\n        // k is maximal (10000)\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = rnd.next(1, 1000000000);\n        k = 10000;\n    } else if (type == \"f_near_a\") {\n        // f is very close to a\n        a = rnd.next(2, 1000000);\n        f = a - 1;\n        b = rnd.next(1, 1000000000);\n        k = rnd.next(1, 10000);\n    } else if (type == \"f_near_0\") {\n        // f is very close to 0\n        a = rnd.next(2, 1000000);\n        f = 1;\n        b = rnd.next(1, 1000000000);\n        k = rnd.next(1, 10000);\n    } else {\n        // Random test case\n        a = rnd.next(2, 1000000);\n        f = rnd.next(1, a - 1);\n        b = rnd.next(1, 1000000000);\n        k = rnd.next(1, 10000);\n    }\n\n    printf(\"%d %d %d %d\\n\", a, b, f, k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type edge1\n\n./gen -type edge2\n\n./gen -type impossible\n\n./gen -type large_b\n\n./gen -type tiny_b\n\n./gen -type k1\n\n./gen -type max_k\n\n./gen -type f_near_a\n\n./gen -type f_near_0\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:41:59.157542",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "864/D",
      "title": "D. Сделай перестановку!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке следует целое число n (2 ≤ n ≤ 200 000) — количество элементов в массиве Ивана.Во второй строке следует последовательность целых чисел a1, a2, ..., an (1 ≤ ai ≤ n) — описание массива Ивана.",
      "output_spec": "Выходные данныеВ первую строку выведите q — минимальное количество элементов, которые нужно изменить в массиве Ивана для того, чтобы массив стал перестановкой. Во вторую строку выведите лексикографически минимальную перестановку, которая получается с помощью q изменений.",
      "sample_tests": "ПримерыВходные данныеСкопировать43 2 2 3Выходные данныеСкопировать21 2 4 3 Входные данныеСкопировать64 5 6 3 2 1Выходные данныеСкопировать04 5 6 3 2 1 Входные данныеСкопировать106 8 4 6 7 1 6 3 4 5Выходные данныеСкопировать32 8 4 6 7 1 9 3 10 5",
      "description": "D. Сделай перестановку!\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке следует целое число n (2 ≤ n ≤ 200 000) — количество элементов в массиве Ивана.Во второй строке следует последовательность целых чисел a1, a2, ..., an (1 ≤ ai ≤ n) — описание массива Ивана.\n\nВходные данные\n\nВыходные данныеВ первую строку выведите q — минимальное количество элементов, которые нужно изменить в массиве Ивана для того, чтобы массив стал перестановкой. Во вторую строку выведите лексикографически минимальную перестановку, которая получается с помощью q изменений.\n\nВыходные данные\n\nВходные данныеСкопировать43 2 2 3Выходные данныеСкопировать21 2 4 3 Входные данныеСкопировать64 5 6 3 2 1Выходные данныеСкопировать04 5 6 3 2 1 Входные данныеСкопировать106 8 4 6 7 1 6 3 4 5Выходные данныеСкопировать32 8 4 6 7 1 9 3 10 5\n\nВходные данныеСкопировать43 2 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 2 4 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать64 5 6 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать04 5 6 3 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать106 8 4 6 7 1 6 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32 8 4 6 7 1 9 3 10 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нужно заменить тройку, стоящую в позиции 1, на единицу, а двойку, стоящую в позиции 3, нужно заменить на четвёрку. Тогда мы получим перестановку [1, 2, 4, 3], изменив два числа — эта перестановка лексикографически минимальная из всех подходящих перестановок. Во втором примере ничего изменять не нужно, так как данный массив является перестановкой.",
      "solutions": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!25 сентября 2017 года в 13:35 MSK состоится очередной раунд Codeforces #436 для участников из второго дивизиона. Традиционно, участники из первого дивизиона приглашаются поучаствовать в соревновании вне конкурса. Обратите внимание на необычное время начала раунда!Этот раунд проводится по задачам школьного этапа Всероссийской олимпиады школьников по информатике 2017/2018 года г. Саратова. Задачи для вас готовили Perforator, MikeMirzayanov и fcspartakm. Огромное спасибо тестерам: sdya и BledDest, а так же координаторам KAN и vintage_Vlad_Makeev.Участникам будет предложено шесть задач и два часа на их решение. UPD Если вы школьник из Саратова и писали сегодня школьный этап Всероссийской олимпиады по информатике, убедительная просьба не принимать участие в сегодняшнем соревновании!Поздравляем победителей!Div. 2: zjt_ioi_2019_ak AngusRitossa Jha_The_ME_Coder cxh007 Alexxx Div. 1: Shik dreamoon_love_AA black_horse2014 orbitingflea KassiJulgus Разбор тут.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54744",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces",
          "content": "864A - Честная играДанная задача может быть решена разными способами. Рассмотрим один из них.Отсортируем все числа по неубыванию. Тогда первые n / 2 чисел должны быть равны между собой, и следующие n / 2 чисел должны быть равны между собой, при этом число из первой половины должно быть отлично от числа из второй половины. Поэтому, если после сортировки выполняются все условия: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] то ответ на задачу «YES», при этом Вася должен выбрать перед игрой число a[1], а Петя — a[n] (или наоборот). Если хотя бы одно из перечисленных условий не выполняется, ответ на задачу «NO». 864B - Поликарп и буквыБудем решать задачу следующим образом. Будем рассматривать буквы в строке в порядке слева направо. Если мы находимся в позиции pos и очередная буква прописная, то пропустим её. В противном случае, заведём set, положим в него букву spos. После этого будем идти вправо по строке до тех пор, пока не встретим прописную букву, либо пока не кончится строка. Каждую новую строчную букву будем класть в set. После того как мы встретили прописную букву (пусть это будем позиция p), либо дошли до конца строки, обновим ответ количеством элементов в set, и будем выполнять заново описанный алгоритм, но уже начиная с позиции p. 864C - АвтобусЕсли автобус не сможет доехать до первой заправки (то есть b < f) выведем -1.В противном случае, автобус доедет до первой заправки, а в баке у него останется b - f литров топлива. Далее будем перебирать рейсы от 1 до k и вычислять величину need — сколько литров топлива должно быть в баке, чтобы автобус смог доехать до следующей заправки. Если need больше, чем b, то нужно вывести -1, так как это означает, что даже с полным баком автобус не сможет доехать до следующей заправки. Если need больше, чем текущее количество топлива в баке, то автобус должен сделать дозаправку. В противном случае, заправляться не нужно. После описанных действий нужно нужно перейти в точку заправки на следующем рейсе, при этом пересчитав оставшееся количество топлива в баке. 864D - Сделай перестановку!Заведём массив cnt, в котором будет храниться сколько раз встречается в заданном массиве a каждое из чисел от 1 до n. Положим все числа, которые ни разу не встречаются в заданном массиве в вектор need — их нам нужно обязательно добавить в массив a, чтобы сделать из него перестановку.Будем добавлять все числа из need по возрастанию, так как нам нужно получить лексикографически минимальную перестановку. Пусть pos указывает на текущее число needpos, которое нужно добавить на текущем ходу. Изначально, pos = 0.Будем итерироваться по массиву a. Пусть текущее число равно ai. Если cntai = 1, то перейдем к следующему числу в массиве. Если мы еще добавили не все числа из need, и ai > needpos или слева уже встречалось число ai (для проверки этого можно завести, например, отдельный массив), то поставим число needpos в текущую позицию, уменьшим cntai на единицу, увеличим pos на единицу и увеличим ответ на единицу, так как мы выполнили очередную замену числа в заданном массиве. Если же мы не производим замену на текущем шаге, то пометим, что число ai уже встречалось на префиксе массива. После этого перейдем к следующему числу в массиве a. 864E - ПожарЕсли поликарп будет спасать две вещи, то все выгнее спасти сначала ту вещь, у которой параметр d меньше. Следовательно, вещи можно отсортировать по параметру d.Путь dpi, j равно максимальной общей стоимости вещей, которые Поликарп спас, рассмотрев первые i - 1 вещи за j секунд. Есть два типа переходов. Либо Поликарп спасает рассматриваемую вещь, либо нет: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), едсе j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) Для восстановления последовательности вещей, которые Поликарп спас, можно запоминать для каждой пары (i, j), была ли спасена вещь i - 1 при обновлении значения dpi, j.Асимптотика решения: O(n·max1 ≤ i ≤ ndi). 864F - Экскурсии по городамВ условии задан ориентированный граф. Для каждого запроса нужно найти kj-ую вершину в лексикографически минимальном пути из sj в tj.Для начала сгруппируем запросы по вершине tj и найдем все вершины, из которых достижима tj. Для этого можно развернуть все дуги графа и запустить любой обход графа из вершины tj.Рассмотрим запрос (sj, tj). Для этого запроса нужно найти лексикографически минимальный путь из sj в tj. Если вершина tj не достижима из sj, то ответом на запрос является '-1'. В противном случае, в лексикографически минимальном пути p из sj в tj вершина pi (i > 1) является минимальной среди вершин u таких, что в графе есть дуга (pi - 1, u) и tj достижима из u.Можно построить новый граф, состоящий из дуг, удовлетворяющих описанному условию. Развернем все дуги в этом графе. Рассмотрим вершины, достижимые из tj в этом графе. Они образуют исходящее дерево. Только для этих вершин существует лексикографически минимальный путь в tj. Лексикографически минимальный путь из sj в tj равен развернутому пути из tj в sj в построенном дереве.Таким образом, можно использовать двоичный подъем для нахождения kj-той вершины на лексикографически минимальном пути.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*D"
          },
          "content_length": 5080
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces",
          "content": "864A - Честная играДанная задача может быть решена разными способами. Рассмотрим один из них.Отсортируем все числа по неубыванию. Тогда первые n / 2 чисел должны быть равны между собой, и следующие n / 2 чисел должны быть равны между собой, при этом число из первой половины должно быть отлично от числа из второй половины. Поэтому, если после сортировки выполняются все условия: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] то ответ на задачу «YES», при этом Вася должен выбрать перед игрой число a[1], а Петя — a[n] (или наоборот). Если хотя бы одно из перечисленных условий не выполняется, ответ на задачу «NO». 864B - Поликарп и буквыБудем решать задачу следующим образом. Будем рассматривать буквы в строке в порядке слева направо. Если мы находимся в позиции pos и очередная буква прописная, то пропустим её. В противном случае, заведём set, положим в него букву spos. После этого будем идти вправо по строке до тех пор, пока не встретим прописную букву, либо пока не кончится строка. Каждую новую строчную букву будем класть в set. После того как мы встретили прописную букву (пусть это будем позиция p), либо дошли до конца строки, обновим ответ количеством элементов в set, и будем выполнять заново описанный алгоритм, но уже начиная с позиции p. 864C - АвтобусЕсли автобус не сможет доехать до первой заправки (то есть b < f) выведем -1.В противном случае, автобус доедет до первой заправки, а в баке у него останется b - f литров топлива. Далее будем перебирать рейсы от 1 до k и вычислять величину need — сколько литров топлива должно быть в баке, чтобы автобус смог доехать до следующей заправки. Если need больше, чем b, то нужно вывести -1, так как это означает, что даже с полным баком автобус не сможет доехать до следующей заправки. Если need больше, чем текущее количество топлива в баке, то автобус должен сделать дозаправку. В противном случае, заправляться не нужно. После описанных действий нужно нужно перейти в точку заправки на следующем рейсе, при этом пересчитав оставшееся количество топлива в баке. 864D - Сделай перестановку!Заведём массив cnt, в котором будет храниться сколько раз встречается в заданном массиве a каждое из чисел от 1 до n. Положим все числа, которые ни разу не встречаются в заданном массиве в вектор need — их нам нужно обязательно добавить в массив a, чтобы сделать из него перестановку.Будем добавлять все числа из need по возрастанию, так как нам нужно получить лексикографически минимальную перестановку. Пусть pos указывает на текущее число needpos, которое нужно добавить на текущем ходу. Изначально, pos = 0.Будем итерироваться по массиву a. Пусть текущее число равно ai. Если cntai = 1, то перейдем к следующему числу в массиве. Если мы еще добавили не все числа из need, и ai > needpos или слева уже встречалось число ai (для проверки этого можно завести, например, отдельный массив), то поставим число needpos в текущую позицию, уменьшим cntai на единицу, увеличим pos на единицу и увеличим ответ на единицу, так как мы выполнили очередную замену числа в заданном массиве. Если же мы не производим замену на текущем шаге, то пометим, что число ai уже встречалось на префиксе массива. После этого перейдем к следующему числу в массиве a. 864E - ПожарЕсли поликарп будет спасать две вещи, то все выгнее спасти сначала ту вещь, у которой параметр d меньше. Следовательно, вещи можно отсортировать по параметру d.Путь dpi, j равно максимальной общей стоимости вещей, которые Поликарп спас, рассмотрев первые i - 1 вещи за j секунд. Есть два типа переходов. Либо Поликарп спасает рассматриваемую вещь, либо нет: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), едсе j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) Для восстановления последовательности вещей, которые Поликарп спас, можно запоминать для каждой пары (i, j), была ли спасена вещь i - 1 при обновлении значения dpi, j.Асимптотика решения: O(n·max1 ≤ i ≤ ndi). 864F - Экскурсии по городамВ условии задан ориентированный граф. Для каждого запроса нужно найти kj-ую вершину в лексикографически минимальном пути из sj в tj.Для начала сгруппируем запросы по вершине tj и найдем все вершины, из которых достижима tj. Для этого можно развернуть все дуги графа и запустить любой обход графа из вершины tj.Рассмотрим запрос (sj, tj). Для этого запроса нужно найти лексикографически минимальный путь из sj в tj. Если вершина tj не достижима из sj, то ответом на запрос является '-1'. В противном случае, в лексикографически минимальном пути p из sj в tj вершина pi (i > 1) является минимальной среди вершин u таких, что в графе есть дуга (pi - 1, u) и tj достижима из u.Можно построить новый граф, состоящий из дуг, удовлетворяющих описанному условию. Развернем все дуги в этом графе. Рассмотрим вершины, достижимые из tj в этом графе. Они образуют исходящее дерево. Только для этих вершин существует лексикографически минимальный путь в tj. Лексикографически минимальный путь из sj в tj равен развернутому пути из tj в sj в построенном дереве.Таким образом, можно использовать двоичный подъем для нахождения kj-той вершины на лексикографически минимальном пути.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*D"
          },
          "content_length": 5080
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 1",
          "code": "**It will be a little unusual round** — you will be given six problems and two hours to solve them",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 2",
          "code": "It will be a little unusual round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 3",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 4",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 5",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 7",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 8",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 9",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 10",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 11",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 12",
          "code": "query(1, 4, 2) == 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 13",
          "code": "1-2-3-4 > 1-2-3-1-2-3-4 > ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 14",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 15",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 16",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 17",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 18",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 19",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 20",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 21",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 22",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 23",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Разбор - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else if (type == \"permutation\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"all_same\") {\n        int num = rnd.next(1, n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = num;\n        }\n    } else if (type == \"few_duplicates\") {\n        // Start with a permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n        // Introduce some duplicates\n        int num_changes = n / 10 + 1; // change about 10% of the elements\n        for (int i = 0; i < num_changes; ++i) {\n            int pos = rnd.next(0, n - 1);\n            a[pos] = rnd.next(1, n);\n        }\n    } else if (type == \"missing_numbers\") {\n        // Remove some numbers and duplicate others\n        set<int> numbers;\n        for (int i = 1; i <= n; ++i) {\n            numbers.insert(i);\n        }\n        int num_missing = n / 10 + 1; // Remove about 10% of numbers\n        vector<int> missing_nums;\n        for (int i = 0; i < num_missing; ++i) {\n            int num = rnd.next(1, n);\n            if (numbers.count(num)) {\n                numbers.erase(num);\n                missing_nums.push_back(num);\n            }\n        }\n        vector<int> remaining_numbers(numbers.begin(), numbers.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = remaining_numbers[rnd.next(0, (int)remaining_numbers.size() - 1)];\n        }\n    } else if (type == \"reverse\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"maximal_duplicates\") {\n        int num = rnd.next(1, n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = num;\n        }\n    } else if (type == \"single_duplicate\") {\n        // Create a permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        // Introduce a single duplicate\n        int dup_pos = rnd.next(0, n - 1);\n        int rem_pos;\n        do {\n            rem_pos = rnd.next(0, n - 1);\n        } while (rem_pos == dup_pos);\n        a[dup_pos] = a[rem_pos];\n    } else if (type == \"single_missing\") {\n        // Start with a shuffled permutation\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i) {\n            perm[i] = i + 1;\n        }\n        shuffle(perm.begin(), perm.end());\n        // Replace one number with a duplicate\n        int missing_num = rnd.next(1, n);\n        int missing_pos = -1;\n        for (int i = 0; i < n; ++i) {\n            if (perm[i] == missing_num) {\n                missing_pos = i;\n                break;\n            }\n        }\n        int dup_pos;\n        do {\n            dup_pos = rnd.next(0, n - 1);\n        } while (dup_pos == missing_pos);\n        perm[missing_pos] = perm[dup_pos];\n        a = perm;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else if (type == \"permutation\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"all_same\") {\n        int num = rnd.next(1, n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = num;\n        }\n    } else if (type == \"few_duplicates\") {\n        // Start with a permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n        // Introduce some duplicates\n        int num_changes = n / 10 + 1; // change about 10% of the elements\n        for (int i = 0; i < num_changes; ++i) {\n            int pos = rnd.next(0, n - 1);\n            a[pos] = rnd.next(1, n);\n        }\n    } else if (type == \"missing_numbers\") {\n        // Remove some numbers and duplicate others\n        set<int> numbers;\n        for (int i = 1; i <= n; ++i) {\n            numbers.insert(i);\n        }\n        int num_missing = n / 10 + 1; // Remove about 10% of numbers\n        vector<int> missing_nums;\n        for (int i = 0; i < num_missing; ++i) {\n            int num = rnd.next(1, n);\n            if (numbers.count(num)) {\n                numbers.erase(num);\n                missing_nums.push_back(num);\n            }\n        }\n        vector<int> remaining_numbers(numbers.begin(), numbers.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = remaining_numbers[rnd.next(0, (int)remaining_numbers.size() - 1)];\n        }\n    } else if (type == \"reverse\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"maximal_duplicates\") {\n        int num = rnd.next(1, n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = num;\n        }\n    } else if (type == \"single_duplicate\") {\n        // Create a permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        // Introduce a single duplicate\n        int dup_pos = rnd.next(0, n - 1);\n        int rem_pos;\n        do {\n            rem_pos = rnd.next(0, n - 1);\n        } while (rem_pos == dup_pos);\n        a[dup_pos] = a[rem_pos];\n    } else if (type == \"single_missing\") {\n        // Start with a shuffled permutation\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i) {\n            perm[i] = i + 1;\n        }\n        shuffle(perm.begin(), perm.end());\n        // Replace one number with a duplicate\n        int missing_num = rnd.next(1, n);\n        int missing_pos = -1;\n        for (int i = 0; i < n; ++i) {\n            if (perm[i] == missing_num) {\n                missing_pos = i;\n                break;\n            }\n        }\n        int dup_pos;\n        do {\n            dup_pos = rnd.next(0, n - 1);\n        } while (dup_pos == missing_pos);\n        perm[missing_pos] = perm[dup_pos];\n        a = perm;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type permutation\n./gen -n 2 -type all_same\n./gen -n 2 -type few_duplicates\n./gen -n 2 -type missing_numbers\n\n./gen -n 10 -type random\n./gen -n 10 -type permutation\n./gen -n 10 -type all_same\n./gen -n 10 -type few_duplicates\n./gen -n 10 -type missing_numbers\n\n./gen -n 1000 -type random\n./gen -n 1000 -type permutation\n./gen -n 1000 -type all_same\n./gen -n 1000 -type few_duplicates\n./gen -n 1000 -type missing_numbers\n\n./gen -n 50000 -type random\n./gen -n 50000 -type permutation\n./gen -n 50000 -type reverse\n./gen -n 50000 -type single_duplicate\n./gen -n 50000 -type single_missing\n\n./gen -n 100000 -type random\n./gen -n 100000 -type permutation\n./gen -n 100000 -type few_duplicates\n./gen -n 100000 -type missing_numbers\n\n./gen -n 200000 -type random\n./gen -n 200000 -type permutation\n./gen -n 200000 -type reverse\n./gen -n 200000 -type all_same\n./gen -n 200000 -type maximal_duplicates\n\n./gen -n 199999 -type single_duplicate\n./gen -n 199998 -type single_missing\n\n./gen -n 99999 -type maximal_duplicates\n./gen -n 99999 -type few_duplicates\n./gen -n 99999 -type missing_numbers\n\n./gen -n 1 -type all_same\n./gen -n 1 -type permutation\n\n./gen -n 200000 -type single_duplicate\n./gen -n 200000 -type single_missing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:00.835903",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "864/E",
      "title": "E. Fire",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of items in Polycarp's house.Each of the following n lines contains three integers ti, di, pi (1 ≤ ti ≤ 20, 1 ≤ di ≤ 2 000, 1 ≤ pi ≤ 20) — the time needed to save the item i, the time after which the item i will burn completely and the value of item i.",
      "output_spec": "OutputIn the first line print the maximum possible total value of the set of saved items. In the second line print one integer m — the number of items in the desired set. In the third line print m distinct integers — numbers of the saved items in the order Polycarp saves them. Items are 1-indexed in the same order in which they appear in the input. If there are several answers, print any of them.",
      "sample_tests": "ExamplesInputCopy33 7 42 6 53 7 6OutputCopy1122 3 InputCopy25 6 13 3 5OutputCopy111",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of items in Polycarp's house.Each of the following n lines contains three integers ti, di, pi (1 ≤ ti ≤ 20, 1 ≤ di ≤ 2 000, 1 ≤ pi ≤ 20) — the time needed to save the item i, the time after which the item i will burn completely and the value of item i.\n\nOutputIn the first line print the maximum possible total value of the set of saved items. In the second line print one integer m — the number of items in the desired set. In the third line print m distinct integers — numbers of the saved items in the order Polycarp saves them. Items are 1-indexed in the same order in which they appear in the input. If there are several answers, print any of them.\n\nInputCopy33 7 42 6 53 7 6OutputCopy1122 3 InputCopy25 6 13 3 5OutputCopy111\n\nInputCopy33 7 42 6 53 7 6\n\nOutputCopy1122 3\n\nInputCopy25 6 13 3 5\n\nOutputCopy111\n\nNoteIn the first example Polycarp will have time to save any two items, but in order to maximize the total value of the saved items, he must save the second and the third item. For example, he can firstly save the third item in 3 seconds, and then save the second item in another 2 seconds. Thus, the total value of the saved items will be 6 + 5 = 11.In the second example Polycarp can save only the first item, since even if he immediately starts saving the second item, he can save it in 3 seconds, but this item will already be completely burned by this time.",
      "solutions": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #436 (Div. 2). It'll be held on Monday, September 25 on 10:35 UTC and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2017/2018 year in city Saratov. They were prepared by Perforator, MikeMirzayanov and fcspartakm. Many thanks to the testers: sdya и BledDest, and coordinators KAN and vintage_Vlad_Makeev.It will be a little unusual round — you will be given six problems and two hours to solve them.Good luck and have fun!Congratulations to winners!Div. 2: zjt_ioi_2019_ak AngusRitossa Jha_The_ME_Coder cxh007 Alexxx Div. 1: Shik dreamoon_love_AA black_horse2014 orbitingflea KassiJulgus Analysis is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54744",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 808
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*E"
          },
          "content_length": 4846
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces",
          "content": "864A - Fair GameThis problem has many different solutions. Let's consider one of them.At first sort all numbers in non-descending order. Then the first n / 2 numbers must be equal to each other, the following n / 2 numbers must be equal to each other, and the number from the first half must be different from the number from the second half. So, if all conditions: a[1] = a[n / 2] a[n / 2 + 1] = a[n] a[1] ≠ a[n] are met after sorting, the answer is «YES». Vasya must choose before the game number a[1] and Petya — a[n] (or vice versa). If at least one from the described conditions is failed, the answer is «NO». 864B - Polycarp and LettersLet's solve the given problem in the following way. We will iterate through the letters in the string in order from left to right.If we are in position pos and the next letter is uppercase we skip it. In the other case, we need to create set and put letter spos in it. After that we iterate through string to the right until we do not met uppercase letter or until the string does not ended. We put in set each new lowercase letter. After we met uppercase letter (let position of this letter is p), or string is ended, we update the answer with the number of elements in set, and repeat described algorithm starting from position p. 864C - BusIf the bus can not reach the first gas station (i.e. b < f) print -1.In the other case, the bus will reach the first gas station with b - f liters in the gasoline tank. Then we need to iterate through journeys from 1 to k and calculate a value need — how many liters of the gasoline needed to bus reach the next gas station. If need more than b — print -1, because it means that the bus can not reach the next gas station even with full gasoline tank. If need more than current level of gasoline in the tank the bus needs to refuel. In the other case, refuel is not necessary. After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank. 864D - Make a Permutation!We will use an array cnt where we will store how many times the numbers from 1 to n met in the given array a. Put all numbers that never occur in the array a in a vector need — we must add this numbers in the array a to make a permutation.We will add numbers from need in ascending order because we want to get lexicographically minimal permutation. Let pos is a pointer on the current number needpos which we need to add on the current move. Initially, pos = 0.We will iterate through the array a. Let the current number equals to ai. If cntai = 1, we move to the next number in the array. If we added not all numbers from need, and ai > needpos or there already was ai on the prefix of the array (to check it we can use, for example, boolean array), then we put needpos in the current position, decrease cntai on one, increase pos and answer on one. If we do not change anything on that step we mark that ai already was on the prefix of the array. After that we move to the next number in array a. 864E - FireIf Polycarp will save two items, it is more profitable to first save the one whose d parameter is less. So, you can sort items by the parameter d.Let dpi, j be the maximum total value of items Polycarp can save by checking first i - 1 items in j seconds. Here are two types of transitions. Polycarp can either save current item or skip it: dpi + 1, j + ti = max(dpi + 1, j + ti, dpi, j + pi), if j + ti < di dpi + 1, j = max(dpi + 1, j, dpi, j) To restore the sequence of items Polycarp can save you can remember for each pair (i, j) whether you took a thing with the number i - 1 when updating the value dpi, j.Overall complexity: O(n·max1 ≤ i ≤ ndi). 864F - Cities ExcursionsThere is a direct graph. For each query, you need to find the kj-th vertex in the lexicographically minimal path from sj to tj.First group the queries on the vertex tj and find all vertices from which the vertex tj is achievable. For this you can invert all the arcs and run dfs from the vertex tj.Now consider the query (sj, tj). For this query, you need to find the lexicographically minimal path from sj to tj. If the vertex tj is not achievable from sj, then the answer is '-1'. Otherwise, in the lexicographically minimal path p from sj to tj the vertex pi (i > 1) is the minimal vertex from vertices u such that there exists an arc (pi - 1, u) and tj is achievable from u.Thus, we can build a new graph consisting of arcs satisfying the previous condition. Let us invert the arcs in this graph. Consider the vertices achievable from tj in this graph. They form an outgoing tree. Only for these vertices there is a lexicographically minimal path to tj. The lexicographically minimal path from the vertex sj to the vertex tj is equal to the inverted path from tj to sj in this tree.So, we can use binary climb to get the k-th vertex on this path.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 864\\s*E"
          },
          "content_length": 4846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 1",
          "code": "**It will be a little unusual round** — you will be given six problems and two hours to solve them",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 2",
          "code": "It will be a little unusual round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 3",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 4",
          "code": "5\n1 2000 1\n1 2000 4\n1 2 19\n1 4 18\n1 3 17\n\nAns:\n59\n5\n3 5 4 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 5",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 7",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 8",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 9",
          "code": "starting node",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 10",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 11",
          "code": "7 7 5\n1 2\n2 3\n1 3\n3 4\n4 5\n5 3\n4 6\n1 4 2 // 2\n2 6 1 // -1\n1 7 3 // -1\n1 3 2 // 2\n1 3 5 // -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 12",
          "code": "query(1, 4, 2) == 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 13",
          "code": "1-2-3-4 > 1-2-3-1-2-3-4 > ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 14",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 15",
          "code": "3 2 1\n1 2\n1 3\n1 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 16",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 17",
          "code": "7 7 1\n3 4\n4 5\n5 1\n5 2\n1 6\n6 1\n2 7\n3 7 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 18",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 19",
          "code": "7\n6 1 1 6 1 1 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 20",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 21",
          "code": "5\n2 1 3 5 4 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 22",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div. 2) - Codeforces - Code 23",
          "code": "5\n2 1 3 4 5 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54744",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 1",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 2",
          "code": "// read n\nConsole.ReadLine();\n// read string s\nstring a=Console.ReadLine();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 3",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #436 (Div.2) Editorial - Codeforces - Code 4",
          "code": "3\n20 21 20\n3 6 1\n4 8 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int ti = inf.readInt(1, 20, \"ti\");\n        inf.readSpace();\n        int di = inf.readInt(1, 2000, \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 20, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int ti = inf.readInt(1, 20, \"ti\");\n        inf.readSpace();\n        int di = inf.readInt(1, 2000, \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 20, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int ti = inf.readInt(1, 20, \"ti\");\n        inf.readSpace();\n        int di = inf.readInt(1, 2000, \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 20, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> ti, di, pi;\n\nlong long readAns(InStream &stream) {\n    long long total_value_output = stream.readLong(0, LLONG_MAX, \"total value\");\n    int m = stream.readInt(0, n, \"number of items\");\n    vector<int> items(m);\n    for (int i = 0; i < m; ++i) {\n        items[i] = stream.readInt(1, n, format(\"items[%d]\", i + 1).c_str());\n    }\n    set<int> item_set(items.begin(), items.end());\n    if ((int)item_set.size() != m) {\n        stream.quitf(_wa, \"Items are not distinct\");\n    }\n    int time = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = items[i] - 1;\n        time += ti[idx];\n        if (time > di[idx]) {\n            stream.quitf(_wa, \"Item %d cannot be saved before it burns\", items[i]);\n        }\n    }\n    long long total_value = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = items[i] - 1;\n        total_value += pi[idx];\n    }\n    if (total_value != total_value_output) {\n        stream.quitf(_wa, \"Computed total value %lld does not match the output total value %lld\", total_value, total_value_output);\n    }\n    return total_value;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100, \"n\");\n    ti.resize(n);\n    di.resize(n);\n    pi.resize(n);\n    for (int i = 0; i < n; ++i) {\n        ti[i] = inf.readInt(1, 20, format(\"ti[%d]\", i + 1).c_str());\n        di[i] = inf.readInt(1, 2000, format(\"di[%d]\", i + 1).c_str());\n        pi[i] = inf.readInt(1, 20, format(\"pi[%d]\", i + 1).c_str());\n    }\n\n    long long jans = readAns(ans);\n    long long pans = readAns(ouf);\n\n    if (pans > jans) {\n        quitf(_fail, \"Participant's total value %lld is greater than jury's %lld\", pans, jans);\n    } else if (pans == jans) {\n        quitf(_ok, \"Correct answer with total value %lld\", pans);\n    } else {\n        quitf(_wa, \"Participant's total value %lld is less than jury's %lld\", pans, jans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, 20);\n            int d = rnd.next(t + 1, 2000);\n            int p = rnd.next(1, 20);\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"cannot_save\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, 20);\n            int d = rnd.next(1, t);\n            int p = rnd.next(1, 20);\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"tight_schedule\") {\n        vector<int> t(n);\n        int sum_t = 0;\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 20);\n            sum_t += t[i];\n        }\n        while (sum_t > 2000) {\n            sum_t = 0;\n            for(int i = 0; i < n; ++i) {\n                t[i] = rnd.next(1, 20);\n                sum_t += t[i];\n            }\n        }\n        int min_d = sum_t;\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int d = min_d;\n            int p = rnd.next(1, 20);\n            printf(\"%d %d %d\\n\", t[i], d, p);\n        }\n    }\n    else if (type == \"same_deadline\") {\n        printf(\"%d\\n\", n);\n        int D = rnd.next(1, 2000);\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, min(20, D - 1));\n            int p = rnd.next(1, 20);\n            int d = D;\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"anti_greedy\") {\n        vector<tuple<int,int,int>> items;\n        int k = n / 2;\n        for (int i = 0; i < k; ++i) {\n            int t = rnd.next(1, 10);\n            int d = t + rnd.next(0, 5);\n            int p = rnd.next(15, 20);\n            items.push_back(make_tuple(t, d, p));\n        }\n        for (int i = k; i < n; ++i) {\n            int t = rnd.next(1, 10);\n            int d = rnd.next(50, 2000);\n            int p = rnd.next(1, 5);\n            items.push_back(make_tuple(t, d, p));\n        }\n        shuffle(items.begin(), items.end());\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int t,d,p;\n            tie(t,d,p) = items[i];\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"max_values\") {\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"20 2000 20\\n\");\n        }\n    }\n    else if (type == \"min_values\") {\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"1 2 1\\n\");\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, 20);\n            int d = rnd.next(t + 1, 2000);\n            int p = rnd.next(1, 20);\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"cannot_save\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, 20);\n            int d = rnd.next(1, t);\n            int p = rnd.next(1, 20);\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"tight_schedule\") {\n        vector<int> t(n);\n        int sum_t = 0;\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 20);\n            sum_t += t[i];\n        }\n        while (sum_t > 2000) {\n            sum_t = 0;\n            for(int i = 0; i < n; ++i) {\n                t[i] = rnd.next(1, 20);\n                sum_t += t[i];\n            }\n        }\n        int min_d = sum_t;\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int d = min_d;\n            int p = rnd.next(1, 20);\n            printf(\"%d %d %d\\n\", t[i], d, p);\n        }\n    }\n    else if (type == \"same_deadline\") {\n        printf(\"%d\\n\", n);\n        int D = rnd.next(1, 2000);\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, min(20, D - 1));\n            int p = rnd.next(1, 20);\n            int d = D;\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"anti_greedy\") {\n        vector<tuple<int,int,int>> items;\n        int k = n / 2;\n        for (int i = 0; i < k; ++i) {\n            int t = rnd.next(1, 10);\n            int d = t + rnd.next(0, 5);\n            int p = rnd.next(15, 20);\n            items.push_back(make_tuple(t, d, p));\n        }\n        for (int i = k; i < n; ++i) {\n            int t = rnd.next(1, 10);\n            int d = rnd.next(50, 2000);\n            int p = rnd.next(1, 5);\n            items.push_back(make_tuple(t, d, p));\n        }\n        shuffle(items.begin(), items.end());\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int t,d,p;\n            tie(t,d,p) = items[i];\n            printf(\"%d %d %d\\n\", t, d, p);\n        }\n    }\n    else if (type == \"max_values\") {\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"20 2000 20\\n\");\n        }\n    }\n    else if (type == \"min_values\") {\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"1 2 1\\n\");\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type cannot_save\n./gen -n 1 -type tight_schedule\n./gen -n 1 -type same_deadline\n./gen -n 1 -type anti_greedy\n./gen -n 1 -type max_values\n./gen -n 1 -type min_values\n\n./gen -n 10 -type random\n./gen -n 10 -type cannot_save\n./gen -n 10 -type tight_schedule\n./gen -n 10 -type same_deadline\n./gen -n 10 -type anti_greedy\n./gen -n 10 -type max_values\n./gen -n 10 -type min_values\n\n./gen -n 50 -type random\n./gen -n 50 -type cannot_save\n./gen -n 50 -type tight_schedule\n./gen -n 50 -type same_deadline\n./gen -n 50 -type anti_greedy\n./gen -n 50 -type max_values\n./gen -n 50 -type min_values\n\n./gen -n 100 -type random\n./gen -n 100 -type cannot_save\n./gen -n 100 -type tight_schedule\n./gen -n 100 -type same_deadline\n./gen -n 100 -type anti_greedy\n./gen -n 100 -type max_values\n./gen -n 100 -type min_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:02.575030",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "864/F",
      "title": "Problem 864/F",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 400000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"No self-loops allowed, but found xi=%d, yi=%d at edge %d\", xi, yi, i + 1);\n\n        pair<int, int> edge = make_pair(xi, yi);\n        ensuref(edges.count(edge) == 0, \"Multiple edges from xi=%d to yi=%d at edge %d\", xi, yi, i + 1);\n        edges.insert(edge);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int sj = inf.readInt(1, n, \"sj\");\n        inf.readSpace();\n        int tj = inf.readInt(1, n, \"tj\");\n        inf.readSpace();\n        int kj = inf.readInt(1, 3000, \"kj\");\n        inf.readEoln();\n\n        ensuref(sj != tj, \"In query %d, sj (%d) == tj (%d)\", i + 1, sj, tj);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 400000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"No self-loops allowed, but found xi=%d, yi=%d at edge %d\", xi, yi, i + 1);\n\n        pair<int, int> edge = make_pair(xi, yi);\n        ensuref(edges.count(edge) == 0, \"Multiple edges from xi=%d to yi=%d at edge %d\", xi, yi, i + 1);\n        edges.insert(edge);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int sj = inf.readInt(1, n, \"sj\");\n        inf.readSpace();\n        int tj = inf.readInt(1, n, \"tj\");\n        inf.readSpace();\n        int kj = inf.readInt(1, 3000, \"kj\");\n        inf.readEoln();\n\n        ensuref(sj != tj, \"In query %d, sj (%d) == tj (%d)\", i + 1, sj, tj);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 3000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 400000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"No self-loops allowed, but found xi=%d, yi=%d at edge %d\", xi, yi, i + 1);\n\n        pair<int, int> edge = make_pair(xi, yi);\n        ensuref(edges.count(edge) == 0, \"Multiple edges from xi=%d to yi=%d at edge %d\", xi, yi, i + 1);\n        edges.insert(edge);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int sj = inf.readInt(1, n, \"sj\");\n        inf.readSpace();\n        int tj = inf.readInt(1, n, \"tj\");\n        inf.readSpace();\n        int kj = inf.readInt(1, 3000, \"kj\");\n        inf.readEoln();\n\n        ensuref(sj != tj, \"In query %d, sj (%d) == tj (%d)\", i + 1, sj, tj);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_NODES = 3000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // Default value -1; will adjust later if needed\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate input parameters\n    ensure(2 <= n && n <= 3000);\n    ensure(1 <= q && q <= 400000);\n    if (m == -1) {\n        m = min(n * (n - 1), 3000);\n    }\n    m = min(m, 3000); // m cannot exceed 3000\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set;\n\n    if (type == \"random\") {\n        // Generate m random edges without duplicates and self-loops\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue; // Avoid self-loops\n            if (edge_set.count({x, y})) continue; // Avoid duplicates\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"chain\") {\n        // Create a chain from 1 to n\n        for (int i = 1; i < n && (int)edges.size() < m; i++) {\n            edges.push_back({i, i + 1});\n            edge_set.insert({i, i + 1});\n        }\n        // Add additional random edges if m > n - 1\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n - 1);\n            int y = rnd.next(x + 1, n);\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"star\") {\n        // Create a star graph from node 1\n        for (int i = 2; i <= n && (int)edges.size() < m; i++) {\n            edges.push_back({1, i});\n            edge_set.insert({1, i});\n        }\n        // Add more random edges if needed\n        while ((int)edges.size() < m) {\n            int x = rnd.next(2, n);\n            int y = rnd.next(2, n);\n            if (x == y) continue;\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"scc\") {\n        // Create a strongly connected component by forming a cycle\n        for (int i = 1; i <= n; i++) {\n            int j = i % n + 1;\n            edges.push_back({i, j});\n            edge_set.insert({i, j});\n        }\n        // Add additional random edges if needed\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue;\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"dag\") {\n        // Create a Directed Acyclic Graph (DAG)\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n && (int)edges.size() < m; i++) {\n            int from = nodes[i];\n            for (int j = i + 1; j < n && (int)edges.size() < m; j++) {\n                int to = nodes[j];\n                if (edge_set.count({from, to})) continue;\n                edges.push_back({from, to});\n                edge_set.insert({from, to});\n            }\n        }\n    } else {\n        // Default to random\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue;\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    }\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, (int)edges.size(), q);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate queries\n    for (int i = 0; i < q; i++) {\n        int sj, tj, kj;\n        int query_type = rnd.next(1, 5);\n        if (query_type == 1) {\n            // Random s, t, k\n            do {\n                sj = rnd.next(1, n);\n                tj = rnd.next(1, n);\n            } while (sj == tj);\n            kj = rnd.next(1, 3000);\n        } else if (query_type == 2) {\n            // Likely connected s and t\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = rnd.next(1, 3000);\n        } else if (query_type == 3) {\n            // Possibly disconnected s and t\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = rnd.next(1, 3000);\n        } else if (query_type == 4) {\n            // kj too large\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = 3000;\n        } else {\n            // Random query\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = rnd.next(1, 3000);\n        }\n        printf(\"%d %d %d\\n\", sj, tj, kj);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_NODES = 3000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // Default value -1; will adjust later if needed\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate input parameters\n    ensure(2 <= n && n <= 3000);\n    ensure(1 <= q && q <= 400000);\n    if (m == -1) {\n        m = min(n * (n - 1), 3000);\n    }\n    m = min(m, 3000); // m cannot exceed 3000\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set;\n\n    if (type == \"random\") {\n        // Generate m random edges without duplicates and self-loops\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue; // Avoid self-loops\n            if (edge_set.count({x, y})) continue; // Avoid duplicates\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"chain\") {\n        // Create a chain from 1 to n\n        for (int i = 1; i < n && (int)edges.size() < m; i++) {\n            edges.push_back({i, i + 1});\n            edge_set.insert({i, i + 1});\n        }\n        // Add additional random edges if m > n - 1\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n - 1);\n            int y = rnd.next(x + 1, n);\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"star\") {\n        // Create a star graph from node 1\n        for (int i = 2; i <= n && (int)edges.size() < m; i++) {\n            edges.push_back({1, i});\n            edge_set.insert({1, i});\n        }\n        // Add more random edges if needed\n        while ((int)edges.size() < m) {\n            int x = rnd.next(2, n);\n            int y = rnd.next(2, n);\n            if (x == y) continue;\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"scc\") {\n        // Create a strongly connected component by forming a cycle\n        for (int i = 1; i <= n; i++) {\n            int j = i % n + 1;\n            edges.push_back({i, j});\n            edge_set.insert({i, j});\n        }\n        // Add additional random edges if needed\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue;\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    } else if (type == \"dag\") {\n        // Create a Directed Acyclic Graph (DAG)\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n && (int)edges.size() < m; i++) {\n            int from = nodes[i];\n            for (int j = i + 1; j < n && (int)edges.size() < m; j++) {\n                int to = nodes[j];\n                if (edge_set.count({from, to})) continue;\n                edges.push_back({from, to});\n                edge_set.insert({from, to});\n            }\n        }\n    } else {\n        // Default to random\n        while ((int)edges.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue;\n            if (edge_set.count({x, y})) continue;\n            edges.push_back({x, y});\n            edge_set.insert({x, y});\n        }\n    }\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, (int)edges.size(), q);\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate queries\n    for (int i = 0; i < q; i++) {\n        int sj, tj, kj;\n        int query_type = rnd.next(1, 5);\n        if (query_type == 1) {\n            // Random s, t, k\n            do {\n                sj = rnd.next(1, n);\n                tj = rnd.next(1, n);\n            } while (sj == tj);\n            kj = rnd.next(1, 3000);\n        } else if (query_type == 2) {\n            // Likely connected s and t\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = rnd.next(1, 3000);\n        } else if (query_type == 3) {\n            // Possibly disconnected s and t\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = rnd.next(1, 3000);\n        } else if (query_type == 4) {\n            // kj too large\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = 3000;\n        } else {\n            // Random query\n            sj = rnd.next(1, n);\n            tj = rnd.next(1, n);\n            while (sj == tj) {\n                tj = rnd.next(1, n);\n            }\n            kj = rnd.next(1, 3000);\n        }\n        printf(\"%d %d %d\\n\", sj, tj, kj);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -q 1 -type chain\n./gen -n 2 -m 1 -q 1 -type random\n\n./gen -n 10 -m 9 -q 10 -type chain\n./gen -n 10 -m 15 -q 20 -type dag\n./gen -n 10 -m 15 -q 30 -type random\n\n./gen -n 50 -m 100 -q 100 -type star\n./gen -n 50 -m 200 -q 200 -type scc\n./gen -n 50 -m 200 -q 200 -type random\n\n./gen -n 100 -m 300 -q 500 -type dag\n./gen -n 100 -m 300 -q 500 -type random\n\n./gen -n 3000 -m 3000 -q 1000 -type chain\n./gen -n 3000 -m 3000 -q 1000 -type scc\n./gen -n 3000 -m 3000 -q 1000 -type star\n\n./gen -n 3000 -m 3000 -q 100000 -type random\n./gen -n 3000 -m 3000 -q 400000 -type random\n\n./gen -n 3000 -m 3000 -q 400000 -type dag\n./gen -n 3000 -m 3000 -q 400000 -type scc\n\n./gen -n 1000 -m 2000 -q 300000 -type random\n\n./gen -n 3000 -m 3000 -q 400000 -type chain\n\n./gen -n 2 -m 0 -q 100 -type random\n\n./gen -n 3000 -m 1000 -q 400000 -type random\n\n./gen -n 3000 -m 3000 -q 400000 -type star\n\n./gen -n 100 -m 500 -q 50000 -type random\n./gen -n 100 -m 500 -q 50000 -type scc\n\n./gen -n 200 -m 1000 -q 100000 -type dag\n\n./gen -n 50 -m 100 -q 50000 -type random\n\n./gen -n 3000 -m 3000 -q 400000 -type random\n\n./gen -n 1000 -m 3000 -q 400000 -type random\n\n./gen -n 1000 -m 3000 -q 400000 -type dag\n\n./gen -n 3000 -m 0 -q 400000 -type random\n\n./gen -n 3000 -m 3000 -q 10000 -type chain\n\n./gen -n 3000 -m 3000 -q 50000 -type scc\n\n./gen -n 3000 -m 3000 -q 400000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:04.952298",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/A",
      "title": "A. Save the problem!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will consist of a single integer A (1 ≤ A ≤ 105), the desired number of ways.",
      "output_spec": "OutputIn the first line print integers N and M (1 ≤ N ≤ 106, 1 ≤ M ≤ 10), the amount of change to be made, and the number of denominations, respectively.Then print M integers D1, D2, ..., DM (1 ≤ Di ≤ 106), the denominations of the coins. All denominations must be distinct: for any i ≠ j we must have Di ≠ Dj.If there are multiple tests, print any of them. You can print denominations in atbitrary order.",
      "sample_tests": "ExamplesInputCopy18OutputCopy30 41 5 10 25InputCopy3OutputCopy20 25 2InputCopy314OutputCopy183 46 5 2 139",
      "description": "A. Save the problem!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will consist of a single integer A (1 ≤ A ≤ 105), the desired number of ways.\n\nOutputIn the first line print integers N and M (1 ≤ N ≤ 106, 1 ≤ M ≤ 10), the amount of change to be made, and the number of denominations, respectively.Then print M integers D1, D2, ..., DM (1 ≤ Di ≤ 106), the denominations of the coins. All denominations must be distinct: for any i ≠ j we must have Di ≠ Dj.If there are multiple tests, print any of them. You can print denominations in atbitrary order.\n\nInputCopy18OutputCopy30 41 5 10 25InputCopy3OutputCopy20 25 2InputCopy314OutputCopy183 46 5 2 139\n\nInputCopy18\n\nOutputCopy30 41 5 10 25\n\nOutputCopy20 25 2\n\nInputCopy314\n\nOutputCopy183 46 5 2 139",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*A"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(1, 100000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(1, 100000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(1, 100000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read A from input file (inf)\n    int A = inf.readInt(1, 100000, \"A\");\n    \n    // Read N and M from contestant's output (ouf)\n    int N = ouf.readInt(1, 1000000, \"N\");\n    ouf.readSpace();\n    int M = ouf.readInt(1, 10, \"M\");\n    ouf.readEoln();\n    \n    vector<int> D(M);\n    set<int> D_set;\n    for(int i = 0; i < M; i++) {\n        D[i] = ouf.readInt(1, 1000000, format(\"D[%d]\", i+1).c_str());\n        if (D_set.count(D[i])) {\n            ouf.quitf(_wa, \"Denomination D[%d]=%d is not unique\", i+1, D[i]);\n        }\n        D_set.insert(D[i]);\n        if (i != M - 1) {\n            ouf.readSpace();\n        }\n    }\n    ouf.readEoln();\n    \n    // Compute number of ways to make change for amount N using denominations D\n    vector<long long> dp(N + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < M; i++) {\n        int coin = D[i];\n        for (int j = coin; j <= N; j++) {\n            dp[j] += dp[j - coin];\n            // Cap dp[j] to prevent overflow\n            if (dp[j] > 1e18) {\n                dp[j] = 1e18;\n            }\n        }\n    }\n    long long num_ways = dp[N];\n    if (num_ways != A) {\n        quitf(_wa, \"Number of ways to make change for amount %d is %lld, expected %d\", N, num_ways, A);\n    } else {\n        quitf(_ok, \"Correct, number of ways is %lld\", num_ways);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  According to the validator's error message:\n    \"FAIL Expected EOLN (stdin, line 1)\"\n  it suggests that the program reading the input expects exactly ONE integer on line #1,\n  followed by a newline (EOLN). Then the file should end immediately on line #2 (EOF),\n  with no additional integers or lines.\n\n  Therefore, we only need to print a single integer A on line #1, followed by a newline,\n  and then end the program so line #2 is EOF.\n\n  We'll still parse the parameters:\n    -A (required or default 1) for the integer to print,\n    -type (optional), but it won't affect the output (the validator doesn't need it).\n*/\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Read the desired A from command-line arguments (default to 1)\n    int A = opt<int>(\"A\", 1);\n\n    // We can consume the \"type\" argument if it is passed, but ignore it in output:\n    string t = opt<string>(\"type\", \"unused\");\n\n    // Print exactly one integer, followed by a newline, then end the program.\n    cout << A << \"\\n\";\n\n    // No further output => line #2 is EOF.\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  According to the validator's error message:\n    \"FAIL Expected EOLN (stdin, line 1)\"\n  it suggests that the program reading the input expects exactly ONE integer on line #1,\n  followed by a newline (EOLN). Then the file should end immediately on line #2 (EOF),\n  with no additional integers or lines.\n\n  Therefore, we only need to print a single integer A on line #1, followed by a newline,\n  and then end the program so line #2 is EOF.\n\n  We'll still parse the parameters:\n    -A (required or default 1) for the integer to print,\n    -type (optional), but it won't affect the output (the validator doesn't need it).\n*/\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Read the desired A from command-line arguments (default to 1)\n    int A = opt<int>(\"A\", 1);\n\n    // We can consume the \"type\" argument if it is passed, but ignore it in output:\n    string t = opt<string>(\"type\", \"unused\");\n\n    // Print exactly one integer, followed by a newline, then end the program.\n    cout << A << \"\\n\";\n\n    // No further output => line #2 is EOF.\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are ~20 sample commands demonstrating how to run this generator.\n# Each will produce exactly ONE line containing a single integer and a newline, then EOF on line #2.\n\n./gen -A 1\n./gen -A 1 -type one\n./gen -A 1 -type two\n./gen -A 2\n./gen -A 2 -type one\n./gen -A 2 -type two\n./gen -A 10\n./gen -A 10 -type one\n./gen -A 18\n./gen -A 30\n./gen -A 42\n./gen -A 100 -type random\n./gen -A 314\n./gen -A 500\n./gen -A 999\n./gen -A 5000\n./gen -A 9999\n./gen -A 50000\n./gen -A 99999\n./gen -A 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:06.782230",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/B",
      "title": "B. Ordering Pizza",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain integers N and S (1 ≤ N ≤ 105, 1 ≤ S ≤ 105), the number of contestants and the number of slices per pizza, respectively. N lines follow.The i-th such line contains integers si, ai, and bi (1 ≤ si ≤ 105, 1 ≤ ai ≤ 105, 1 ≤ bi ≤ 105), the number of slices the i-th contestant will eat, the happiness they will gain from each type 1 slice they eat, and the happiness they will gain from each type 2 slice they eat, respectively.",
      "output_spec": "OutputPrint the maximum total happiness that can be achieved.",
      "sample_tests": "ExamplesInputCopy3 123 5 74 6 75 9 5OutputCopy84InputCopy6 107 4 75 8 812 5 86 11 63 3 75 9 6OutputCopy314",
      "description": "B. Ordering Pizza\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will contain integers N and S (1 ≤ N ≤ 105, 1 ≤ S ≤ 105), the number of contestants and the number of slices per pizza, respectively. N lines follow.The i-th such line contains integers si, ai, and bi (1 ≤ si ≤ 105, 1 ≤ ai ≤ 105, 1 ≤ bi ≤ 105), the number of slices the i-th contestant will eat, the happiness they will gain from each type 1 slice they eat, and the happiness they will gain from each type 2 slice they eat, respectively.\n\nOutputPrint the maximum total happiness that can be achieved.\n\nInputCopy3 123 5 74 6 75 9 5OutputCopy84InputCopy6 107 4 75 8 812 5 86 11 63 3 75 9 6OutputCopy314\n\nInputCopy3 123 5 74 6 75 9 5\n\nOutputCopy84\n\nInputCopy6 107 4 75 8 812 5 86 11 63 3 75 9 6\n\nOutputCopy314\n\nNoteIn the first example, you only need to buy one pizza. If you buy a type 1 pizza, the total happiness will be 3·5 + 4·6 + 5·9 = 84, and if you buy a type 2 pizza, the total happiness will be 3·7 + 4·7 + 5·5 = 74.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*B"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int S = inf.readInt(1, 100000, \"S\");\n    inf.readEoln();\n    for (int i = 0; i < N; ++i) {\n        int si = inf.readInt(1, 100000, \"si\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 100000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100000, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int S = inf.readInt(1, 100000, \"S\");\n    inf.readEoln();\n    for (int i = 0; i < N; ++i) {\n        int si = inf.readInt(1, 100000, \"si\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 100000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100000, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int S = inf.readInt(1, 100000, \"S\");\n    inf.readEoln();\n    for (int i = 0; i < N; ++i) {\n        int si = inf.readInt(1, 100000, \"si\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 100000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100000, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of contestants\n    int s = opt<int>(\"s\"); // Slices per pizza\n    string type = opt<string>(\"type\", \"random\"); // Default type is random\n\n    if (type == \"random\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"max_values\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = 100000;\n            int ai = 100000;\n            int bi = 100000;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"min_values\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = 1;\n            int ai = 1;\n            int bi = 1;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"ai_greater_bi\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int bi = rnd.next(1, 50000);\n            int ai = rnd.next(bi + 1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"bi_greater_ai\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int ai = rnd.next(1, 50000);\n            int bi = rnd.next(ai + 1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"ai_equal_bi\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int val = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, val, val);\n        }\n    }\n    else if (type == \"equal_si\") {\n        printf(\"%d %d\\n\", n, s);\n        int fixed_si = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", fixed_si, ai, bi);\n        }\n    }\n    else if (type == \"total_slices_exact\") {\n        printf(\"%d %d\\n\", n, s);\n        vector<int> si(n);\n        int64_t total_slices = 0;\n        for(int i = 0; i < n; ++i) {\n            si[i] = rnd.next(1, 100000);\n            total_slices += si[i];\n        }\n        int rem = total_slices % s;\n        if (rem != 0) {\n            int delta = rem;\n            for (int i = 0; i < n; ++i) {\n                if (si[i] - delta >= 1) {\n                    si[i] -= delta;\n                    total_slices -= delta;\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si[i], ai, bi);\n        }\n    }\n    else if (type == \"total_slices_greater\") {\n        printf(\"%d %d\\n\", n, s);\n        vector<int> si(n);\n        int64_t total_slices = 0;\n        for(int i = 0; i < n; ++i) {\n            si[i] = rnd.next(1, 100000);\n            total_slices += si[i];\n        }\n        int rem = total_slices % s;\n        int delta = s - rem - 1; // Make remainder s - 1\n        for (int i = 0; i < n; ++i) {\n            if (si[i] + delta <= 100000) {\n                si[i] += delta;\n                total_slices += delta;\n                break;\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si[i], ai, bi);\n        }\n    }\n    else {\n        // default random\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of contestants\n    int s = opt<int>(\"s\"); // Slices per pizza\n    string type = opt<string>(\"type\", \"random\"); // Default type is random\n\n    if (type == \"random\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"max_values\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = 100000;\n            int ai = 100000;\n            int bi = 100000;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"min_values\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = 1;\n            int ai = 1;\n            int bi = 1;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"ai_greater_bi\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int bi = rnd.next(1, 50000);\n            int ai = rnd.next(bi + 1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"bi_greater_ai\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int ai = rnd.next(1, 50000);\n            int bi = rnd.next(ai + 1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    else if (type == \"ai_equal_bi\") {\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int val = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, val, val);\n        }\n    }\n    else if (type == \"equal_si\") {\n        printf(\"%d %d\\n\", n, s);\n        int fixed_si = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", fixed_si, ai, bi);\n        }\n    }\n    else if (type == \"total_slices_exact\") {\n        printf(\"%d %d\\n\", n, s);\n        vector<int> si(n);\n        int64_t total_slices = 0;\n        for(int i = 0; i < n; ++i) {\n            si[i] = rnd.next(1, 100000);\n            total_slices += si[i];\n        }\n        int rem = total_slices % s;\n        if (rem != 0) {\n            int delta = rem;\n            for (int i = 0; i < n; ++i) {\n                if (si[i] - delta >= 1) {\n                    si[i] -= delta;\n                    total_slices -= delta;\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si[i], ai, bi);\n        }\n    }\n    else if (type == \"total_slices_greater\") {\n        printf(\"%d %d\\n\", n, s);\n        vector<int> si(n);\n        int64_t total_slices = 0;\n        for(int i = 0; i < n; ++i) {\n            si[i] = rnd.next(1, 100000);\n            total_slices += si[i];\n        }\n        int rem = total_slices % s;\n        int delta = s - rem - 1; // Make remainder s - 1\n        for (int i = 0; i < n; ++i) {\n            if (si[i] + delta <= 100000) {\n                si[i] += delta;\n                total_slices += delta;\n                break;\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si[i], ai, bi);\n        }\n    }\n    else {\n        // default random\n        printf(\"%d %d\\n\", n, s);\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, 100000);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -s 1 -type min_values\n./gen -n 1 -s 100000 -type min_values\n./gen -n 100000 -s 1 -type max_values\n./gen -n 100000 -s 100000 -type max_values\n./gen -n 100000 -s 100000 -type random\n./gen -n 1000 -s 1000 -type ai_greater_bi\n./gen -n 1000 -s 1000 -type bi_greater_ai\n./gen -n 1000 -s 1000 -type ai_equal_bi\n./gen -n 100000 -s 10000 -type equal_si\n./gen -n 100000 -s 10000 -type total_slices_exact\n./gen -n 100000 -s 10000 -type total_slices_greater\n./gen -n 99999 -s 99999 -type ai_greater_bi\n./gen -n 99999 -s 99999 -type bi_greater_ai\n./gen -n 100000 -s 99999 -type min_values\n./gen -n 100000 -s 100000 -type max_values\n./gen -n 100000 -s 1 -type ai_equal_bi\n./gen -n 100000 -s 1 -type total_slices_exact\n./gen -n 50000 -s 100 -type random\n./gen -n 50000 -s 100 -type total_slices_exact\n./gen -n 20 -s 200 -type min_values\n./gen -n 100 -s 1000 -type ai_greater_bi\n./gen -n 100000 -s 50000 -type ai_greater_bi\n./gen -n 100000 -s 50000 -type bi_greater_ai\n./gen -n 100000 -s 50000 -type ai_equal_bi\n./gen -n 100000 -s 1000 -type equal_si\n./gen -n 100000 -s 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:08.583136",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/C",
      "title": "C. Пройди быстрее",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа N и R  — число уровней и число секунд, за которое вы хотите пройти игру, соответственно.Далее следуют N строк. Строка i содержит целые числа Fi, Si, Pi (1 ≤ Fi < Si ≤ 100, 80 ≤ Pi ≤ 99) — время быстрого прохождения уровня i, время медленного прохождения уровня i, и вероятность (в процентах) прохождения уровня i быстро.",
      "output_spec": "Выходные данныеВыведите математическое ожидание времени игры. Ваш ответ будет считаться правильным, если его абсолютная или относительная точность не превосходит 10 - 9.Формально, если ваш ответ равен a, а ответ жюри равен b, то ваш ответ будет считаться правильным, если .",
      "sample_tests": "ПримерыВходные данныеСкопировать1 82 8 81Выходные данныеСкопировать3.14Входные данныеСкопировать2 3020 30 803 9 85Выходные данныеСкопировать31.4Входные данныеСкопировать4 31963 79 8979 97 9175 87 8875 90 83Выходные данныеСкопировать314.159265358",
      "description": "C. Пройди быстрее\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа N и R  — число уровней и число секунд, за которое вы хотите пройти игру, соответственно.Далее следуют N строк. Строка i содержит целые числа Fi, Si, Pi (1 ≤ Fi < Si ≤ 100, 80 ≤ Pi ≤ 99) — время быстрого прохождения уровня i, время медленного прохождения уровня i, и вероятность (в процентах) прохождения уровня i быстро.\n\nВходные данные\n\nВыходные данныеВыведите математическое ожидание времени игры. Ваш ответ будет считаться правильным, если его абсолютная или относительная точность не превосходит 10 - 9.Формально, если ваш ответ равен a, а ответ жюри равен b, то ваш ответ будет считаться правильным, если .\n\nВыходные данные\n\nВходные данныеСкопировать1 82 8 81Выходные данныеСкопировать3.14Входные данныеСкопировать2 3020 30 803 9 85Выходные данныеСкопировать31.4Входные данныеСкопировать4 31963 79 8979 97 9175 87 8875 90 83Выходные данныеСкопировать314.159265358\n\nВходные данныеСкопировать1 82 8 81\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3.14\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3020 30 803 9 85\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31.4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 31963 79 8979 97 9175 87 8875 90 83\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать314.159265358\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере вам никогда не надо начинать сначала. С вероятностью 81% вы закончите игру за 2 секунды, и с вероятностью 19% — за 8 секунд. И то и другое вас устроит. Ожидаемое время игры равно 0.81·2 + 0.19·8 = 3.14.Во втором примере вы должны сбрасывать после первого уровня, если прошли его медленно. В среднем у вас будет 0.25 медленных попыток перед быстрой попыткой. Затем безразлично, закончите ли вы второй уровень быстро или медленно. Ожидаемое время равно 0.25·30 + 20 + 0.85·3 + 0.15·9 = 31.4.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*C"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readSpace();\n    int R = inf.readInt(1, 1000, \"R\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int Fi = inf.readInt(1, 100, \"Fi\");\n        inf.readSpace();\n        int Si = inf.readInt(1, 100, \"Si\");\n        ensuref(Fi < Si, \"Fi must be less than Si\");\n        inf.readSpace();\n        int Pi = inf.readInt(80, 99, \"Pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readSpace();\n    int R = inf.readInt(1, 1000, \"R\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int Fi = inf.readInt(1, 100, \"Fi\");\n        inf.readSpace();\n        int Si = inf.readInt(1, 100, \"Si\");\n        ensuref(Fi < Si, \"Fi must be less than Si\");\n        inf.readSpace();\n        int Pi = inf.readInt(80, 99, \"Pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 50, \"N\");\n    inf.readSpace();\n    int R = inf.readInt(1, 1000, \"R\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        int Fi = inf.readInt(1, 100, \"Fi\");\n        inf.readSpace();\n        int Si = inf.readInt(1, 100, \"Si\");\n        ensuref(Fi < Si, \"Fi must be less than Si\");\n        inf.readSpace();\n        int Pi = inf.readInt(80, 99, \"Pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Output N and R\n    printf(\"%d %d\\n\", n, r);\n    \n    // Generate per 'type'\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minFiSi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = 2;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxFiSi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 99;\n            int Si = 100;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minPi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxPi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"edgeReset\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = 100;\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"edgeNoReset\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 99;\n            int Si = 100;\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Output N and R\n    printf(\"%d %d\\n\", n, r);\n    \n    // Generate per 'type'\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minFiSi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = 2;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxFiSi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 99;\n            int Si = 100;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minPi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxPi\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"edgeReset\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = 100;\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"edgeNoReset\") {\n        for(int i = 0; i < n; ++i) {\n            int Fi = 99;\n            int Si = 100;\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -r 8 -type random\n./gen -n 1 -r 1 -type edgeReset\n./gen -n 1 -r 100 -type edgeNoReset\n\n./gen -n 2 -r 30 -type random\n./gen -n 2 -r 2 -type edgeReset\n./gen -n 2 -r 200 -type edgeNoReset\n\n./gen -n 4 -r 319 -type random\n./gen -n 4 -r 4 -type edgeReset\n./gen -n 4 -r 400 -type edgeNoReset\n\n./gen -n 10 -r 100 -type random\n./gen -n 10 -r 10 -type edgeReset\n./gen -n 10 -r 1000 -type edgeNoReset\n\n./gen -n 10 -r 10 -type minFiSi\n./gen -n 10 -r 1000 -type maxFiSi\n\n./gen -n 100 -r 10000 -type random\n./gen -n 100 -r 100 -type edgeReset\n./gen -n 100 -r 10000 -type edgeNoReset\n\n./gen -n 100 -r 10000 -type minPi\n./gen -n 100 -r 10000 -type maxPi\n\n./gen -n 1000 -r 100000 -type random\n./gen -n 1000 -r 1000 -type edgeReset\n./gen -n 1000 -r 100000 -type edgeNoReset\n\n./gen -n 10000 -r 1000000 -type random\n./gen -n 10000 -r 10000 -type edgeReset\n./gen -n 10000 -r 1000000 -type edgeNoReset\n\n./gen -n 10000 -r 1000000 -type minFiSi\n./gen -n 10000 -r 1000000 -type maxFiSi\n\n./gen -n 100000 -r 10000000 -type random\n./gen -n 100000 -r 100000 -type edgeReset\n./gen -n 100000 -r 10000000 -type edgeNoReset\n\n./gen -n 100000 -r 10000000 -type minPi\n./gen -n 100000 -r 10000000 -type maxPi\n\n# Extreme cases\n./gen -n 1 -r 1 -type minFiSi\n./gen -n 1 -r 2 -type maxFiSi\n\n./gen -n 100000 -r 100000000 -type edgeReset\n./gen -n 100000 -r 1000000000 -type edgeNoReset\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:10.879793",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/D",
      "title": "D. Buy Low Sell High",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput begins with an integer N (2 ≤ N ≤ 3·105), the number of days.Following this is a line with exactly N integers p1, p2, ..., pN (1 ≤ pi ≤ 106). The price of one share of stock on the i-th day is given by pi.",
      "output_spec": "OutputPrint the maximum amount of money you can end up with at the end of N days.",
      "sample_tests": "ExamplesInputCopy910 5 4 7 9 12 6 2 10OutputCopy20InputCopy203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4OutputCopy41",
      "description": "D. Buy Low Sell High\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput begins with an integer N (2 ≤ N ≤ 3·105), the number of days.Following this is a line with exactly N integers p1, p2, ..., pN (1 ≤ pi ≤ 106). The price of one share of stock on the i-th day is given by pi.\n\nOutputPrint the maximum amount of money you can end up with at the end of N days.\n\nInputCopy910 5 4 7 9 12 6 2 10OutputCopy20InputCopy203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4OutputCopy41\n\nInputCopy910 5 4 7 9 12 6 2 10\n\nOutputCopy20\n\nInputCopy203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4\n\nOutputCopy41\n\nNoteIn the first example, buy a share at 5, buy another at 4, sell one at 9 and another at 12. Then buy at 2 and sell at 10. The total profit is  - 5 - 4 + 9 + 12 - 2 + 10 = 20.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*D"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(2, 300000, \"N\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(N, 1, 1000000, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(2, 300000, \"N\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(N, 1, 1000000, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(2, 300000, \"N\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(N, 1, 1000000, \"p_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> prices(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1, 1000000 - n);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n, 1000000);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = start - i;\n        }\n    } else if (type == \"constant\") {\n        int p = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = p;\n        }\n    } else if (type == \"alternating\") {\n        int low = rnd.next(1, 500000);\n        int high = rnd.next(low + 1, 1000000);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = (i % 2 == 0) ? low : high;\n        }\n    } else if (type == \"peaks\") {\n        int p = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i) {\n            int delta = rnd.next(-1000, 1000);\n            p = max(1, min(1000000, p + delta));\n            prices[i] = p;\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            prices[i] = 1000000;\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            prices[i] = 1;\n        }\n    } else if (type == \"random_large_prices\"){\n        for(int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(999000, 1000000);\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", prices[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> prices(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1, 1000000 - n);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n, 1000000);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = start - i;\n        }\n    } else if (type == \"constant\") {\n        int p = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = p;\n        }\n    } else if (type == \"alternating\") {\n        int low = rnd.next(1, 500000);\n        int high = rnd.next(low + 1, 1000000);\n        for(int i = 0; i < n; ++i) {\n            prices[i] = (i % 2 == 0) ? low : high;\n        }\n    } else if (type == \"peaks\") {\n        int p = rnd.next(1, 1000000);\n        for(int i = 0; i < n; ++i) {\n            int delta = rnd.next(-1000, 1000);\n            p = max(1, min(1000000, p + delta));\n            prices[i] = p;\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            prices[i] = 1000000;\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            prices[i] = 1;\n        }\n    } else if (type == \"random_large_prices\"){\n        for(int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(999000, 1000000);\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", prices[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type constant\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n\n./gen -n 3 -type random\n\n./gen -n 10 -type constant\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type peaks\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type constant\n\n./gen -n 300000 -type random\n./gen -n 300000 -type increasing\n./gen -n 300000 -type decreasing\n./gen -n 300000 -type alternating\n\n./gen -n 300000 -type peaks\n./gen -n 300000 -type constant\n\n./gen -n 50000 -type max\n./gen -n 50000 -type min\n\n./gen -n 300000 -type random_large_prices\n\n./gen -n 2 -type max\n./gen -n 2 -type min\n\n./gen -n 300000 -type alternating\n./gen -n 300000 -type peaks\n\n./gen -n 299999 -type random\n./gen -n 2 -type peaks\n./gen -n 2 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:12.633971",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/E",
      "title": "E. Hex Dyslexia",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will contain a hexadecimal string S consisting only of digits 0 to 9 and lowercase English letters from a to f, with length at most 14. At least one of the characters is non-zero.",
      "output_spec": "OutputIf it is not possible, print \"NO\" (without quotes).Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct.",
      "sample_tests": "ExamplesInputCopyf1eOutputCopyNOInputCopy0f1eOutputCopy00f1InputCopy12d2cOutputCopy00314",
      "description": "E. Hex Dyslexia\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will contain a hexadecimal string S consisting only of digits 0 to 9 and lowercase English letters from a to f, with length at most 14. At least one of the characters is non-zero.\n\nOutputIf it is not possible, print \"NO\" (without quotes).Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct.\n\nInputCopyf1eOutputCopyNOInputCopy0f1eOutputCopy00f1InputCopy12d2cOutputCopy00314\n\nInputCopyf1e\n\nOutputCopyNO\n\nInputCopy0f1e\n\nOutputCopy00f1\n\nInputCopy12d2c\n\nOutputCopy00314\n\nNoteThe numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of 16, starting with the rightmost digit, which is multiplied by 160. Hexadecimal digits representing values greater than 9 are represented by letters: a = 10, b = 11, c = 12, d = 13, e = 14, f = 15.For example, the numerical value of 0f1e is 0·163 + 15·162 + 1·161 + 14·160 = 3870, the numerical value of 00f1 is 0·163 + 0·162 + 15·161 + 1·160 = 241, and the numerical value of 100f is 1·163 + 0·162 + 0·161 + 15·160 = 4111. Since 3870 + 241 = 4111 and 00f1 is a permutation of 100f, 00f1 is a valid answer to the second test case.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*E"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string S = inf.readToken(\"[0-9a-f]{1,14}\", \"S\");\n    inf.readEoln();\n    bool has_non_zero = false;\n    for (char c : S) {\n        if (c != '0') {\n            has_non_zero = true;\n            break;\n        }\n    }\n    ensuref(has_non_zero, \"At least one character in S must be non-zero\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string S = inf.readToken(\"[0-9a-f]{1,14}\", \"S\");\n    inf.readEoln();\n    bool has_non_zero = false;\n    for (char c : S) {\n        if (c != '0') {\n            has_non_zero = true;\n            break;\n        }\n    }\n    ensuref(has_non_zero, \"At least one character in S must be non-zero\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string S = inf.readToken(\"[0-9a-f]{1,14}\", \"S\");\n    inf.readEoln();\n    bool has_non_zero = false;\n    for (char c : S) {\n        if (c != '0') {\n            has_non_zero = true;\n            break;\n        }\n    }\n    ensuref(has_non_zero, \"At least one character in S must be non-zero\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S;\n\n    if (type == \"random\") {\n        do {\n            S = \"\";\n            for(int i = 0; i < n; ++i) {\n                int digit = rnd.next(16);\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    } else if (type == \"leadingZeros\") {\n        do {\n            S = \"\";\n            int numZeros = rnd.next(1, n - 1);\n            for(int i = 0; i < numZeros; ++i) {\n                S += '0';\n            }\n            for(int i = numZeros; i < n; ++i) {\n                int digit = rnd.next(1, 15); // Non-zero digit\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    } else if (type == \"minimalDifference\") {\n        // Minimal non-zero value with leading zeros\n        S = string(n - 1, '0') + '1';\n    } else if (type == \"maximalDifference\") {\n        // Maximal possible value for the given length\n        S = string(n, 'f');\n    } else if (type == \"impossibleCase\") {\n        // Generate an impossible case where the answer should be \"NO\"\n        // Here we set S to a value that cannot be obtained by permuting a hexadecimal string\n        if (n >= 3) {\n            S = \"f1e\";\n            while ((int)S.size() < n) {\n                S = '0' + S;\n            }\n        } else {\n            // For small n, generate a specific impossible case\n            S = string(n, 'f');\n        }\n    } else if (type == \"maximalLength\") {\n        // n is set to 14 (maximum allowed length)\n        n = 14;\n        do {\n            S = \"\";\n            for(int i = 0; i < n; ++i) {\n                int digit = rnd.next(16);\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    } else if (type == \"oneNonZero\") {\n        // Generate S with only one non-zero digit\n        S = string(n, '0');\n        int pos = rnd.next(0, n - 1);\n        int digit = rnd.next(1, 15); // Non-zero digit\n        char c;\n        if (digit < 10)\n            c = '0' + digit;\n        else\n            c = 'a' + (digit - 10);\n        S[pos] = c;\n    } else {\n        // Default to random if type is unrecognized\n        do {\n            S = \"\";\n            for(int i = 0; i < n; ++i) {\n                int digit = rnd.next(16);\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    }\n\n    // Output the generated hexadecimal string S\n    printf(\"%s\\n\", S.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S;\n\n    if (type == \"random\") {\n        do {\n            S = \"\";\n            for(int i = 0; i < n; ++i) {\n                int digit = rnd.next(16);\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    } else if (type == \"leadingZeros\") {\n        do {\n            S = \"\";\n            int numZeros = rnd.next(1, n - 1);\n            for(int i = 0; i < numZeros; ++i) {\n                S += '0';\n            }\n            for(int i = numZeros; i < n; ++i) {\n                int digit = rnd.next(1, 15); // Non-zero digit\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    } else if (type == \"minimalDifference\") {\n        // Minimal non-zero value with leading zeros\n        S = string(n - 1, '0') + '1';\n    } else if (type == \"maximalDifference\") {\n        // Maximal possible value for the given length\n        S = string(n, 'f');\n    } else if (type == \"impossibleCase\") {\n        // Generate an impossible case where the answer should be \"NO\"\n        // Here we set S to a value that cannot be obtained by permuting a hexadecimal string\n        if (n >= 3) {\n            S = \"f1e\";\n            while ((int)S.size() < n) {\n                S = '0' + S;\n            }\n        } else {\n            // For small n, generate a specific impossible case\n            S = string(n, 'f');\n        }\n    } else if (type == \"maximalLength\") {\n        // n is set to 14 (maximum allowed length)\n        n = 14;\n        do {\n            S = \"\";\n            for(int i = 0; i < n; ++i) {\n                int digit = rnd.next(16);\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    } else if (type == \"oneNonZero\") {\n        // Generate S with only one non-zero digit\n        S = string(n, '0');\n        int pos = rnd.next(0, n - 1);\n        int digit = rnd.next(1, 15); // Non-zero digit\n        char c;\n        if (digit < 10)\n            c = '0' + digit;\n        else\n            c = 'a' + (digit - 10);\n        S[pos] = c;\n    } else {\n        // Default to random if type is unrecognized\n        do {\n            S = \"\";\n            for(int i = 0; i < n; ++i) {\n                int digit = rnd.next(16);\n                char c;\n                if (digit < 10)\n                    c = '0' + digit;\n                else\n                    c = 'a' + (digit - 10);\n                S += c;\n            }\n        } while (count_if(S.begin(), S.end(), [](char c){ return c != '0'; }) == 0);\n    }\n\n    // Output the generated hexadecimal string S\n    printf(\"%s\\n\", S.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type minimalDifference\n./gen -n 1 -type maximalDifference\n./gen -n 1 -type impossibleCase\n./gen -n 1 -type oneNonZero\n\n./gen -n 2 -type random\n./gen -n 2 -type leadingZeros\n./gen -n 2 -type minimalDifference\n./gen -n 2 -type maximalDifference\n./gen -n 2 -type impossibleCase\n./gen -n 2 -type oneNonZero\n\n./gen -n 3 -type random\n./gen -n 3 -type leadingZeros\n./gen -n 3 -type minimalDifference\n./gen -n 3 -type maximalDifference\n./gen -n 3 -type impossibleCase\n./gen -n 3 -type oneNonZero\n\n./gen -n 5 -type random\n./gen -n 5 -type leadingZeros\n./gen -n 5 -type minimalDifference\n./gen -n 5 -type maximalDifference\n./gen -n 5 -type impossibleCase\n./gen -n 5 -type oneNonZero\n\n./gen -n 7 -type random\n./gen -n 7 -type leadingZeros\n./gen -n 7 -type minimalDifference\n./gen -n 7 -type maximalDifference\n./gen -n 7 -type impossibleCase\n./gen -n 7 -type oneNonZero\n\n./gen -n 10 -type random\n./gen -n 10 -type leadingZeros\n./gen -n 10 -type minimalDifference\n./gen -n 10 -type maximalDifference\n./gen -n 10 -type impossibleCase\n./gen -n 10 -type oneNonZero\n\n./gen -n 14 -type random\n./gen -n 14 -type leadingZeros\n./gen -n 14 -type minimalDifference\n./gen -n 14 -type maximalDifference\n./gen -n 14 -type impossibleCase\n./gen -n 14 -type oneNonZero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:14.477070",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/F",
      "title": "F. Egg Roulette",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain integers R and C (1 ≤ R, C ≤ 20, R + C ≤ 30).The second line of input will contain the string S of length 2(R + C) consisting only of characters 'A', 'B', '?'.",
      "output_spec": "OutputPrint the number of valid orderings that minimize unfairness and match S.",
      "sample_tests": "ExamplesInputCopy1 1??BBOutputCopy0InputCopy2 4?BA??B??A???OutputCopy1InputCopy4 14????A??BB?????????????AB????????????OutputCopy314",
      "description": "F. Egg Roulette\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will contain integers R and C (1 ≤ R, C ≤ 20, R + C ≤ 30).The second line of input will contain the string S of length 2(R + C) consisting only of characters 'A', 'B', '?'.\n\nOutputPrint the number of valid orderings that minimize unfairness and match S.\n\nInputCopy1 1??BBOutputCopy0InputCopy2 4?BA??B??A???OutputCopy1InputCopy4 14????A??BB?????????????AB????????????OutputCopy314\n\nInputCopy1 1??BB\n\nOutputCopy0\n\nInputCopy2 4?BA??B??A???\n\nOutputCopy1\n\nInputCopy4 14????A??BB?????????????AB????????????\n\nOutputCopy314\n\nNoteIn the first test case, the minimum unfairness is 0, and the orderings that achieve it are \"ABBA\" and \"BAAB\", neither of which match S. Note that an ordering such as \"ABBB\" would also have an unfairness of 0, but is invalid because it does not contain the same number of 'A's as 'B's.In the second example, the only matching ordering is \"BBAAABABABBA\".",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*F"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int R = inf.readInt(1, 20, \"R\");\n    inf.readSpace();\n    int C = inf.readInt(1, 20, \"C\");\n    inf.readEoln();\n\n    ensuref(R + C <= 30, \"R + C must be ≤ 30, but R=%d, C=%d\", R, C);\n\n    string pattern = \"[AB\\\\?]{\" + to_string(2 * (R + C)) + \"}\";\n    string S = inf.readLine(pattern, \"S\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int R = inf.readInt(1, 20, \"R\");\n    inf.readSpace();\n    int C = inf.readInt(1, 20, \"C\");\n    inf.readEoln();\n\n    ensuref(R + C <= 30, \"R + C must be ≤ 30, but R=%d, C=%d\", R, C);\n\n    string pattern = \"[AB\\\\?]{\" + to_string(2 * (R + C)) + \"}\";\n    string S = inf.readLine(pattern, \"S\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int R = inf.readInt(1, 20, \"R\");\n    inf.readSpace();\n    int C = inf.readInt(1, 20, \"C\");\n    inf.readEoln();\n\n    ensuref(R + C <= 30, \"R + C must be ≤ 30, but R=%d, C=%d\", R, C);\n\n    string pattern = \"[AB\\\\?]{\" + to_string(2 * (R + C)) + \"}\";\n    string S = inf.readLine(pattern, \"S\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring genString(int len, string pattern, int num_A, int num_B) {\n    string S(len, '?');\n    if (pattern == \"random\") {\n        for (int i = 0; i < len; ++i) {\n            int ch = rnd.next(3);\n            if (ch == 0) S[i] = 'A';\n            else if (ch == 1) S[i] = 'B';\n            else S[i] = '?';\n        }\n    } else if (pattern == \"all_fixed\") {\n        vector<char> chars = {'A', 'B'};\n        for (int i = 0; i < len; ++i) {\n            S[i] = chars[rnd.next(2)];\n        }\n    } else if (pattern == \"all_question\") {\n        S = string(len, '?');\n    } else if (pattern == \"half_question\") {\n        for (int i = 0; i < len; ++i) {\n            if (i % 2 == 0) {\n                S[i] = '?';\n            } else {\n                S[i] = (rnd.next(2) == 0) ? 'A' : 'B';\n            }\n        }\n    } else if (pattern == \"alternate_AB\") {\n        for (int i = 0; i < len; ++i) {\n            S[i] = (i % 2 == 0) ? 'A' : 'B';\n        }\n    } else if (pattern == \"more_A\") {\n        int A_count = 0, B_count = 0;\n        for(int i=0; i<len; ++i){\n            if(A_count < num_A){\n                S[i] = 'A';\n                ++A_count;\n            } else if(B_count < num_B){\n                S[i] = 'B';\n                ++B_count;\n            } else {\n                S[i] = '?';\n            }\n        }\n    } else if (pattern == \"more_B\") {\n        int A_count = 0, B_count = 0;\n        for(int i=0; i<len; ++i){\n            if(B_count < num_B){\n                S[i] = 'B';\n                ++B_count;\n            } else if(A_count < num_A){\n                S[i] = 'A';\n                ++A_count;\n            } else {\n                S[i] = '?';\n            }\n        }\n    } else if (pattern == \"long_same_char\") {\n        char ch = rnd.next(2) ? 'A' : 'B';\n        S = string(len, ch);\n    } else if (pattern == \"empty\") {\n        // Do nothing, leave S as '?'s\n    }\n    return S;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int R = opt<int>(\"R\");\n    int C = opt<int>(\"C\");\n    string type = opt<string>(\"type\", \"random\");\n    int len = 2 * (R + C);\n\n    int num_A = opt<int>(\"num_A\", -1);\n    int num_B = opt<int>(\"num_B\", -1);\n\n    // Generate S\n    string S = genString(len, type, num_A, num_B);\n\n    printf(\"%d %d\\n\", R, C);\n    printf(\"%s\\n\", S.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring genString(int len, string pattern, int num_A, int num_B) {\n    string S(len, '?');\n    if (pattern == \"random\") {\n        for (int i = 0; i < len; ++i) {\n            int ch = rnd.next(3);\n            if (ch == 0) S[i] = 'A';\n            else if (ch == 1) S[i] = 'B';\n            else S[i] = '?';\n        }\n    } else if (pattern == \"all_fixed\") {\n        vector<char> chars = {'A', 'B'};\n        for (int i = 0; i < len; ++i) {\n            S[i] = chars[rnd.next(2)];\n        }\n    } else if (pattern == \"all_question\") {\n        S = string(len, '?');\n    } else if (pattern == \"half_question\") {\n        for (int i = 0; i < len; ++i) {\n            if (i % 2 == 0) {\n                S[i] = '?';\n            } else {\n                S[i] = (rnd.next(2) == 0) ? 'A' : 'B';\n            }\n        }\n    } else if (pattern == \"alternate_AB\") {\n        for (int i = 0; i < len; ++i) {\n            S[i] = (i % 2 == 0) ? 'A' : 'B';\n        }\n    } else if (pattern == \"more_A\") {\n        int A_count = 0, B_count = 0;\n        for(int i=0; i<len; ++i){\n            if(A_count < num_A){\n                S[i] = 'A';\n                ++A_count;\n            } else if(B_count < num_B){\n                S[i] = 'B';\n                ++B_count;\n            } else {\n                S[i] = '?';\n            }\n        }\n    } else if (pattern == \"more_B\") {\n        int A_count = 0, B_count = 0;\n        for(int i=0; i<len; ++i){\n            if(B_count < num_B){\n                S[i] = 'B';\n                ++B_count;\n            } else if(A_count < num_A){\n                S[i] = 'A';\n                ++A_count;\n            } else {\n                S[i] = '?';\n            }\n        }\n    } else if (pattern == \"long_same_char\") {\n        char ch = rnd.next(2) ? 'A' : 'B';\n        S = string(len, ch);\n    } else if (pattern == \"empty\") {\n        // Do nothing, leave S as '?'s\n    }\n    return S;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int R = opt<int>(\"R\");\n    int C = opt<int>(\"C\");\n    string type = opt<string>(\"type\", \"random\");\n    int len = 2 * (R + C);\n\n    int num_A = opt<int>(\"num_A\", -1);\n    int num_B = opt<int>(\"num_B\", -1);\n\n    // Generate S\n    string S = genString(len, type, num_A, num_B);\n\n    printf(\"%d %d\\n\", R, C);\n    printf(\"%s\\n\", S.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -R 1 -C 1 -type all_question\n./gen -R 1 -C 1 -type random\n./gen -R 1 -C 1 -type all_fixed\n./gen -R 1 -C 1 -type alternate_AB\n./gen -R 1 -C 1 -type half_question\n./gen -R 1 -C 1 -type long_same_char\n\n./gen -R 1 -C 29 -type all_question\n./gen -R 1 -C 29 -type random\n./gen -R 1 -C 29 -type all_fixed\n./gen -R 1 -C 29 -type alternate_AB\n./gen -R 1 -C 29 -type half_question\n./gen -R 1 -C 29 -type long_same_char\n\n./gen -R 15 -C 15 -type all_question\n./gen -R 15 -C 15 -type random\n./gen -R 15 -C 15 -type all_fixed\n./gen -R 15 -C 15 -type alternate_AB\n./gen -R 15 -C 15 -type half_question\n./gen -R 15 -C 15 -type long_same_char\n\n./gen -R 10 -C 20 -type all_question\n./gen -R 10 -C 20 -type random\n./gen -R 10 -C 20 -type all_fixed\n./gen -R 10 -C 20 -type alternate_AB\n./gen -R 10 -C 20 -type half_question\n./gen -R 10 -C 20 -type more_A -num_A 40 -num_B 20\n\n./gen -R 20 -C 10 -type all_question\n./gen -R 20 -C 10 -type random\n./gen -R 20 -C 10 -type all_fixed\n./gen -R 20 -C 10 -type alternate_AB\n./gen -R 20 -C 10 -type half_question\n./gen -R 20 -C 10 -type more_B -num_A 20 -num_B 40\n\n./gen -R 5 -C 5 -type alternate_AB\n./gen -R 5 -C 5 -type long_same_char\n./gen -R 10 -C 10 -type empty\n\n./gen -R 15 -C 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:16.329824",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "865/G",
      "title": "G. Flowers and Chocolate",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain integers F, B, and N (1 ≤ F ≤ 10, 1 ≤ B ≤ 100, 1 ≤ N ≤ 1018), the number of types of flowers, the number of types of boxes, and the number of flowers that must go into the bouquet, respectively.The second line of input will contain F integers p1, p2, ..., pF (1 ≤ pi ≤ 109), the numbers of petals on each of the flower types.The third line of input will contain B integers c1, c2, ..., cB (1 ≤ ci ≤ 250), the number of pieces of chocolate in each of the box types.",
      "output_spec": "OutputPrint the number of bouquet+basket combinations Pieguy can buy, modulo 1000000007 = 109 + 7.",
      "sample_tests": "ExamplesInputCopy2 3 33 510 3 7OutputCopy17InputCopy6 5 109 3 3 4 9 99 9 1 6 4OutputCopy31415926",
      "description": "G. Flowers and Chocolate\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will contain integers F, B, and N (1 ≤ F ≤ 10, 1 ≤ B ≤ 100, 1 ≤ N ≤ 1018), the number of types of flowers, the number of types of boxes, and the number of flowers that must go into the bouquet, respectively.The second line of input will contain F integers p1, p2, ..., pF (1 ≤ pi ≤ 109), the numbers of petals on each of the flower types.The third line of input will contain B integers c1, c2, ..., cB (1 ≤ ci ≤ 250), the number of pieces of chocolate in each of the box types.\n\nOutputPrint the number of bouquet+basket combinations Pieguy can buy, modulo 1000000007 = 109 + 7.\n\nInputCopy2 3 33 510 3 7OutputCopy17InputCopy6 5 109 3 3 4 9 99 9 1 6 4OutputCopy31415926\n\nInputCopy2 3 33 510 3 7\n\nOutputCopy17\n\nInputCopy6 5 109 3 3 4 9 99 9 1 6 4\n\nOutputCopy31415926\n\nNoteIn the first example, there is 1 way to make a bouquet with 9 petals (3 + 3 + 3), and 1 way to make a basket with 9 pieces of chocolate (3 + 3 + 3), for 1 possible combination. There are 3 ways to make a bouquet with 13 petals (3 + 5 + 5, 5 + 3 + 5, 5 + 5 + 3), and 5 ways to make a basket with 13 pieces of chocolate (3 + 10, 10 + 3, 3 + 3 + 7, 3 + 7 + 3, 7 + 3 + 3), for 15 more combinations. Finally there is 1 way to make a bouquet with 15 petals (5 + 5 + 5) and 1 way to make a basket with 15 pieces of chocolate (3 + 3 + 3 + 3 + 3), for 1 more combination.Note that it is possible for multiple types of flowers to have the same number of petals. Such types are still considered different. Similarly different types of boxes may contain the same number of pieces of chocolate, but are still considered different.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 865\\s*G"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int F = inf.readInt(1,10,\"F\");\n    inf.readSpace();\n    int B = inf.readInt(1,100,\"B\");\n    inf.readSpace();\n    long long N = inf.readLong(1, (long long)1e18, \"N\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(F, 1, 1000000000, \"p\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(B, 1, 250, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int F = inf.readInt(1,10,\"F\");\n    inf.readSpace();\n    int B = inf.readInt(1,100,\"B\");\n    inf.readSpace();\n    long long N = inf.readLong(1, (long long)1e18, \"N\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(F, 1, 1000000000, \"p\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(B, 1, 250, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int F = inf.readInt(1,10,\"F\");\n    inf.readSpace();\n    int B = inf.readInt(1,100,\"B\");\n    inf.readSpace();\n    long long N = inf.readLong(1, (long long)1e18, \"N\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(F, 1, 1000000000, \"p\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(B, 1, 250, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long N = opt<long long>(\"N\");\n    int F = opt<int>(\"F\");\n    int B = opt<int>(\"B\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p;\n    vector<int> c;\n\n    if (type == \"minimal\") {\n        // Minimal input\n        N = 1;\n        F = 1;\n        B = 1;\n        p.push_back(1);\n        c.push_back(1);\n    } else if (type == \"maximal\") {\n        // Maximal input\n        N = 1000000000000000000LL; // 1e18\n        F = 10;\n        B = 100;\n        for (int i = 0; i < F; ++i)\n            p.push_back(1000000000); // 1e9\n        for (int i = 0; i < B; ++i)\n            c.push_back(250);\n    } else if (type == \"single_petal\") {\n        // All flower types have the same number of petals\n        int pi = rnd.next(1, 1000000000);\n        for (int i = 0; i < F; ++i)\n            p.push_back(pi);\n        for (int i = 0; i < B; ++i)\n            c.push_back(rnd.next(1, 250));\n    } else if (type == \"unique_petal\") {\n        // All pi are unique\n        set<int> used_pi;\n        while ((int)p.size() < F) {\n            int pi = rnd.next(1, 1000000000);\n            if (used_pi.count(pi)) continue;\n            p.push_back(pi);\n            used_pi.insert(pi);\n        }\n        set<int> used_c;\n        while ((int)c.size() < B) {\n            int ci = rnd.next(1, 250);\n            if (used_c.count(ci)) continue;\n            c.push_back(ci);\n            used_c.insert(ci);\n        }\n    } else if (type == \"repeated_petal\") {\n        // Multiple pis are the same\n        int num_same = rnd.next(1, F);\n        int pi_same = rnd.next(1, 1000000000);\n        for (int i = 0; i < num_same; ++i)\n            p.push_back(pi_same);\n        while ((int)p.size() < F)\n            p.push_back(rnd.next(1, 1000000000));\n        int num_same_c = rnd.next(1, B);\n        int ci_same = rnd.next(1, 250);\n        for (int i = 0; i < num_same_c; ++i)\n            c.push_back(ci_same);\n        while ((int)c.size() < B)\n            c.push_back(rnd.next(1, 250));\n    } else {\n        // Random test case\n        for (int i = 0; i < F; ++i)\n            p.push_back(rnd.next(1, 1000000000));\n        for (int i = 0; i < B; ++i)\n            c.push_back(rnd.next(1, 250));\n    }\n\n    // Output the values\n    printf(\"%d %d %lld\\n\", F, B, N);\n    for (int i = 0; i < F; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < B; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", c[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long N = opt<long long>(\"N\");\n    int F = opt<int>(\"F\");\n    int B = opt<int>(\"B\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p;\n    vector<int> c;\n\n    if (type == \"minimal\") {\n        // Minimal input\n        N = 1;\n        F = 1;\n        B = 1;\n        p.push_back(1);\n        c.push_back(1);\n    } else if (type == \"maximal\") {\n        // Maximal input\n        N = 1000000000000000000LL; // 1e18\n        F = 10;\n        B = 100;\n        for (int i = 0; i < F; ++i)\n            p.push_back(1000000000); // 1e9\n        for (int i = 0; i < B; ++i)\n            c.push_back(250);\n    } else if (type == \"single_petal\") {\n        // All flower types have the same number of petals\n        int pi = rnd.next(1, 1000000000);\n        for (int i = 0; i < F; ++i)\n            p.push_back(pi);\n        for (int i = 0; i < B; ++i)\n            c.push_back(rnd.next(1, 250));\n    } else if (type == \"unique_petal\") {\n        // All pi are unique\n        set<int> used_pi;\n        while ((int)p.size() < F) {\n            int pi = rnd.next(1, 1000000000);\n            if (used_pi.count(pi)) continue;\n            p.push_back(pi);\n            used_pi.insert(pi);\n        }\n        set<int> used_c;\n        while ((int)c.size() < B) {\n            int ci = rnd.next(1, 250);\n            if (used_c.count(ci)) continue;\n            c.push_back(ci);\n            used_c.insert(ci);\n        }\n    } else if (type == \"repeated_petal\") {\n        // Multiple pis are the same\n        int num_same = rnd.next(1, F);\n        int pi_same = rnd.next(1, 1000000000);\n        for (int i = 0; i < num_same; ++i)\n            p.push_back(pi_same);\n        while ((int)p.size() < F)\n            p.push_back(rnd.next(1, 1000000000));\n        int num_same_c = rnd.next(1, B);\n        int ci_same = rnd.next(1, 250);\n        for (int i = 0; i < num_same_c; ++i)\n            c.push_back(ci_same);\n        while ((int)c.size() < B)\n            c.push_back(rnd.next(1, 250));\n    } else {\n        // Random test case\n        for (int i = 0; i < F; ++i)\n            p.push_back(rnd.next(1, 1000000000));\n        for (int i = 0; i < B; ++i)\n            c.push_back(rnd.next(1, 250));\n    }\n\n    // Output the values\n    printf(\"%d %d %lld\\n\", F, B, N);\n    for (int i = 0; i < F; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < B; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", c[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -N 1 -F 1 -B 1 -type minimal\n\n# Maximal input\n./gen -N 1000000000000000000 -F 10 -B 100 -type maximal\n\n# All flower types have same number of petals\n./gen -N 5 -F 2 -B 3 -type single_petal\n./gen -N 1000 -F 5 -B 10 -type single_petal\n./gen -N 1000000000 -F 10 -B 50 -type single_petal\n\n# All petals counts are unique\n./gen -N 10 -F 3 -B 5 -type unique_petal\n./gen -N 100 -F 5 -B 20 -type unique_petal\n./gen -N 50000000000 -F 8 -B 80 -type unique_petal\n\n# Multiple flower types with same petal counts\n./gen -N 100 -F 5 -B 10 -type repeated_petal\n./gen -N 100000000000 -F 10 -B 50 -type repeated_petal\n\n# Random test cases\n./gen -N 1 -F 1 -B 1 -type random\n./gen -N 999999999999999999 -F 10 -B 100 -type random\n./gen -N 500000000000000000 -F 8 -B 80 -type random\n./gen -N 123456789 -F 5 -B 50 -type random\n./gen -N 987654321 -F 6 -B 60 -type random\n./gen -N 1000000 -F 7 -B 70 -type random\n./gen -N 999999999999999999 -F 10 -B 100 -type random\n./gen -N 1000000000000000000 -F 10 -B 100 -type random\n\n# Edge cases with minimal F and B\n./gen -N 1000000000000000000 -F 1 -B 1 -type random\n./gen -N 500000000000000000 -F 1 -B 1 -type random\n\n# Edge cases with maximal F and minimal B\n./gen -N 1000000000000000000 -F 10 -B 1 -type random\n\n# Edge cases with minimal F and maximal B\n./gen -N 1000000000000000000 -F 1 -B 100 -type random\n\n# Edge cases with minimal N\n./gen -N 1 -F 10 -B 100 -type random\n./gen -N 1 -F 5 -B 50 -type random\n\n# Edge cases with maximal petal counts\n./gen -N 100000000000 -F 10 -B 100 -type maximal\n\n# Test cases with repeated petal counts\n./gen -N 500000000000 -F 10 -B 100 -type repeated_petal\n\n# Test cases where ci values are all the same\n./gen -N 1000000 -F 5 -B 10 -type repeated_petal\n\n# Random test cases with varying N\n./gen -N 2 -F 3 -B 5 -type random\n./gen -N 3 -F 3 -B 5 -type random\n./gen -N 4 -F 3 -B 5 -type random\n./gen -N 5 -F 3 -B 5 -type random\n./gen -N 6 -F 3 -B 5 -type random\n./gen -N 7 -F 3 -B 5 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:18.278869",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "867/A",
      "title": "A. Between the Offices",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains single integer n (2 ≤ n ≤ 100) — the number of days.The second line contains a string of length n consisting of only capital 'S' and 'F' letters. If the i-th letter is 'S', then you were in Seattle office on that day. Otherwise you were in San Francisco. The days are given in chronological order, i.e. today is the last day in this sequence.",
      "output_spec": "OutputPrint \"YES\" if you flew more times from Seattle to San Francisco, and \"NO\" otherwise.You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy4FSSFOutputCopyNOInputCopy2SFOutputCopyYESInputCopy10FFFFFFFFFFOutputCopyNOInputCopy10SSFFSFFSFFOutputCopyYES",
      "description": "A. Between the Offices\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains single integer n (2 ≤ n ≤ 100) — the number of days.The second line contains a string of length n consisting of only capital 'S' and 'F' letters. If the i-th letter is 'S', then you were in Seattle office on that day. Otherwise you were in San Francisco. The days are given in chronological order, i.e. today is the last day in this sequence.\n\nOutputPrint \"YES\" if you flew more times from Seattle to San Francisco, and \"NO\" otherwise.You can print each letter in any case (upper or lower).\n\nInputCopy4FSSFOutputCopyNOInputCopy2SFOutputCopyYESInputCopy10FFFFFFFFFFOutputCopyNOInputCopy10SSFFSFFSFFOutputCopyYES\n\nInputCopy4FSSF\n\nOutputCopyNO\n\nInputCopy2SF\n\nOutputCopyYES\n\nInputCopy10FFFFFFFFFF\n\nOutputCopyNO\n\nInputCopy10SSFFSFFSFF\n\nOutputCopyYES\n\nNoteIn the first example you were initially at San Francisco, then flew to Seattle, were there for two days and returned to San Francisco. You made one flight in each direction, so the answer is \"NO\".In the second example you just flew from Seattle to San Francisco, so the answer is \"YES\".In the third example you stayed the whole period in San Francisco, so the answer is \"NO\".In the fourth example if you replace 'S' with ones, and 'F' with zeros, you'll get the first few digits of π in binary representation. Not very useful information though.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 867\\s*A"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[SF]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[SF]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[SF]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'S'); // Initialize with 'S'\n\n    if (type == \"all_S\") {\n        // All 'S'\n        fill(s.begin(), s.end(), 'S');\n    } else if (type == \"all_F\") {\n        // All 'F'\n        fill(s.begin(), s.end(), 'F');\n    } else if (type == \"start_S_end_F\") {\n        // Starts with 'S', ends with 'F', middle random\n        s[0] = 'S';\n        s[n - 1] = 'F';\n        for (int i = 1; i < n - 1; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"start_F_end_S\") {\n        // Starts with 'F', ends with 'S', middle random\n        s[0] = 'F';\n        s[n - 1] = 'S';\n        for (int i = 1; i < n - 1; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"starts_with_S\") {\n        // Starts with 'S', rest random\n        s[0] = 'S';\n        for (int i = 1; i < n; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"ends_with_F\") {\n        // Ends with 'F', rest random\n        s[n - 1] = 'F';\n        for (int i = 0; i < n - 1; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"alternating_SF\") {\n        // 'S', 'F', 'S', 'F', ...\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? 'S' : 'F';\n    } else if (type == \"alternating_FS\") {\n        // 'F', 'S', 'F', 'S', ...\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? 'F' : 'S';\n    } else {\n        // Random\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    }\n\n    // Output n and the string s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'S'); // Initialize with 'S'\n\n    if (type == \"all_S\") {\n        // All 'S'\n        fill(s.begin(), s.end(), 'S');\n    } else if (type == \"all_F\") {\n        // All 'F'\n        fill(s.begin(), s.end(), 'F');\n    } else if (type == \"start_S_end_F\") {\n        // Starts with 'S', ends with 'F', middle random\n        s[0] = 'S';\n        s[n - 1] = 'F';\n        for (int i = 1; i < n - 1; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"start_F_end_S\") {\n        // Starts with 'F', ends with 'S', middle random\n        s[0] = 'F';\n        s[n - 1] = 'S';\n        for (int i = 1; i < n - 1; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"starts_with_S\") {\n        // Starts with 'S', rest random\n        s[0] = 'S';\n        for (int i = 1; i < n; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"ends_with_F\") {\n        // Ends with 'F', rest random\n        s[n - 1] = 'F';\n        for (int i = 0; i < n - 1; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    } else if (type == \"alternating_SF\") {\n        // 'S', 'F', 'S', 'F', ...\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? 'S' : 'F';\n    } else if (type == \"alternating_FS\") {\n        // 'F', 'S', 'F', 'S', ...\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? 'F' : 'S';\n    } else {\n        // Random\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(0, 1) ? 'S' : 'F';\n    }\n\n    // Output n and the string s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type all_S\n./gen -n 2 -type all_F\n./gen -n 2 -type random\n./gen -n 2 -type start_S_end_F\n./gen -n 2 -type start_F_end_S\n\n./gen -n 3 -type alternating_SF\n./gen -n 3 -type alternating_FS\n\n./gen -n 10 -type start_S_end_F\n./gen -n 10 -type start_F_end_S\n./gen -n 10 -type starts_with_S\n./gen -n 10 -type ends_with_F\n\n./gen -n 50 -type random\n./gen -n 50 -type starts_with_S\n./gen -n 50 -type ends_with_F\n\n./gen -n 99 -type start_S_end_F\n./gen -n 99 -type start_F_end_S\n./gen -n 99 -type random\n\n./gen -n 100 -type all_S\n./gen -n 100 -type all_F\n./gen -n 100 -type alternating_SF\n./gen -n 100 -type alternating_FS\n./gen -n 100 -type random\n./gen -n 100 -type start_S_end_F\n./gen -n 100 -type start_F_end_S\n\n./gen -n 2 -type alternating_SF\n./gen -n 2 -type alternating_FS\n./gen -n 2 -type starts_with_S\n./gen -n 2 -type ends_with_F\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:19.913755",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "867/B",
      "title": "B. Save the problem!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will consist of a single integer A (1 ≤ A ≤ 105), the desired number of ways.",
      "output_spec": "OutputIn the first line print integers N and M (1 ≤ N ≤ 106, 1 ≤ M ≤ 10), the amount of change to be made, and the number of denominations, respectively.Then print M integers D1, D2, ..., DM (1 ≤ Di ≤ 106), the denominations of the coins. All denominations must be distinct: for any i ≠ j we must have Di ≠ Dj.If there are multiple tests, print any of them. You can print denominations in atbitrary order.",
      "sample_tests": "ExamplesInputCopy18OutputCopy30 41 5 10 25InputCopy3OutputCopy20 25 2InputCopy314OutputCopy183 46 5 2 139",
      "description": "B. Save the problem!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will consist of a single integer A (1 ≤ A ≤ 105), the desired number of ways.\n\nOutputIn the first line print integers N and M (1 ≤ N ≤ 106, 1 ≤ M ≤ 10), the amount of change to be made, and the number of denominations, respectively.Then print M integers D1, D2, ..., DM (1 ≤ Di ≤ 106), the denominations of the coins. All denominations must be distinct: for any i ≠ j we must have Di ≠ Dj.If there are multiple tests, print any of them. You can print denominations in atbitrary order.\n\nInputCopy18OutputCopy30 41 5 10 25InputCopy3OutputCopy20 25 2InputCopy314OutputCopy183 46 5 2 139\n\nInputCopy18\n\nOutputCopy30 41 5 10 25\n\nOutputCopy20 25 2\n\nInputCopy314\n\nOutputCopy183 46 5 2 139",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 867 和字母"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(1, 100000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(1, 100000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int A = inf.readInt(1, 100000, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read A from input file\n    int A = inf.readInt(1, 100000, \"A\");\n    // Read N and M from participant output\n    int N = ouf.readInt(1, 1000000, \"N\");\n    int M = ouf.readInt(1, 10, \"M\");\n    // Read M denominations\n    vector<int> D;\n    set<int> denominations_set;\n    for (int i = 1; i <= M; ++i) {\n        int val = ouf.readInt(1, 1000000, format(\"D[%d]\", i).c_str());\n        if (denominations_set.count(val) > 0) {\n            quitf(_wa, \"Coin denominations are not distinct. Denomination %d appears more than once.\", val);\n        }\n        denominations_set.insert(val);\n        D.push_back(val);\n    }\n    // Now compute the number of ways to make change for amount N with denominations D\n    vector<uint64_t> dp(N+1, 0);\n    dp[0] = 1;\n    for (int coin : D) {\n        for (int i = coin; i <= N; ++i) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    uint64_t ways = dp[N];\n    if (ways == (uint64_t)A) {\n        quitf(_ok, \"Number of ways matches A: %d\", A);\n    } else {\n        quitf(_wa, (\"Number of ways to make change is \" + toString(ways) + \", but expected %d\").c_str(), A);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read A from command-line argument, defaulting to 1 if not provided.\n    // We just need to print A, as the \"correct solution\" code will read\n    // exactly this one integer, then produce the final test case itself.\n    int A = opt<int>(\"A\", 1);\n\n    // Print exactly one line with the integer A, and nothing else.\n    cout << A << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read A from command-line argument, defaulting to 1 if not provided.\n    // We just need to print A, as the \"correct solution\" code will read\n    // exactly this one integer, then produce the final test case itself.\n    int A = opt<int>(\"A\", 1);\n\n    // Print exactly one line with the integer A, and nothing else.\n    cout << A << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are 20 example commands to run this generator.\n# Each command prints exactly one integer (A) with a newline.\n\n./gen -A 1\n./gen -A 2\n./gen -A 3\n./gen -A 4\n./gen -A 5\n./gen -A 6\n./gen -A 10\n./gen -A 20\n./gen -A 30\n./gen -A 40\n./gen -A 50\n./gen -A 100\n./gen -A 314\n./gen -A 999\n./gen -A 1000\n./gen -A 9999\n./gen -A 10000\n./gen -A 50000\n./gen -A 99999\n./gen -A 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:21.827139",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "867/C",
      "title": "C. Ordering Pizza",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain integers N and S (1 ≤ N ≤ 105, 1 ≤ S ≤ 105), the number of contestants and the number of slices per pizza, respectively. N lines follow.The i-th such line contains integers si, ai, and bi (1 ≤ si ≤ 105, 1 ≤ ai ≤ 105, 1 ≤ bi ≤ 105), the number of slices the i-th contestant will eat, the happiness they will gain from each type 1 slice they eat, and the happiness they will gain from each type 2 slice they eat, respectively.",
      "output_spec": "OutputPrint the maximum total happiness that can be achieved.",
      "sample_tests": "ExamplesInputCopy3 123 5 74 6 75 9 5OutputCopy84InputCopy6 107 4 75 8 812 5 86 11 63 3 75 9 6OutputCopy314",
      "description": "C. Ordering Pizza\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will contain integers N and S (1 ≤ N ≤ 105, 1 ≤ S ≤ 105), the number of contestants and the number of slices per pizza, respectively. N lines follow.The i-th such line contains integers si, ai, and bi (1 ≤ si ≤ 105, 1 ≤ ai ≤ 105, 1 ≤ bi ≤ 105), the number of slices the i-th contestant will eat, the happiness they will gain from each type 1 slice they eat, and the happiness they will gain from each type 2 slice they eat, respectively.\n\nOutputPrint the maximum total happiness that can be achieved.\n\nInputCopy3 123 5 74 6 75 9 5OutputCopy84InputCopy6 107 4 75 8 812 5 86 11 63 3 75 9 6OutputCopy314\n\nInputCopy3 123 5 74 6 75 9 5\n\nOutputCopy84\n\nInputCopy6 107 4 75 8 812 5 86 11 63 3 75 9 6\n\nOutputCopy314\n\nNoteIn the first example, you only need to buy one pizza. If you buy a type 1 pizza, the total happiness will be 3·5 + 4·6 + 5·9 = 84, and if you buy a type 2 pizza, the total happiness will be 3·7 + 4·7 + 5·5 = 74.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 867 和字母"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000);\n    inf.readSpace();\n    int S = inf.readInt(1, 100000);\n    inf.readEoln();\n    for(int i = 0; i < N; ++i){\n        int s_i = inf.readInt(1, 100000);\n        inf.readSpace();\n        int a_i = inf.readInt(1, 100000);\n        inf.readSpace();\n        int b_i = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000);\n    inf.readSpace();\n    int S = inf.readInt(1, 100000);\n    inf.readEoln();\n    for(int i = 0; i < N; ++i){\n        int s_i = inf.readInt(1, 100000);\n        inf.readSpace();\n        int a_i = inf.readInt(1, 100000);\n        inf.readSpace();\n        int b_i = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000);\n    inf.readSpace();\n    int S = inf.readInt(1, 100000);\n    inf.readEoln();\n    for(int i = 0; i < N; ++i){\n        int s_i = inf.readInt(1, 100000);\n        inf.readSpace();\n        int a_i = inf.readInt(1, 100000);\n        inf.readSpace();\n        int b_i = inf.readInt(1, 100000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%d %d\\n\", n, s);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"max_happiness_type1\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = 100000;\n            int bi = 1;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"max_happiness_type2\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = 1;\n            int bi = 100000;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"equal_happiness\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai_bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai_bi, ai_bi);\n        }\n    } else if (type == \"max_slices\") {\n        for (int i = 0; i < n; ++i) {\n            int si = s;\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"min_slices\") {\n        for (int i = 0; i < n; ++i) {\n            int si = 1;\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"max_total_happiness\") {\n        for (int i = 0; i < n; ++i) {\n            int si = s;\n            int ai = 100000;\n            int bi = 1;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"alternate_preferences\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai, bi;\n            if (i % 2 == 0) {\n                ai = 100000;\n                bi = 1;\n            } else {\n                ai = 1;\n                bi = 100000;\n            }\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int si = 100000;\n            int ai = 100000;\n            int bi = 100000;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%d %d\\n\", n, s);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"max_happiness_type1\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = 100000;\n            int bi = 1;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"max_happiness_type2\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = 1;\n            int bi = 100000;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"equal_happiness\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai_bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai_bi, ai_bi);\n        }\n    } else if (type == \"max_slices\") {\n        for (int i = 0; i < n; ++i) {\n            int si = s;\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"min_slices\") {\n        for (int i = 0; i < n; ++i) {\n            int si = 1;\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"max_total_happiness\") {\n        for (int i = 0; i < n; ++i) {\n            int si = s;\n            int ai = 100000;\n            int bi = 1;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"alternate_preferences\") {\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai, bi;\n            if (i % 2 == 0) {\n                ai = 100000;\n                bi = 1;\n            } else {\n                ai = 1;\n                bi = 100000;\n            }\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int si = 100000;\n            int ai = 100000;\n            int bi = 100000;\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int si = rnd.next(1, s);\n            int ai = rnd.next(1, 100000);\n            int bi = rnd.next(1, 100000);\n            printf(\"%d %d %d\\n\", si, ai, bi);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -s 12 -type random                # Small test case\n./gen -n 6 -s 10 -type random                # Small test case\n./gen -n 10 -s 15 -type random               # Small test case\n\n./gen -n 50 -s 20 -type equal_happiness      # Small, ai == bi\n\n./gen -n 1000 -s 1000 -type random           # Medium random test case\n\n./gen -n 5000 -s 100000 -type min_slices     # si == 1\n\n./gen -n 100000 -s 1 -type min_slices        # n and s at max and min\n\n./gen -n 100000 -s 100000 -type random       # Maximum size random test case\n\n./gen -n 100000 -s 100000 -type max_happiness_type1   # ai maximum, bi minimum\n\n./gen -n 100000 -s 100000 -type max_happiness_type2   # ai minimum, bi maximum\n\n./gen -n 100000 -s 100000 -type equal_happiness       # ai == bi\n\n./gen -n 100000 -s 100000 -type max_slices            # si == s\n\n./gen -n 100000 -s 100000 -type alternate_preferences # Alternating ai and bi\n\n./gen -n 100000 -s 1 -type max_happiness_type1        # s = 1, ai maximum\n\n./gen -n 1 -s 100000 -type max_happiness_type1        # Single contestant\n\n./gen -n 100000 -s 100000 -type max_total_happiness   # Max total happiness\n\n./gen -n 99999 -s 100000 -type random                 # n just under limit\n\n./gen -n 100000 -s 2 -type min_slices                 # s small\n\n./gen -n 1000 -s 100000 -type random                  # n small, s large\n\n./gen -n 100000 -s 50000 -type max_happiness_type1    # s medium\n\n./gen -n 50000 -s 100000 -type random                 # n medium\n\n./gen -n 100000 -s 100000 -type large_numbers         # Maximum numbers\n\n./gen -n 10 -s 100 -type equal_happiness              # Small n, s\n\n./gen -n 100000 -s 50000 -type max_happiness_type2    # s medium\n\n./gen -n 100000 -s 1 -type max_slices                 # s = 1, si = s\n\n./gen -n 100000 -s 10000 -type random                 # s moderate\n\n./gen -n 100000 -s 100000 -type random                # Another maximum random\n\n./gen -n 2 -s 2 -type random                          # Very small test case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:23.774658",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "867/D",
      "title": "D. Пройди быстрее",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа N и R  — число уровней и число секунд, за которое вы хотите пройти игру, соответственно.Далее следуют N строк. Строка i содержит целые числа Fi, Si, Pi (1 ≤ Fi < Si ≤ 100, 80 ≤ Pi ≤ 99) — время быстрого прохождения уровня i, время медленного прохождения уровня i, и вероятность (в процентах) прохождения уровня i быстро.",
      "output_spec": "Выходные данныеВыведите математическое ожидание времени игры. Ваш ответ будет считаться правильным, если его абсолютная или относительная точность не превосходит 10 - 9.Формально, если ваш ответ равен a, а ответ жюри равен b, то ваш ответ будет считаться правильным, если .",
      "sample_tests": "ПримерыВходные данныеСкопировать1 82 8 81Выходные данныеСкопировать3.14Входные данныеСкопировать2 3020 30 803 9 85Выходные данныеСкопировать31.4Входные данныеСкопировать4 31963 79 8979 97 9175 87 8875 90 83Выходные данныеСкопировать314.159265358",
      "description": "D. Пройди быстрее\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа N и R  — число уровней и число секунд, за которое вы хотите пройти игру, соответственно.Далее следуют N строк. Строка i содержит целые числа Fi, Si, Pi (1 ≤ Fi < Si ≤ 100, 80 ≤ Pi ≤ 99) — время быстрого прохождения уровня i, время медленного прохождения уровня i, и вероятность (в процентах) прохождения уровня i быстро.\n\nВходные данные\n\nВыходные данныеВыведите математическое ожидание времени игры. Ваш ответ будет считаться правильным, если его абсолютная или относительная точность не превосходит 10 - 9.Формально, если ваш ответ равен a, а ответ жюри равен b, то ваш ответ будет считаться правильным, если .\n\nВыходные данные\n\nВходные данныеСкопировать1 82 8 81Выходные данныеСкопировать3.14Входные данныеСкопировать2 3020 30 803 9 85Выходные данныеСкопировать31.4Входные данныеСкопировать4 31963 79 8979 97 9175 87 8875 90 83Выходные данныеСкопировать314.159265358\n\nВходные данныеСкопировать1 82 8 81\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3.14\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3020 30 803 9 85\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31.4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 31963 79 8979 97 9175 87 8875 90 83\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать314.159265358\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере вам никогда не надо начинать сначала. С вероятностью 81% вы закончите игру за 2 секунды, и с вероятностью 19% — за 8 секунд. И то и другое вас устроит. Ожидаемое время игры равно 0.81·2 + 0.19·8 = 3.14.Во втором примере вы должны сбрасывать после первого уровня, если прошли его медленно. В среднем у вас будет 0.25 медленных попыток перед быстрой попыткой. Затем безразлично, закончите ли вы второй уровень быстро или медленно. Ожидаемое время равно 0.25·30 + 20 + 0.85·3 + 0.15·9 = 31.4.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 867 和字母"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 100000;\n    const int MAX_R = 1000000000;\n    const int MIN_Fi_Si = 1;\n    const int MAX_Fi_Si = 100;\n    const int MIN_Pi = 80;\n    const int MAX_Pi = 99;\n\n    int N = inf.readInt(1, MAX_N, \"N\");\n    inf.readSpace();\n    int R = inf.readInt(1, MAX_R, \"R\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; i++) {\n        int Fi = inf.readInt(MIN_Fi_Si, MAX_Fi_Si, \"Fi\");\n        inf.readSpace();\n        int Si = inf.readInt(MIN_Fi_Si, MAX_Fi_Si, \"Si\");\n        ensuref(Fi < Si, \"Fi must be less than Si at line %d\", i + 2);\n        inf.readSpace();\n        int Pi = inf.readInt(MIN_Pi, MAX_Pi, \"Pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 100000;\n    const int MAX_R = 1000000000;\n    const int MIN_Fi_Si = 1;\n    const int MAX_Fi_Si = 100;\n    const int MIN_Pi = 80;\n    const int MAX_Pi = 99;\n\n    int N = inf.readInt(1, MAX_N, \"N\");\n    inf.readSpace();\n    int R = inf.readInt(1, MAX_R, \"R\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; i++) {\n        int Fi = inf.readInt(MIN_Fi_Si, MAX_Fi_Si, \"Fi\");\n        inf.readSpace();\n        int Si = inf.readInt(MIN_Fi_Si, MAX_Fi_Si, \"Si\");\n        ensuref(Fi < Si, \"Fi must be less than Si at line %d\", i + 2);\n        inf.readSpace();\n        int Pi = inf.readInt(MIN_Pi, MAX_Pi, \"Pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 100000;\n    const int MAX_R = 1000000000;\n    const int MIN_Fi_Si = 1;\n    const int MAX_Fi_Si = 100;\n    const int MIN_Pi = 80;\n    const int MAX_Pi = 99;\n\n    int N = inf.readInt(1, MAX_N, \"N\");\n    inf.readSpace();\n    int R = inf.readInt(1, MAX_R, \"R\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; i++) {\n        int Fi = inf.readInt(MIN_Fi_Si, MAX_Fi_Si, \"Fi\");\n        inf.readSpace();\n        int Si = inf.readInt(MIN_Fi_Si, MAX_Fi_Si, \"Si\");\n        ensuref(Fi < Si, \"Fi must be less than Si at line %d\", i + 2);\n        inf.readSpace();\n        int Pi = inf.readInt(MIN_Pi, MAX_Pi, \"Pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, r);\n    if (type == \"minFi\") {\n        // Fi = 1\n        for (int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxFi\") {\n        // Fi = 99\n        for (int i = 0; i < n; ++i) {\n            int Fi = 99;\n            int Si = 100;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minPi\") {\n        // Pi = 80\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxPi\") {\n        // Pi = 99\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minSiFiGap\") {\n        // Si = Fi + 1\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = Fi + 1;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxSiFiGap\") {\n        // Si = 100\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = 100;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"resetOptimal\") {\n        // Ensure that resetting is the optimal strategy\n        for (int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = 100;\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"resetNotOptimal\") {\n        // Ensure that not resetting is optimal\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(50, 60);\n            int Si = Fi + rnd.next(1, 5);\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, r);\n    if (type == \"minFi\") {\n        // Fi = 1\n        for (int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxFi\") {\n        // Fi = 99\n        for (int i = 0; i < n; ++i) {\n            int Fi = 99;\n            int Si = 100;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minPi\") {\n        // Pi = 80\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxPi\") {\n        // Pi = 99\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"minSiFiGap\") {\n        // Si = Fi + 1\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = Fi + 1;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"maxSiFiGap\") {\n        // Si = 100\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = 100;\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"resetOptimal\") {\n        // Ensure that resetting is the optimal strategy\n        for (int i = 0; i < n; ++i) {\n            int Fi = 1;\n            int Si = 100;\n            int Pi = 80;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else if (type == \"resetNotOptimal\") {\n        // Ensure that not resetting is optimal\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(50, 60);\n            int Si = Fi + rnd.next(1, 5);\n            int Pi = 99;\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            int Fi = rnd.next(1, 99);\n            int Si = rnd.next(Fi + 1, 100);\n            int Pi = rnd.next(80, 99);\n            printf(\"%d %d %d\\n\", Fi, Si, Pi);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -r 100 -type minFi\n./gen -n 1 -r 100 -type maxFi\n./gen -n 1 -r 100 -type minPi\n./gen -n 1 -r 100 -type maxPi\n./gen -n 1 -r 100 -type minSiFiGap\n./gen -n 1 -r 100 -type maxSiFiGap\n./gen -n 1 -r 100 -type resetOptimal\n./gen -n 1 -r 100 -type resetNotOptimal\n\n./gen -n 10 -r 1000 -type minFi\n./gen -n 10 -r 1000 -type maxFi\n./gen -n 10 -r 1000 -type minPi\n./gen -n 10 -r 1000 -type maxPi\n./gen -n 10 -r 1000 -type minSiFiGap\n./gen -n 10 -r 1000 -type maxSiFiGap\n./gen -n 10 -r 1000 -type resetOptimal\n./gen -n 10 -r 1000 -type resetNotOptimal\n\n./gen -n 1000 -r 100000 -type random\n./gen -n 1000 -r 100000 -type minFi\n./gen -n 1000 -r 100000 -type maxFi\n./gen -n 1000 -r 100000 -type minPi\n./gen -n 1000 -r 100000 -type maxPi\n./gen -n 1000 -r 100000 -type minSiFiGap\n./gen -n 1000 -r 100000 -type maxSiFiGap\n./gen -n 1000 -r 100000 -type resetOptimal\n./gen -n 1000 -r 100000 -type resetNotOptimal\n\n./gen -n 100000 -r 1000000000 -type random\n./gen -n 100000 -r 1000000000 -type minFi\n./gen -n 100000 -r 1000000000 -type maxFi\n./gen -n 100000 -r 1000000000 -type minPi\n./gen -n 100000 -r 1000000000 -type maxPi\n./gen -n 100000 -r 1000000000 -type minSiFiGap\n./gen -n 100000 -r 1000000000 -type maxSiFiGap\n./gen -n 100000 -r 1000000000 -type resetOptimal\n./gen -n 100000 -r 1000000000 -type resetNotOptimal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:26.062531",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "867/E",
      "title": "E. Buy Low Sell High",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput begins with an integer N (2 ≤ N ≤ 3·105), the number of days.Following this is a line with exactly N integers p1, p2, ..., pN (1 ≤ pi ≤ 106). The price of one share of stock on the i-th day is given by pi.",
      "output_spec": "OutputPrint the maximum amount of money you can end up with at the end of N days.",
      "sample_tests": "ExamplesInputCopy910 5 4 7 9 12 6 2 10OutputCopy20InputCopy203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4OutputCopy41",
      "description": "E. Buy Low Sell High\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput begins with an integer N (2 ≤ N ≤ 3·105), the number of days.Following this is a line with exactly N integers p1, p2, ..., pN (1 ≤ pi ≤ 106). The price of one share of stock on the i-th day is given by pi.\n\nOutputPrint the maximum amount of money you can end up with at the end of N days.\n\nInputCopy910 5 4 7 9 12 6 2 10OutputCopy20InputCopy203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4OutputCopy41\n\nInputCopy910 5 4 7 9 12 6 2 10\n\nOutputCopy20\n\nInputCopy203 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4\n\nOutputCopy41\n\nNoteIn the first example, buy a share at 5, buy another at 4, sell one at 9 and another at 12. Then buy at 2 and sell at 10. The total profit is  - 5 - 4 + 9 + 12 - 2 + 10 = 20.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 867 和字母"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(2, 300000, \"N\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(N, 1, 1000000, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(2, 300000, \"N\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(N, 1, 1000000, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(2, 300000, \"N\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(N, 1, 1000000, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> price(n);\n\n    if (type == \"random\") {\n        // Random prices between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            price[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"increasing\") {\n        // Increasing prices from 1 to 1e6\n        int start = rnd.next(1, 1000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            price[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Decreasing prices from 1e6 down to 1\n        int start = rnd.next(n, 1000000);\n        for (int i = 0; i < n; ++i) {\n            price[i] = start - i;\n        }\n    } else if (type == \"equal\") {\n        // All prices are the same\n        int p = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            price[i] = p;\n        }\n    } else if (type == \"peaks\") {\n        // Prices with peaks\n        int p = rnd.next(1, 1000000);\n        bool up = true;\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(1, 1000);\n            if (up) {\n                p += delta;\n                if (p > 1000000) p = 1000000;\n            } else {\n                p -= delta;\n                if (p < 1) p = 1;\n            }\n            price[i] = p;\n            if (rnd.next(0, 3) == 0) up = !up; // Randomly switch direction\n        }\n    } else if (type == \"valleys\") {\n        // Prices with valleys\n        int p = rnd.next(1, 1000000);\n        bool down = true;\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(1, 1000);\n            if (down) {\n                p -= delta;\n                if (p < 1) p = 1;\n            } else {\n                p += delta;\n                if (p > 1000000) p = 1000000;\n            }\n            price[i] = p;\n            if (rnd.next(0, 3) == 0) down = !down; // Randomly switch direction\n        }\n    } else if (type == \"alternate\") {\n        // Prices alternate between high and low\n        int low = rnd.next(1, 500000);\n        int high = rnd.next(500001, 1000000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                price[i] = low;\n            } else {\n                price[i] = high;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            price[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", price[i], (i+1==n)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> price(n);\n\n    if (type == \"random\") {\n        // Random prices between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            price[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"increasing\") {\n        // Increasing prices from 1 to 1e6\n        int start = rnd.next(1, 1000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            price[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Decreasing prices from 1e6 down to 1\n        int start = rnd.next(n, 1000000);\n        for (int i = 0; i < n; ++i) {\n            price[i] = start - i;\n        }\n    } else if (type == \"equal\") {\n        // All prices are the same\n        int p = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            price[i] = p;\n        }\n    } else if (type == \"peaks\") {\n        // Prices with peaks\n        int p = rnd.next(1, 1000000);\n        bool up = true;\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(1, 1000);\n            if (up) {\n                p += delta;\n                if (p > 1000000) p = 1000000;\n            } else {\n                p -= delta;\n                if (p < 1) p = 1;\n            }\n            price[i] = p;\n            if (rnd.next(0, 3) == 0) up = !up; // Randomly switch direction\n        }\n    } else if (type == \"valleys\") {\n        // Prices with valleys\n        int p = rnd.next(1, 1000000);\n        bool down = true;\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(1, 1000);\n            if (down) {\n                p -= delta;\n                if (p < 1) p = 1;\n            } else {\n                p += delta;\n                if (p > 1000000) p = 1000000;\n            }\n            price[i] = p;\n            if (rnd.next(0, 3) == 0) down = !down; // Randomly switch direction\n        }\n    } else if (type == \"alternate\") {\n        // Prices alternate between high and low\n        int low = rnd.next(1, 500000);\n        int high = rnd.next(500001, 1000000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                price[i] = low;\n            } else {\n                price[i] = high;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            price[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", price[i], (i+1==n)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type equal\n./gen -n 2 -type peaks\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type equal\n./gen -n 10 -type peaks\n./gen -n 10 -type valleys\n./gen -n 10 -type alternate\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type equal\n./gen -n 1000 -type peaks\n./gen -n 1000 -type valleys\n./gen -n 1000 -type alternate\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type equal\n./gen -n 100000 -type peaks\n./gen -n 100000 -type valleys\n./gen -n 100000 -type alternate\n./gen -n 300000 -type random\n./gen -n 300000 -type increasing\n./gen -n 300000 -type decreasing\n./gen -n 300000 -type equal\n./gen -n 300000 -type peaks\n./gen -n 300000 -type valleys\n./gen -n 300000 -type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:27.856979",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "867/F",
      "title": "F. Hex Dyslexia",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput will contain a hexadecimal string S consisting only of digits 0 to 9 and lowercase English letters from a to f, with length at most 14. At least one of the characters is non-zero.",
      "output_spec": "OutputIf it is not possible, print \"NO\" (without quotes).Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct.",
      "sample_tests": "ExamplesInputCopyf1eOutputCopyNOInputCopy0f1eOutputCopy00f1InputCopy12d2cOutputCopy00314",
      "description": "F. Hex Dyslexia\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput will contain a hexadecimal string S consisting only of digits 0 to 9 and lowercase English letters from a to f, with length at most 14. At least one of the characters is non-zero.\n\nOutputIf it is not possible, print \"NO\" (without quotes).Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct.\n\nInputCopyf1eOutputCopyNOInputCopy0f1eOutputCopy00f1InputCopy12d2cOutputCopy00314\n\nInputCopyf1e\n\nOutputCopyNO\n\nInputCopy0f1e\n\nOutputCopy00f1\n\nInputCopy12d2c\n\nOutputCopy00314\n\nNoteThe numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of 16, starting with the rightmost digit, which is multiplied by 160. Hexadecimal digits representing values greater than 9 are represented by letters: a = 10, b = 11, c = 12, d = 13, e = 14, f = 15.For example, the numerical value of 0f1e is 0·163 + 15·162 + 1·161 + 14·160 = 3870, the numerical value of 00f1 is 0·163 + 0·162 + 15·161 + 1·160 = 241, and the numerical value of 100f is 1·163 + 0·162 + 0·161 + 15·160 = 4111. Since 3870 + 241 = 4111 and 00f1 is a permutation of 100f, 00f1 is a valid answer to the second test case.",
      "solutions": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces",
          "content": "Hello everyone!The second round of MemSQL Start[c]UP 3.0 will take place this Saturday, September 30, at 10:05am US/Pacific.There will be an onsite round at MemSQL HQ and parallel online rounds that will be open for div1 and div2 participants. The online finalists (placed in top 500 in Round 1) will be given 100 MemSQL Start[c]UP T-shirts.The onsite contestants will be participating from MemSQL HQ using their personal laptops. Breakfast will be served starting at 8:30 am, contest starts at 10:05 am and lunch will be served after the contest. The three winners of the onsite round will be awarded Amazon gift cards for $1000, $500 and $250. Please come early to set everything up.Here is the list of people who agreed to participate: aandrew, al13n, ToTLeS, architkarandikar, Belonogov, BIT-silence, chenmark, farmersrice, Lewin, LiChenKoh, _M_, NgocHai, dkxdjy, Jatana, SaveVMK, scott_wu, sdya, SnapDragon, winger, Aviously, xiaowuc1, yum, yzyz.If you haven't accepted the invitation yet or you think that we missed you, please message MikeMirzayanov or cerealguy.We will update this post with more contest details later.Good luck!UPD: For onsite finalists: you are already registered for the corresponding round. You don't need to register anywhere else. For everybody else: choose the corresponding division round. All rounds will be rated for everybody, and we'll make special standings for the official participants of Round 2 (who placed in top 500 in Round 1).UPD2: All online finalists will be registered in Div. 1 round automatically.UPD3: Huge thanks to round testers: ashmelev, Errichto, cyand1317, vintage_Vlad_Makeev!UPD4: You will be able to see results of offsite finalists using this link.Congratulations to winners!Onsite finalists: scott_wu — $1000 Amazon gift card! Belonogov — $500 Amazon gift card! xiaowuc1 — $250 Amazon gift card! LiChenKoh sdya Other finalists and div. 1: tourist Petr ksun48 halyavin Arterm Div. 2: laizenan PSMao lqs2015 Ahmed_Abdellah kr_abhinav",
          "author": "cerealguy",
          "url": "https://codeforces.com/blog/entry/54821",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1994
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces",
          "content": "867A - Between the OfficesThe answer is \"YES\" if the first character of the given string is 'S' and the last character is 'F', otherwise it's \"NO\". 865A - Save the problem!The simplest solution is to make the denominations always {1, 2}, and set N = 2·A - 1. This provides exactly A ways to make change, because you can choose any number of 2 cent pieces from 0 to A - 1, then the rest must be 1 cent pieces. 865B - Ordering PizzaTo simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi - ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness. 865C - Gotta Go FastLet's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.This modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer. 865D - Buy Low Sell HighLet's introduce the idea of options to the problem. Instead of having to buy stock when it is at a given price, each day you gain the option to buy a share at that days price, which you can exercise at any time in the future. This way we only need to exercise an option in order to sell it, and we never need to \"hold\" any stock.Each day, 2 things happen. First, we get one more option. Second, if there is some option whose price is lower than today's price, we can be sure that we're going to exercise that option. What we don't know is when it's best to sell that option. However, we don't need to know when the best time is to sell - we can just sell it now, but give ourselves the option to buy it back at the price we just sold it for.Options can be stored in a heap since we only ever care about the cheapest one. Running time . 865E - Hex DyslexiaFirst, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.Now let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.To build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|·2|S|).Side note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by is a valid solution, and starts with 0. 865F - Egg RouletteWe can permute any prefix of an ordering containing at most R - 1 'A's or R - 1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R - 1 'A's followed by R - 1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering. To search for canonical forms, we need to consider the remaining 2 * (C + 1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C + 1 turns and right C + 1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness. For each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.The total runtime is O(C * 2C). 865G - Flowers and ChocolateLet's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.Now lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation.Consider the following algorithm for computing the number of ways to make a basket with K chocolates: ways = [1]repeat K times: for i from 1 to B: ways[c_i] += ways[0] ways[0] = 0 ways.pop_front()return ways[0] Now let's define a polynomial . Initially, W(x) = 1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x - K modulo Q(x).The final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x - K coefficient of P(x - 1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/54888",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 867 和字母"
          },
          "content_length": 8110
        }
      ],
      "code_examples": [
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 1",
          "code": "DP(at_which_level, total_time_up_to_this_level)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 2",
          "code": "DP(0,0) is X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 3",
          "code": "onsite finalists need to have some rest and talk before they will be ready for the results revealing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 4",
          "code": "max(a[i], b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 5",
          "code": "a[i] — b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 6",
          "code": "b[i] — a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 7",
          "code": "a[i] > b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 8",
          "code": "a[i] <= b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 9",
          "code": "a[i] — b[i], s[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 - Codeforces - Code 10",
          "code": "max_happiness_ignoring_restriction -  min_regret_of_the_two_possibilities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54821",
          "author": "cerealguy"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 1",
          "code": "ways = [1]repeat K times:    for i from 1 to B:        ways[c_i] += ways[0]    ways[0] = 0    ways.pop_front()return ways[0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 2",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 3",
          "code": "If(y < x) {\n if(y came from unused set) buy y and sell x.\n else if(y came from \"already sold\" set) put y in unused set and sell x.\n}\nelse put \"x\" in unused set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 4",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 5",
          "code": "if (i+S[j] <= R) \n{\n    play += (S[j] + EXP[j+1][i+S[j]]) * (1-P[j]);\n} \nelse \n{\n    play += (S[j] + ans) * (1-P[j]);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 7",
          "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <cassert>\n\n#define INFLL 2000000000000000000\n#define INF 2000000000\n#define MOD 1000000007\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef vector <ll> vll;\n\nstruct Level {\n\tint a;\n\tint b;\n\tdouble p;\n};\n\nint n, r;\nLevel arr[50];\ndouble p[51][5001];\ndouble good[51][5001];\ndouble sums[51][5001];\ndouble back, con;\ndouble dp[51][5001];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> r;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i].a >> arr[i].b >> arr[i].p;\n\t\tarr[i].p /= 100.0;\n\t}\n\tp[n][0] = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j + arr[i].a <= 5000) p[i][j + arr[i].a] += p[i + 1][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) p[i][j + arr[i].b] += p[i + 1][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tsums[i][0] = p[i][0];\n\t\tfor (int j = 1; j <= 5000; j++) sums[i][j] = sums[i][j - 1] + p[i][j];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= r; j++) {\n\t\t\tgood[i][j] = sums[i][r - j];\n\t\t}\n\t}\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) {\n\t\t\tif (j > r) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (good[i][j] < good[0][0]) {\n\t\t\t\tback += dp[i][j];\n\t\t\t\tcon += dp[i][j] * j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + arr[i].a <= 5000)\n\t\t\t\tdp[i + 1][j + arr[i].a] += dp[i][j] * arr[i].p;\n\t\t\tif (j + arr[i].b <= 5000) \n\t\t\t\tdp[i + 1][j + arr[i].b] += dp[i][j] * (1 - arr[i].p);\n\t\t}\n\t}\n\tfor (int i = 0; i <= r; i++) \n\t\tcon += dp[n][i] * i;\n\tfor (int i = r + 1; i <= 5000; i++) {\n\t\tcon += dp[n][i] * i; \n\t\tback += dp[n][i];\n\t}\t\n\tprintf(\"%.15f\\n\", con / (1 - back));\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 8",
          "code": "it is optimal to go to the start every time when p[i][t] < p[0][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        },
        {
          "title": "MemSQL Start[c]UP 3.0 Round 2 Editorial - Codeforces - Code 10",
          "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <utility>      // std::pair, std::make_pair\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nbool comp(pll a, pll b) {\n    return a.first >= b.first;\n}\n\n// x is number of pieces to consume\nll findBest(vector<pll> &ps, ll x) {\n    ll res = 0;\n    for (ll i = 0; i < ps.size(); i++) {\n        ll num = ps[i].second;\n        ll diff = ps[i].first;\n        if (x - num >= 0) {\n            res += (num * diff);\n            x -= num;\n        } else {\n            res += (x * diff);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    ll n, s;\n    cin >> n >> s;\n    vector<pll> ps;\n    ll total = 0;\n    ll positives = 0;\n    ll pieces = 0; // overall pieces\n    for (ll i = 0; i < n; i++) {\n        ll num, a, b;\n        cin >> num >> a >> b;\n        ps.push_back(make_pair(a-b, num));\n        total += num * b;\n        pieces += num;\n        if (a-b > 0) {\n            positives += num;\n        }\n    }\n    sort(ps.begin(), ps.end(), comp);\n    ll pizzas = (pieces % s == 0) ? (pieces / s) : (pieces / s + 1);\n    ll extra = pizzas * s - pieces;\n\n    ll best = total;\n    if (positives > 0) {\n        best = max(best, findBest(ps, positives / s * s) + total);\n        if (positives % s != 0) {\n            ll x = max(positives, (positives/s + 1) * s - extra);\n            best = max(best, findBest(ps, x) + total);\n        }\n    }\n    cout << best << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/54888",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read S, ensure it consists of 1 to 14 characters from 0-9 or a-f\n    string s = inf.readToken(\"[0-9a-f]{1,14}\", \"s\");\n\n    // Expect end of line\n    inf.readEoln();\n\n    // Check that at least one character is non-zero\n    bool has_non_zero = false;\n    for (char c : s) {\n        if (c != '0') {\n            has_non_zero = true;\n            break;\n        }\n    }\n    ensuref(has_non_zero, \"At least one of the characters in s must be non-zero\");\n\n    // Ensure no extra input\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read S, ensure it consists of 1 to 14 characters from 0-9 or a-f\n    string s = inf.readToken(\"[0-9a-f]{1,14}\", \"s\");\n\n    // Expect end of line\n    inf.readEoln();\n\n    // Check that at least one character is non-zero\n    bool has_non_zero = false;\n    for (char c : s) {\n        if (c != '0') {\n            has_non_zero = true;\n            break;\n        }\n    }\n    ensuref(has_non_zero, \"At least one of the characters in s must be non-zero\");\n\n    // Ensure no extra input\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read S, ensure it consists of 1 to 14 characters from 0-9 or a-f\n    string s = inf.readToken(\"[0-9a-f]{1,14}\", \"s\");\n\n    // Expect end of line\n    inf.readEoln();\n\n    // Check that at least one character is non-zero\n    bool has_non_zero = false;\n    for (char c : s) {\n        if (c != '0') {\n            has_non_zero = true;\n            break;\n        }\n    }\n    ensuref(has_non_zero, \"At least one of the characters in s must be non-zero\");\n\n    // Ensure no extra input\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random hexadecimal string of length n, at least one non-zero character.\n        s = \"\";\n        bool has_nonzero = false;\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 15);\n            if (digit > 0) has_nonzero = true;\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n        if (!has_nonzero) {\n            // Ensure at least one non-zero digit\n            int pos = rnd.next(0, n - 1);\n            int digit = rnd.next(1, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s[pos] = c;\n        }\n    } else if (type == \"max_value\") {\n        // Generate a string of length n filled with 'f's\n        s = string(n, 'f');\n    } else if (type == \"leading_zero\") {\n        // Generate a string with leading zeros\n        s = \"\";\n        int num_leading_zeros = rnd.next(1, n - 1);\n        s += string(num_leading_zeros, '0');\n        // Remaining digits\n        for (int i = num_leading_zeros; i < n; ++i) {\n            int digit = rnd.next(1, 15); // Non-zero digits\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n    } else if (type == \"minimal_non_zero\") {\n        // Generate a string with only one non-zero digit\n        s = string(n, '0');\n        int pos = rnd.next(0, n - 1);\n        int digit = rnd.next(1, 15);\n        char c;\n        if (digit < 10) c = '0' + digit;\n        else c = 'a' + digit - 10;\n        s[pos] = c;\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome string\n        s = \"\";\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            int digit = rnd.next(0, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n        // Create the mirrored part\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            s += s[i];\n        }\n        // Ensure at least one non-zero character\n        bool has_nonzero = false;\n        for (char c : s)\n            if (c != '0')\n                has_nonzero = true;\n        if (!has_nonzero) {\n            // Ensure at least one non-zero digit\n            int pos = rnd.next(0, n - 1);\n            int digit = rnd.next(1, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s[pos] = c;\n        }\n    } else if (type == \"same_digit\") {\n        // Generate a string with the same digit repeated\n        int digit = rnd.next(1, 15);\n        char c;\n        if (digit < 10) c = '0' + digit;\n        else c = 'a' + digit - 10;\n        s = string(n, c);\n    } else {\n        // Default to random\n        s = \"\";\n        bool has_nonzero = false;\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 15);\n            if (digit > 0) has_nonzero = true;\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n        if (!has_nonzero) {\n            // Ensure at least one non-zero digit\n            int pos = rnd.next(0, n - 1);\n            int digit = rnd.next(1, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s[pos] = c;\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random hexadecimal string of length n, at least one non-zero character.\n        s = \"\";\n        bool has_nonzero = false;\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 15);\n            if (digit > 0) has_nonzero = true;\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n        if (!has_nonzero) {\n            // Ensure at least one non-zero digit\n            int pos = rnd.next(0, n - 1);\n            int digit = rnd.next(1, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s[pos] = c;\n        }\n    } else if (type == \"max_value\") {\n        // Generate a string of length n filled with 'f's\n        s = string(n, 'f');\n    } else if (type == \"leading_zero\") {\n        // Generate a string with leading zeros\n        s = \"\";\n        int num_leading_zeros = rnd.next(1, n - 1);\n        s += string(num_leading_zeros, '0');\n        // Remaining digits\n        for (int i = num_leading_zeros; i < n; ++i) {\n            int digit = rnd.next(1, 15); // Non-zero digits\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n    } else if (type == \"minimal_non_zero\") {\n        // Generate a string with only one non-zero digit\n        s = string(n, '0');\n        int pos = rnd.next(0, n - 1);\n        int digit = rnd.next(1, 15);\n        char c;\n        if (digit < 10) c = '0' + digit;\n        else c = 'a' + digit - 10;\n        s[pos] = c;\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome string\n        s = \"\";\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            int digit = rnd.next(0, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n        // Create the mirrored part\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            s += s[i];\n        }\n        // Ensure at least one non-zero character\n        bool has_nonzero = false;\n        for (char c : s)\n            if (c != '0')\n                has_nonzero = true;\n        if (!has_nonzero) {\n            // Ensure at least one non-zero digit\n            int pos = rnd.next(0, n - 1);\n            int digit = rnd.next(1, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s[pos] = c;\n        }\n    } else if (type == \"same_digit\") {\n        // Generate a string with the same digit repeated\n        int digit = rnd.next(1, 15);\n        char c;\n        if (digit < 10) c = '0' + digit;\n        else c = 'a' + digit - 10;\n        s = string(n, c);\n    } else {\n        // Default to random\n        s = \"\";\n        bool has_nonzero = false;\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 15);\n            if (digit > 0) has_nonzero = true;\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s += c;\n        }\n        if (!has_nonzero) {\n            // Ensure at least one non-zero digit\n            int pos = rnd.next(0, n - 1);\n            int digit = rnd.next(1, 15);\n            char c;\n            if (digit < 10) c = '0' + digit;\n            else c = 'a' + digit - 10;\n            s[pos] = c;\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 6 -type random\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 9 -type random\n./gen -n 10 -type random\n./gen -n 11 -type random\n./gen -n 12 -type random\n./gen -n 13 -type random\n./gen -n 14 -type random\n\n./gen -n 14 -type max_value\n\n./gen -n 14 -type leading_zero\n./gen -n 3 -type leading_zero\n./gen -n 5 -type leading_zero\n\n./gen -n 14 -type minimal_non_zero\n./gen -n 1 -type minimal_non_zero\n./gen -n 2 -type minimal_non_zero\n\n./gen -n 14 -type palindrome\n./gen -n 1 -type palindrome\n./gen -n 3 -type palindrome\n./gen -n 5 -type palindrome\n\n./gen -n 14 -type same_digit\n./gen -n 1 -type same_digit\n./gen -n 2 -type same_digit\n./gen -n 3 -type same_digit\n\n./gen -n 7 -type random\n./gen -n 14 -type random\n./gen -n 14 -type random\n\n./gen -n 1 -type max_value\n./gen -n 5 -type max_value\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:42:30.117182",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}