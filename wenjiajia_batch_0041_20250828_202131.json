{
  "metadata": {
    "batch_number": 41,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 4200,
    "created_at": "2025-08-28T20:21:31.881028",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "379/E",
      "title": "E. New Year Tree Decorations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and k (1 ≤ n, k ≤ 300). Each of the following n lines contains k + 1 integers — the description of the polyline. If the i-th line contains ontegers yi, 0, yi, 1, ..., yi, k, that means that the polyline of the i-th piece goes through points (0, 0), (0, yi, 0), (1, yi, 1), (2, yi, 2), ..., (k, yi, k), (k, 0) (1 ≤ yi, j ≤ 1000).",
      "output_spec": "OutputPrint n real numbers — for each polyline, the area of its visible part.The answer will be considered correct if its relative or absolute error do not exceed 10 - 4.",
      "sample_tests": "ExamplesInputCopy2 22 1 21 2 1OutputCopy3.0000000000000.500000000000InputCopy1 11 1OutputCopy1.000000000000InputCopy4 12 77 25 56 4OutputCopy4.5000000000001.2500000000000.0500000000000.016666666667",
      "description": "E. New Year Tree Decorations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and k (1 ≤ n, k ≤ 300). Each of the following n lines contains k + 1 integers — the description of the polyline. If the i-th line contains ontegers yi, 0, yi, 1, ..., yi, k, that means that the polyline of the i-th piece goes through points (0, 0), (0, yi, 0), (1, yi, 1), (2, yi, 2), ..., (k, yi, k), (k, 0) (1 ≤ yi, j ≤ 1000).\n\nOutputPrint n real numbers — for each polyline, the area of its visible part.The answer will be considered correct if its relative or absolute error do not exceed 10 - 4.\n\nInputCopy2 22 1 21 2 1OutputCopy3.0000000000000.500000000000InputCopy1 11 1OutputCopy1.000000000000InputCopy4 12 77 25 56 4OutputCopy4.5000000000001.2500000000000.0500000000000.016666666667\n\nInputCopy2 22 1 21 2 1\n\nOutputCopy3.0000000000000.500000000000\n\nInputCopy1 11 1\n\nOutputCopy1.000000000000\n\nInputCopy4 12 77 25 56 4\n\nOutputCopy4.5000000000001.2500000000000.0500000000000.016666666667",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*E"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 300, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> y = inf.readInts(k + 1, 1, 1000, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 300, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> y = inf.readInts(k + 1, 1, 1000, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 300, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> y = inf.readInts(k + 1, 1, 1000, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    n = max(1, min(300, n));\n    k = max(1, min(300, k));\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = rnd.next(1, 1000);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"max\") {\n        n = 300;\n        k = 300;\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = 1000;\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"min\") {\n        n = 1;\n        k = 1;\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = 1;\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"identical\") {\n        int val = opt<int>(\"val\", 500);\n        val = max(1, min(1000, val));\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = val;\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"increasing\") {\n        int base_value = opt<int>(\"base\", 1);\n        int delta_i = opt<int>(\"delta_i\", 1);\n        int delta_j = opt<int>(\"delta_j\", 1);\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = base_value + i*delta_i + j*delta_j;\n                y = min(y, 1000);\n                y = max(y, 1);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"decreasing\") {\n        int base_value = opt<int>(\"base\", 1000);\n        int delta_i = opt<int>(\"delta_i\", 1);\n        int delta_j = opt<int>(\"delta_j\", 1);\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = base_value - i*delta_i - j*delta_j;\n                y = max(y, 1);\n                y = min(y, 1000);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"alternate\") {\n        int val1 = opt<int>(\"val1\", 1000);\n        int val2 = opt<int>(\"val2\", 1);\n        val1 = max(1, min(1000, val1));\n        val2 = max(1, min(1000, val2));\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y;\n                if ((i + j) % 2 == 0) {\n                    y = val1;\n                } else {\n                    y = val2;\n                }\n                y = max(1, min(1000, y));\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else {\n        // Default to random\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = rnd.next(1, 1000);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    n = max(1, min(300, n));\n    k = max(1, min(300, k));\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = rnd.next(1, 1000);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"max\") {\n        n = 300;\n        k = 300;\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = 1000;\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"min\") {\n        n = 1;\n        k = 1;\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = 1;\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"identical\") {\n        int val = opt<int>(\"val\", 500);\n        val = max(1, min(1000, val));\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = val;\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"increasing\") {\n        int base_value = opt<int>(\"base\", 1);\n        int delta_i = opt<int>(\"delta_i\", 1);\n        int delta_j = opt<int>(\"delta_j\", 1);\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = base_value + i*delta_i + j*delta_j;\n                y = min(y, 1000);\n                y = max(y, 1);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"decreasing\") {\n        int base_value = opt<int>(\"base\", 1000);\n        int delta_i = opt<int>(\"delta_i\", 1);\n        int delta_j = opt<int>(\"delta_j\", 1);\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = base_value - i*delta_i - j*delta_j;\n                y = max(y, 1);\n                y = min(y, 1000);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"alternate\") {\n        int val1 = opt<int>(\"val1\", 1000);\n        int val2 = opt<int>(\"val2\", 1);\n        val1 = max(1, min(1000, val1));\n        val2 = max(1, min(1000, val2));\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y;\n                if ((i + j) % 2 == 0) {\n                    y = val1;\n                } else {\n                    y = val2;\n                }\n                y = max(1, min(1000, y));\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    } else {\n        // Default to random\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int y = rnd.next(1, 1000);\n                printf(\"%d\", y);\n                if (j < k) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type min\n./gen -n 300 -k 300 -type max\n./gen -n 100 -k 100 -type random\n\n./gen -n 10 -k 10 -type identical -val 500\n./gen -n 10 -k 10 -type identical -val 1000\n./gen -n 10 -k 10 -type identical -val 1\n\n./gen -n 50 -k 50 -type increasing -base 1 -delta_i 1 -delta_j 1\n./gen -n 50 -k 50 -type increasing -base 1 -delta_i 5 -delta_j 5\n./gen -n 50 -k 50 -type decreasing -base 1000 -delta_i 1 -delta_j 1\n./gen -n 50 -k 50 -type decreasing -base 1000 -delta_i 5 -delta_j 5\n\n./gen -n 50 -k 50 -type alternate -val1 1000 -val2 1\n./gen -n 50 -k 50 -type alternate -val1 500 -val2 500\n\n./gen -n 300 -k 1 -type random\n./gen -n 1 -k 300 -type random\n./gen -n 300 -k 300 -type random\n\n./gen -n 200 -k 200 -type random\n./gen -n 300 -k 10 -type increasing -base 1 -delta_i 1 -delta_j 10\n./gen -n 300 -k 10 -type decreasing -base 1000 -delta_i 1 -delta_j 10\n\n./gen -n 10 -k 300 -type random\n\n./gen -n 5 -k 5 -type identical -val 999\n./gen -n 5 -k 5 -type identical -val 2\n\n./gen -n 299 -k 299 -type increasing -base 1 -delta_i 2 -delta_j 3\n./gen -n 298 -k 298 -type decreasing -base 1000 -delta_i 2 -delta_j 3\n\n./gen -n 150 -k 150 -type random\n\n./gen -n 50 -k 200 -type random\n\n./gen -n 200 -k 50 -type random\n\n./gen -n 100 -k 100 -type random\n\n./gen -n 100 -k 100 -type increasing -base 1 -delta_i 0 -delta_j 0\n\n./gen -n 90 -k 90 -type decreasing -base 1000 -delta_i 0 -delta_j 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:55.341875",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "379/F",
      "title": "F. New Year Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer q (1 ≤ q ≤ 5·105) — the number of operations. Each of the next q lines contains integer vi (1 ≤ vi ≤ n) — the operation of adding leaves to vertex vi. Variable n represents the number of vertices in the current tree.It is guaranteed that all given operations are correct.",
      "output_spec": "OutputPrint q integers — the diameter of the current tree after each operation.",
      "sample_tests": "ExamplesInputCopy523485OutputCopy34456",
      "description": "F. New Year Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer q (1 ≤ q ≤ 5·105) — the number of operations. Each of the next q lines contains integer vi (1 ≤ vi ≤ n) — the operation of adding leaves to vertex vi. Variable n represents the number of vertices in the current tree.It is guaranteed that all given operations are correct.\n\nOutputPrint q integers — the diameter of the current tree after each operation.\n\nInputCopy523485OutputCopy34456\n\nInputCopy523485\n\nOutputCopy34456",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*F"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000005;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    // Initialize degrees\n    vector<int> degree(MAX_N, 0);\n    int n = 4; // initial number of nodes\n    degree[1]=3;\n    degree[2]=1;\n    degree[3]=1;\n    degree[4]=1;\n\n    for(int i = 0; i < q; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(degree[vi]==1, \"Operation %d: vi=%d is not a leaf\", i+1, vi);\n\n        // Add two new nodes n+1 and n+2, connected to vi\n        // Update degrees\n        degree[vi] += 2;\n        if (n+2 >= MAX_N) {\n            quitf(_fail, \"Number of nodes exceeds the limit\");\n        }\n        // New nodes will have degree 1\n        degree[n+1] = 1;\n        degree[n+2] = 1;\n        n +=2;\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000005;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    // Initialize degrees\n    vector<int> degree(MAX_N, 0);\n    int n = 4; // initial number of nodes\n    degree[1]=3;\n    degree[2]=1;\n    degree[3]=1;\n    degree[4]=1;\n\n    for(int i = 0; i < q; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(degree[vi]==1, \"Operation %d: vi=%d is not a leaf\", i+1, vi);\n\n        // Add two new nodes n+1 and n+2, connected to vi\n        // Update degrees\n        degree[vi] += 2;\n        if (n+2 >= MAX_N) {\n            quitf(_fail, \"Number of nodes exceeds the limit\");\n        }\n        // New nodes will have degree 1\n        degree[n+1] = 1;\n        degree[n+2] = 1;\n        n +=2;\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000005;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    // Initialize degrees\n    vector<int> degree(MAX_N, 0);\n    int n = 4; // initial number of nodes\n    degree[1]=3;\n    degree[2]=1;\n    degree[3]=1;\n    degree[4]=1;\n\n    for(int i = 0; i < q; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(degree[vi]==1, \"Operation %d: vi=%d is not a leaf\", i+1, vi);\n\n        // Add two new nodes n+1 and n+2, connected to vi\n        // Update degrees\n        degree[vi] += 2;\n        if (n+2 >= MAX_N) {\n            quitf(_fail, \"Number of nodes exceeds the limit\");\n        }\n        // New nodes will have degree 1\n        degree[n+1] = 1;\n        degree[n+2] = 1;\n        n +=2;\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the command-line arguments\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = 4;  // initial number of nodes\n\n    // Initialize leaf_nodes to {2, 3, 4}\n    vector<int> leaf_nodes = {2, 3, 4};\n    unordered_map<int, int> index_map;  // node value -> index in leaf_nodes\n    for (int i = 0; i < (int)leaf_nodes.size(); ++i) {\n        index_map[leaf_nodes[i]] = i;\n    }\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int vi;\n\n        if (type == \"random\") {\n            // Select a random leaf\n            int idx = rnd.next((int)leaf_nodes.size());\n            vi = leaf_nodes[idx];\n        } else if (type == \"same\") {\n            // Always select the same leaf (the first one)\n            vi = leaf_nodes[0];\n        } else if (type == \"last\") {\n            // Always select the last added leaf\n            vi = leaf_nodes.back();\n        } else if (type == \"alternate\") {\n            // Alternate between the first and the last leaf\n            if (i % 2 == 0)\n                vi = leaf_nodes[0];\n            else\n                vi = leaf_nodes.back();\n        } else if (type == \"deep\") {\n            // Select the last added leaf to create depth\n            vi = leaf_nodes.back();\n        } else if (type == \"shallow\") {\n            // Always select the initial leaf to keep the tree shallow\n            vi = leaf_nodes[0];\n        } else {\n            // Default to random selection\n            int idx = rnd.next((int)leaf_nodes.size());\n            vi = leaf_nodes[idx];\n        }\n\n        printf(\"%d\\n\", vi);\n\n        // Remove vi from leaf_nodes efficiently\n        int idx = index_map[vi];\n        int last = leaf_nodes.back();\n        leaf_nodes[idx] = last;\n        index_map[last] = idx;\n        leaf_nodes.pop_back();\n        index_map.erase(vi);\n\n        // Add new nodes n + 1 and n + 2 as new leaves\n        n += 2;\n\n        leaf_nodes.push_back(n - 1);\n        index_map[n - 1] = leaf_nodes.size() - 1;\n        leaf_nodes.push_back(n);\n        index_map[n] = leaf_nodes.size() - 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the command-line arguments\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = 4;  // initial number of nodes\n\n    // Initialize leaf_nodes to {2, 3, 4}\n    vector<int> leaf_nodes = {2, 3, 4};\n    unordered_map<int, int> index_map;  // node value -> index in leaf_nodes\n    for (int i = 0; i < (int)leaf_nodes.size(); ++i) {\n        index_map[leaf_nodes[i]] = i;\n    }\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int vi;\n\n        if (type == \"random\") {\n            // Select a random leaf\n            int idx = rnd.next((int)leaf_nodes.size());\n            vi = leaf_nodes[idx];\n        } else if (type == \"same\") {\n            // Always select the same leaf (the first one)\n            vi = leaf_nodes[0];\n        } else if (type == \"last\") {\n            // Always select the last added leaf\n            vi = leaf_nodes.back();\n        } else if (type == \"alternate\") {\n            // Alternate between the first and the last leaf\n            if (i % 2 == 0)\n                vi = leaf_nodes[0];\n            else\n                vi = leaf_nodes.back();\n        } else if (type == \"deep\") {\n            // Select the last added leaf to create depth\n            vi = leaf_nodes.back();\n        } else if (type == \"shallow\") {\n            // Always select the initial leaf to keep the tree shallow\n            vi = leaf_nodes[0];\n        } else {\n            // Default to random selection\n            int idx = rnd.next((int)leaf_nodes.size());\n            vi = leaf_nodes[idx];\n        }\n\n        printf(\"%d\\n\", vi);\n\n        // Remove vi from leaf_nodes efficiently\n        int idx = index_map[vi];\n        int last = leaf_nodes.back();\n        leaf_nodes[idx] = last;\n        index_map[last] = idx;\n        leaf_nodes.pop_back();\n        index_map.erase(vi);\n\n        // Add new nodes n + 1 and n + 2 as new leaves\n        n += 2;\n\n        leaf_nodes.push_back(n - 1);\n        index_map[n - 1] = leaf_nodes.size() - 1;\n        leaf_nodes.push_back(n);\n        index_map[n] = leaf_nodes.size() - 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -q 1 -type random\n./gen -q 1 -type same\n./gen -q 1 -type last\n./gen -q 1 -type deep\n./gen -q 1 -type shallow\n\n./gen -q 5 -type random\n./gen -q 5 -type alternate\n./gen -q 5 -type deep\n./gen -q 5 -type shallow\n\n./gen -q 10 -type random\n./gen -q 10 -type same\n./gen -q 10 -type alternate\n./gen -q 10 -type deep\n./gen -q 10 -type shallow\n\n./gen -q 1000 -type random\n./gen -q 1000 -type same\n./gen -q 1000 -type last\n./gen -q 1000 -type alternate\n./gen -q 1000 -type deep\n./gen -q 1000 -type shallow\n\n./gen -q 50000 -type random\n./gen -q 50000 -type same\n./gen -q 50000 -type alternate\n./gen -q 50000 -type deep\n./gen -q 50000 -type shallow\n\n./gen -q 123456 -type random\n./gen -q 123456 -type alternate\n./gen -q 123456 -type same\n\n./gen -q 200000 -type random\n\n./gen -q 500000 -type random\n./gen -q 500000 -type same\n./gen -q 500000 -type last\n./gen -q 500000 -type alternate\n./gen -q 500000 -type deep\n./gen -q 500000 -type shallow\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:57.361131",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "379/G",
      "title": "G. New Year Cactus",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 2500, n - 1 ≤ m) — the number of vertices and the number of edges, correspondingly. The next m lines contain two integers a, b each (1 ≤ a, b ≤ n, a ≠ b) that mean that there is an edge connecting vertices a и b. Any pair of vertices has at most one edge between them.",
      "output_spec": "OutputThe first line must contain space-separated ba (for all 0 ≤ a ≤ n) where ba equals the maximum number of Jill's toys on the cactus considering that it has a Jack's toys. Numbers ba go in the order of increasing a.",
      "sample_tests": "ExamplesInputCopy1 0OutputCopy1 0 InputCopy16 201 23 45 66 77 89 1010 1111 1213 1415 161 59 1314 1010 66 215 1111 77 316 128 4OutputCopy16 13 12 12 10 8 8 7 6 4 4 3 3 1 0 0 0",
      "description": "G. New Year Cactus\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 2500, n - 1 ≤ m) — the number of vertices and the number of edges, correspondingly. The next m lines contain two integers a, b each (1 ≤ a, b ≤ n, a ≠ b) that mean that there is an edge connecting vertices a и b. Any pair of vertices has at most one edge between them.\n\nOutputThe first line must contain space-separated ba (for all 0 ≤ a ≤ n) where ba equals the maximum number of Jill's toys on the cactus considering that it has a Jack's toys. Numbers ba go in the order of increasing a.\n\nInputCopy1 0OutputCopy1 0 InputCopy16 201 23 45 66 77 89 1010 1111 1213 1415 161 59 1314 1010 66 215 1111 77 316 128 4OutputCopy16 13 12 12 10 8 8 7 6 4 4 3 3 1 0 0 0\n\nInputCopy1 0\n\nOutputCopy1 0\n\nInputCopy16 201 23 45 66 77 89 1010 1111 1213 1415 161 59 1314 1010 66 215 1111 77 316 128 4\n\nOutputCopy16 13 12 12 10 8 8 7 6 4 4 3 3 1 0 0 0\n\nNoteThe cactus from the second example is:",
      "solutions": [
        {
          "title": "Good Bye 2013 - Codeforces",
          "content": "Good day)Welcome to the last Codeforces round in this year Good Bye 2013. This round will be unusual because it will be common for participants of both divisions.The problems were prepared by authors Gerald Agapov (Gerald) and Svechnikov Artur (ikar). Pavel Kholkin (HolkinPV) and Vitaly Aksenov (Aksenov239) also help us to prepare the problems. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution is similar to standard — 500-1000-1500-2000-2500-3000-3500UPD2: Thanks to all participants, we hope everyone enjoyed prepared tasks. Problem analysis. UPD3: Congratulations to the winners of the last round in this year. Rating will be changed in a few hours.1. BaconLi2. Egor3. liympanda We wish everyone good luck, high rating and excellent mood)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10161",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 868
        },
        {
          "title": "Tutorial Good Bye 2013 - Codeforces",
          "content": "Excuse me for my english, but I tried very hard to.=)A: 379A - New Year CandlesLet cura amount of new candles, curb — amount of burnt out. Initially cura = a, curb = 0, after burning all cura new candles, amount of hours incremented by cura and curb +  = cura, lets make all burnt out candles into new cura = curb / b , repeat this algorithm until we can make at least one new candle. #### B: 379B - New Year Present If wallet contains more then one coin, then between orders to \"put a coin\" we can orders to move to adjacent wallet then back. Since for each orders to \"put a coin\" we spend at most 2 other orders, number of total orders for maximum test equals 300 * 300 * 3 = 270000 it less then 106.C: 379C - New Year Ratings ChangeWe can to sort ratings in nondecrease order, then iterate by them we can keep minimal rating not used before. If ai > cur, i's user recieve ai of rating and cur = ai + 1, else ai ≤ cur then i's user recieve cur of rating and cur increased by one. D: 379D - New Year LetterWe can't fairly calculate sk because of length of this string which can be very large. But note that whole string not need, we just need number of AC substrings, first and last letter. That help us to easy calculate number AC substrings for any sk for some s1, s2. Let's iterate through s1, s2 using alphabet of A, C, and any other letter. We need just first and last letter and number of AC. Using some s1, s2 we can calculate sk.E: 379E - New Year Tree DecorationsLet's keep union of first i pieces, S(i) denote the area of union for the first i pieces. Then to know visible part of i's piece we need to calculate S(i) - S(i - 1), (Unable to parse markup [type=CF_TEX] and with end at x = 1. Union looks like a downward convex polyline, lets represent it sequence of points, adjacent are connected. So calculate i's union, if new union will be contains new segment, this segment must intersects two segments of union, this intersection we can calculate for the amount of points in union. All points lower than new segment must be erased from union. Because each segment can add at most one point in union calculating of one range is O(n2).F: 379F - New Year TreeComing soon.G: 379G - New Year CactusThis problem can be solved for tree by using of dynamic programming d[v][c][a], where v — vertex, c — type of vertex(whose toys are hanged or nothing are hanged there), a — number of toys hanged by Jack for this subtree, d[v][c][a] denote of maximum number of toys which can be hanged by Jill. Value d[v][c][a] can be calculated iterated through sons of v vertext and type of these vertices. Let's compress our cactus into tree by compressing each cycle into vertex. Vertex of tree will be looks like sequence of vertex from cactus which have edges not from this cycle and intermediates that belongs only to this cycle. Now we can calculate all d[v][c][a] for this tree but we must be carefully processing a vertices.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10171",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 379\\s*G"
          },
          "content_length": 2925
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2013 - Codeforces - Code 1",
          "code": "while (vet[u] <= l) ++vet[u];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 2",
          "code": "while(v[i].a<=v[i-1].a) v[i].a++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 3",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 4",
          "code": "300000\n1000000000 1 1 1 ... 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 5",
          "code": "Codeforces Round",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 6",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 7",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 8",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 9",
          "code": "162,171c162,167\n<           if col = 1 then begin\n<             if dp[col][v][cn + 1] < val1 then\n<               dp[col][v][cn + 1] := val1;\n<           end else if col = 0 then begin\n<             if dp[col][v][cn] < val1 then\n<               dp[col][v][cn] := val1\n<           end else begin\n<             if dp[col][v][cn] < val1 + 1 then\n<               dp[col][v][cn] := val1 + 1;\n<           end;\n---\n>           if col = 1 then\n>             dp[col][v][cn + 1] := val1\n>           else if col = 0 then\n>             dp[col][v][cn] := val1\n>           else\n>             dp[col][v][cn] := val1 + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 10",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 11",
          "code": "while (a[i] < a[x]) i++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 12",
          "code": "a[i] < a[x]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 13",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 14",
          "code": "bool cmp (  rating a  ,rating b )\n{\n\tif( a.rate > b.rate )\n\t\t\treturn 0 ;\n\treturn 1 ;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2013 - Codeforces - Code 15",
          "code": "Happy New Year!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10161",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2500;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1); // Indexing vertices from 1 to n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_\" + vtos(i + 1));\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_\" + vtos(i + 1));\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected on edge %d: (%d, %d)\", i + 1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edgeSet.count({ u, v }) == 0, \"Multiple edge detected between %d and %d\", u, v);\n        edgeSet.insert({ u, v });\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that the graph is connected\n    vector<bool> visited(n + 1, false); // Indexing vertices from 1 to n\n\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int cnt = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                cnt++;\n                q.push(v);\n            }\n        }\n    }\n    ensuref(cnt == n, \"The graph is not connected\");\n\n    // Now check that the graph is a cactus\n    // Implement Tarjan's algorithm to find biconnected components\n    vector<int> disc(n + 1, -1);\n    vector<int> low(n + 1, -1);\n    vector<int> parent(n + 1, -1);\n    stack<pair<int, int>> edgeStack;\n    int time = 0;\n\n    vector<vector<pair<int, int>>> biconnComponents;\n\n    // Function to convert integer to string (vtos)\n    auto vtos = [](int v) {\n        char buf[20];\n        sprintf(buf, \"%d\", v);\n        return string(buf);\n    };\n\n    function<void(int)> dfs = [&](int u) {\n        disc[u] = low[u] = ++time;\n        int children = 0;\n        for (int v : adj[u]) {\n            if (disc[v] == -1) {\n                parent[v] = u;\n                edgeStack.push({ u, v });\n                dfs(v);\n\n                low[u] = min(low[u], low[v]);\n\n                if ((disc[u] == 1 && ++children > 1) || (disc[u] > 1 && low[v] >= disc[u])) {\n                    // Found a biconnected component\n                    vector<pair<int, int>> component;\n                    pair<int, int> e;\n                    do {\n                        e = edgeStack.top(); edgeStack.pop();\n                        component.push_back(e);\n                    } while (!((e.first == u && e.second == v) || (e.first == v && e.second == u)));\n                    biconnComponents.push_back(component);\n                }\n            }\n            else if (v != parent[u] && disc[v] < disc[u]) {\n                // Back edge\n                low[u] = min(low[u], disc[v]);\n                edgeStack.push({ u, v });\n            }\n        }\n    };\n\n    dfs(1);\n\n    // There may be remaining edges in the stack\n    if (!edgeStack.empty()) {\n        vector<pair<int, int>> component;\n        while (!edgeStack.empty()) {\n            component.push_back(edgeStack.top());\n            edgeStack.pop();\n        }\n        biconnComponents.push_back(component);\n    }\n\n    // Check each biconnected component\n    for (const auto& component : biconnComponents) {\n        // Collect nodes and their degrees\n        set<int> nodes;\n        map<int, int> degree;\n        for (const auto& edge : component) {\n            int u = edge.first;\n            int v = edge.second;\n            nodes.insert(u);\n            nodes.insert(v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        if (component.size() == 1) {\n            // It's a bridge\n            continue;\n        }\n        else {\n            // Check if all nodes have degree 2\n            bool isCycle = true;\n            for (int node : nodes) {\n                if (degree[node] != 2) {\n                    isCycle = false;\n                    break;\n                }\n            }\n            ensuref(isCycle, \"Biconnected component is not a simple cycle nor a bridge\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2500;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1); // Indexing vertices from 1 to n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_\" + vtos(i + 1));\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_\" + vtos(i + 1));\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected on edge %d: (%d, %d)\", i + 1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edgeSet.count({ u, v }) == 0, \"Multiple edge detected between %d and %d\", u, v);\n        edgeSet.insert({ u, v });\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that the graph is connected\n    vector<bool> visited(n + 1, false); // Indexing vertices from 1 to n\n\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int cnt = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                cnt++;\n                q.push(v);\n            }\n        }\n    }\n    ensuref(cnt == n, \"The graph is not connected\");\n\n    // Now check that the graph is a cactus\n    // Implement Tarjan's algorithm to find biconnected components\n    vector<int> disc(n + 1, -1);\n    vector<int> low(n + 1, -1);\n    vector<int> parent(n + 1, -1);\n    stack<pair<int, int>> edgeStack;\n    int time = 0;\n\n    vector<vector<pair<int, int>>> biconnComponents;\n\n    // Function to convert integer to string (vtos)\n    auto vtos = [](int v) {\n        char buf[20];\n        sprintf(buf, \"%d\", v);\n        return string(buf);\n    };\n\n    function<void(int)> dfs = [&](int u) {\n        disc[u] = low[u] = ++time;\n        int children = 0;\n        for (int v : adj[u]) {\n            if (disc[v] == -1) {\n                parent[v] = u;\n                edgeStack.push({ u, v });\n                dfs(v);\n\n                low[u] = min(low[u], low[v]);\n\n                if ((disc[u] == 1 && ++children > 1) || (disc[u] > 1 && low[v] >= disc[u])) {\n                    // Found a biconnected component\n                    vector<pair<int, int>> component;\n                    pair<int, int> e;\n                    do {\n                        e = edgeStack.top(); edgeStack.pop();\n                        component.push_back(e);\n                    } while (!((e.first == u && e.second == v) || (e.first == v && e.second == u)));\n                    biconnComponents.push_back(component);\n                }\n            }\n            else if (v != parent[u] && disc[v] < disc[u]) {\n                // Back edge\n                low[u] = min(low[u], disc[v]);\n                edgeStack.push({ u, v });\n            }\n        }\n    };\n\n    dfs(1);\n\n    // There may be remaining edges in the stack\n    if (!edgeStack.empty()) {\n        vector<pair<int, int>> component;\n        while (!edgeStack.empty()) {\n            component.push_back(edgeStack.top());\n            edgeStack.pop();\n        }\n        biconnComponents.push_back(component);\n    }\n\n    // Check each biconnected component\n    for (const auto& component : biconnComponents) {\n        // Collect nodes and their degrees\n        set<int> nodes;\n        map<int, int> degree;\n        for (const auto& edge : component) {\n            int u = edge.first;\n            int v = edge.second;\n            nodes.insert(u);\n            nodes.insert(v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        if (component.size() == 1) {\n            // It's a bridge\n            continue;\n        }\n        else {\n            // Check if all nodes have degree 2\n            bool isCycle = true;\n            for (int node : nodes) {\n                if (degree[node] != 2) {\n                    isCycle = false;\n                    break;\n                }\n            }\n            ensuref(isCycle, \"Biconnected component is not a simple cycle nor a bridge\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2500;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, n * (n - 1) / 2, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1); // Indexing vertices from 1 to n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_\" + vtos(i + 1));\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_\" + vtos(i + 1));\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected on edge %d: (%d, %d)\", i + 1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edgeSet.count({ u, v }) == 0, \"Multiple edge detected between %d and %d\", u, v);\n        edgeSet.insert({ u, v });\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that the graph is connected\n    vector<bool> visited(n + 1, false); // Indexing vertices from 1 to n\n\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int cnt = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                cnt++;\n                q.push(v);\n            }\n        }\n    }\n    ensuref(cnt == n, \"The graph is not connected\");\n\n    // Now check that the graph is a cactus\n    // Implement Tarjan's algorithm to find biconnected components\n    vector<int> disc(n + 1, -1);\n    vector<int> low(n + 1, -1);\n    vector<int> parent(n + 1, -1);\n    stack<pair<int, int>> edgeStack;\n    int time = 0;\n\n    vector<vector<pair<int, int>>> biconnComponents;\n\n    // Function to convert integer to string (vtos)\n    auto vtos = [](int v) {\n        char buf[20];\n        sprintf(buf, \"%d\", v);\n        return string(buf);\n    };\n\n    function<void(int)> dfs = [&](int u) {\n        disc[u] = low[u] = ++time;\n        int children = 0;\n        for (int v : adj[u]) {\n            if (disc[v] == -1) {\n                parent[v] = u;\n                edgeStack.push({ u, v });\n                dfs(v);\n\n                low[u] = min(low[u], low[v]);\n\n                if ((disc[u] == 1 && ++children > 1) || (disc[u] > 1 && low[v] >= disc[u])) {\n                    // Found a biconnected component\n                    vector<pair<int, int>> component;\n                    pair<int, int> e;\n                    do {\n                        e = edgeStack.top(); edgeStack.pop();\n                        component.push_back(e);\n                    } while (!((e.first == u && e.second == v) || (e.first == v && e.second == u)));\n                    biconnComponents.push_back(component);\n                }\n            }\n            else if (v != parent[u] && disc[v] < disc[u]) {\n                // Back edge\n                low[u] = min(low[u], disc[v]);\n                edgeStack.push({ u, v });\n            }\n        }\n    };\n\n    dfs(1);\n\n    // There may be remaining edges in the stack\n    if (!edgeStack.empty()) {\n        vector<pair<int, int>> component;\n        while (!edgeStack.empty()) {\n            component.push_back(edgeStack.top());\n            edgeStack.pop();\n        }\n        biconnComponents.push_back(component);\n    }\n\n    // Check each biconnected component\n    for (const auto& component : biconnComponents) {\n        // Collect nodes and their degrees\n        set<int> nodes;\n        map<int, int> degree;\n        for (const auto& edge : component) {\n            int u = edge.first;\n            int v = edge.second;\n            nodes.insert(u);\n            nodes.insert(v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        if (component.size() == 1) {\n            // It's a bridge\n            continue;\n        }\n        else {\n            // Check if all nodes have degree 2\n            bool isCycle = true;\n            for (int node : nodes) {\n                if (degree[node] != 2) {\n                    isCycle = false;\n                    break;\n                }\n            }\n            ensuref(isCycle, \"Biconnected component is not a simple cycle nor a bridge\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> edges;\nint n;\n\nvoid generate_chain() {\n    for (int i = 1; i < n; i++) {\n        edges.push_back({i, i + 1});\n    }\n}\n\nvoid generate_star() {\n    for (int i = 2; i <= n; i++) {\n        edges.push_back({1, i});\n    }\n}\n\nvoid generate_cycle() {\n    if (n == 1) {\n        // Single node, no edges\n    } else {\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i + 1});\n        }\n        edges.push_back({n, 1});\n    }\n}\n\nvoid generate_random_cactus(double p) {\n    vector<int> parent(n + 1);\n    parent[1] = 0;\n    vector<vector<int>> children(n + 1);\n    for (int i = 2; i <= n; i++) {\n        parent[i] = rnd.next(1, i - 1);\n        edges.push_back({parent[i], i});\n        children[parent[i]].push_back(i);\n    }\n    // Now add back edges to create cycles\n    // For each node, with probability p, add a back edge to an ancestor\n    for (int u = 2; u <= n; u++) {\n        if (rnd.next(0.0, 1.0) < p) { // probability p\n            // Get ancestors of u\n            vector<int> ancestors;\n            int v = parent[u];\n            while (v != 0) {\n                ancestors.push_back(v);\n                v = parent[v];\n            }\n            if (!ancestors.empty()) {\n                int idx = rnd.next(0, (int)ancestors.size() - 1);\n                int anc = ancestors[idx];\n                // Check if edge already exists\n                if (find(edges.begin(), edges.end(), make_pair(u, anc)) == edges.end()\n                    && find(edges.begin(), edges.end(), make_pair(anc, u)) == edges.end()) {\n                    edges.push_back({u, anc});\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5);\n\n    edges.clear();\n\n    if (type == \"chain\") {\n        generate_chain();\n    } else if (type == \"star\") {\n        generate_star();\n    } else if (type == \"cycle\") {\n        generate_cycle();\n    } else if (type == \"random\") {\n        generate_random_cactus(p);\n    } else {\n        // default to random\n        generate_random_cactus(p);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    // Output\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> edges;\nint n;\n\nvoid generate_chain() {\n    for (int i = 1; i < n; i++) {\n        edges.push_back({i, i + 1});\n    }\n}\n\nvoid generate_star() {\n    for (int i = 2; i <= n; i++) {\n        edges.push_back({1, i});\n    }\n}\n\nvoid generate_cycle() {\n    if (n == 1) {\n        // Single node, no edges\n    } else {\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i + 1});\n        }\n        edges.push_back({n, 1});\n    }\n}\n\nvoid generate_random_cactus(double p) {\n    vector<int> parent(n + 1);\n    parent[1] = 0;\n    vector<vector<int>> children(n + 1);\n    for (int i = 2; i <= n; i++) {\n        parent[i] = rnd.next(1, i - 1);\n        edges.push_back({parent[i], i});\n        children[parent[i]].push_back(i);\n    }\n    // Now add back edges to create cycles\n    // For each node, with probability p, add a back edge to an ancestor\n    for (int u = 2; u <= n; u++) {\n        if (rnd.next(0.0, 1.0) < p) { // probability p\n            // Get ancestors of u\n            vector<int> ancestors;\n            int v = parent[u];\n            while (v != 0) {\n                ancestors.push_back(v);\n                v = parent[v];\n            }\n            if (!ancestors.empty()) {\n                int idx = rnd.next(0, (int)ancestors.size() - 1);\n                int anc = ancestors[idx];\n                // Check if edge already exists\n                if (find(edges.begin(), edges.end(), make_pair(u, anc)) == edges.end()\n                    && find(edges.begin(), edges.end(), make_pair(anc, u)) == edges.end()) {\n                    edges.push_back({u, anc});\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5);\n\n    edges.clear();\n\n    if (type == \"chain\") {\n        generate_chain();\n    } else if (type == \"star\") {\n        generate_star();\n    } else if (type == \"cycle\") {\n        generate_cycle();\n    } else if (type == \"random\") {\n        generate_random_cactus(p);\n    } else {\n        // default to random\n        generate_random_cactus(p);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    // Output\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 2 -type chain\n./gen -n 3 -type chain\n./gen -n 4 -type chain\n./gen -n 5 -type chain\n\n./gen -n 1 -type star\n./gen -n 2 -type star\n./gen -n 5 -type star\n./gen -n 10 -type star\n\n./gen -n 1 -type cycle\n./gen -n 2 -type cycle\n./gen -n 5 -type cycle\n./gen -n 10 -type cycle\n\n./gen -n 1 -type random -p 0.0\n./gen -n 2 -type random -p 0.0\n./gen -n 5 -type random -p 0.0\n./gen -n 5 -type random -p 0.5\n./gen -n 5 -type random -p 1.0\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type cycle\n./gen -n 100 -type random -p 0.2\n./gen -n 100 -type random -p 0.8\n\n./gen -n 500 -type random -p 0.0\n./gen -n 500 -type random -p 0.5\n./gen -n 500 -type random -p 1.0\n\n./gen -n 1000 -type random -p 0.3\n./gen -n 1000 -type random -p 0.7\n\n./gen -n 2500 -type chain\n./gen -n 2500 -type star\n./gen -n 2500 -type cycle\n./gen -n 2500 -type random -p 0.5\n\n./gen -n 2500 -type random -p 0.0\n./gen -n 2500 -type random -p 1.0\n\n./gen -n 2500 -type random -p 0.9\n\n./gen -n 2500 -type random -p 0.1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:17:59.125509",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/A",
      "title": "A. Army",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains an integer n (2 ≤ n ≤ 100). The second line contains n - 1 integers di (1 ≤ di ≤ 100). The third input line contains two integers a and b (1 ≤ a < b ≤ n). The numbers on the lines are space-separated.",
      "output_spec": "OutputPrint the single number which is the number of years that Vasya needs to rise from rank a to rank b.",
      "sample_tests": "ExamplesInputCopy35 61 2OutputCopy5InputCopy35 61 3OutputCopy11",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains an integer n (2 ≤ n ≤ 100). The second line contains n - 1 integers di (1 ≤ di ≤ 100). The third input line contains two integers a and b (1 ≤ a < b ≤ n). The numbers on the lines are space-separated.\n\nOutputPrint the single number which is the number of years that Vasya needs to rise from rank a to rank b.\n\nInputCopy35 61 2OutputCopy5InputCopy35 61 3OutputCopy11\n\nInputCopy35 61 2\n\nOutputCopy5\n\nInputCopy35 61 3\n\nOutputCopy11",
      "solutions": [
        {
          "title": "School Individual Contest #1 (WCS 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Hello everybody.I would like to invite you to participate in a new competition, that will be held on the 30th of October at 16:00 MSK. It will be a part of the series of winter programming school olympiads, but it will be only a standart Codeforces round for adult participants.Teams aren't invited, only single members. The official rules will be ACM-ICPC.Jury has decided to increase the duration of the competition, which will be 4 hours long.Attention: People, who are considered out of competition, are participants of Codeforces Round #38, others are participants of School Personal Contest #1. But we will use merged result table for updating rating.The authors are me, Mike Mirzayanov and Artem Rakhov. Also I'm expressing gratitude to Maria Belova, Max Ivanov and Natalia Bondarenko for help.P.S. Please, don't forget to register to the competition!UPD: The contest has finished, thanks to all. I hope, you have got fun :)Congratulations to tourist. It tooks him ~2 hours to solve all problems!The next official school contest will be on November, 6, at 14.00 MSK. Total number of participants is 788, 274 of them have taken part in the school competition.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1165
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> d = inf.readInts(n - 1, 1, 100, \"d\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n\n    ensuref(a < b, \"a (%d) must be less than b (%d)\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> d = inf.readInts(n - 1, 1, 100, \"d\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n\n    ensuref(a < b, \"a (%d) must be less than b (%d)\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> d = inf.readInts(n - 1, 1, 100, \"d\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n\n    ensuref(a < b, \"a (%d) must be less than b (%d)\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string di_type = opt<string>(\"di_type\", \"random\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n\n    vector<int> di(n - 1);\n\n    if (di_type == \"min\") {\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = 1;\n        }\n    } else if (di_type == \"max\") {\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = 100;\n        }\n    } else if (di_type == \"random\") {\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = rnd.next(1, 100);\n        }\n    } else if (di_type == \"increasing\") {\n        int increment = max(1, 100 / (n - 1));\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = min(1 + i * increment, 100);\n        }\n    } else if (di_type == \"decreasing\") {\n        int decrement = max(1, 100 / (n - 1));\n        for (int i = 0; i < n -1; ++i) {\n            di[i] = max(100 - i * decrement, 1);\n        }\n    } else if (di_type == \"one_large_rest_small\") {\n        int pos = rnd.next(0, n - 2);\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = 1;\n        }\n        di[pos] = 100;\n    } else if (di_type == \"alternating\") {\n        for (int i = 0; i < n - 1; ++i) {\n            if (i % 2 == 0) di[i] = 1;\n            else di[i] = 100;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = rnd.next(1, 100);\n        }\n    }\n\n    int a;\n    if (a_type == \"start\") {\n        a = 1;\n    } else if (a_type == \"near_end\") {\n        a = n - 1;\n    } else if (a_type == \"random\") {\n        a = rnd.next(1, n - 1);\n    } else {\n        // default to random\n        a = rnd.next(1, n - 1);\n    }\n\n    int b;\n    if (b_type == \"end\") {\n        b = n;\n    } else if (b_type == \"adjacent\") {\n        b = a + 1;\n    } else if (b_type == \"random\") {\n        b = rnd.next(a + 1, n);\n    } else {\n        // default to random\n        b = rnd.next(a + 1, n);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 2) ? '\\n' : ' ');\n    }\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string di_type = opt<string>(\"di_type\", \"random\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n\n    vector<int> di(n - 1);\n\n    if (di_type == \"min\") {\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = 1;\n        }\n    } else if (di_type == \"max\") {\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = 100;\n        }\n    } else if (di_type == \"random\") {\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = rnd.next(1, 100);\n        }\n    } else if (di_type == \"increasing\") {\n        int increment = max(1, 100 / (n - 1));\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = min(1 + i * increment, 100);\n        }\n    } else if (di_type == \"decreasing\") {\n        int decrement = max(1, 100 / (n - 1));\n        for (int i = 0; i < n -1; ++i) {\n            di[i] = max(100 - i * decrement, 1);\n        }\n    } else if (di_type == \"one_large_rest_small\") {\n        int pos = rnd.next(0, n - 2);\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = 1;\n        }\n        di[pos] = 100;\n    } else if (di_type == \"alternating\") {\n        for (int i = 0; i < n - 1; ++i) {\n            if (i % 2 == 0) di[i] = 1;\n            else di[i] = 100;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n - 1; ++i) {\n            di[i] = rnd.next(1, 100);\n        }\n    }\n\n    int a;\n    if (a_type == \"start\") {\n        a = 1;\n    } else if (a_type == \"near_end\") {\n        a = n - 1;\n    } else if (a_type == \"random\") {\n        a = rnd.next(1, n - 1);\n    } else {\n        // default to random\n        a = rnd.next(1, n - 1);\n    }\n\n    int b;\n    if (b_type == \"end\") {\n        b = n;\n    } else if (b_type == \"adjacent\") {\n        b = a + 1;\n    } else if (b_type == \"random\") {\n        b = rnd.next(a + 1, n);\n    } else {\n        // default to random\n        b = rnd.next(a + 1, n);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 2) ? '\\n' : ' ');\n    }\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -di_type min -a_type start -b_type end\n./gen -n 2 -di_type max -a_type start -b_type end\n./gen -n 2 -di_type random -a_type random -b_type random\n\n./gen -n 3 -di_type min -a_type start -b_type end\n./gen -n 3 -di_type max -a_type start -b_type end\n./gen -n 3 -di_type random -a_type random -b_type random\n\n./gen -n 4 -di_type min -a_type start -b_type end\n./gen -n 4 -di_type max -a_type start -b_type end\n./gen -n 4 -di_type random -a_type random -b_type random\n\n./gen -n 10 -di_type one_large_rest_small -a_type start -b_type random\n./gen -n 10 -di_type one_large_rest_small -a_type near_end -b_type end\n./gen -n 10 -di_type random -a_type near_end -b_type end\n./gen -n 10 -di_type random -a_type random -b_type adjacent\n./gen -n 10 -di_type random -a_type random -b_type random\n\n./gen -n 50 -di_type increasing -a_type start -b_type end\n./gen -n 50 -di_type decreasing -a_type near_end -b_type end\n./gen -n 50 -di_type one_large_rest_small -a_type random -b_type random\n./gen -n 50 -di_type alternating -a_type random -b_type random\n\n./gen -n 99 -di_type min -a_type start -b_type end\n./gen -n 99 -di_type max -a_type random -b_type end\n./gen -n 99 -di_type random -a_type random -b_type end\n./gen -n 99 -di_type one_large_rest_small -a_type random -b_type random\n./gen -n 99 -di_type alternating -a_type random -b_type random\n\n./gen -n 100 -di_type min -a_type start -b_type end\n./gen -n 100 -di_type max -a_type start -b_type end\n./gen -n 100 -di_type random -a_type random -b_type random\n./gen -n 100 -di_type random -a_type start -b_type adjacent\n./gen -n 100 -di_type random -a_type random -b_type adjacent\n./gen -n 100 -di_type random -a_type near_end -b_type end\n./gen -n 100 -di_type min -a_type random -b_type random\n./gen -n 100 -di_type max -a_type random -b_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:00.834646",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/B",
      "title": "B. Ладья, Конь... и снова Конь",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеПервая строка входных данных содержит описание положения ладьи на доске, которое представляет собой строку длины 2, где первый символ — это строчная буква латинского алфавита от a до h, а второй символ — цифра от 1 до 8. Вторая строка содержит описание положения коня в аналогичном формате. Гарантируется, что позиции не совпадают.",
      "output_spec": "Выходные данныеВыведите одно число — искомое количество способов.",
      "sample_tests": "ПримерыВходные данныеСкопироватьa1b2Выходные данныеСкопировать44Входные данныеСкопироватьa8d4Выходные данныеСкопировать38",
      "description": "B. Ладья, Конь... и снова Конь\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит описание положения ладьи на доске, которое представляет собой строку длины 2, где первый символ — это строчная буква латинского алфавита от a до h, а второй символ — цифра от 1 до 8. Вторая строка содержит описание положения коня в аналогичном формате. Гарантируется, что позиции не совпадают.\n\nВходные данные\n\nВыходные данныеВыведите одно число — искомое количество способов.\n\nВыходные данные\n\nВходные данныеСкопироватьa1b2Выходные данныеСкопировать44Входные данныеСкопироватьa8d4Выходные данныеСкопировать38\n\nВходные данныеСкопироватьa1b2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать44\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьa8d4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать38\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Всем доброго времени сутокЗавтра, 30 октября я приглашаю Вас принять участие в увлекательном соревновании. Оно будет являться отборочным раундом в ЗКШ (Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11), подробнее читайте тут), но для более взрослых участников это будет просто новым Codeforces раундом (Codeforces Beta Round #38, ACM-ICPC Rules).Замечу, что в отличие от предыдущей отборочной олимпиады, наше завтрашнее соревнование - личное. Официальные правила соревнования, как видно из названия, - ACM-ICPC.За это соревнование, как и обычно, будет начисляться рейтинг. Участники, которые не принимают участие в отборе в ЗКШ, будут в таблице результатов отображаться, как участники \"вне конкурса\", но не пугайтесь, рейтинг будет подсчитан по совмещенной таблице.Также, после совещания жюри, было решено продлить раунд. Теперь он будет длиться 4 часа, обратите на это внимание!Авторами соревнования являюсь я (NALP), Михаил Мирзаянов и Артем Рахов. Также я хочу поблагодарить Марию Белову - нашего переводчика задач, Максима Иванова, Наталью Бондаренко за помощь.Жюри Codeforces.P.S. Напоминаю о том, что для участия в соревновании Вам нужно зарегистироваться. Не забудьте это сделать.UPD: Соревнование закончено, всем спасибо за участие. Надеюсь, что вам понравилось :)Поздравляем победителя, который занял первое место как в общем, так и в школьном зачетах, решив все предложенные задачи за ~2 часа: tourist. Поздравляем!Следующая отборочная олимпиада для школьников состоится 6 ноября, в 14.00 по московскому времени. Следите за новостями!Немного статистики: всего участников было 788, из которых 274 принимали участие в отборе. Мы надеемся, что в следующем соревновании эти показатели будут побиты :)UPD2: опубликованы некоторые разборы. Скоро появятся и остальные, не беспокойтесь:Разбор задачи АРазбор задачи BРазбор задачи CРазбор задачи DРазбор задачи EРазбор задачи FРазбор задачи G",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1894
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 1",
          "code": "7-9 -9 9 9-8 3 0 -5-16 -8 6 1414 -11 -6 95 -5 1 -9-11 -21 13 3-10 5 10 -15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 2",
          "code": "108 91 86 05 107 99 34 93 82 010 1ответ: 1 5 6 2 3 4 7 8 10 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"^[a-h][1-8]$\", \"rookPosition\");\n    string s2 = inf.readLine(\"^[a-h][1-8]$\", \"knightPosition\");\n    ensuref(s1 != s2, \"Rook and Knight positions should not coincide\");\n\n    auto getCoordinates = [](string s) {\n        int x = s[0] - 'a';\n        int y = s[1] - '1';\n        return make_pair(x, y);\n    };\n\n    pair<int, int> pos1 = getCoordinates(s1); // Rook position\n    pair<int, int> pos2 = getCoordinates(s2); // Knight position\n\n    int x1 = pos1.first, y1 = pos1.second;\n    int x2 = pos2.first, y2 = pos2.second;\n\n    // Ensure that the rook does not attack the knight\n    ensuref(x1 != x2 && y1 != y2, \"Rook attacks Knight\");\n\n    // Ensure that the knight does not attack the rook\n    bool knightAttacks = (abs(x1 - x2) == 1 && abs(y1 - y2) == 2) || \n                         (abs(x1 - x2) == 2 && abs(y1 - y2) == 1);\n    ensuref(!knightAttacks, \"Knight attacks Rook\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"^[a-h][1-8]$\", \"rookPosition\");\n    string s2 = inf.readLine(\"^[a-h][1-8]$\", \"knightPosition\");\n    ensuref(s1 != s2, \"Rook and Knight positions should not coincide\");\n\n    auto getCoordinates = [](string s) {\n        int x = s[0] - 'a';\n        int y = s[1] - '1';\n        return make_pair(x, y);\n    };\n\n    pair<int, int> pos1 = getCoordinates(s1); // Rook position\n    pair<int, int> pos2 = getCoordinates(s2); // Knight position\n\n    int x1 = pos1.first, y1 = pos1.second;\n    int x2 = pos2.first, y2 = pos2.second;\n\n    // Ensure that the rook does not attack the knight\n    ensuref(x1 != x2 && y1 != y2, \"Rook attacks Knight\");\n\n    // Ensure that the knight does not attack the rook\n    bool knightAttacks = (abs(x1 - x2) == 1 && abs(y1 - y2) == 2) || \n                         (abs(x1 - x2) == 2 && abs(y1 - y2) == 1);\n    ensuref(!knightAttacks, \"Knight attacks Rook\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"^[a-h][1-8]$\", \"rookPosition\");\n    string s2 = inf.readLine(\"^[a-h][1-8]$\", \"knightPosition\");\n    ensuref(s1 != s2, \"Rook and Knight positions should not coincide\");\n\n    auto getCoordinates = [](string s) {\n        int x = s[0] - 'a';\n        int y = s[1] - '1';\n        return make_pair(x, y);\n    };\n\n    pair<int, int> pos1 = getCoordinates(s1); // Rook position\n    pair<int, int> pos2 = getCoordinates(s2); // Knight position\n\n    int x1 = pos1.first, y1 = pos1.second;\n    int x2 = pos2.first, y2 = pos2.second;\n\n    // Ensure that the rook does not attack the knight\n    ensuref(x1 != x2 && y1 != y2, \"Rook attacks Knight\");\n\n    // Ensure that the knight does not attack the rook\n    bool knightAttacks = (abs(x1 - x2) == 1 && abs(y1 - y2) == 2) || \n                         (abs(x1 - x2) == 2 && abs(y1 - y2) == 1);\n    ensuref(!knightAttacks, \"Knight attacks Rook\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * This generator produces exactly ONE test case (two lines):\n *   1) The position of the rook (e.g., \"a1\")\n *   2) The position of the knight (e.g., \"b2\")\n *\n * Both positions must be distinct and must not threaten each other.\n * (No piece can beat the other.)\n *\n * The board is 8x8, columns labeled from 'a'..'h' and rows labeled '1'..'8'.\n * Internally, we'll treat rows and columns as zero-based:\n *   row = 0..7, col = 0..7\n *   chess notation: col -> 'a'+col, row -> '1'+row\n *\n * Command line argument:\n *   -type string   (default = \"random\")\n *       Possible values:\n *         \"random\"\n *         \"corner-corner\"\n *         \"corner-center\"\n *         \"near\"\n *         \"far\"\n *         \"rookA1\"\n *         \"rookH8\"\n *         \"rookA8\"\n *         \"rookH1\"\n *\n * The generator picks a valid (rook, knight) configuration\n * according to the specified \"type\" and prints it.\n */\n\nstatic bool canRookCapture(int rR, int cR, int rN, int cN) {\n    // Rook threatens same row or same column\n    return (rR == rN || cR == cN);\n}\n\nstatic bool canKnightCapture(int rK, int cK, int rR, int cR) {\n    // Knight moves in an L shape: (±1, ±2) or (±2, ±1)\n    int dr = abs(rK - rR);\n    int dc = abs(cK - cR);\n    return (dr == 2 && dc == 1) || (dr == 1 && dc == 2);\n}\n\n// Returns true if the rook at (rR, cR) and the knight at (rN, cN)\n// are in conflict (one can capture the other).\nstatic bool isConflict(int rR, int cR, int rN, int cN) {\n    // Must also be distinct squares\n    if (rR == rN && cR == cN) return true;\n    // Rook captures knight?\n    if (canRookCapture(rR, cR, rN, cN)) return true;\n    // Knight captures rook?\n    if (canKnightCapture(rN, cN, rR, cR)) return true;\n    return false;\n}\n\n// Convert 0-based row, col to standard chess notation (e.g. 0->'a1', 7->'h8')\nstatic string toChessNotation(int row, int col) {\n    // col -> letter a..h\n    // row -> number 1..8\n    char letter = char('a' + col);\n    char digit  = char('1' + row);\n    string s;\n    s.push_back(letter);\n    s.push_back(digit);\n    return s;\n}\n\n// Pick a random cell on the 8x8 board: (row, col).\nstatic pair<int,int> pickRandomCell() {\n    int r = rnd.next(8);  // [0..7]\n    int c = rnd.next(8);  \n    return make_pair(r, c);\n}\n\n// All corners (row,col)\nstatic vector<pair<int,int>> corners = {\n    {0,0}, {0,7}, {7,0}, {7,7}\n};\n\n// A \"center\" region, somewhat large to increase variety.\nstatic vector<pair<int,int>> centerCells() {\n    // For example, rows 2..5, cols 2..5\n    // That's a 4x4 region in the middle.\n    vector<pair<int,int>> v;\n    for(int r = 2; r <= 5; r++) {\n        for(int c = 2; c <= 5; c++) {\n            v.push_back({r, c});\n        }\n    }\n    return v;\n}\n\n// Returns the Manhattan distance between two cells\nstatic int manhattanDist(int r1, int c1, int r2, int c2) {\n    return abs(r1 - r2) + abs(c1 - c2);\n}\n\n// Try to find a pair (rR,cR) and (rN,cN) that is valid (not in conflict).\n// We'll do repeated attempts if random selection is used.\nstatic pair<pair<int,int>, pair<int,int>> getRandomPositions() {\n    while (true) {\n        auto R = pickRandomCell();\n        auto K = pickRandomCell();\n        if (!isConflict(R.first, R.second, K.first, K.second)) {\n            return make_pair(R, K);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse a single argument that indicates type of generation\n    string t = opt<string>(\"type\", \"random\");\n\n    pair<int,int> rPos, nPos;\n\n    if (t == \"corner-corner\") {\n        // Pick corners for both rook and knight\n        // Keep picking until they don't conflict\n        while(true) {\n            auto rc = corners[rnd.next(int(corners.size()))];\n            auto kc = corners[rnd.next(int(corners.size()))];\n            if (!isConflict(rc.first, rc.second, kc.first, kc.second)) {\n                rPos = rc;\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"corner-center\") {\n        // Rook in corner, Knight in center region\n        auto cCells = centerCells();\n        while(true) {\n            auto rc = corners[rnd.next(int(corners.size()))];\n            auto kc = cCells[rnd.next(int(cCells.size()))];\n            if (!isConflict(rc.first, rc.second, kc.first, kc.second)) {\n                rPos = rc;\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"near\") {\n        // We want the knight near the rook (small manhattan distance),\n        // but not in conflict. We'll pick the rook randomly,\n        // then try random squares in a small radius around rook.\n        while(true) {\n            auto rc = pickRandomCell();\n            // Collect squares \"close\" to rook\n            vector<pair<int,int>> candidates;\n            for (int r = 0; r < 8; r++) {\n                for (int c = 0; c < 8; c++) {\n                    int dist = manhattanDist(rc.first, rc.second, r, c);\n                    // near = manhattan distance <= 2, say\n                    if (dist <= 2) {\n                        candidates.push_back({r, c});\n                    }\n                }\n            }\n            // If no candidates, continue\n            if (candidates.empty()) continue;\n            rnd.shuffle(candidates.begin(), candidates.end());\n            bool found = false;\n            for (auto &k : candidates) {\n                if (!isConflict(rc.first, rc.second, k.first, k.second)) {\n                    rPos = rc;\n                    nPos = k;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n    }\n    else if (t == \"far\") {\n        // Knight far from rook (large manhattan distance)\n        while(true) {\n            auto rc = pickRandomCell();\n            // Collect squares \"far\" from rook\n            vector<pair<int,int>> candidates;\n            for (int r = 0; r < 8; r++) {\n                for (int c = 0; c < 8; c++) {\n                    int dist = manhattanDist(rc.first, rc.second, r, c);\n                    // far = manhattan distance >= 10, for instance\n                    if (dist >= 10) {\n                        candidates.push_back({r, c});\n                    }\n                }\n            }\n            if (candidates.empty()) continue;\n            rnd.shuffle(candidates.begin(), candidates.end());\n            bool found = false;\n            for (auto &k : candidates) {\n                if (!isConflict(rc.first, rc.second, k.first, k.second)) {\n                    rPos = rc;\n                    nPos = k;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n    }\n    else if (t == \"rookA1\") {\n        // Rook fixed at (0,0), knight random\n        // Must not conflict\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(0, 0, kc.first, kc.second)) {\n                rPos = {0, 0};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"rookH8\") {\n        // Rook fixed at (7,7), knight random\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(7, 7, kc.first, kc.second)) {\n                rPos = {7, 7};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"rookA8\") {\n        // Rook fixed at (7,0), knight random\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(7, 0, kc.first, kc.second)) {\n                rPos = {7, 0};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"rookH1\") {\n        // Rook fixed at (0,7), knight random\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(0, 7, kc.first, kc.second)) {\n                rPos = {0, 7};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else {\n        // Default: random\n        auto p = getRandomPositions();\n        rPos = p.first;\n        nPos = p.second;\n    }\n\n    // Print the two lines of output\n    cout << toChessNotation(rPos.first, rPos.second) << \"\\n\";\n    cout << toChessNotation(nPos.first, nPos.second) << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * This generator produces exactly ONE test case (two lines):\n *   1) The position of the rook (e.g., \"a1\")\n *   2) The position of the knight (e.g., \"b2\")\n *\n * Both positions must be distinct and must not threaten each other.\n * (No piece can beat the other.)\n *\n * The board is 8x8, columns labeled from 'a'..'h' and rows labeled '1'..'8'.\n * Internally, we'll treat rows and columns as zero-based:\n *   row = 0..7, col = 0..7\n *   chess notation: col -> 'a'+col, row -> '1'+row\n *\n * Command line argument:\n *   -type string   (default = \"random\")\n *       Possible values:\n *         \"random\"\n *         \"corner-corner\"\n *         \"corner-center\"\n *         \"near\"\n *         \"far\"\n *         \"rookA1\"\n *         \"rookH8\"\n *         \"rookA8\"\n *         \"rookH1\"\n *\n * The generator picks a valid (rook, knight) configuration\n * according to the specified \"type\" and prints it.\n */\n\nstatic bool canRookCapture(int rR, int cR, int rN, int cN) {\n    // Rook threatens same row or same column\n    return (rR == rN || cR == cN);\n}\n\nstatic bool canKnightCapture(int rK, int cK, int rR, int cR) {\n    // Knight moves in an L shape: (±1, ±2) or (±2, ±1)\n    int dr = abs(rK - rR);\n    int dc = abs(cK - cR);\n    return (dr == 2 && dc == 1) || (dr == 1 && dc == 2);\n}\n\n// Returns true if the rook at (rR, cR) and the knight at (rN, cN)\n// are in conflict (one can capture the other).\nstatic bool isConflict(int rR, int cR, int rN, int cN) {\n    // Must also be distinct squares\n    if (rR == rN && cR == cN) return true;\n    // Rook captures knight?\n    if (canRookCapture(rR, cR, rN, cN)) return true;\n    // Knight captures rook?\n    if (canKnightCapture(rN, cN, rR, cR)) return true;\n    return false;\n}\n\n// Convert 0-based row, col to standard chess notation (e.g. 0->'a1', 7->'h8')\nstatic string toChessNotation(int row, int col) {\n    // col -> letter a..h\n    // row -> number 1..8\n    char letter = char('a' + col);\n    char digit  = char('1' + row);\n    string s;\n    s.push_back(letter);\n    s.push_back(digit);\n    return s;\n}\n\n// Pick a random cell on the 8x8 board: (row, col).\nstatic pair<int,int> pickRandomCell() {\n    int r = rnd.next(8);  // [0..7]\n    int c = rnd.next(8);  \n    return make_pair(r, c);\n}\n\n// All corners (row,col)\nstatic vector<pair<int,int>> corners = {\n    {0,0}, {0,7}, {7,0}, {7,7}\n};\n\n// A \"center\" region, somewhat large to increase variety.\nstatic vector<pair<int,int>> centerCells() {\n    // For example, rows 2..5, cols 2..5\n    // That's a 4x4 region in the middle.\n    vector<pair<int,int>> v;\n    for(int r = 2; r <= 5; r++) {\n        for(int c = 2; c <= 5; c++) {\n            v.push_back({r, c});\n        }\n    }\n    return v;\n}\n\n// Returns the Manhattan distance between two cells\nstatic int manhattanDist(int r1, int c1, int r2, int c2) {\n    return abs(r1 - r2) + abs(c1 - c2);\n}\n\n// Try to find a pair (rR,cR) and (rN,cN) that is valid (not in conflict).\n// We'll do repeated attempts if random selection is used.\nstatic pair<pair<int,int>, pair<int,int>> getRandomPositions() {\n    while (true) {\n        auto R = pickRandomCell();\n        auto K = pickRandomCell();\n        if (!isConflict(R.first, R.second, K.first, K.second)) {\n            return make_pair(R, K);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse a single argument that indicates type of generation\n    string t = opt<string>(\"type\", \"random\");\n\n    pair<int,int> rPos, nPos;\n\n    if (t == \"corner-corner\") {\n        // Pick corners for both rook and knight\n        // Keep picking until they don't conflict\n        while(true) {\n            auto rc = corners[rnd.next(int(corners.size()))];\n            auto kc = corners[rnd.next(int(corners.size()))];\n            if (!isConflict(rc.first, rc.second, kc.first, kc.second)) {\n                rPos = rc;\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"corner-center\") {\n        // Rook in corner, Knight in center region\n        auto cCells = centerCells();\n        while(true) {\n            auto rc = corners[rnd.next(int(corners.size()))];\n            auto kc = cCells[rnd.next(int(cCells.size()))];\n            if (!isConflict(rc.first, rc.second, kc.first, kc.second)) {\n                rPos = rc;\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"near\") {\n        // We want the knight near the rook (small manhattan distance),\n        // but not in conflict. We'll pick the rook randomly,\n        // then try random squares in a small radius around rook.\n        while(true) {\n            auto rc = pickRandomCell();\n            // Collect squares \"close\" to rook\n            vector<pair<int,int>> candidates;\n            for (int r = 0; r < 8; r++) {\n                for (int c = 0; c < 8; c++) {\n                    int dist = manhattanDist(rc.first, rc.second, r, c);\n                    // near = manhattan distance <= 2, say\n                    if (dist <= 2) {\n                        candidates.push_back({r, c});\n                    }\n                }\n            }\n            // If no candidates, continue\n            if (candidates.empty()) continue;\n            rnd.shuffle(candidates.begin(), candidates.end());\n            bool found = false;\n            for (auto &k : candidates) {\n                if (!isConflict(rc.first, rc.second, k.first, k.second)) {\n                    rPos = rc;\n                    nPos = k;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n    }\n    else if (t == \"far\") {\n        // Knight far from rook (large manhattan distance)\n        while(true) {\n            auto rc = pickRandomCell();\n            // Collect squares \"far\" from rook\n            vector<pair<int,int>> candidates;\n            for (int r = 0; r < 8; r++) {\n                for (int c = 0; c < 8; c++) {\n                    int dist = manhattanDist(rc.first, rc.second, r, c);\n                    // far = manhattan distance >= 10, for instance\n                    if (dist >= 10) {\n                        candidates.push_back({r, c});\n                    }\n                }\n            }\n            if (candidates.empty()) continue;\n            rnd.shuffle(candidates.begin(), candidates.end());\n            bool found = false;\n            for (auto &k : candidates) {\n                if (!isConflict(rc.first, rc.second, k.first, k.second)) {\n                    rPos = rc;\n                    nPos = k;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n    }\n    else if (t == \"rookA1\") {\n        // Rook fixed at (0,0), knight random\n        // Must not conflict\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(0, 0, kc.first, kc.second)) {\n                rPos = {0, 0};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"rookH8\") {\n        // Rook fixed at (7,7), knight random\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(7, 7, kc.first, kc.second)) {\n                rPos = {7, 7};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"rookA8\") {\n        // Rook fixed at (7,0), knight random\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(7, 0, kc.first, kc.second)) {\n                rPos = {7, 0};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else if (t == \"rookH1\") {\n        // Rook fixed at (0,7), knight random\n        while(true) {\n            auto kc = pickRandomCell();\n            if (!isConflict(0, 7, kc.first, kc.second)) {\n                rPos = {0, 7};\n                nPos = kc;\n                break;\n            }\n        }\n    }\n    else {\n        // Default: random\n        auto p = getRandomPositions();\n        rPos = p.first;\n        nPos = p.second;\n    }\n\n    // Print the two lines of output\n    cout << toChessNotation(rPos.first, rPos.second) << \"\\n\";\n    cout << toChessNotation(nPos.first, nPos.second) << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct commands showing how to run this generator\n# (each command prints exactly one test case to STDOUT):\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type corner-corner\n./gen -type corner-center\n\n./gen -type corner-corner\n./gen -type corner-center\n\n./gen -type near\n./gen -type far\n./gen -type near\n./gen -type far\n\n./gen -type rookA1\n./gen -type rookH1\n./gen -type rookA8\n./gen -type rookH8\n\n./gen -type corner-corner\n./gen -type corner-center\n./gen -type near\n./gen -type far\n\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:02.516195",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/C",
      "title": "C. Жалюзи",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных находятся два целых числа, записанных через пробел, n и l (1 ≤ n, l ≤ 100) — количество полос на складе и минимальная допустимая длина части жалюзи в бурльметрах. Во второй строке через пробел записаны n целыx чисел ai — длины исходных полос в бурльметрах (1 ≤ ai ≤ 100).",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальную площадь окна в квадратных бурльметрах, которую можно закрыть полностью. Если не существует окна положительной площади, которое можно закрыть полностью, не нарушив никакое из описанных правил, то выведите единственное число 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 21 2 3 4Выходные данныеСкопировать8Входные данныеСкопировать5 35 5 7 3 1Выходные данныеСкопировать15Входные данныеСкопировать2 31 2Выходные данныеСкопировать0",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных находятся два целых числа, записанных через пробел, n и l (1 ≤ n, l ≤ 100) — количество полос на складе и минимальная допустимая длина части жалюзи в бурльметрах. Во второй строке через пробел записаны n целыx чисел ai — длины исходных полос в бурльметрах (1 ≤ ai ≤ 100).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальную площадь окна в квадратных бурльметрах, которую можно закрыть полностью. Если не существует окна положительной площади, которое можно закрыть полностью, не нарушив никакое из описанных правил, то выведите единственное число 0.\n\nВыходные данные\n\nВходные данныеСкопировать4 21 2 3 4Выходные данныеСкопировать8Входные данныеСкопировать5 35 5 7 3 1Выходные данныеСкопировать15Входные данныеСкопировать2 31 2Выходные данныеСкопировать0\n\nВходные данныеСкопировать4 21 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 35 5 7 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать15\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 31 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия, искомое окно имеет размеры 2 × 4, а жалюзи для него состоят из 4 частей по 2 бурльметра каждая. Одна из частей — это исходная полоса длины 2, другая — часть обрезанной полосы длины 3, а две оставшиеся — части разрезанной пополам полосы длины 4.",
      "solutions": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Всем доброго времени сутокЗавтра, 30 октября я приглашаю Вас принять участие в увлекательном соревновании. Оно будет являться отборочным раундом в ЗКШ (Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11), подробнее читайте тут), но для более взрослых участников это будет просто новым Codeforces раундом (Codeforces Beta Round #38, ACM-ICPC Rules).Замечу, что в отличие от предыдущей отборочной олимпиады, наше завтрашнее соревнование - личное. Официальные правила соревнования, как видно из названия, - ACM-ICPC.За это соревнование, как и обычно, будет начисляться рейтинг. Участники, которые не принимают участие в отборе в ЗКШ, будут в таблице результатов отображаться, как участники \"вне конкурса\", но не пугайтесь, рейтинг будет подсчитан по совмещенной таблице.Также, после совещания жюри, было решено продлить раунд. Теперь он будет длиться 4 часа, обратите на это внимание!Авторами соревнования являюсь я (NALP), Михаил Мирзаянов и Артем Рахов. Также я хочу поблагодарить Марию Белову - нашего переводчика задач, Максима Иванова, Наталью Бондаренко за помощь.Жюри Codeforces.P.S. Напоминаю о том, что для участия в соревновании Вам нужно зарегистироваться. Не забудьте это сделать.UPD: Соревнование закончено, всем спасибо за участие. Надеюсь, что вам понравилось :)Поздравляем победителя, который занял первое место как в общем, так и в школьном зачетах, решив все предложенные задачи за ~2 часа: tourist. Поздравляем!Следующая отборочная олимпиада для школьников состоится 6 ноября, в 14.00 по московскому времени. Следите за новостями!Немного статистики: всего участников было 788, из которых 274 принимали участие в отборе. Мы надеемся, что в следующем соревновании эти показатели будут побиты :)UPD2: опубликованы некоторые разборы. Скоро появятся и остальные, не беспокойтесь:Разбор задачи АРазбор задачи BРазбор задачи CРазбор задачи DРазбор задачи EРазбор задачи FРазбор задачи G",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1894
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 1",
          "code": "7-9 -9 9 9-8 3 0 -5-16 -8 6 1414 -11 -6 95 -5 1 -9-11 -21 13 3-10 5 10 -15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 2",
          "code": "108 91 86 05 107 99 34 93 82 010 1ответ: 1 5 6 2 3 4 7 8 10 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"ai_equals_l\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = l;\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(1 + i, 100);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = max(100 - i, 1);\n    } else if (type == \"l_gt_ai\") {\n        // l is greater than ai\n        if (l <= 1) {\n            for (int i = 0; i < n; ++i)\n                a[i] = 1;\n        } else {\n            for (int i = 0; i < n; ++i)\n                a[i] = rnd.next(1, l - 1);\n        }\n    } else if (type == \"ai_gt_l\") {\n        // ai greater than l\n        if (l >= 100) {\n            for (int i = 0; i < n; ++i)\n                a[i] = 100;\n        } else {\n            for (int i = 0; i < n; ++i)\n                a[i] = rnd.next(l + 1, 100);\n        }\n    } else if (type == \"large_variety\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, l);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"ai_equals_l\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = l;\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(1 + i, 100);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = max(100 - i, 1);\n    } else if (type == \"l_gt_ai\") {\n        // l is greater than ai\n        if (l <= 1) {\n            for (int i = 0; i < n; ++i)\n                a[i] = 1;\n        } else {\n            for (int i = 0; i < n; ++i)\n                a[i] = rnd.next(1, l - 1);\n        }\n    } else if (type == \"ai_gt_l\") {\n        // ai greater than l\n        if (l >= 100) {\n            for (int i = 0; i < n; ++i)\n                a[i] = 100;\n        } else {\n            for (int i = 0; i < n; ++i)\n                a[i] = rnd.next(l + 1, 100);\n        }\n    } else if (type == \"large_variety\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, l);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l 1 -type random\n./gen -n 1 -l 1 -type max_ai\n./gen -n 1 -l 1 -type min_ai\n./gen -n 1 -l 1 -type ai_equals_l\n./gen -n 1 -l 1 -type l_gt_ai\n\n./gen -n 10 -l 1 -type random\n./gen -n 10 -l 1 -type max_ai\n./gen -n 10 -l 1 -type min_ai\n./gen -n 10 -l 1 -type ai_equals_l\n./gen -n 10 -l 1 -type l_gt_ai\n\n./gen -n 10 -l 100 -type random\n./gen -n 10 -l 100 -type ai_equals_l\n./gen -n 10 -l 100 -type l_gt_ai\n\n./gen -n 50 -l 50 -type random\n./gen -n 50 -l 50 -type ai_equals_l\n\n./gen -n 100 -l 100 -type random\n./gen -n 100 -l 100 -type ai_equals_l\n\n./gen -n 100 -l 1 -type increasing\n./gen -n 100 -l 1 -type decreasing\n\n./gen -n 100 -l 50 -type increasing\n./gen -n 100 -l 50 -type decreasing\n\n./gen -n 100 -l 1 -type random\n./gen -n 100 -l 1 -type max_ai\n./gen -n 100 -l 1 -type min_ai\n\n./gen -n 100 -l 100 -type l_gt_ai\n./gen -n 100 -l 1 -type ai_gt_l\n\n./gen -n 100 -l 99 -type ai_gt_l\n./gen -n 100 -l 99 -type l_gt_ai\n\n./gen -n 100 -l 100 -type ai_equals_l\n./gen -n 100 -l 1 -type ai_equals_l\n\n./gen -n 100 -l 50 -type ai_equals_l\n\n./gen -n 100 -l 1 -type large_variety\n./gen -n 100 -l 1 -type random\n\n./gen -n 100 -l 50 -type large_variety\n./gen -n 100 -l 50 -type random\n\n./gen -n 100 -l 100 -type large_variety\n./gen -n 100 -l 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:04.431518",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/D",
      "title": "D. Vasya the Architect",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input file contains an integer n (1 ≤ n ≤ 100) which is the number of bricks. Each of the next n lines contains four numbers xi, 1, yi, 1, xi, 2, yi, 2 (xi, 1 ≠ xi, 2, |xi, 1 - xi, 2| = |yi, 1 - yi, 2|) which are the coordinates of the opposite angles of the base of the brick number i. The coordinates are integers and their absolute value does not exceed 50. The cubes are given in the order Vasya puts them. It is guaranteed that the area of intersection of the upper side of the brick number i - 1 and the lower side of the brick number i is strictly strictly greater than zero for all i ≥ 2.",
      "output_spec": "OutputPrint the number of bricks in the maximal stable tower.",
      "sample_tests": "ExamplesInputCopy20 0 3 31 0 4 3OutputCopy2InputCopy20 0 3 32 0 5 3OutputCopy1InputCopy30 0 3 31 0 4 32 0 5 3OutputCopy3",
      "description": "D. Vasya the Architect\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input file contains an integer n (1 ≤ n ≤ 100) which is the number of bricks. Each of the next n lines contains four numbers xi, 1, yi, 1, xi, 2, yi, 2 (xi, 1 ≠ xi, 2, |xi, 1 - xi, 2| = |yi, 1 - yi, 2|) which are the coordinates of the opposite angles of the base of the brick number i. The coordinates are integers and their absolute value does not exceed 50. The cubes are given in the order Vasya puts them. It is guaranteed that the area of intersection of the upper side of the brick number i - 1 and the lower side of the brick number i is strictly strictly greater than zero for all i ≥ 2.\n\nOutputPrint the number of bricks in the maximal stable tower.\n\nInputCopy20 0 3 31 0 4 3OutputCopy2InputCopy20 0 3 32 0 5 3OutputCopy1InputCopy30 0 3 31 0 4 32 0 5 3OutputCopy3\n\nInputCopy20 0 3 31 0 4 3\n\nOutputCopy2\n\nInputCopy20 0 3 32 0 5 3\n\nOutputCopy1\n\nInputCopy30 0 3 31 0 4 32 0 5 3\n\nOutputCopy3",
      "solutions": [
        {
          "title": "School Individual Contest #1 (WCS 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Hello everybody.I would like to invite you to participate in a new competition, that will be held on the 30th of October at 16:00 MSK. It will be a part of the series of winter programming school olympiads, but it will be only a standart Codeforces round for adult participants.Teams aren't invited, only single members. The official rules will be ACM-ICPC.Jury has decided to increase the duration of the competition, which will be 4 hours long.Attention: People, who are considered out of competition, are participants of Codeforces Round #38, others are participants of School Personal Contest #1. But we will use merged result table for updating rating.The authors are me, Mike Mirzayanov and Artem Rakhov. Also I'm expressing gratitude to Maria Belova, Max Ivanov and Natalia Bondarenko for help.P.S. Please, don't forget to register to the competition!UPD: The contest has finished, thanks to all. I hope, you have got fun :)Congratulations to tourist. It tooks him ~2 hours to solve all problems!The next official school contest will be on November, 6, at 14.00 MSK. Total number of participants is 788, 274 of them have taken part in the school competition.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1165
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> x1(n), y1(n), x2(n), y2(n);\n\n    for (int i = 0; i < n; ++i) {\n        x1[i] = inf.readInt(-50, 50, \"xi1\");\n        inf.readSpace();\n        y1[i] = inf.readInt(-50, 50, \"yi1\");\n        inf.readSpace();\n        x2[i] = inf.readInt(-50, 50, \"xi2\");\n        inf.readSpace();\n        y2[i] = inf.readInt(-50, 50, \"yi2\");\n        inf.readEoln();\n\n        ensuref(x1[i] != x2[i], \"In brick %d, xi1 (%d) must not be equal to xi2 (%d)\", i+1, x1[i], x2[i]);\n        int delta_x = abs(x1[i] - x2[i]);\n        int delta_y = abs(y1[i] - y2[i]);\n        ensuref(delta_x == delta_y, \"In brick %d, abs(xi1 - xi2) (%d) must be equal to abs(yi1 - yi2) (%d)\", i+1, delta_x, delta_y);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int x1_prev = min(x1[i-1], x2[i-1]);\n        int x2_prev = max(x1[i-1], x2[i-1]);\n        int y1_prev = min(y1[i-1], y2[i-1]);\n        int y2_prev = max(y1[i-1], y2[i-1]);\n\n        int x1_curr = min(x1[i], x2[i]);\n        int x2_curr = max(x1[i], x2[i]);\n        int y1_curr = min(y1[i], y2[i]);\n        int y2_curr = max(y1[i], y2[i]);\n\n        int x_overlap = min(x2_prev, x2_curr) - max(x1_prev, x1_curr);\n        int y_overlap = min(y2_prev, y2_curr) - max(y1_prev, y1_curr);\n\n        ensuref(x_overlap > 0 && y_overlap > 0,\n            \"Area of intersection between brick %d and brick %d must be strictly greater than zero\", i, i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> x1(n), y1(n), x2(n), y2(n);\n\n    for (int i = 0; i < n; ++i) {\n        x1[i] = inf.readInt(-50, 50, \"xi1\");\n        inf.readSpace();\n        y1[i] = inf.readInt(-50, 50, \"yi1\");\n        inf.readSpace();\n        x2[i] = inf.readInt(-50, 50, \"xi2\");\n        inf.readSpace();\n        y2[i] = inf.readInt(-50, 50, \"yi2\");\n        inf.readEoln();\n\n        ensuref(x1[i] != x2[i], \"In brick %d, xi1 (%d) must not be equal to xi2 (%d)\", i+1, x1[i], x2[i]);\n        int delta_x = abs(x1[i] - x2[i]);\n        int delta_y = abs(y1[i] - y2[i]);\n        ensuref(delta_x == delta_y, \"In brick %d, abs(xi1 - xi2) (%d) must be equal to abs(yi1 - yi2) (%d)\", i+1, delta_x, delta_y);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int x1_prev = min(x1[i-1], x2[i-1]);\n        int x2_prev = max(x1[i-1], x2[i-1]);\n        int y1_prev = min(y1[i-1], y2[i-1]);\n        int y2_prev = max(y1[i-1], y2[i-1]);\n\n        int x1_curr = min(x1[i], x2[i]);\n        int x2_curr = max(x1[i], x2[i]);\n        int y1_curr = min(y1[i], y2[i]);\n        int y2_curr = max(y1[i], y2[i]);\n\n        int x_overlap = min(x2_prev, x2_curr) - max(x1_prev, x1_curr);\n        int y_overlap = min(y2_prev, y2_curr) - max(y1_prev, y1_curr);\n\n        ensuref(x_overlap > 0 && y_overlap > 0,\n            \"Area of intersection between brick %d and brick %d must be strictly greater than zero\", i, i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> x1(n), y1(n), x2(n), y2(n);\n\n    for (int i = 0; i < n; ++i) {\n        x1[i] = inf.readInt(-50, 50, \"xi1\");\n        inf.readSpace();\n        y1[i] = inf.readInt(-50, 50, \"yi1\");\n        inf.readSpace();\n        x2[i] = inf.readInt(-50, 50, \"xi2\");\n        inf.readSpace();\n        y2[i] = inf.readInt(-50, 50, \"yi2\");\n        inf.readEoln();\n\n        ensuref(x1[i] != x2[i], \"In brick %d, xi1 (%d) must not be equal to xi2 (%d)\", i+1, x1[i], x2[i]);\n        int delta_x = abs(x1[i] - x2[i]);\n        int delta_y = abs(y1[i] - y2[i]);\n        ensuref(delta_x == delta_y, \"In brick %d, abs(xi1 - xi2) (%d) must be equal to abs(yi1 - yi2) (%d)\", i+1, delta_x, delta_y);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int x1_prev = min(x1[i-1], x2[i-1]);\n        int x2_prev = max(x1[i-1], x2[i-1]);\n        int y1_prev = min(y1[i-1], y2[i-1]);\n        int y2_prev = max(y1[i-1], y2[i-1]);\n\n        int x1_curr = min(x1[i], x2[i]);\n        int x2_curr = max(x1[i], x2[i]);\n        int y1_curr = min(y1[i], y2[i]);\n        int y2_curr = max(y1[i], y2[i]);\n\n        int x_overlap = min(x2_prev, x2_curr) - max(x1_prev, x1_curr);\n        int y_overlap = min(y2_prev, y2_curr) - max(y1_prev, y1_curr);\n\n        ensuref(x_overlap > 0 && y_overlap > 0,\n            \"Area of intersection between brick %d and brick %d must be strictly greater than zero\", i, i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -50;\nconst int MAX_COORD = 50;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi1(n), yi1(n), xi2(n), yi2(n);\n\n    if (type == \"aligned\") {\n        // All bricks are perfectly aligned\n        int size = rnd.next(1, 100);\n        int x1 = rnd.next(MIN_COORD, MAX_COORD - size);\n        int y1 = rnd.next(MIN_COORD, MAX_COORD - size);\n        int x2 = x1 + size;\n        int y2 = y1 + size;\n\n        for (int i = 0; i < n; ++i) {\n            xi1[i] = x1;\n            yi1[i] = y1;\n            xi2[i] = x2;\n            yi2[i] = y2;\n        }\n    } else if (type == \"shifted\") {\n        // Bricks are shifted slightly each time\n        int size = rnd.next(1, 10);\n        xi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        yi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        xi2[0] = xi1[0] + size;\n        yi2[0] = yi1[0] + size;\n\n        for (int i = 1; i < n; ++i) {\n            int shift_x = rnd.next(-size / 2, size / 2);\n            int shift_y = rnd.next(-size / 2, size / 2);\n            xi1[i] = xi1[i - 1] + shift_x;\n            yi1[i] = yi1[i - 1] + shift_y;\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure coordinates are within bounds\n            xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n            yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure positive overlap with previous brick\n            int overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n            int overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            while (overlap_x <= 0 || overlap_y <= 0) {\n                xi1[i] = xi1[i - 1] + rnd.next(-size / 2, size / 2);\n                yi1[i] = yi1[i - 1] + rnd.next(-size / 2, size / 2);\n                xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n                yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n                xi2[i] = xi1[i] + size;\n                yi2[i] = yi1[i] + size;\n                overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n                overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            }\n        }\n    } else if (type == \"unstable\") {\n        // Tower becomes unstable at some point\n        int size = rnd.next(1, 10);\n        xi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        yi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        xi2[0] = xi1[0] + size;\n        yi2[0] = yi1[0] + size;\n\n        for (int i = 1; i < n; ++i) {\n            int shift_x, shift_y;\n            if (i <= n / 2) {\n                // Small shifts\n                shift_x = rnd.next(-size / 4, size / 4);\n                shift_y = rnd.next(-size / 4, size / 4);\n            } else {\n                // Larger shifts to make it unstable\n                shift_x = rnd.next(size / 2, size);\n                shift_y = rnd.next(-size / 4, size / 4);\n            }\n            xi1[i] = xi1[i - 1] + shift_x;\n            yi1[i] = yi1[i - 1] + shift_y;\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure coordinates are within bounds\n            xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n            yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure positive overlap with previous brick\n            int overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n            int overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            while (overlap_x <= 0 || overlap_y <= 0) {\n                xi1[i] = xi1[i - 1] + rnd.next(-size / 4, size / 4);\n                yi1[i] = yi1[i - 1] + rnd.next(-size / 4, size / 4);\n                xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n                yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n                xi2[i] = xi1[i] + size;\n                yi2[i] = yi1[i] + size;\n                overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n                overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            }\n        }\n    } else {  // type == \"random\" or any other type\n        // Random bricks with positive overlap\n        xi1[0] = rnd.next(MIN_COORD, MAX_COORD - 1);\n        yi1[0] = rnd.next(MIN_COORD, MAX_COORD - 1);\n        int size = rnd.next(1, min(100, MAX_COORD - max(abs(xi1[0]), abs(yi1[0]))));\n        xi2[0] = xi1[0] + size;\n        yi2[0] = yi1[0] + size;\n\n        for (int i = 1; i < n; ++i) {\n            size = rnd.next(1, 100);\n            xi1[i] = rnd.next(MIN_COORD, MAX_COORD - size);\n            yi1[i] = rnd.next(MIN_COORD, MAX_COORD - size);\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure positive overlap with previous brick\n            int overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n            int overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            while (overlap_x <= 0 || overlap_y <= 0) {\n                xi1[i] = xi1[i - 1] + rnd.next(-size / 2, size / 2);\n                yi1[i] = yi1[i - 1] + rnd.next(-size / 2, size / 2);\n                xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n                yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n                xi2[i] = xi1[i] + size;\n                yi2[i] = yi1[i] + size;\n                overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n                overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        // Ensure xi1 != xi2\n        if (xi1[i] == xi2[i]) xi2[i]++;\n        // Ensure |xi1 - xi2| = |yi1 - yi2|\n        int side = abs(xi1[i] - xi2[i]);\n        int sign = (yi2[i] >= yi1[i]) ? 1 : -1;\n        yi2[i] = yi1[i] + sign * side;\n\n        printf(\"%d %d %d %d\\n\", xi1[i], yi1[i], xi2[i], yi2[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_COORD = -50;\nconst int MAX_COORD = 50;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi1(n), yi1(n), xi2(n), yi2(n);\n\n    if (type == \"aligned\") {\n        // All bricks are perfectly aligned\n        int size = rnd.next(1, 100);\n        int x1 = rnd.next(MIN_COORD, MAX_COORD - size);\n        int y1 = rnd.next(MIN_COORD, MAX_COORD - size);\n        int x2 = x1 + size;\n        int y2 = y1 + size;\n\n        for (int i = 0; i < n; ++i) {\n            xi1[i] = x1;\n            yi1[i] = y1;\n            xi2[i] = x2;\n            yi2[i] = y2;\n        }\n    } else if (type == \"shifted\") {\n        // Bricks are shifted slightly each time\n        int size = rnd.next(1, 10);\n        xi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        yi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        xi2[0] = xi1[0] + size;\n        yi2[0] = yi1[0] + size;\n\n        for (int i = 1; i < n; ++i) {\n            int shift_x = rnd.next(-size / 2, size / 2);\n            int shift_y = rnd.next(-size / 2, size / 2);\n            xi1[i] = xi1[i - 1] + shift_x;\n            yi1[i] = yi1[i - 1] + shift_y;\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure coordinates are within bounds\n            xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n            yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure positive overlap with previous brick\n            int overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n            int overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            while (overlap_x <= 0 || overlap_y <= 0) {\n                xi1[i] = xi1[i - 1] + rnd.next(-size / 2, size / 2);\n                yi1[i] = yi1[i - 1] + rnd.next(-size / 2, size / 2);\n                xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n                yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n                xi2[i] = xi1[i] + size;\n                yi2[i] = yi1[i] + size;\n                overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n                overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            }\n        }\n    } else if (type == \"unstable\") {\n        // Tower becomes unstable at some point\n        int size = rnd.next(1, 10);\n        xi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        yi1[0] = rnd.next(MIN_COORD, MAX_COORD - size);\n        xi2[0] = xi1[0] + size;\n        yi2[0] = yi1[0] + size;\n\n        for (int i = 1; i < n; ++i) {\n            int shift_x, shift_y;\n            if (i <= n / 2) {\n                // Small shifts\n                shift_x = rnd.next(-size / 4, size / 4);\n                shift_y = rnd.next(-size / 4, size / 4);\n            } else {\n                // Larger shifts to make it unstable\n                shift_x = rnd.next(size / 2, size);\n                shift_y = rnd.next(-size / 4, size / 4);\n            }\n            xi1[i] = xi1[i - 1] + shift_x;\n            yi1[i] = yi1[i - 1] + shift_y;\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure coordinates are within bounds\n            xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n            yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure positive overlap with previous brick\n            int overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n            int overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            while (overlap_x <= 0 || overlap_y <= 0) {\n                xi1[i] = xi1[i - 1] + rnd.next(-size / 4, size / 4);\n                yi1[i] = yi1[i - 1] + rnd.next(-size / 4, size / 4);\n                xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n                yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n                xi2[i] = xi1[i] + size;\n                yi2[i] = yi1[i] + size;\n                overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n                overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            }\n        }\n    } else {  // type == \"random\" or any other type\n        // Random bricks with positive overlap\n        xi1[0] = rnd.next(MIN_COORD, MAX_COORD - 1);\n        yi1[0] = rnd.next(MIN_COORD, MAX_COORD - 1);\n        int size = rnd.next(1, min(100, MAX_COORD - max(abs(xi1[0]), abs(yi1[0]))));\n        xi2[0] = xi1[0] + size;\n        yi2[0] = yi1[0] + size;\n\n        for (int i = 1; i < n; ++i) {\n            size = rnd.next(1, 100);\n            xi1[i] = rnd.next(MIN_COORD, MAX_COORD - size);\n            yi1[i] = rnd.next(MIN_COORD, MAX_COORD - size);\n            xi2[i] = xi1[i] + size;\n            yi2[i] = yi1[i] + size;\n\n            // Ensure positive overlap with previous brick\n            int overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n            int overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            while (overlap_x <= 0 || overlap_y <= 0) {\n                xi1[i] = xi1[i - 1] + rnd.next(-size / 2, size / 2);\n                yi1[i] = yi1[i - 1] + rnd.next(-size / 2, size / 2);\n                xi1[i] = max(MIN_COORD, min(MAX_COORD - size, xi1[i]));\n                yi1[i] = max(MIN_COORD, min(MAX_COORD - size, yi1[i]));\n                xi2[i] = xi1[i] + size;\n                yi2[i] = yi1[i] + size;\n                overlap_x = min(xi2[i], xi2[i - 1]) - max(xi1[i], xi1[i - 1]);\n                overlap_y = min(yi2[i], yi2[i - 1]) - max(yi1[i], yi1[i - 1]);\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        // Ensure xi1 != xi2\n        if (xi1[i] == xi2[i]) xi2[i]++;\n        // Ensure |xi1 - xi2| = |yi1 - yi2|\n        int side = abs(xi1[i] - xi2[i]);\n        int sign = (yi2[i] >= yi1[i]) ? 1 : -1;\n        yi2[i] = yi1[i] + sign * side;\n\n        printf(\"%d %d %d %d\\n\", xi1[i], yi1[i], xi2[i], yi2[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with different types\n./gen -n 1 -type aligned\n./gen -n 1 -type random\n./gen -n 1 -type shifted\n./gen -n 1 -type unstable\n\n./gen -n 5 -type aligned\n./gen -n 5 -type random\n./gen -n 5 -type shifted\n./gen -n 5 -type unstable\n\n# Medium n\n./gen -n 20 -type aligned\n./gen -n 20 -type random\n./gen -n 20 -type shifted\n./gen -n 20 -type unstable\n\n# Large n\n./gen -n 50 -type aligned\n./gen -n 50 -type random\n./gen -n 50 -type shifted\n./gen -n 50 -type unstable\n\n# Maximum n\n./gen -n 100 -type aligned\n./gen -n 100 -type random\n./gen -n 100 -type shifted\n./gen -n 100 -type unstable\n\n# Edge cases with minimal overlap\n./gen -n 10 -type shifted\n./gen -n 30 -type shifted\n./gen -n 70 -type shifted\n./gen -n 100 -type shifted\n\n# Edge cases with maximal coordinate values\n./gen -n 10 -type aligned\n./gen -n 10 -type random\n\n# Additional random test cases\n./gen -n 15 -type random\n./gen -n 35 -type random\n./gen -n 60 -type random\n./gen -n 90 -type random\n\n# Test cases to check unstable towers\n./gen -n 25 -type unstable\n./gen -n 50 -type unstable\n./gen -n 75 -type unstable\n./gen -n 100 -type unstable\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:06.555538",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/E",
      "title": "E. Let's Go Rolling!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains an integer n (1 ≤ n ≤ 3000) which is the number of marbles. The next n lines contain the descriptions of the marbles in pairs of integers xi, ci ( - 109 ≤ xi, ci ≤ 109). The numbers are space-separated. Each description is given on a separate line. No two marbles have identical initial positions.",
      "output_spec": "OutputOutput the single number — the least fine you will have to pay.",
      "sample_tests": "ExamplesInputCopy32 33 41 2OutputCopy5InputCopy41 73 15 106 1OutputCopy11",
      "description": "E. Let's Go Rolling!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains an integer n (1 ≤ n ≤ 3000) which is the number of marbles. The next n lines contain the descriptions of the marbles in pairs of integers xi, ci ( - 109 ≤ xi, ci ≤ 109). The numbers are space-separated. Each description is given on a separate line. No two marbles have identical initial positions.\n\nOutputOutput the single number — the least fine you will have to pay.\n\nInputCopy32 33 41 2OutputCopy5InputCopy41 73 15 106 1OutputCopy11\n\nInputCopy32 33 41 2\n\nOutputCopy5\n\nInputCopy41 73 15 106 1\n\nOutputCopy11",
      "solutions": [
        {
          "title": "School Individual Contest #1 (WCS 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Hello everybody.I would like to invite you to participate in a new competition, that will be held on the 30th of October at 16:00 MSK. It will be a part of the series of winter programming school olympiads, but it will be only a standart Codeforces round for adult participants.Teams aren't invited, only single members. The official rules will be ACM-ICPC.Jury has decided to increase the duration of the competition, which will be 4 hours long.Attention: People, who are considered out of competition, are participants of Codeforces Round #38, others are participants of School Personal Contest #1. But we will use merged result table for updating rating.The authors are me, Mike Mirzayanov and Artem Rakhov. Also I'm expressing gratitude to Maria Belova, Max Ivanov and Natalia Bondarenko for help.P.S. Please, don't forget to register to the competition!UPD: The contest has finished, thanks to all. I hope, you have got fun :)Congratulations to tourist. It tooks him ~2 hours to solve all problems!The next official school contest will be on November, 6, at 14.00 MSK. Total number of participants is 788, 274 of them have taken part in the school competition.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1165
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    set<int> xs;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int ci = inf.readInt(-1000000000, 1000000000, \"ci\");\n        inf.readEoln();\n        ensuref(xs.count(xi) == 0, \"xi[%d] = %d is not unique\", i+1, xi);\n        xs.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    set<int> xs;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int ci = inf.readInt(-1000000000, 1000000000, \"ci\");\n        inf.readEoln();\n        ensuref(xs.count(xi) == 0, \"xi[%d] = %d is not unique\", i+1, xi);\n        xs.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    set<int> xs;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int ci = inf.readInt(-1000000000, 1000000000, \"ci\");\n        inf.readEoln();\n        ensuref(xs.count(xi) == 0, \"xi[%d] = %d is not unique\", i+1, xi);\n        xs.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int MIN_COORD = -1000000000;\n    const int MAX_COORD = 1000000000;\n    const int MIN_COST = -1000000000;\n    const int MAX_COST = 1000000000;\n\n    vector<int> xi(n);\n    vector<int> ci(n);\n\n    if (type == \"random\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n    } else if (type == \"all_positive_ci\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate positive costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, MAX_COST);\n        }\n\n    } else if (type == \"all_negative_ci\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate negative costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, -1);\n        }\n\n    } else if (type == \"positions_clustered\") {\n        // Generate positions clustered around a point\n        int x0 = rnd.next(MIN_COORD + 10000, MAX_COORD - 10000);\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = x0 + rnd.next(-10000, 10000);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n    } else if (type == \"positions_spread\") {\n        // Generate positions spread over the entire range\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n    } else if (type == \"leftmost_pinned_high_cost\") {\n        // Generate sorted positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // Generate costs\n        ci[0] = rnd.next(MAX_COST - 1000000, MAX_COST);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n        // Shuffle xi and ci together\n        vector<pair<int, int>> marbles(n);\n        for (int i = 0; i < n; ++i) {\n            marbles[i] = make_pair(xi[i], ci[i]);\n        }\n        shuffle(marbles.begin(), marbles.end());\n        for (int i = 0; i < n; ++i) {\n            xi[i] = marbles[i].first;\n            ci[i] = marbles[i].second;\n        }\n\n    } else if (type == \"leftmost_pinned_negative_cost\") {\n        // Generate sorted positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // Generate costs\n        ci[0] = rnd.next(MIN_COST, -1);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n        // Shuffle xi and ci together\n        vector<pair<int, int>> marbles(n);\n        for (int i = 0; i < n; ++i) {\n            marbles[i] = make_pair(xi[i], ci[i]);\n        }\n        shuffle(marbles.begin(), marbles.end());\n        for (int i = 0; i < n; ++i) {\n            xi[i] = marbles[i].first;\n            ci[i] = marbles[i].second;\n        }\n\n    } else if (type == \"ci_alternate_signs\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate costs with alternating signs\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ci[i] = rnd.next(MIN_COST, -1);\n            } else {\n                ci[i] = rnd.next(1, MAX_COST);\n            }\n        }\n\n    } else {\n        // Default to random\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int MIN_COORD = -1000000000;\n    const int MAX_COORD = 1000000000;\n    const int MIN_COST = -1000000000;\n    const int MAX_COST = 1000000000;\n\n    vector<int> xi(n);\n    vector<int> ci(n);\n\n    if (type == \"random\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n    } else if (type == \"all_positive_ci\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate positive costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, MAX_COST);\n        }\n\n    } else if (type == \"all_negative_ci\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate negative costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, -1);\n        }\n\n    } else if (type == \"positions_clustered\") {\n        // Generate positions clustered around a point\n        int x0 = rnd.next(MIN_COORD + 10000, MAX_COORD - 10000);\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = x0 + rnd.next(-10000, 10000);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n    } else if (type == \"positions_spread\") {\n        // Generate positions spread over the entire range\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n    } else if (type == \"leftmost_pinned_high_cost\") {\n        // Generate sorted positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // Generate costs\n        ci[0] = rnd.next(MAX_COST - 1000000, MAX_COST);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n        // Shuffle xi and ci together\n        vector<pair<int, int>> marbles(n);\n        for (int i = 0; i < n; ++i) {\n            marbles[i] = make_pair(xi[i], ci[i]);\n        }\n        shuffle(marbles.begin(), marbles.end());\n        for (int i = 0; i < n; ++i) {\n            xi[i] = marbles[i].first;\n            ci[i] = marbles[i].second;\n        }\n\n    } else if (type == \"leftmost_pinned_negative_cost\") {\n        // Generate sorted positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n\n        // Generate costs\n        ci[0] = rnd.next(MIN_COST, -1);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n\n        // Shuffle xi and ci together\n        vector<pair<int, int>> marbles(n);\n        for (int i = 0; i < n; ++i) {\n            marbles[i] = make_pair(xi[i], ci[i]);\n        }\n        shuffle(marbles.begin(), marbles.end());\n        for (int i = 0; i < n; ++i) {\n            xi[i] = marbles[i].first;\n            ci[i] = marbles[i].second;\n        }\n\n    } else if (type == \"ci_alternate_signs\") {\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate costs with alternating signs\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ci[i] = rnd.next(MIN_COST, -1);\n            } else {\n                ci[i] = rnd.next(1, MAX_COST);\n            }\n        }\n\n    } else {\n        // Default to random\n        // Generate random unique positions\n        set<int> positions;\n        while (int(positions.size()) < n) {\n            int x = rnd.next(MIN_COORD, MAX_COORD);\n            positions.insert(x);\n        }\n        xi.assign(positions.begin(), positions.end());\n        shuffle(xi.begin(), xi.end());\n\n        // Generate random costs\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(MIN_COST, MAX_COST);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xi[i], ci[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 3000 -type random\n\n./gen -n 3000 -type all_positive_ci\n./gen -n 3000 -type all_negative_ci\n./gen -n 3000 -type positions_clustered\n./gen -n 3000 -type positions_spread\n\n./gen -n 3000 -type leftmost_pinned_high_cost\n./gen -n 3000 -type leftmost_pinned_negative_cost\n./gen -n 3000 -type ci_alternate_signs\n\n./gen -n 100 -type positions_clustered\n./gen -n 100 -type positions_spread\n./gen -n 100 -type leftmost_pinned_high_cost\n./gen -n 100 -type leftmost_pinned_negative_cost\n./gen -n 100 -type ci_alternate_signs\n\n./gen -n 500 -type random\n./gen -n 500 -type all_positive_ci\n./gen -n 500 -type all_negative_ci\n\n./gen -n 2000 -type random\n./gen -n 2000 -type positions_clustered\n./gen -n 2000 -type positions_spread\n\n./gen -n 3000 -type random\n./gen -n 3000 -type ci_alternate_signs\n\n./gen -n 1 -type leftmost_pinned_high_cost\n./gen -n 1 -type leftmost_pinned_negative_cost\n./gen -n 2 -type ci_alternate_signs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:08.562281",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/F",
      "title": "F. Умный мальчик",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных записано целое число n — количество слов в зафиксированном словаре (1 ≤ n ≤ 30). Далее в n строках по одному на строке записаны слова из словаря — непустые строки, состоящие из строчных букв латинского алфавита, длиной не более 30 символов. Среди списка слов могут быть одинаковые.",
      "output_spec": "Выходные данныеВ первую строку выходных данных выведите строку «First» или «Second» — кто выиграет в игре. Во вторую строку выведите количество очков у первого игрока и количество очков у второго игрока после завершения игры. Числа разделите одним пробелом.",
      "sample_tests": "ПримерыВходные данныеСкопировать2abaabacВыходные данныеСкопироватьSecond29 35Входные данныеСкопировать3artemnikmaxВыходные данныеСкопироватьFirst2403 1882",
      "description": "F. Умный мальчик\n\nограничение по времени на тест4 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано целое число n — количество слов в зафиксированном словаре (1 ≤ n ≤ 30). Далее в n строках по одному на строке записаны слова из словаря — непустые строки, состоящие из строчных букв латинского алфавита, длиной не более 30 символов. Среди списка слов могут быть одинаковые.\n\nВходные данные\n\nВыходные данныеВ первую строку выходных данных выведите строку «First» или «Second» — кто выиграет в игре. Во вторую строку выведите количество очков у первого игрока и количество очков у второго игрока после завершения игры. Числа разделите одним пробелом.\n\nВыходные данные\n\nВходные данныеСкопировать2abaabacВыходные данныеСкопироватьSecond29 35Входные данныеСкопировать3artemnikmaxВыходные данныеСкопироватьFirst2403 1882\n\nВходные данныеСкопировать2abaabac\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьSecond29 35\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3artemnikmax\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFirst2403 1882\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Всем доброго времени сутокЗавтра, 30 октября я приглашаю Вас принять участие в увлекательном соревновании. Оно будет являться отборочным раундом в ЗКШ (Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11), подробнее читайте тут), но для более взрослых участников это будет просто новым Codeforces раундом (Codeforces Beta Round #38, ACM-ICPC Rules).Замечу, что в отличие от предыдущей отборочной олимпиады, наше завтрашнее соревнование - личное. Официальные правила соревнования, как видно из названия, - ACM-ICPC.За это соревнование, как и обычно, будет начисляться рейтинг. Участники, которые не принимают участие в отборе в ЗКШ, будут в таблице результатов отображаться, как участники \"вне конкурса\", но не пугайтесь, рейтинг будет подсчитан по совмещенной таблице.Также, после совещания жюри, было решено продлить раунд. Теперь он будет длиться 4 часа, обратите на это внимание!Авторами соревнования являюсь я (NALP), Михаил Мирзаянов и Артем Рахов. Также я хочу поблагодарить Марию Белову - нашего переводчика задач, Максима Иванова, Наталью Бондаренко за помощь.Жюри Codeforces.P.S. Напоминаю о том, что для участия в соревновании Вам нужно зарегистироваться. Не забудьте это сделать.UPD: Соревнование закончено, всем спасибо за участие. Надеюсь, что вам понравилось :)Поздравляем победителя, который занял первое место как в общем, так и в школьном зачетах, решив все предложенные задачи за ~2 часа: tourist. Поздравляем!Следующая отборочная олимпиада для школьников состоится 6 ноября, в 14.00 по московскому времени. Следите за новостями!Немного статистики: всего участников было 788, из которых 274 принимали участие в отборе. Мы надеемся, что в следующем соревновании эти показатели будут побиты :)UPD2: опубликованы некоторые разборы. Скоро появятся и остальные, не беспокойтесь:Разбор задачи АРазбор задачи BРазбор задачи CРазбор задачи DРазбор задачи EРазбор задачи FРазбор задачи G",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1894
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 1",
          "code": "7-9 -9 9 9-8 3 0 -5-16 -8 6 1414 -11 -6 95 -5 1 -9-11 -21 13 3-10 5 10 -15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 2",
          "code": "108 91 86 05 107 99 34 93 82 010 1ответ: 1 5 6 2 3 4 7 8 10 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,30}\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,30}\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,30}\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\", 0); // default to 0 means random length between minlen and maxlen\n    int minlen = opt<int>(\"minlen\", 1);\n    int maxlen = opt<int>(\"maxlen\", 30);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words(n);\n\n    if (type == \"duplicates\") {\n        // All words are the same\n        int l = len;\n        if (l == 0) {\n            l = rnd.next(minlen, maxlen);\n        }\n        string word = \"\";\n        for (int i = 0; i < l; i++) {\n            word += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            words[i] = word;\n        }\n    } else if (type == \"unique\") {\n        // All words are different, no common substrings\n        // For simplicity, use disjoint character sets\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch) {\n            letters.push_back(ch);\n        }\n        // We have 26 letters, so at most can have 26 words with disjoint letters\n\n        if (n > 26) {\n            fprintf(stderr, \"Cannot generate more than 26 unique words with disjoint letters\\n\");\n            n = 26;\n        }\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string word(l, letters[i]);\n            words[i] = word;\n        }\n    } else if (type == \"palindromic\") {\n        // Generate palindromic words\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string half;\n            for (int j = 0; j < (l + 1) / 2; j++) {\n                half += (char)('a' + rnd.next(26));\n            }\n            string word = half;\n            if (l % 2 == 0) {\n                string rev_half = half;\n                reverse(rev_half.begin(), rev_half.end());\n                word += rev_half;\n            } else {\n                string rev_half = half.substr(0, half.size() - 1);\n                reverse(rev_half.begin(), rev_half.end());\n                word += rev_half;\n            }\n            words[i] = word;\n        }\n    } else if (type == \"maxoverlap\") {\n        // Build words with maximum overlaps\n        // First, generate a base word\n        int l = len;\n        if (l == 0) {\n            l = rnd.next(minlen, maxlen);\n        }\n        string base_word;\n        for (int i = 0; i < l; i++) {\n            base_word += (char)('a' + rnd.next(26));\n        }\n        // Now, generate words by taking substrings of the base word,\n        // starting at various positions\n        for (int i = 0; i < n; i++) {\n            int start = rnd.next(0, l - 1);\n            int end = rnd.next(start + 1, l);\n            words[i] = base_word.substr(start, end - start);\n        }\n    } else if (type == \"singleletter\") {\n        // All words are single letter\n        for (int i = 0; i < n; i++) {\n            char ch = 'a' + rnd.next(26);\n            words[i] = string(1, ch);\n        }\n    } else if (type == \"longwords\") {\n        // Words have maximum length (30)\n        for (int i = 0; i < n; i++) {\n            string word;\n            for (int j = 0; j < 30; j++) {\n                word += (char)('a' + rnd.next(26));\n            }\n            words[i] = word;\n        }\n    } else if (type == \"random\") {\n        // Random words with random lengths\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string word;\n            for (int j = 0; j < l; j++) {\n                word += (char)('a' + rnd.next(26));\n            }\n            words[i] = word;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string word;\n            for (int j = 0; j < l; j++) {\n                word += (char)('a' + rnd.next(26));\n            }\n            words[i] = word;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", words[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\", 0); // default to 0 means random length between minlen and maxlen\n    int minlen = opt<int>(\"minlen\", 1);\n    int maxlen = opt<int>(\"maxlen\", 30);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words(n);\n\n    if (type == \"duplicates\") {\n        // All words are the same\n        int l = len;\n        if (l == 0) {\n            l = rnd.next(minlen, maxlen);\n        }\n        string word = \"\";\n        for (int i = 0; i < l; i++) {\n            word += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            words[i] = word;\n        }\n    } else if (type == \"unique\") {\n        // All words are different, no common substrings\n        // For simplicity, use disjoint character sets\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch) {\n            letters.push_back(ch);\n        }\n        // We have 26 letters, so at most can have 26 words with disjoint letters\n\n        if (n > 26) {\n            fprintf(stderr, \"Cannot generate more than 26 unique words with disjoint letters\\n\");\n            n = 26;\n        }\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string word(l, letters[i]);\n            words[i] = word;\n        }\n    } else if (type == \"palindromic\") {\n        // Generate palindromic words\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string half;\n            for (int j = 0; j < (l + 1) / 2; j++) {\n                half += (char)('a' + rnd.next(26));\n            }\n            string word = half;\n            if (l % 2 == 0) {\n                string rev_half = half;\n                reverse(rev_half.begin(), rev_half.end());\n                word += rev_half;\n            } else {\n                string rev_half = half.substr(0, half.size() - 1);\n                reverse(rev_half.begin(), rev_half.end());\n                word += rev_half;\n            }\n            words[i] = word;\n        }\n    } else if (type == \"maxoverlap\") {\n        // Build words with maximum overlaps\n        // First, generate a base word\n        int l = len;\n        if (l == 0) {\n            l = rnd.next(minlen, maxlen);\n        }\n        string base_word;\n        for (int i = 0; i < l; i++) {\n            base_word += (char)('a' + rnd.next(26));\n        }\n        // Now, generate words by taking substrings of the base word,\n        // starting at various positions\n        for (int i = 0; i < n; i++) {\n            int start = rnd.next(0, l - 1);\n            int end = rnd.next(start + 1, l);\n            words[i] = base_word.substr(start, end - start);\n        }\n    } else if (type == \"singleletter\") {\n        // All words are single letter\n        for (int i = 0; i < n; i++) {\n            char ch = 'a' + rnd.next(26);\n            words[i] = string(1, ch);\n        }\n    } else if (type == \"longwords\") {\n        // Words have maximum length (30)\n        for (int i = 0; i < n; i++) {\n            string word;\n            for (int j = 0; j < 30; j++) {\n                word += (char)('a' + rnd.next(26));\n            }\n            words[i] = word;\n        }\n    } else if (type == \"random\") {\n        // Random words with random lengths\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string word;\n            for (int j = 0; j < l; j++) {\n                word += (char)('a' + rnd.next(26));\n            }\n            words[i] = word;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            int l = len;\n            if (l == 0) {\n                l = rnd.next(minlen, maxlen);\n            }\n            string word;\n            for (int j = 0; j < l; j++) {\n                word += (char)('a' + rnd.next(26));\n            }\n            words[i] = word;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", words[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -len 1 -type singleletter\n./gen -n 1 -len 30 -type longwords\n./gen -n 2 -type duplicates\n./gen -n 2 -type unique\n./gen -n 5 -type palindromic\n./gen -n 5 -minlen 5 -maxlen 10 -type palindromic\n./gen -n 10 -type maxoverlap\n./gen -n 10 -len 10 -type random\n./gen -n 15 -len 15 -type duplicates\n./gen -n 20 -type singleletter\n./gen -n 26 -type unique\n./gen -n 26 -minlen 1 -maxlen 30 -type unique\n./gen -n 30 -type random\n./gen -n 30 -type maxoverlap\n./gen -n 30 -type palindromic\n./gen -n 29 -type longwords\n./gen -n 30 -minlen 30 -type longwords\n./gen -n 30 -len 5 -type duplicates\n./gen -n 16 -type singleletter\n./gen -n 18 -type unique\n./gen -n 25 -type random\n./gen -n 20 -type palindromic\n./gen -n 12 -minlen 10 -maxlen 20 -type random\n./gen -n 8 -type maxoverlap\n./gen -n 10 -len 1 -type duplicates\n./gen -n 6 -minlen 5 -maxlen 5 -type unique\n./gen -n 9 -len 2 -type singleletter\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:10.493587",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/G",
      "title": "G. Queue",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains an integer n which is the number of people who has joined the queue (1 ≤ n ≤ 105). In the next n lines descriptions of the people are given in order of their coming — space-separated integers ai and ci (1 ≤ ai ≤ n, 0 ≤ ci ≤ n). Every description is located on s single line. All the ai's are different.",
      "output_spec": "OutputOutput the permutation of numbers from 1 to n, which signifies the queue formed according to the above described rules, starting from the beginning to the end. In this succession the i-th number stands for the number of a person who will stand in line on the place number i after the swaps ends. People are numbered starting with 1 in the order in which they were given in the input. Separate numbers by a space.",
      "sample_tests": "ExamplesInputCopy21 02 1OutputCopy2 1 InputCopy31 32 33 3OutputCopy3 2 1 InputCopy52 31 44 33 15 2OutputCopy3 1 5 4 2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains an integer n which is the number of people who has joined the queue (1 ≤ n ≤ 105). In the next n lines descriptions of the people are given in order of their coming — space-separated integers ai and ci (1 ≤ ai ≤ n, 0 ≤ ci ≤ n). Every description is located on s single line. All the ai's are different.\n\nOutputOutput the permutation of numbers from 1 to n, which signifies the queue formed according to the above described rules, starting from the beginning to the end. In this succession the i-th number stands for the number of a person who will stand in line on the place number i after the swaps ends. People are numbered starting with 1 in the order in which they were given in the input. Separate numbers by a space.\n\nInputCopy21 02 1OutputCopy2 1 InputCopy31 32 33 3OutputCopy3 2 1 InputCopy52 31 44 33 15 2OutputCopy3 1 5 4 2\n\nInputCopy21 02 1\n\nOutputCopy2 1\n\nInputCopy31 32 33 3\n\nOutputCopy3 2 1\n\nInputCopy52 31 44 33 15 2\n\nOutputCopy3 1 5 4 2",
      "solutions": [
        {
          "title": "School Individual Contest #1 (WCS 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Hello everybody.I would like to invite you to participate in a new competition, that will be held on the 30th of October at 16:00 MSK. It will be a part of the series of winter programming school olympiads, but it will be only a standart Codeforces round for adult participants.Teams aren't invited, only single members. The official rules will be ACM-ICPC.Jury has decided to increase the duration of the competition, which will be 4 hours long.Attention: People, who are considered out of competition, are participants of Codeforces Round #38, others are participants of School Personal Contest #1. But we will use merged result table for updating rating.The authors are me, Mike Mirzayanov and Artem Rakhov. Also I'm expressing gratitude to Maria Belova, Max Ivanov and Natalia Bondarenko for help.P.S. Please, don't forget to register to the competition!UPD: The contest has finished, thanks to all. I hope, you have got fun :)Congratulations to tourist. It tooks him ~2 hours to solve all problems!The next official school contest will be on November, 6, at 14.00 MSK. Total number of participants is 788, 274 of them have taken part in the school competition.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1165
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<int> used_ai;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int ci = inf.readInt(0, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(used_ai.count(ai) == 0, \"ai[%d] = %d is duplicated\", i+1, ai);\n        used_ai.insert(ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<int> used_ai;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int ci = inf.readInt(0, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(used_ai.count(ai) == 0, \"ai[%d] = %d is duplicated\", i+1, ai);\n        used_ai.insert(ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<int> used_ai;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int ci = inf.readInt(0, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(used_ai.count(ai) == 0, \"ai[%d] = %d is duplicated\", i+1, ai);\n        used_ai.insert(ai);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string c_type = opt<string>(\"c_type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> c(n);\n\n    // Generate a_i based on a_type\n    if (a_type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (a_type == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (a_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else if (a_type == \"max_last\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = i + 1;\n        a[n - 1] = n;\n        shuffle(a.begin(), a.begin() + n - 1);\n    } else if (a_type == \"min_last\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = i + 2;\n        a[n - 1] = 1;\n        shuffle(a.begin(), a.begin() + n - 1);\n    } else {\n        // Default: random permutation\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    }\n\n    // Generate c_i based on c_type\n    if (c_type == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = 0;\n    } else if (c_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = n;\n    } else if (c_type == \"last_max\") {\n        for (int i = 0; i < n - 1; ++i)\n            c[i] = 0;\n        c[n - 1] = n;\n    } else if (c_type == \"alternate\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = (i % 2 == 0) ? 0 : n;\n    } else if (c_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = rnd.next(0, n);\n    } else {\n        // Default: zero c_i\n        for (int i = 0; i < n; ++i)\n            c[i] = 0;\n    }\n\n    // Output n, then a_i and c_i\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], c[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string c_type = opt<string>(\"c_type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> c(n);\n\n    // Generate a_i based on a_type\n    if (a_type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (a_type == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (a_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else if (a_type == \"max_last\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = i + 1;\n        a[n - 1] = n;\n        shuffle(a.begin(), a.begin() + n - 1);\n    } else if (a_type == \"min_last\") {\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = i + 2;\n        a[n - 1] = 1;\n        shuffle(a.begin(), a.begin() + n - 1);\n    } else {\n        // Default: random permutation\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    }\n\n    // Generate c_i based on c_type\n    if (c_type == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = 0;\n    } else if (c_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = n;\n    } else if (c_type == \"last_max\") {\n        for (int i = 0; i < n - 1; ++i)\n            c[i] = 0;\n        c[n - 1] = n;\n    } else if (c_type == \"alternate\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = (i % 2 == 0) ? 0 : n;\n    } else if (c_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            c[i] = rnd.next(0, n);\n    } else {\n        // Default: zero c_i\n        for (int i = 0; i < n; ++i)\n            c[i] = 0;\n    }\n\n    // Output n, then a_i and c_i\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], c[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -a_type ascending -c_type zero\n./gen -n 10 -a_type ascending -c_type max\n./gen -n 10 -a_type ascending -c_type random\n\n./gen -n 10 -a_type descending -c_type zero\n./gen -n 10 -a_type descending -c_type max\n./gen -n 10 -a_type descending -c_type random\n\n./gen -n 10 -a_type random -c_type zero\n./gen -n 10 -a_type random -c_type max\n./gen -n 10 -a_type random -c_type random\n\n./gen -n 1000 -a_type ascending -c_type zero\n./gen -n 1000 -a_type descending -c_type max\n./gen -n 1000 -a_type random -c_type random\n\n./gen -n 1000 -a_type max_last -c_type zero\n./gen -n 1000 -a_type max_last -c_type last_max\n\n./gen -n 1000 -a_type min_last -c_type zero\n./gen -n 1000 -a_type min_last -c_type last_max\n\n./gen -n 100000 -a_type ascending -c_type zero\n./gen -n 100000 -a_type descending -c_type max\n./gen -n 100000 -a_type random -c_type random\n\n./gen -n 100000 -a_type max_last -c_type last_max\n./gen -n 100000 -a_type min_last -c_type last_max\n./gen -n 100000 -a_type ascending -c_type alternate\n./gen -n 100000 -a_type descending -c_type alternate\n\n./gen -n 100000 -a_type random -c_type zero\n./gen -n 100000 -a_type random -c_type max\n./gen -n 100000 -a_type random -c_type random\n\n./gen -n 100000 -a_type ascending -c_type random\n./gen -n 100000 -a_type descending -c_type random\n./gen -n 100000 -a_type random -c_type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:12.936421",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "38/H",
      "title": "H. Великий марафон",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных заданы целые числа n и m (3 ≤ n ≤ 50, n - 1 ≤ m ≤ 1000), где n — количество городов в Берляндии, а m — количество дорог.Далее в m строках даны описания дорог в виде тройки целых чисел v, u, c — номера соединяемых городов и ее длина (1 ≤ v, u ≤ n, v ≠ u, 1 ≤ c ≤ 1000). Между каждой парой городов — не более одной дороги.В последней строке записаны целые числа g1, g2, s1, s2 (1 ≤ g1 ≤ g2, 1 ≤ s1 ≤ s2, g2 + s2 < n). Числа во входных данных, расположенные на одной строке, разделены пробелом.",
      "output_spec": "Выходные данныеВыведите единственное число — количество способов распределить медали. Гарантируется, что это число помещается в стандартный знаковый 64-битный тип данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 21 2 12 3 11 1 1 1Выходные данныеСкопировать3Входные данныеСкопировать4 51 2 22 3 13 4 24 1 21 3 31 2 1 1Выходные данныеСкопировать19Входные данныеСкопировать3 31 2 22 3 13 1 21 1 1 1Выходные данныеСкопировать4",
      "description": "H. Великий марафон\n\nограничение по времени на тест4 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных заданы целые числа n и m (3 ≤ n ≤ 50, n - 1 ≤ m ≤ 1000), где n — количество городов в Берляндии, а m — количество дорог.Далее в m строках даны описания дорог в виде тройки целых чисел v, u, c — номера соединяемых городов и ее длина (1 ≤ v, u ≤ n, v ≠ u, 1 ≤ c ≤ 1000). Между каждой парой городов — не более одной дороги.В последней строке записаны целые числа g1, g2, s1, s2 (1 ≤ g1 ≤ g2, 1 ≤ s1 ≤ s2, g2 + s2 < n). Числа во входных данных, расположенные на одной строке, разделены пробелом.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество способов распределить медали. Гарантируется, что это число помещается в стандартный знаковый 64-битный тип данных.\n\nВыходные данные\n\nВходные данныеСкопировать3 21 2 12 3 11 1 1 1Выходные данныеСкопировать3Входные данныеСкопировать4 51 2 22 3 13 4 24 1 21 3 31 2 1 1Выходные данныеСкопировать19Входные данныеСкопировать3 31 2 22 3 13 1 21 1 1 1Выходные данныеСкопировать4\n\nВходные данныеСкопировать3 21 2 12 3 11 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 51 2 22 3 13 4 24 1 21 3 31 2 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать19\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 2 22 3 13 1 21 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces",
          "content": "Всем доброго времени сутокЗавтра, 30 октября я приглашаю Вас принять участие в увлекательном соревновании. Оно будет являться отборочным раундом в ЗКШ (Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11), подробнее читайте тут), но для более взрослых участников это будет просто новым Codeforces раундом (Codeforces Beta Round #38, ACM-ICPC Rules).Замечу, что в отличие от предыдущей отборочной олимпиады, наше завтрашнее соревнование - личное. Официальные правила соревнования, как видно из названия, - ACM-ICPC.За это соревнование, как и обычно, будет начисляться рейтинг. Участники, которые не принимают участие в отборе в ЗКШ, будут в таблице результатов отображаться, как участники \"вне конкурса\", но не пугайтесь, рейтинг будет подсчитан по совмещенной таблице.Также, после совещания жюри, было решено продлить раунд. Теперь он будет длиться 4 часа, обратите на это внимание!Авторами соревнования являюсь я (NALP), Михаил Мирзаянов и Артем Рахов. Также я хочу поблагодарить Марию Белову - нашего переводчика задач, Максима Иванова, Наталью Бондаренко за помощь.Жюри Codeforces.P.S. Напоминаю о том, что для участия в соревновании Вам нужно зарегистироваться. Не забудьте это сделать.UPD: Соревнование закончено, всем спасибо за участие. Надеюсь, что вам понравилось :)Поздравляем победителя, который занял первое место как в общем, так и в школьном зачетах, решив все предложенные задачи за ~2 часа: tourist. Поздравляем!Следующая отборочная олимпиада для школьников состоится 6 ноября, в 14.00 по московскому времени. Следите за новостями!Немного статистики: всего участников было 788, из которых 274 принимали участие в отборе. Мы надеемся, что в следующем соревновании эти показатели будут побиты :)UPD2: опубликованы некоторые разборы. Скоро появятся и остальные, не беспокойтесь:Разбор задачи АРазбор задачи BРазбор задачи CРазбор задачи DРазбор задачи EРазбор задачи FРазбор задачи G",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/800",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 38 和字母"
          },
          "content_length": 1894
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи C) - Codeforces",
          "content": "Задача C. \"Жалюзи\"Нетрудно понять, что для некоторой фиксированной длины полос жалюзи x, максимальное количество полос, которые можно получить, равно: тогда переберем это значение x ≥ l, и найдем максимум выражения x· f(x). Это число и надо вывести.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 249
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 - Codeforces Beta Round #38. (Разбор задачи E) - Codeforces",
          "content": "Задача E. \"Ну-ка, покатились!\"Рассмотрим решение с помощью метода динамического программирования.Пусть Di - минимальный штраф, который мы заплатим, если будем решать задачу для шариков с номерами от i до n, причем шарик номер i будет обязательно приколот.Тогда Di = mini ≤ j  ≤ n(Dj + 1 + S(i, j) + ci)где Если числа S(i, j) не считать каждый раз, а пересчитывать, используя формулу S(i, j) = S(i, j - 1) + xj - xi, то решение требует всего O(n) памяти и  O(n2) времени на решение.Важное замечание: в приведенных рассуждениях, шарики нужно рассматривать в порядке увеличения их координат.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/815",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 588
        }
      ],
      "code_examples": [
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 1",
          "code": "7-9 -9 9 9-8 3 0 -5-16 -8 6 1414 -11 -6 95 -5 1 -9-11 -21 13 3-10 5 10 -15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        },
        {
          "title": "Школьная индивидуальная олимпиада #1 (ЗКШ 2010/11) - Codeforces Beta Round #38 (ACM-ICPC Rules) - Codeforces - Code 2",
          "code": "108 91 86 05 107 99 34 93 82 010 1ответ: 1 5 6 2 3 4 7 8 10 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/800",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, 1000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int c = inf.readInt(1, 1000, \"c\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge cannot connect city %d to itself\", v);\n\n        int a = min(v, u);\n        int b = max(v, u);\n\n        ensuref(edges.count({a, b}) == 0, \"Duplicate edge between cities %d and %d\", a, b);\n        edges.insert({a, b});\n\n        adj[v].push_back(u);\n        adj[u].push_back(v);\n    }\n\n    // Check if the graph is connected\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    visited[1] = true;\n    q.push(1);\n    while (!q.empty()) {\n        int curr = q.front(); q.pop();\n        for (int neighbor : adj[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, city %d is unreachable\", i);\n    }\n\n    int g1 = inf.readInt(1, n - 1, \"g1\");\n    inf.readSpace();\n    int g2 = inf.readInt(g1, n - 1, \"g2\");\n    inf.readSpace();\n    int s1 = inf.readInt(1, n - g2 - 1, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(s1, n - g2 - 1, \"s2\");\n    inf.readEoln();\n\n    ensuref(g2 + s2 < n, \"Sum of g2 and s2 must be less than n, but g2 + s2 = %d, n = %d\", g2 + s2, n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, 1000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int c = inf.readInt(1, 1000, \"c\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge cannot connect city %d to itself\", v);\n\n        int a = min(v, u);\n        int b = max(v, u);\n\n        ensuref(edges.count({a, b}) == 0, \"Duplicate edge between cities %d and %d\", a, b);\n        edges.insert({a, b});\n\n        adj[v].push_back(u);\n        adj[u].push_back(v);\n    }\n\n    // Check if the graph is connected\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    visited[1] = true;\n    q.push(1);\n    while (!q.empty()) {\n        int curr = q.front(); q.pop();\n        for (int neighbor : adj[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, city %d is unreachable\", i);\n    }\n\n    int g1 = inf.readInt(1, n - 1, \"g1\");\n    inf.readSpace();\n    int g2 = inf.readInt(g1, n - 1, \"g2\");\n    inf.readSpace();\n    int s1 = inf.readInt(1, n - g2 - 1, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(s1, n - g2 - 1, \"s2\");\n    inf.readEoln();\n\n    ensuref(g2 + s2 < n, \"Sum of g2 and s2 must be less than n, but g2 + s2 = %d, n = %d\", g2 + s2, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n - 1, 1000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int c = inf.readInt(1, 1000, \"c\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge cannot connect city %d to itself\", v);\n\n        int a = min(v, u);\n        int b = max(v, u);\n\n        ensuref(edges.count({a, b}) == 0, \"Duplicate edge between cities %d and %d\", a, b);\n        edges.insert({a, b});\n\n        adj[v].push_back(u);\n        adj[u].push_back(v);\n    }\n\n    // Check if the graph is connected\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    visited[1] = true;\n    q.push(1);\n    while (!q.empty()) {\n        int curr = q.front(); q.pop();\n        for (int neighbor : adj[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, city %d is unreachable\", i);\n    }\n\n    int g1 = inf.readInt(1, n - 1, \"g1\");\n    inf.readSpace();\n    int g2 = inf.readInt(g1, n - 1, \"g2\");\n    inf.readSpace();\n    int s1 = inf.readInt(1, n - g2 - 1, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(s1, n - g2 - 1, \"s2\");\n    inf.readEoln();\n\n    ensuref(g2 + s2 < n, \"Sum of g2 and s2 must be less than n, but g2 + s2 = %d, n = %d\", g2 + s2, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // if m not provided, default according to type\n    string type = opt<string>(\"type\", \"random\");\n    int maxc = opt<int>(\"maxc\", 1000);\n\n    int g1 = opt<int>(\"g1\", 1);\n    int g2 = opt<int>(\"g2\", n - 2);\n    int s1 = opt<int>(\"s1\", 1);\n    int s2 = opt<int>(\"s2\", n - g2 -1);\n\n    // Adjust medal constraints if necessary\n\n    g2 = min(g2, n - 2);\n    g1 = min(g1, g2);\n    s2 = min(s2, n - g2 -1);\n    s1 = min(s1, s2);\n\n    ensure(3 <= n && n <= 50);\n    ensure(g1 <= g2);\n    ensure(s1 <= s2);\n    ensure(g2 + s2 < n);\n\n    vector<pair<int,int> > edges;\n    set<pair<int,int>> edge_set;\n\n    if (type == \"chain\") {\n        m = n -1;\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({min(u,v), max(u,v)});\n        }\n    } else if (type == \"star\") {\n        int center = 1;\n        m = n -1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({center, i});\n            edge_set.insert({min(center, i), max(center, i)});\n        }\n    } else if (type == \"complete\") {\n        m = n * (n -1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u +1; v <= n; ++v) {\n                edges.push_back({u, v});\n                edge_set.insert({u,v});\n            }\n        }\n    } else if (type == \"ties\") {\n        // fully connected graph with equal weights\n        m = n * (n -1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u +1; v <= n; ++v) {\n                edges.push_back({u, v});\n                edge_set.insert({u,v});\n            }\n        }\n    } else if (type == \"unique\") {\n        // Construct a chain with varying edge weights\n        m = n -1;\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i +1;\n            edges.push_back({u, v});\n            edge_set.insert({min(u,v), max(u,v)});\n        }\n    } else {\n        // Random connected graph\n        if (m == -1) m = rnd.next(n -1, min(1000, n*(n-1)/2));\n        ensure(n -1 <= m && m <= 1000);\n        vector<int> parent(n +1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i -1);\n            edges.push_back({i, parent[i]});\n            edge_set.insert({min(i, parent[i]), max(i, parent[i])});\n        }\n        int extra_edges = m - (n -1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u,v);\n            int b = max(u,v);\n            if (edge_set.count({a,b})) continue;\n            edges.push_back({u,v});\n            edge_set.insert({a,b});\n            --extra_edges;\n        }\n    }\n\n    // Now assign edge weights\n\n    vector<tuple<int,int,int> > weighted_edges;\n    if (type == \"ties\") {\n        // All edge weights equal, e.g., 1\n        for (auto e : edges) {\n            int c = 1;\n            weighted_edges.push_back(make_tuple(e.first, e.second, c));\n        }\n    } else if (type == \"unique\") {\n        // Assign edge weights to ensure unique shortest path lengths\n        int c = 1;\n        for (auto e : edges) {\n            weighted_edges.push_back(make_tuple(e.first, e.second, c));\n            ++c;\n        }\n    } else {\n        for (auto e : edges) {\n            int c = rnd.next(1, maxc);\n            weighted_edges.push_back(make_tuple(e.first, e.second, c));\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, edges.size());\n    for (auto e : weighted_edges) {\n        int u, v, c;\n        tie(u,v,c) = e;\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n    printf(\"%d %d %d %d\\n\", g1, g2, s1, s2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // if m not provided, default according to type\n    string type = opt<string>(\"type\", \"random\");\n    int maxc = opt<int>(\"maxc\", 1000);\n\n    int g1 = opt<int>(\"g1\", 1);\n    int g2 = opt<int>(\"g2\", n - 2);\n    int s1 = opt<int>(\"s1\", 1);\n    int s2 = opt<int>(\"s2\", n - g2 -1);\n\n    // Adjust medal constraints if necessary\n\n    g2 = min(g2, n - 2);\n    g1 = min(g1, g2);\n    s2 = min(s2, n - g2 -1);\n    s1 = min(s1, s2);\n\n    ensure(3 <= n && n <= 50);\n    ensure(g1 <= g2);\n    ensure(s1 <= s2);\n    ensure(g2 + s2 < n);\n\n    vector<pair<int,int> > edges;\n    set<pair<int,int>> edge_set;\n\n    if (type == \"chain\") {\n        m = n -1;\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({min(u,v), max(u,v)});\n        }\n    } else if (type == \"star\") {\n        int center = 1;\n        m = n -1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({center, i});\n            edge_set.insert({min(center, i), max(center, i)});\n        }\n    } else if (type == \"complete\") {\n        m = n * (n -1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u +1; v <= n; ++v) {\n                edges.push_back({u, v});\n                edge_set.insert({u,v});\n            }\n        }\n    } else if (type == \"ties\") {\n        // fully connected graph with equal weights\n        m = n * (n -1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u +1; v <= n; ++v) {\n                edges.push_back({u, v});\n                edge_set.insert({u,v});\n            }\n        }\n    } else if (type == \"unique\") {\n        // Construct a chain with varying edge weights\n        m = n -1;\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i +1;\n            edges.push_back({u, v});\n            edge_set.insert({min(u,v), max(u,v)});\n        }\n    } else {\n        // Random connected graph\n        if (m == -1) m = rnd.next(n -1, min(1000, n*(n-1)/2));\n        ensure(n -1 <= m && m <= 1000);\n        vector<int> parent(n +1);\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i -1);\n            edges.push_back({i, parent[i]});\n            edge_set.insert({min(i, parent[i]), max(i, parent[i])});\n        }\n        int extra_edges = m - (n -1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u,v);\n            int b = max(u,v);\n            if (edge_set.count({a,b})) continue;\n            edges.push_back({u,v});\n            edge_set.insert({a,b});\n            --extra_edges;\n        }\n    }\n\n    // Now assign edge weights\n\n    vector<tuple<int,int,int> > weighted_edges;\n    if (type == \"ties\") {\n        // All edge weights equal, e.g., 1\n        for (auto e : edges) {\n            int c = 1;\n            weighted_edges.push_back(make_tuple(e.first, e.second, c));\n        }\n    } else if (type == \"unique\") {\n        // Assign edge weights to ensure unique shortest path lengths\n        int c = 1;\n        for (auto e : edges) {\n            weighted_edges.push_back(make_tuple(e.first, e.second, c));\n            ++c;\n        }\n    } else {\n        for (auto e : edges) {\n            int c = rnd.next(1, maxc);\n            weighted_edges.push_back(make_tuple(e.first, e.second, c));\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, edges.size());\n    for (auto e : weighted_edges) {\n        int u, v, c;\n        tie(u,v,c) = e;\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n    printf(\"%d %d %d %d\\n\", g1, g2, s1, s2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size test cases\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type complete\n./gen -n 3 -type ties\n./gen -n 3 -type unique\n\n# Small size test cases\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type complete\n./gen -n 10 -type ties\n./gen -n 10 -type unique\n\n# Medium size test cases\n./gen -n 25 -type chain\n./gen -n 25 -type star\n./gen -n 25 -type complete\n./gen -n 25 -type ties\n./gen -n 25 -type unique\n\n# Maximum size test cases\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type complete\n./gen -n 50 -type ties\n./gen -n 50 -type unique\n\n# Random graphs with various m\n./gen -n 20 -type random\n./gen -n 20 -type random -m 30\n./gen -n 20 -type random -m 100\n\n./gen -n 50 -type random\n./gen -n 50 -type random -m 100\n./gen -n 50 -type random -m 500\n./gen -n 50 -type random -m 1000\n\n# Edge cases for medal constraints\n./gen -n 10 -type complete -g1 1 -g2 1 -s1 1 -s2 1\n./gen -n 10 -type complete -g1 3 -g2 3 -s1 3 -s2 3\n./gen -n 10 -type complete -g1 5 -g2 5 -s1 3 -s2 3\n\n./gen -n 20 -type ties -g1 1 -g2 1 -s1 1 -s2 1\n./gen -n 20 -type ties -g1 5 -g2 10 -s1 5 -s2 10\n\n# Edge cases with different maxc\n./gen -n 30 -type random -maxc 1\n./gen -n 30 -type random -maxc 1000\n\n./gen -n 50 -type chain -maxc 1\n./gen -n 50 -type chain -maxc 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:14.730093",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "380/A",
      "title": "A. Sereja and Prefixes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer m (1 ≤ m ≤ 105) — the number of stages to build a sequence. Next m lines contain the description of the stages in the order they follow. The first number in the line is a type of stage (1 or 2). Type 1 means adding one number to the end of the sequence, in this case the line contains integer xi (1 ≤ xi ≤ 105) — the number to add. Type 2 means copying a prefix of length li to the end ci times, in this case the line further contains two integers li, ci (1 ≤ li ≤ 105, 1 ≤ ci ≤ 104), li is the length of the prefix, ci is the number of copyings. It is guaranteed that the length of prefix li is never larger than the current length of the sequence.The next line contains integer n (1 ≤ n ≤ 105) — the number of elements Sereja is interested in. The next line contains the numbers of elements of the final sequence Sereja is interested in. The numbers are given in the strictly increasing order. It is guaranteed that all numbers are strictly larger than zero and do not exceed the length of the resulting sequence. Consider the elements of the final sequence numbered starting from 1 from the beginning to the end of the sequence.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint the elements that Sereja is interested in, in the order in which their numbers occur in the input.",
      "sample_tests": "ExamplesInputCopy61 11 22 2 11 32 5 21 4161 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16OutputCopy1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4",
      "description": "A. Sereja and Prefixes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer m (1 ≤ m ≤ 105) — the number of stages to build a sequence. Next m lines contain the description of the stages in the order they follow. The first number in the line is a type of stage (1 or 2). Type 1 means adding one number to the end of the sequence, in this case the line contains integer xi (1 ≤ xi ≤ 105) — the number to add. Type 2 means copying a prefix of length li to the end ci times, in this case the line further contains two integers li, ci (1 ≤ li ≤ 105, 1 ≤ ci ≤ 104), li is the length of the prefix, ci is the number of copyings. It is guaranteed that the length of prefix li is never larger than the current length of the sequence.The next line contains integer n (1 ≤ n ≤ 105) — the number of elements Sereja is interested in. The next line contains the numbers of elements of the final sequence Sereja is interested in. The numbers are given in the strictly increasing order. It is guaranteed that all numbers are strictly larger than zero and do not exceed the length of the resulting sequence. Consider the elements of the final sequence numbered starting from 1 from the beginning to the end of the sequence.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint the elements that Sereja is interested in, in the order in which their numbers occur in the input.\n\nInputCopy61 11 22 2 11 32 5 21 4161 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16OutputCopy1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4\n\nInputCopy61 11 22 2 11 32 5 21 4161 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nOutputCopy1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 380\\s*A"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long seq_length = 0;\n\n    // For each of m stages\n    for (int i = 0; i < m; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int xi = inf.readInt(1, 100000, \"xi\");\n            inf.readEoln();\n            seq_length += 1;\n            ensuref(seq_length > 0, \"Sequence length overflow at step %d\", i + 1);\n        } else { // type == 2\n            inf.readSpace();\n            int li = inf.readInt(1, 100000, \"li\");\n            inf.readSpace();\n            int ci = inf.readInt(1, 10000, \"ci\");\n            inf.readEoln();\n\n            ensuref(li <= seq_length, \"li (%d) at step %d is greater than current sequence length (%lld)\", li, i + 1, seq_length);\n\n            long long increment = (long long) li * ci;\n            ensuref(seq_length <= LLONG_MAX - increment, \"Sequence length exceeds limit at step %d\", i + 1);\n            seq_length += increment;\n        }\n    }\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read positions\n    vector<long long> positions = inf.readLongs(n, 1LL, seq_length, \"positions\");\n    inf.readEoln();\n\n    // Ensure positions are in strictly increasing order\n    for (int i = 1; i < n; ++i) {\n        ensuref(positions[i - 1] < positions[i], \"Positions must be strictly increasing at position %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long seq_length = 0;\n\n    // For each of m stages\n    for (int i = 0; i < m; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int xi = inf.readInt(1, 100000, \"xi\");\n            inf.readEoln();\n            seq_length += 1;\n            ensuref(seq_length > 0, \"Sequence length overflow at step %d\", i + 1);\n        } else { // type == 2\n            inf.readSpace();\n            int li = inf.readInt(1, 100000, \"li\");\n            inf.readSpace();\n            int ci = inf.readInt(1, 10000, \"ci\");\n            inf.readEoln();\n\n            ensuref(li <= seq_length, \"li (%d) at step %d is greater than current sequence length (%lld)\", li, i + 1, seq_length);\n\n            long long increment = (long long) li * ci;\n            ensuref(seq_length <= LLONG_MAX - increment, \"Sequence length exceeds limit at step %d\", i + 1);\n            seq_length += increment;\n        }\n    }\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read positions\n    vector<long long> positions = inf.readLongs(n, 1LL, seq_length, \"positions\");\n    inf.readEoln();\n\n    // Ensure positions are in strictly increasing order\n    for (int i = 1; i < n; ++i) {\n        ensuref(positions[i - 1] < positions[i], \"Positions must be strictly increasing at position %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long seq_length = 0;\n\n    // For each of m stages\n    for (int i = 0; i < m; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int xi = inf.readInt(1, 100000, \"xi\");\n            inf.readEoln();\n            seq_length += 1;\n            ensuref(seq_length > 0, \"Sequence length overflow at step %d\", i + 1);\n        } else { // type == 2\n            inf.readSpace();\n            int li = inf.readInt(1, 100000, \"li\");\n            inf.readSpace();\n            int ci = inf.readInt(1, 10000, \"ci\");\n            inf.readEoln();\n\n            ensuref(li <= seq_length, \"li (%d) at step %d is greater than current sequence length (%lld)\", li, i + 1, seq_length);\n\n            long long increment = (long long) li * ci;\n            ensuref(seq_length <= LLONG_MAX - increment, \"Sequence length exceeds limit at step %d\", i + 1);\n            seq_length += increment;\n        }\n    }\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read positions\n    vector<long long> positions = inf.readLongs(n, 1LL, seq_length, \"positions\");\n    inf.readEoln();\n\n    // Ensure positions are in strictly increasing order\n    for (int i = 1; i < n; ++i) {\n        ensuref(positions[i - 1] < positions[i], \"Positions must be strictly increasing at position %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Revised Generator for the \"Sereja\" problem, fixing:\n   1) Compilation issues with \"rnd.next<long long>()\" usage.\n   2) Validation issues where l could exceed 100000 in type=2.\n\n  Constraints from the problem statement:\n   - 1 ≤ m ≤ 10^5\n   - For stage type=1, we add x where 1 ≤ x ≤ 10^5.\n   - For stage type=2, we copy a prefix of length l (1 ≤ l ≤ 10^5) exactly c times (1 ≤ c ≤ 10^4).\n   - l must not exceed the *current* length of the sequence at that stage.\n   - The next line's integer n (1 ≤ n ≤ 10^5) is the number of queries.\n   - Each query is a position (1 ≤ position ≤ length of final sequence).\n \n  Command-line parameters:\n    -m        (int)       number of stages\n    -n        (long long) number of queries desired (can be clamped)\n    -Xmax     (int)       max integer for type=1 additions [default=100000, with clamp ≤100000]\n    -cmax     (int)       max c for type=2 [default=10000, clamp ≤10000]\n    -mode     (string)    \"random\", \"only1\", \"only2\", or \"mixed\" (default=\"random\")\n\n  We do NOT set the random seed in this generator.\n*/\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int m               = opt<int>(\"m\");                  // number of stages\n    long long desiredN  = opt<long long>(\"n\");            // number of queries desired\n    int XmaxArg         = opt<int>(\"Xmax\", 100000);       // user might pass a value, clamp to ≤ 100000\n    int cmaxArg         = opt<int>(\"cmax\", 10000);        // user might pass a value, clamp to ≤ 10000\n    string mode         = opt<string>(\"mode\", \"random\");  // generation mode\n\n    // Clamp user-provided Xmax to the valid range [1..100000]\n    int Xmax = min(XmaxArg, 100000);\n\n    // Clamp user-provided cmax to the valid range [1..10000]\n    int cmax = min(cmaxArg, 10000);\n\n    // We'll store stages as:\n    //  type=1 => {1, x}\n    //  type=2 => {2, l, c}\n    vector<vector<long long>> stages;\n    stages.reserve(m);\n\n    // Track the current length of the sequence\n    long long currentLength = 0;\n\n    // Helper to add a type=1 operation\n    auto produce_type1 = [&](long long x) {\n        // 1 ≤ x ≤ 100000\n        stages.push_back({1, x});\n        currentLength += 1; \n    };\n\n    // Helper to add a type=2 operation\n    auto produce_type2 = [&](long long l, long long c) {\n        // 1 ≤ l ≤ 100000, 1 ≤ c ≤ 10000\n        // l ≤ currentLength\n        // new length = currentLength + l*c\n        stages.push_back({2, l, c});\n        currentLength += (l * c);\n    };\n\n    // A safety limit so we don't exceed extremely large sequence sizes\n    const long long LIMIT = (long long)1e14;\n\n    // Generate m operations\n    for(int i = 0; i < m; i++)\n    {\n        // If the sequence is empty, we must produce a type=1 to have a prefix\n        if(currentLength == 0) {\n            long long x = rnd.next((long long)1, (long long)Xmax);\n            produce_type1(x);\n            continue;\n        }\n\n        // Depending on mode, produce type=1 or type=2\n        if(mode == \"only1\") {\n            // Always type=1\n            long long x = rnd.next((long long)1, (long long)Xmax);\n            produce_type1(x);\n        }\n        else if(mode == \"only2\") {\n            // Always type=2\n            // l in [1..min(currentLength,100000)]\n            long long Lconstraint = min(currentLength, 100000LL);\n            long long l = rnd.next((long long)1, Lconstraint);\n            long long c = rnd.next((long long)1, (long long)cmax);\n\n            // Avoid overly large final size\n            while(currentLength + l*c > LIMIT && l > 0) {\n                c /= 2;\n                if(c < 1) {\n                    c = 1; \n                    break;\n                }\n            }\n            produce_type2(l, c);\n        }\n        else if(mode == \"mixed\") {\n            // 50% chance type=1, 50% chance type=2\n            if(rnd.next(0, 1) == 0) {\n                // type=1\n                long long x = rnd.next((long long)1, (long long)Xmax);\n                produce_type1(x);\n            } else {\n                // type=2\n                long long Lconstraint = min(currentLength, 100000LL);\n                long long l = rnd.next((long long)1, Lconstraint);\n                long long c = rnd.next((long long)1, (long long)cmax);\n\n                while(currentLength + l*c > LIMIT && l > 0) {\n                    c /= 2;\n                    if(c < 1) {\n                        c = 1;\n                        break;\n                    }\n                }\n                produce_type2(l, c);\n            }\n        }\n        else {\n            // \"random\" mode\n            // ~2/3 chance type=1, ~1/3 chance type=2\n            int opType = rnd.next(1, 3); // uniform in {1,2,3}\n            if(opType <= 2) {\n                // type=1\n                long long x = rnd.next((long long)1, (long long)Xmax);\n                produce_type1(x);\n            } else {\n                // type=2\n                long long Lconstraint = min(currentLength, 100000LL);\n                long long l = rnd.next((long long)1, Lconstraint);\n                long long c = rnd.next((long long)1, (long long)cmax);\n\n                while(currentLength + l*c > LIMIT && l > 0) {\n                    c /= 2;\n                    if(c < 1) {\n                        c = 1;\n                        break;\n                    }\n                }\n                produce_type2(l, c);\n            }\n        }\n    }\n\n    // Now currentLength is the total length of the final sequence\n    // We produce n queries, each in [1..currentLength], in strictly ascending order\n    if(currentLength == 0) {\n        // No valid queries if sequence is empty\n        desiredN = 0;\n    }\n    long long finalLength = currentLength;\n    long long n = desiredN;\n    if(n > finalLength) {\n        n = finalLength; // clamp\n    }\n\n    vector<long long> queries;\n    queries.reserve(n);\n\n    // Collect n distinct random queries within [1..finalLength]\n    if(n > 0) {\n        unordered_set<long long> chosen;\n        chosen.reserve((size_t)n * 2);\n\n        while((long long)chosen.size() < n) {\n            long long pos = rnd.next((long long)1, finalLength);\n            chosen.insert(pos);\n        }\n        queries.assign(chosen.begin(), chosen.end());\n        sort(queries.begin(), queries.end());\n    }\n\n    // Output: \n    // 1) m\n    // 2) m lines describing the stages\n    // 3) n\n    // 4) n queries in ascending order\n    cout << m << \"\\n\";\n    for(int i = 0; i < m; i++) {\n        if(stages[i][0] == 1) {\n            // type=1 x\n            cout << 1 << \" \" << stages[i][1] << \"\\n\";\n        } else {\n            // type=2 l c\n            cout << 2 << \" \" << stages[i][1] << \" \" << stages[i][2] << \"\\n\";\n        }\n    }\n\n    cout << n << \"\\n\";\n    for(int i = 0; i < (int)n; i++) {\n        cout << queries[i];\n        if(i + 1 < (int)n) cout << ' ';\n    }\n    cout << '\\n';\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Revised Generator for the \"Sereja\" problem, fixing:\n   1) Compilation issues with \"rnd.next<long long>()\" usage.\n   2) Validation issues where l could exceed 100000 in type=2.\n\n  Constraints from the problem statement:\n   - 1 ≤ m ≤ 10^5\n   - For stage type=1, we add x where 1 ≤ x ≤ 10^5.\n   - For stage type=2, we copy a prefix of length l (1 ≤ l ≤ 10^5) exactly c times (1 ≤ c ≤ 10^4).\n   - l must not exceed the *current* length of the sequence at that stage.\n   - The next line's integer n (1 ≤ n ≤ 10^5) is the number of queries.\n   - Each query is a position (1 ≤ position ≤ length of final sequence).\n \n  Command-line parameters:\n    -m        (int)       number of stages\n    -n        (long long) number of queries desired (can be clamped)\n    -Xmax     (int)       max integer for type=1 additions [default=100000, with clamp ≤100000]\n    -cmax     (int)       max c for type=2 [default=10000, clamp ≤10000]\n    -mode     (string)    \"random\", \"only1\", \"only2\", or \"mixed\" (default=\"random\")\n\n  We do NOT set the random seed in this generator.\n*/\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int m               = opt<int>(\"m\");                  // number of stages\n    long long desiredN  = opt<long long>(\"n\");            // number of queries desired\n    int XmaxArg         = opt<int>(\"Xmax\", 100000);       // user might pass a value, clamp to ≤ 100000\n    int cmaxArg         = opt<int>(\"cmax\", 10000);        // user might pass a value, clamp to ≤ 10000\n    string mode         = opt<string>(\"mode\", \"random\");  // generation mode\n\n    // Clamp user-provided Xmax to the valid range [1..100000]\n    int Xmax = min(XmaxArg, 100000);\n\n    // Clamp user-provided cmax to the valid range [1..10000]\n    int cmax = min(cmaxArg, 10000);\n\n    // We'll store stages as:\n    //  type=1 => {1, x}\n    //  type=2 => {2, l, c}\n    vector<vector<long long>> stages;\n    stages.reserve(m);\n\n    // Track the current length of the sequence\n    long long currentLength = 0;\n\n    // Helper to add a type=1 operation\n    auto produce_type1 = [&](long long x) {\n        // 1 ≤ x ≤ 100000\n        stages.push_back({1, x});\n        currentLength += 1; \n    };\n\n    // Helper to add a type=2 operation\n    auto produce_type2 = [&](long long l, long long c) {\n        // 1 ≤ l ≤ 100000, 1 ≤ c ≤ 10000\n        // l ≤ currentLength\n        // new length = currentLength + l*c\n        stages.push_back({2, l, c});\n        currentLength += (l * c);\n    };\n\n    // A safety limit so we don't exceed extremely large sequence sizes\n    const long long LIMIT = (long long)1e14;\n\n    // Generate m operations\n    for(int i = 0; i < m; i++)\n    {\n        // If the sequence is empty, we must produce a type=1 to have a prefix\n        if(currentLength == 0) {\n            long long x = rnd.next((long long)1, (long long)Xmax);\n            produce_type1(x);\n            continue;\n        }\n\n        // Depending on mode, produce type=1 or type=2\n        if(mode == \"only1\") {\n            // Always type=1\n            long long x = rnd.next((long long)1, (long long)Xmax);\n            produce_type1(x);\n        }\n        else if(mode == \"only2\") {\n            // Always type=2\n            // l in [1..min(currentLength,100000)]\n            long long Lconstraint = min(currentLength, 100000LL);\n            long long l = rnd.next((long long)1, Lconstraint);\n            long long c = rnd.next((long long)1, (long long)cmax);\n\n            // Avoid overly large final size\n            while(currentLength + l*c > LIMIT && l > 0) {\n                c /= 2;\n                if(c < 1) {\n                    c = 1; \n                    break;\n                }\n            }\n            produce_type2(l, c);\n        }\n        else if(mode == \"mixed\") {\n            // 50% chance type=1, 50% chance type=2\n            if(rnd.next(0, 1) == 0) {\n                // type=1\n                long long x = rnd.next((long long)1, (long long)Xmax);\n                produce_type1(x);\n            } else {\n                // type=2\n                long long Lconstraint = min(currentLength, 100000LL);\n                long long l = rnd.next((long long)1, Lconstraint);\n                long long c = rnd.next((long long)1, (long long)cmax);\n\n                while(currentLength + l*c > LIMIT && l > 0) {\n                    c /= 2;\n                    if(c < 1) {\n                        c = 1;\n                        break;\n                    }\n                }\n                produce_type2(l, c);\n            }\n        }\n        else {\n            // \"random\" mode\n            // ~2/3 chance type=1, ~1/3 chance type=2\n            int opType = rnd.next(1, 3); // uniform in {1,2,3}\n            if(opType <= 2) {\n                // type=1\n                long long x = rnd.next((long long)1, (long long)Xmax);\n                produce_type1(x);\n            } else {\n                // type=2\n                long long Lconstraint = min(currentLength, 100000LL);\n                long long l = rnd.next((long long)1, Lconstraint);\n                long long c = rnd.next((long long)1, (long long)cmax);\n\n                while(currentLength + l*c > LIMIT && l > 0) {\n                    c /= 2;\n                    if(c < 1) {\n                        c = 1;\n                        break;\n                    }\n                }\n                produce_type2(l, c);\n            }\n        }\n    }\n\n    // Now currentLength is the total length of the final sequence\n    // We produce n queries, each in [1..currentLength], in strictly ascending order\n    if(currentLength == 0) {\n        // No valid queries if sequence is empty\n        desiredN = 0;\n    }\n    long long finalLength = currentLength;\n    long long n = desiredN;\n    if(n > finalLength) {\n        n = finalLength; // clamp\n    }\n\n    vector<long long> queries;\n    queries.reserve(n);\n\n    // Collect n distinct random queries within [1..finalLength]\n    if(n > 0) {\n        unordered_set<long long> chosen;\n        chosen.reserve((size_t)n * 2);\n\n        while((long long)chosen.size() < n) {\n            long long pos = rnd.next((long long)1, finalLength);\n            chosen.insert(pos);\n        }\n        queries.assign(chosen.begin(), chosen.end());\n        sort(queries.begin(), queries.end());\n    }\n\n    // Output: \n    // 1) m\n    // 2) m lines describing the stages\n    // 3) n\n    // 4) n queries in ascending order\n    cout << m << \"\\n\";\n    for(int i = 0; i < m; i++) {\n        if(stages[i][0] == 1) {\n            // type=1 x\n            cout << 1 << \" \" << stages[i][1] << \"\\n\";\n        } else {\n            // type=2 l c\n            cout << 2 << \" \" << stages[i][1] << \" \" << stages[i][2] << \"\\n\";\n        }\n    }\n\n    cout << n << \"\\n\";\n    for(int i = 0; i < (int)n; i++) {\n        cout << queries[i];\n        if(i + 1 < (int)n) cout << ' ';\n    }\n    cout << '\\n';\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Approximately 20 distinct commands for generating test cases with the revised code:\n\n# 1) Small test, only type=1\n./gen -m 5 -n 5 -mode only1\n\n# 2) Small test, only type=2\n./gen -m 5 -n 5 -mode only2\n\n# 3) Small test, random mode\n./gen -m 5 -n 5 -mode random\n\n# 4) Medium random, smaller m & n\n./gen -m 20 -n 15 -mode random\n\n# 5) Medium \"mixed\" mode\n./gen -m 20 -n 20 -mode mixed\n\n# 6) Larger random test\n./gen -m 50 -n 50 -mode random\n\n# 7) Larger random test with many queries\n./gen -m 100 -n 500 -mode random\n\n# 8) Large, only type=1\n./gen -m 100 -n 100 -mode only1\n\n# 9) Large, only type=2\n./gen -m 100 -n 90 -mode only2\n\n# 10) Mixed mode, medium range\n./gen -m 30 -n 25 -mode mixed\n\n# 11) Mixed mode, bigger range\n./gen -m 500 -n 400 -mode mixed\n\n# 12) Random mode, bigger M\n./gen -m 1000 -n 1000 -mode random\n\n# 13) Another large random scenario\n./gen -m 2000 -n 2000 -mode random\n\n# 14) Larger \"only2\" scenario\n./gen -m 2000 -n 1500 -mode only2\n\n# 15) \"mixed\" with moderate m, bigger n\n./gen -m 200 -n 500 -mode mixed\n\n# 16) \"only1\" with big m and bigger n\n./gen -m 3000 -n 2500 -mode only1\n\n# 17) Another large random, moderate queries\n./gen -m 5000 -n 1000 -mode random\n\n# 18) Very large M random scenario\n./gen -m 10000 -n 10000 -mode random\n\n# 19) Large \"only2\" scenario (cmax default=10000)\n./gen -m 10000 -n 5000 -mode only2\n\n# 20) Mixed scenario with fairly large parameters\n./gen -m 10000 -n 9999 -mode mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:17.126212",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "380/B",
      "title": "B. Сережа и дерево",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целые числа n и m (1 ≤ n, m ≤ 7000). Следующие m строк содержат описания операций. Операция первого типа задается пятью целыми числами: 1 t l r x (1 ≤ t ≤ n; 1 ≤ l ≤ r ≤ cnt[t]; 1 ≤ x ≤ 106). Операция второго типа задается тремя целыми числами: 2 t v (1 ≤ t ≤ n; 1 ≤ v ≤ cnt[t]).",
      "output_spec": "Выходные данныеДля каждой операции второго типа выведите ответ в отдельной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 4 4 7 11 3 1 2 22 1 12 4 12 3 3Выходные данныеСкопировать201",
      "description": "B. Сережа и дерево\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целые числа n и m (1 ≤ n, m ≤ 7000). Следующие m строк содержат описания операций. Операция первого типа задается пятью целыми числами: 1 t l r x (1 ≤ t ≤ n; 1 ≤ l ≤ r ≤ cnt[t]; 1 ≤ x ≤ 106). Операция второго типа задается тремя целыми числами: 2 t v (1 ≤ t ≤ n; 1 ≤ v ≤ cnt[t]).\n\nВходные данные\n\nВыходные данныеДля каждой операции второго типа выведите ответ в отдельной строке.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 4 4 7 11 3 1 2 22 1 12 4 12 3 3Выходные данныеСкопировать201\n\nВходные данныеСкопировать4 51 4 4 7 11 3 1 2 22 1 12 4 12 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать201\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОпределения связанные с корневыми деревьями можно найти по ссылке http://ru.wikipedia.org/wiki/Дерево_(теория_графов).Ниже нарисовано построенное дерево для n = 4.",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Всем привет!Совсем скоро, 12 января в 19:30 MSK состоится Codeforces Round #223, автором которого являюсь я. Это мой десятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Это первый раунд в этом году. Кстати, в прошлом году первый раунд для двух дивизионов тоже был мой(а по статистике +1/-1, оказался самым крутым из тех, что я давал). Надеюсь, что в этот раз задачи окажутся еще более интересными для Вас. Получится ли? Узнаем после окончания раунда :)Gl & hf ! :)Разбалловка в обоих дивизионах стандартная.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 689
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces",
          "content": "381A - Сережа и ДимаПросто проделаем все операции описанные в условии.381B - Сережа и лесенкаПосчитаем количества каждого числа. Все различные числа, кроме максимального можно использовать не более 2-х раз. Максимальное же — только 1.380A - Сережа и префиксыСгенерируем первые 100000 чисел. Будем по очереди обратывать запросы, если запрос попадает в точку доабвления 1 числа, то просто выведем его. Иначе посмотрим, какому элементу будет соотвествовать наш, и просто выведм его из предподсчитаного массива.380B - Сережа и деревоСгенерируем дерево, как описано в условии. Для каждого запроса на добавление элементов. Просто для уровня будем добавлять отрезок. На запрос количества элементов будем просто проходить по всем нижним уровням, считая самую левую и самую правую вершину в поддереве. Далее для каждого уровня будем проходить по отрезкам, которые ему принадлежат и для каждого проверять — пересекается ли он с тем, что у нас сгенерирован на текущем этапе. Если да, то просто добавим элемент в множество. Сложность решения O(n·m).380C - Сережа и скобочкиБудем поддерживать дерево отрезков, в каждой вершине будем хранить:av — максимальную длину скобочной подпоследовательностиbv — сколько вне нее есть открытых скобокcv — сколько вне нее есть закрытых скобокЕсли нам нужно объединить две вершины с параметрами (a1, b1, c1) и (a2, b2, c2), то можно пользоваться следующими правилами:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Сережа и кинотеатрДля того, что бы никто не обиделся достаточно, что бы все кроме первого человека содились возле уже сидящего. Теперь когда приходит любой челвек мы точно знаем, что по одну сторону от него никто не сидит. Будем использовать это. Будем поддерживать интервал точно занятых мест. Если первый человек не известен, то таких возможных интервала будет 2. Теперь лишь осталось аккуратно рассмотреть все случаи того как могли заходить люди, ведь на каждой итерации мы точно знаем сколько людей куда сядут.380E - Сережа и делениеЗаметим, что на любом конкретном отрезке нас интересует не более 60 чисел. Самое большое войдет в ответ с коэфициентом 1/2, следующее — 1/4, 1/8 и так далее. Таким образом для решения нужно для каждого числа знать: в сколько отрезков оно входит как максимум, как второй максимум, третий, и так далее до 60ого.Что бы знать такую информацию достаточно найти 60 чисел больше заданого слева и справа. Это можно делать аккуратно написаным set-ом, или dsu. Теперь имея такую информацию можно посчитать величину, которую элемент несет в ответ. Это не сложно сделать, зная позиции элементов, больших текущего. Пускай позиции элементов слева p1 > p2 > ... > ps1. А позиций справа q1 < q2 < ... < qs2. .Все детали можно посмотреть в любом прошедшем решении.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 380\\s*B"
          },
          "content_length": 2741
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 - Codeforces - Code 1",
          "code": "9 января в 19:30 MSK",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 - Codeforces - Code 2",
          "code": "Получится ли? Узнаем после окончания раунда :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 1",
          "code": "max(0, -minimum_balance)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 2",
          "code": "b[l] + b[r] - 2*min",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 3",
          "code": "r' выступает за r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 4",
          "code": "это граница после уменьшения её до тех пор, пока она не влезет.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 5",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 6",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 7",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 8",
          "code": "cin>>s;\ns=\" \"+s;\nint n=sz(s);\nn--;\nsegtree=vector<Info*>(4*(n));\nfo(i,4*(n)) segtree[i]=new Info(0,0,0);\nbuild(1,1,n);\nint m;\ncin>>m;\nwhile(m--){\n    int a,b;\n    cin>>a>>b;\n    cout<<(query(1,1,n,a,b)->full)*2<<\"\\n\";\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 9",
          "code": "this gives a memory limit exceeded but",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 10",
          "code": "this gives a memory limit exceeded but",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 11",
          "code": "cin>>s;\ns=\" \"+s;\nint n=sz(s);\nn--;\nsegtree=vector<Info*>(4*(n),new Info(0,0,0));\nbuild(1,1,n);\nint m;\ncin>>m;\nwhile(m--){\n    int a,b;\n    cin>>a>>b;\n    cout<<(query(1,1,n,a,b)->full)*2<<\"\\n\";\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 12",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 13",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerOfTwo(int x) {\n    return x>=1 && (x & (x -1)) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 7000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 7000, \"m\");\n    inf.readEoln();\n\n    vector<int> cnt(n + 2);\n    cnt[1] = 1;\n\n    for (int level = 1; level < n; level++) {\n        cnt[level +1 ] = 0;\n        for (int position =1; position <= cnt[level]; position++) {\n            if (isPowerOfTwo(position)) {\n                cnt[level+1] +=2;\n            } else {\n                cnt[level+1] +=1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        if (op == 1) {\n            // Read \"1 t l r x\"\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int l = inf.readInt(1, cnt[t], \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, cnt[t], \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000, \"x\");\n            inf.readEoln();\n        } else {\n            // Read \"2 t v\"\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int v = inf.readInt(1, cnt[t], \"v\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerOfTwo(int x) {\n    return x>=1 && (x & (x -1)) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 7000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 7000, \"m\");\n    inf.readEoln();\n\n    vector<int> cnt(n + 2);\n    cnt[1] = 1;\n\n    for (int level = 1; level < n; level++) {\n        cnt[level +1 ] = 0;\n        for (int position =1; position <= cnt[level]; position++) {\n            if (isPowerOfTwo(position)) {\n                cnt[level+1] +=2;\n            } else {\n                cnt[level+1] +=1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        if (op == 1) {\n            // Read \"1 t l r x\"\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int l = inf.readInt(1, cnt[t], \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, cnt[t], \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000, \"x\");\n            inf.readEoln();\n        } else {\n            // Read \"2 t v\"\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int v = inf.readInt(1, cnt[t], \"v\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerOfTwo(int x) {\n    return x>=1 && (x & (x -1)) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 7000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 7000, \"m\");\n    inf.readEoln();\n\n    vector<int> cnt(n + 2);\n    cnt[1] = 1;\n\n    for (int level = 1; level < n; level++) {\n        cnt[level +1 ] = 0;\n        for (int position =1; position <= cnt[level]; position++) {\n            if (isPowerOfTwo(position)) {\n                cnt[level+1] +=2;\n            } else {\n                cnt[level+1] +=1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        if (op == 1) {\n            // Read \"1 t l r x\"\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int l = inf.readInt(1, cnt[t], \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, cnt[t], \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000, \"x\");\n            inf.readEoln();\n        } else {\n            // Read \"2 t v\"\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int v = inf.readInt(1, cnt[t], \"v\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Compute cnt[]\n    vector<int> cnt(n + 1);\n    cnt[1] = 1;\n    for (int level = 1; level < n; ++level) {\n        cnt[level+1] = 0;\n        for (int position = 1; position <= cnt[level]; ++position) {\n            if ((position & (position -1)) == 0) {\n                // position is power of two\n                cnt[level+1] += 2;\n            } else {\n                cnt[level+1] += 1;\n            }\n        }\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << endl;\n\n    if (type == \"all1\" || type == \"alltype1\") {\n        // All Type 1 operations\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int l = rnd.next(1, cnt[t]);\n            int r = rnd.next(l, cnt[t]);\n            int x = rnd.next(1, 1000000);\n            printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n        }\n    } else if (type == \"all2\" || type == \"alltype2\") {\n        // All Type 2 operations\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int v = rnd.next(1, cnt[t]);\n            printf(\"2 %d %d\\n\", t, v);\n        }\n    } else if (type == \"alternating\") {\n        // Alternating Type 1 and Type 2 operations\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"maxvalues\") {\n        // Operations with maximum values\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = n;\n                int l = 1;\n                int r = cnt[t];\n                int x = 1000000;\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = n;\n                int v = cnt[t];\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"minvalues\") {\n        // Operations with minimum values\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = 1;\n                int l = 1;\n                int r = 1;\n                int x = 1;\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = 1;\n                int v = 1;\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"edgecases\") {\n        // Edge cases to test boundary conditions\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            int t = rnd.next(1,n);\n            if (op_type == 1) {\n                int l = rnd.next(1, cnt[t]);\n                int r = l; // l == r\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"samex\") {\n        // All operations with the same x value\n        int x = rnd.next(1, 1000000);\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"samet\") {\n        // All operations on the same level t\n        int t = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else {\n        // Default: random operations\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Compute cnt[]\n    vector<int> cnt(n + 1);\n    cnt[1] = 1;\n    for (int level = 1; level < n; ++level) {\n        cnt[level+1] = 0;\n        for (int position = 1; position <= cnt[level]; ++position) {\n            if ((position & (position -1)) == 0) {\n                // position is power of two\n                cnt[level+1] += 2;\n            } else {\n                cnt[level+1] += 1;\n            }\n        }\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << endl;\n\n    if (type == \"all1\" || type == \"alltype1\") {\n        // All Type 1 operations\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int l = rnd.next(1, cnt[t]);\n            int r = rnd.next(l, cnt[t]);\n            int x = rnd.next(1, 1000000);\n            printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n        }\n    } else if (type == \"all2\" || type == \"alltype2\") {\n        // All Type 2 operations\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int v = rnd.next(1, cnt[t]);\n            printf(\"2 %d %d\\n\", t, v);\n        }\n    } else if (type == \"alternating\") {\n        // Alternating Type 1 and Type 2 operations\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"maxvalues\") {\n        // Operations with maximum values\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = n;\n                int l = 1;\n                int r = cnt[t];\n                int x = 1000000;\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = n;\n                int v = cnt[t];\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"minvalues\") {\n        // Operations with minimum values\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = 1;\n                int l = 1;\n                int r = 1;\n                int x = 1;\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = 1;\n                int v = 1;\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"edgecases\") {\n        // Edge cases to test boundary conditions\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            int t = rnd.next(1,n);\n            if (op_type == 1) {\n                int l = rnd.next(1, cnt[t]);\n                int r = l; // l == r\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"samex\") {\n        // All operations with the same x value\n        int x = rnd.next(1, 1000000);\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else if (type == \"samet\") {\n        // All operations on the same level t\n        int t = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    } else {\n        // Default: random operations\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1,2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                printf(\"1 %d %d %d %d\\n\", t, l, r, x);\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                printf(\"2 %d %d\\n\", t, v);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type minvalues\n./gen -n 1 -m 1 -type maxvalues\n./gen -n 1 -m 10 -type minvalues\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 100 -type random\n./gen -n 100 -m 1000 -type random\n./gen -n 7000 -m 7000 -type random\n./gen -n 7000 -m 7000 -type maxvalues\n./gen -n 7000 -m 7000 -type minvalues\n./gen -n 7000 -m 7000 -type alltype1\n./gen -n 7000 -m 7000 -type alltype2\n./gen -n 7000 -m 7000 -type alternating\n./gen -n 7000 -m 7000 -type edgecases\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 7000 -type random\n./gen -n 7000 -m 7000 -type maxvalues\n./gen -n 7000 -m 7000 -type minvalues\n./gen -n 1 -m 7000 -type alltype1\n./gen -n 1 -m 7000 -type alltype2\n./gen -n 7000 -m 7000 -type edgecases\n./gen -n 7000 -m 7000 -type alltype1\n./gen -n 7000 -m 7000 -type alltype2\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 20 -type alternating\n./gen -n 7000 -m 7000 -type samex\n./gen -n 7000 -m 7000 -type samet\n./gen -n 7000 -m 7000 -type edgecases\n./gen -n 7000 -m 7000 -type samet\n./gen -n 7000 -m 7000 -type samex\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:18.909547",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "380/C",
      "title": "C. Sereja and Brackets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a sequence of characters s1, s2, ..., sn (1 ≤ n ≤ 106) without any spaces. Each character is either a \"(\" or a \")\". The second line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers li, ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th query.",
      "output_spec": "OutputPrint the answer to each question on a single line. Print the answers in the order they go in the input.",
      "sample_tests": "ExamplesInputCopy())(())(())(71 12 31 21 128 125 112 10OutputCopy00210466",
      "description": "C. Sereja and Brackets\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a sequence of characters s1, s2, ..., sn (1 ≤ n ≤ 106) without any spaces. Each character is either a \"(\" or a \")\". The second line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers li, ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th query.\n\nOutputPrint the answer to each question on a single line. Print the answers in the order they go in the input.\n\nInputCopy())(())(())(71 12 31 21 128 125 112 10OutputCopy00210466\n\nInputCopy())(())(())(71 12 31 21 128 125 112 10\n\nOutputCopy00210466\n\nNoteA subsequence of length |x| of string s = s1s2... s|s| (where |s| is the length of string s) is string x = sk1sk2... sk|x| (1 ≤ k1 < k2 < ... < k|x| ≤ |s|).A correct bracket sequence is a bracket sequence that can be transformed into a correct aryphmetic expression by inserting characters \"1\" and \"+\" between the characters of the string. For example, bracket sequences \"()()\", \"(())\" are correct (the resulting expressions \"(1)+(1)\", \"((1+1)+1)\"), and \")(\" and \"(\" are not.For the third query required sequence will be «()».For the fourth query required sequence will be «()(())(())».",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 380\\s*C"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of s (%d) is not in range [1, 1e6]\", (int)s.length());\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> arr = inf.readInts(2, 1, n);\n        inf.readEoln();\n        int l_i = arr[0];\n        int r_i = arr[1];\n        ensuref(l_i <= r_i, \"Query %d: l_i (%d) > r_i (%d)\", i+1, l_i, r_i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of s (%d) is not in range [1, 1e6]\", (int)s.length());\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> arr = inf.readInts(2, 1, n);\n        inf.readEoln();\n        int l_i = arr[0];\n        int r_i = arr[1];\n        ensuref(l_i <= r_i, \"Query %d: l_i (%d) > r_i (%d)\", i+1, l_i, r_i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of s (%d) is not in range [1, 1e6]\", (int)s.length());\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> arr = inf.readInts(2, 1, n);\n        inf.readEoln();\n        int l_i = arr[0];\n        int r_i = arr[1];\n        ensuref(l_i <= r_i, \"Query %d: l_i (%d) > r_i (%d)\", i+1, l_i, r_i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    assert(1 <= n && n <= 1000000);\n    assert(1 <= m && m <= 100000);\n\n    string s(n, ' ');\n\n    if (s_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"all_open\") {\n        s.assign(n, '(');\n    } else if (s_type == \"all_close\") {\n        s.assign(n, ')');\n    } else if (s_type == \"perfect\") {\n        // Generate a correct bracket sequence of length n\n        int n_pairs = n / 2;\n        int n_open = 0;\n        int n_close = 0;\n        for (int i = 0; i < n; ++i) {\n            if (n_open < n_pairs && (n_close == n_open || rnd.next(2) == 0)) {\n                s[i] = '(';\n                n_open++;\n            } else {\n                s[i] = ')';\n                n_close++;\n            }\n        }\n        // If n is odd, fill the last character randomly\n        if (n % 2 != 0) {\n            s[n-1] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"nested\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i < n / 2) ? '(' : ')';\n        }\n        // If n is odd, fill the last character randomly\n        if (n % 2 != 0) {\n            s[n-1] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"mismatched\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n        // Introduce mismatches\n        int num_changes = rnd.next(1, min(10, n));\n        for (int i = 0; i < num_changes; ++i) {\n            int idx = rnd.next(0, n - 1);\n            s[idx] = (s[idx] == '(') ? ')' : '(';\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    // Generate m queries, according to q_type\n    printf(\"%d\\n\", m);\n\n    for (int i = 0; i < m; ++i) {\n        int l, r;\n        if (q_type == \"random\") {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        } else if (q_type == \"full\") {\n            l = 1;\n            r = n;\n        } else if (q_type == \"small\") {\n            l = rnd.next(1, n);\n            r = l;\n        } else if (q_type == \"prefix\") {\n            l = 1;\n            r = rnd.next(1, n);\n        } else if (q_type == \"suffix\") {\n            l = rnd.next(1, n);\n            r = n;\n        } else {\n            // Default to random\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        }\n        printf(\"%d %d\\n\", l, r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    assert(1 <= n && n <= 1000000);\n    assert(1 <= m && m <= 100000);\n\n    string s(n, ' ');\n\n    if (s_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"all_open\") {\n        s.assign(n, '(');\n    } else if (s_type == \"all_close\") {\n        s.assign(n, ')');\n    } else if (s_type == \"perfect\") {\n        // Generate a correct bracket sequence of length n\n        int n_pairs = n / 2;\n        int n_open = 0;\n        int n_close = 0;\n        for (int i = 0; i < n; ++i) {\n            if (n_open < n_pairs && (n_close == n_open || rnd.next(2) == 0)) {\n                s[i] = '(';\n                n_open++;\n            } else {\n                s[i] = ')';\n                n_close++;\n            }\n        }\n        // If n is odd, fill the last character randomly\n        if (n % 2 != 0) {\n            s[n-1] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"nested\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i < n / 2) ? '(' : ')';\n        }\n        // If n is odd, fill the last character randomly\n        if (n % 2 != 0) {\n            s[n-1] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    } else if (s_type == \"mismatched\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n        // Introduce mismatches\n        int num_changes = rnd.next(1, min(10, n));\n        for (int i = 0; i < num_changes; ++i) {\n            int idx = rnd.next(0, n - 1);\n            s[idx] = (s[idx] == '(') ? ')' : '(';\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(2) == 0) ? '(' : ')';\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    // Generate m queries, according to q_type\n    printf(\"%d\\n\", m);\n\n    for (int i = 0; i < m; ++i) {\n        int l, r;\n        if (q_type == \"random\") {\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        } else if (q_type == \"full\") {\n            l = 1;\n            r = n;\n        } else if (q_type == \"small\") {\n            l = rnd.next(1, n);\n            r = l;\n        } else if (q_type == \"prefix\") {\n            l = 1;\n            r = rnd.next(1, n);\n        } else if (q_type == \"suffix\") {\n            l = rnd.next(1, n);\n            r = n;\n        } else {\n            // Default to random\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        }\n        printf(\"%d %d\\n\", l, r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -s_type all_open -q_type random\n./gen -n 1 -m 1 -s_type all_close -q_type random\n./gen -n 2 -m 1 -s_type perfect -q_type full\n./gen -n 2 -m 1 -s_type alternate -q_type small\n./gen -n 5 -m 3 -s_type mismatched -q_type random\n./gen -n 10 -m 5 -s_type nested -q_type prefix\n./gen -n 20 -m 10 -s_type random -q_type suffix\n./gen -n 50 -m 20 -s_type random -q_type random\n\n./gen -n 100 -m 50 -s_type perfect -q_type random\n./gen -n 100 -m 50 -s_type mismatched -q_type full\n./gen -n 100 -m 50 -s_type random -q_type small\n\n./gen -n 1000 -m 500 -s_type nested -q_type random\n./gen -n 1000 -m 500 -s_type alternate -q_type random\n./gen -n 1000 -m 500 -s_type random -q_type random\n\n./gen -n 1000000 -m 100000 -s_type perfect -q_type full\n./gen -n 1000000 -m 100000 -s_type mismatched -q_type random\n./gen -n 1000000 -m 100000 -s_type random -q_type random\n\n./gen -n 1 -m 1 -s_type random -q_type full\n./gen -n 1 -m 1 -s_type random -q_type small\n./gen -n 1000000 -m 1 -s_type all_open -q_type full\n./gen -n 1000000 -m 100000 -s_type all_close -q_type small\n\n./gen -n 999999 -m 99999 -s_type nested -q_type suffix\n./gen -n 1000000 -m 100000 -s_type alternate -q_type prefix\n\n./gen -n 1000000 -m 1 -s_type random -q_type random\n\n./gen -n 10 -m 100000 -s_type random -q_type random\n\n./gen -n 500000 -m 50000 -s_type all_open -q_type random\n./gen -n 500000 -m 50000 -s_type all_close -q_type random\n./gen -n 500000 -m 50000 -s_type perfect -q_type random\n./gen -n 500000 -m 50000 -s_type nested -q_type random\n./gen -n 500000 -m 50000 -s_type alternate -q_type random\n./gen -n 500000 -m 50000 -s_type mismatched -q_type random\n\n./gen -n 1000000 -m 100000 -s_type random -q_type prefix\n./gen -n 1000000 -m 100000 -s_type random -q_type suffix\n./gen -n 1000000 -m 100000 -s_type random -q_type small\n\n./gen -n 1000000 -m 100000 -s_type random -q_type full\n\n./gen -n 1000000 -m 100000 -s_type random -q_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:21.153034",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "380/D",
      "title": "D. Сережа и кинотеатр",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105). Вторая строка содержит n целых чисел, i-ое число — либо каким по номеру будет человек, у которого билет на i-ое место, либо 0, если его порядковый номер не известен. Гарантируется, что все положительные числа во второй строке будут различны.Считайте, что порядковый номер зашедшего в зал — это уникальное целое число от 1 до n. Человек, имеющий порядковый номер 1, зайдет первым в зал, человек, имеющий порядковый номер 2, зайдет вторым в зал и так далее.",
      "output_spec": "Выходные данныеВ единственную строку выведите остаток от деления ответа на число 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать110 0 0 0 0 0 0 0 0 0 0Выходные данныеСкопировать1024Входные данныеСкопировать60 3 1 0 0 0Выходные данныеСкопировать3",
      "description": "D. Сережа и кинотеатр\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105). Вторая строка содержит n целых чисел, i-ое число — либо каким по номеру будет человек, у которого билет на i-ое место, либо 0, если его порядковый номер не известен. Гарантируется, что все положительные числа во второй строке будут различны.Считайте, что порядковый номер зашедшего в зал — это уникальное целое число от 1 до n. Человек, имеющий порядковый номер 1, зайдет первым в зал, человек, имеющий порядковый номер 2, зайдет вторым в зал и так далее.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите остаток от деления ответа на число 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать110 0 0 0 0 0 0 0 0 0 0Выходные данныеСкопировать1024Входные данныеСкопировать60 3 1 0 0 0Выходные данныеСкопировать3\n\nВходные данныеСкопировать110 0 0 0 0 0 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1024\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать60 3 1 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Всем привет!Совсем скоро, 12 января в 19:30 MSK состоится Codeforces Round #223, автором которого являюсь я. Это мой десятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Это первый раунд в этом году. Кстати, в прошлом году первый раунд для двух дивизионов тоже был мой(а по статистике +1/-1, оказался самым крутым из тех, что я давал). Надеюсь, что в этот раз задачи окажутся еще более интересными для Вас. Получится ли? Узнаем после окончания раунда :)Gl & hf ! :)Разбалловка в обоих дивизионах стандартная.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 689
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces",
          "content": "381A - Сережа и ДимаПросто проделаем все операции описанные в условии.381B - Сережа и лесенкаПосчитаем количества каждого числа. Все различные числа, кроме максимального можно использовать не более 2-х раз. Максимальное же — только 1.380A - Сережа и префиксыСгенерируем первые 100000 чисел. Будем по очереди обратывать запросы, если запрос попадает в точку доабвления 1 числа, то просто выведем его. Иначе посмотрим, какому элементу будет соотвествовать наш, и просто выведм его из предподсчитаного массива.380B - Сережа и деревоСгенерируем дерево, как описано в условии. Для каждого запроса на добавление элементов. Просто для уровня будем добавлять отрезок. На запрос количества элементов будем просто проходить по всем нижним уровням, считая самую левую и самую правую вершину в поддереве. Далее для каждого уровня будем проходить по отрезкам, которые ему принадлежат и для каждого проверять — пересекается ли он с тем, что у нас сгенерирован на текущем этапе. Если да, то просто добавим элемент в множество. Сложность решения O(n·m).380C - Сережа и скобочкиБудем поддерживать дерево отрезков, в каждой вершине будем хранить:av — максимальную длину скобочной подпоследовательностиbv — сколько вне нее есть открытых скобокcv — сколько вне нее есть закрытых скобокЕсли нам нужно объединить две вершины с параметрами (a1, b1, c1) и (a2, b2, c2), то можно пользоваться следующими правилами:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Сережа и кинотеатрДля того, что бы никто не обиделся достаточно, что бы все кроме первого человека содились возле уже сидящего. Теперь когда приходит любой челвек мы точно знаем, что по одну сторону от него никто не сидит. Будем использовать это. Будем поддерживать интервал точно занятых мест. Если первый человек не известен, то таких возможных интервала будет 2. Теперь лишь осталось аккуратно рассмотреть все случаи того как могли заходить люди, ведь на каждой итерации мы точно знаем сколько людей куда сядут.380E - Сережа и делениеЗаметим, что на любом конкретном отрезке нас интересует не более 60 чисел. Самое большое войдет в ответ с коэфициентом 1/2, следующее — 1/4, 1/8 и так далее. Таким образом для решения нужно для каждого числа знать: в сколько отрезков оно входит как максимум, как второй максимум, третий, и так далее до 60ого.Что бы знать такую информацию достаточно найти 60 чисел больше заданого слева и справа. Это можно делать аккуратно написаным set-ом, или dsu. Теперь имея такую информацию можно посчитать величину, которую элемент несет в ответ. Это не сложно сделать, зная позиции элементов, больших текущего. Пускай позиции элементов слева p1 > p2 > ... > ps1. А позиций справа q1 < q2 < ... < qs2. .Все детали можно посмотреть в любом прошедшем решении.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 380\\s*D"
          },
          "content_length": 2741
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 - Codeforces - Code 1",
          "code": "9 января в 19:30 MSK",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 - Codeforces - Code 2",
          "code": "Получится ли? Узнаем после окончания раунда :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 1",
          "code": "max(0, -minimum_balance)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 2",
          "code": "b[l] + b[r] - 2*min",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 3",
          "code": "r' выступает за r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 4",
          "code": "это граница после уменьшения её до тех пор, пока она не влезет.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 5",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 6",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 7",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 8",
          "code": "cin>>s;\ns=\" \"+s;\nint n=sz(s);\nn--;\nsegtree=vector<Info*>(4*(n));\nfo(i,4*(n)) segtree[i]=new Info(0,0,0);\nbuild(1,1,n);\nint m;\ncin>>m;\nwhile(m--){\n    int a,b;\n    cin>>a>>b;\n    cout<<(query(1,1,n,a,b)->full)*2<<\"\\n\";\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 9",
          "code": "this gives a memory limit exceeded but",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 10",
          "code": "this gives a memory limit exceeded but",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 11",
          "code": "cin>>s;\ns=\" \"+s;\nint n=sz(s);\nn--;\nsegtree=vector<Info*>(4*(n),new Info(0,0,0));\nbuild(1,1,n);\nint m;\ncin>>m;\nwhile(m--){\n    int a,b;\n    cin>>a>>b;\n    cout<<(query(1,1,n,a,b)->full)*2<<\"\\n\";\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 12",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 13",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> pi = inf.readInts(n, 0, n, \"pi\");\n    inf.readEoln();\n\n    set<int> positive_pi;\n    for (int i = 0; i < n; ++i) {\n        if (pi[i] > 0) {\n            ensuref(positive_pi.count(pi[i]) == 0,\n                    \"Positive numbers in pi must be distinct, but pi[%d]=%d repeats\",\n                    i + 1, pi[i]);\n            positive_pi.insert(pi[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> pi = inf.readInts(n, 0, n, \"pi\");\n    inf.readEoln();\n\n    set<int> positive_pi;\n    for (int i = 0; i < n; ++i) {\n        if (pi[i] > 0) {\n            ensuref(positive_pi.count(pi[i]) == 0,\n                    \"Positive numbers in pi must be distinct, but pi[%d]=%d repeats\",\n                    i + 1, pi[i]);\n            positive_pi.insert(pi[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> pi = inf.readInts(n, 0, n, \"pi\");\n    inf.readEoln();\n\n    set<int> positive_pi;\n    for (int i = 0; i < n; ++i) {\n        if (pi[i] > 0) {\n            ensuref(positive_pi.count(pi[i]) == 0,\n                    \"Positive numbers in pi must be distinct, but pi[%d]=%d repeats\",\n                    i + 1, pi[i]);\n            positive_pi.insert(pi[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0); // Number of known seat assignments\n\n    vector<int> a(n, 0); // Initialize all positions with 0 (unknown assignments)\n\n    if (type == \"random\") {\n        // Randomly assign k known indices\n        if (k > n) k = n;\n        vector<int> positions(n);\n        for (int i = 0; i < n; i++) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            int pos = positions[i];\n            int idx = indices[i];\n            a[pos] = idx;\n        }\n    } else if (type == \"all_known\") {\n        // Assign indices 1..n to positions 0..n-1 in random order\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < n; i++) {\n            a[i] = indices[i];\n        }\n    } else if (type == \"all_unknown\") {\n        // All positions remain 0 (unknown assignments)\n    } else if (type == \"one_known\") {\n        // Assign one position with a known index\n        int pos = rnd.next(0, n - 1);\n        int idx = rnd.next(1, n);\n        a[pos] = idx;\n    } else if (type == \"first_known\") {\n        // Assign the first k positions with known indices\n        if (k > n) k = n;\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            a[i] = indices[i];\n        }\n    } else if (type == \"last_known\") {\n        // Assign the last k positions with known indices\n        if (k > n) k = n;\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            a[n - k + i] = indices[i];\n        }\n    } else {\n        // Default case: treat as random\n        if (k > n) k = n;\n        vector<int> positions(n);\n        for (int i = 0; i < n; i++) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            int pos = positions[i];\n            int idx = indices[i];\n            a[pos] = idx;\n        }\n    }\n\n    // Output the generated test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0); // Number of known seat assignments\n\n    vector<int> a(n, 0); // Initialize all positions with 0 (unknown assignments)\n\n    if (type == \"random\") {\n        // Randomly assign k known indices\n        if (k > n) k = n;\n        vector<int> positions(n);\n        for (int i = 0; i < n; i++) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            int pos = positions[i];\n            int idx = indices[i];\n            a[pos] = idx;\n        }\n    } else if (type == \"all_known\") {\n        // Assign indices 1..n to positions 0..n-1 in random order\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < n; i++) {\n            a[i] = indices[i];\n        }\n    } else if (type == \"all_unknown\") {\n        // All positions remain 0 (unknown assignments)\n    } else if (type == \"one_known\") {\n        // Assign one position with a known index\n        int pos = rnd.next(0, n - 1);\n        int idx = rnd.next(1, n);\n        a[pos] = idx;\n    } else if (type == \"first_known\") {\n        // Assign the first k positions with known indices\n        if (k > n) k = n;\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            a[i] = indices[i];\n        }\n    } else if (type == \"last_known\") {\n        // Assign the last k positions with known indices\n        if (k > n) k = n;\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            a[n - k + i] = indices[i];\n        }\n    } else {\n        // Default case: treat as random\n        if (k > n) k = n;\n        vector<int> positions(n);\n        for (int i = 0; i < n; i++) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n\n        vector<int> indices(n);\n        for (int i = 0; i < n; i++) indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        for (int i = 0; i < k; i++) {\n            int pos = positions[i];\n            int idx = indices[i];\n            a[pos] = idx;\n        }\n    }\n\n    // Output the generated test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_unknown\n./gen -n 1 -type all_known\n./gen -n 1 -type one_known\n\n./gen -n 2 -type random -k 0\n./gen -n 2 -type random -k 1\n./gen -n 2 -type random -k 2\n\n./gen -n 10 -type random -k 0\n./gen -n 10 -type random -k 5\n./gen -n 10 -type random -k 10\n\n./gen -n 10 -type first_known -k 5\n./gen -n 10 -type last_known -k 5\n\n./gen -n 100 -type all_unknown\n./gen -n 100 -type all_known\n./gen -n 100 -type one_known\n\n./gen -n 1000 -type random -k 0\n./gen -n 1000 -type random -k 500\n./gen -n 1000 -type random -k 1000\n\n./gen -n 1000 -type first_known -k 100\n./gen -n 1000 -type last_known -k 100\n\n./gen -n 100000 -type all_unknown\n./gen -n 100000 -type all_known\n./gen -n 100000 -type random -k 0\n./gen -n 100000 -type random -k 50000\n./gen -n 100000 -type random -k 100000\n\n./gen -n 100000 -type first_known -k 99999\n./gen -n 100000 -type last_known -k 99999\n\n./gen -n 100000 -type one_known\n\n./gen -n 99999 -type random -k 50000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:23.550976",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "380/E",
      "title": "E. Sereja and Dividing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer |b| (1 ≤ |b| ≤ 3·105) — the length of sequence b. The second line contains |b| integers b1, b2, ..., b|b| (1 ≤ bi ≤ 105).",
      "output_spec": "OutputIn a single line print a real number — the required sum divided by |b|2. Your answer will be considered correct if its absolute or relative error won't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy51 2 3 4 1OutputCopy1.238750000000000",
      "description": "E. Sereja and Dividing\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer |b| (1 ≤ |b| ≤ 3·105) — the length of sequence b. The second line contains |b| integers b1, b2, ..., b|b| (1 ≤ bi ≤ 105).\n\nOutputIn a single line print a real number — the required sum divided by |b|2. Your answer will be considered correct if its absolute or relative error won't exceed 10 - 6.\n\nInputCopy51 2 3 4 1OutputCopy1.238750000000000\n\nInputCopy51 2 3 4 1\n\nOutputCopy1.238750000000000",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 380\\s*E"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(1, 300000, \"b\"); // 1 ≤ b ≤ 3·10^5\n    inf.readEoln();\n    vector<int> bi = inf.readInts(b, 1, 100000, \"b_i\"); // b_i between 1 and 1e5\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(1, 300000, \"b\"); // 1 ≤ b ≤ 3·10^5\n    inf.readEoln();\n    vector<int> bi = inf.readInts(b, 1, 100000, \"b_i\"); // b_i between 1 and 1e5\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(1, 300000, \"b\"); // 1 ≤ b ≤ 3·10^5\n    inf.readEoln();\n    vector<int> bi = inf.readInts(b, 1, 100000, \"b_i\"); // b_i between 1 and 1e5\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> b(n);\n\n    if (type == \"max\") {\n        /* All elements are the maximum value */\n        for (int i = 0; i < n; ++i)\n            b[i] = 100000; // b_i = 1e5\n    } else if (type == \"min\") {\n        /* All elements are the minimum value */\n        for (int i = 0; i < n; ++i)\n            b[i] = 1;\n    } else if (type == \"random\") {\n        /* Random elements between 1 and 1e5 */\n        for (int i = 0; i < n; ++i)\n            b[i] = rnd.next(1, 100000);\n    } else if (type == \"alternating\") {\n        /* Elements alternate between 1 and 1e5 */\n        for (int i = 0; i < n; ++i)\n            b[i] = (i % 2 == 0) ? 1 : 100000;\n    } else if (type == \"increasing\") {\n        /* Elements increase from 1 to 1e5 */\n        for (int i = 0; i < n; ++i)\n            b[i] = 1 + (long long)(i) * (100000 - 1) / (n - 1);\n    } else if (type == \"decreasing\") {\n        /* Elements decrease from 1e5 to 1 */\n        for (int i = 0; i < n; ++i)\n            b[i] = 100000 - (long long)(i) * (100000 - 1) / (n - 1);\n    } else if (type == \"constant\") {\n        /* All elements are the same specified value */\n        int value = opt<int>(\"value\");\n        ensuref(1 <= value && value <= 100000, \"value must be between 1 and 100000\");\n        for (int i = 0; i < n; ++i)\n            b[i] = value;\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the sequence */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> b(n);\n\n    if (type == \"max\") {\n        /* All elements are the maximum value */\n        for (int i = 0; i < n; ++i)\n            b[i] = 100000; // b_i = 1e5\n    } else if (type == \"min\") {\n        /* All elements are the minimum value */\n        for (int i = 0; i < n; ++i)\n            b[i] = 1;\n    } else if (type == \"random\") {\n        /* Random elements between 1 and 1e5 */\n        for (int i = 0; i < n; ++i)\n            b[i] = rnd.next(1, 100000);\n    } else if (type == \"alternating\") {\n        /* Elements alternate between 1 and 1e5 */\n        for (int i = 0; i < n; ++i)\n            b[i] = (i % 2 == 0) ? 1 : 100000;\n    } else if (type == \"increasing\") {\n        /* Elements increase from 1 to 1e5 */\n        for (int i = 0; i < n; ++i)\n            b[i] = 1 + (long long)(i) * (100000 - 1) / (n - 1);\n    } else if (type == \"decreasing\") {\n        /* Elements decrease from 1e5 to 1 */\n        for (int i = 0; i < n; ++i)\n            b[i] = 100000 - (long long)(i) * (100000 - 1) / (n - 1);\n    } else if (type == \"constant\") {\n        /* All elements are the same specified value */\n        int value = opt<int>(\"value\");\n        ensuref(1 <= value && value <= 100000, \"value must be between 1 and 100000\");\n        for (int i = 0; i < n; ++i)\n            b[i] = value;\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the sequence */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 1 -type max\n./gen -n 1 -type random\n\n./gen -n 2 -type alternating\n\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type random\n\n./gen -n 1000 -type random\n./gen -n 1000 -type constant -value 50000\n\n./gen -n 100000 -type max\n./gen -n 100000 -type min\n\n./gen -n 200000 -type random\n./gen -n 200000 -type alternating\n\n./gen -n 300000 -type random\n\n./gen -n 300000 -type constant -value 1\n\n./gen -n 300000 -type constant -value 100000\n\n./gen -n 300000 -type increasing\n\n./gen -n 300000 -type decreasing\n\n./gen -n 300000 -type random\n\n./gen -n 300000 -type constant -value 99999\n\n./gen -n 2 -type constant -value 50000\n\n./gen -n 3 -type random\n\n./gen -n 3 -type constant -value 1\n\n./gen -n 3 -type constant -value 100000\n\n./gen -n 5000 -type increasing\n\n./gen -n 5000 -type decreasing\n\n./gen -n 50000 -type random\n\n./gen -n 50000 -type alternating\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type alternating\n\n./gen -n 100000 -type constant -value 1\n\n./gen -n 100000 -type constant -value 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:26.003075",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "381/A",
      "title": "A. Sereja and Dima",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.",
      "output_spec": "OutputOn a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.",
      "sample_tests": "ExamplesInputCopy44 1 2 10OutputCopy12 5InputCopy71 2 3 4 5 6 7OutputCopy16 12",
      "description": "A. Sereja and Dima\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.\n\nOutputOn a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.\n\nInputCopy44 1 2 10OutputCopy12 5InputCopy71 2 3 4 5 6 7OutputCopy16 12\n\nInputCopy44 1 2 10\n\nOutputCopy12 5\n\nInputCopy71 2 3 4 5 6 7\n\nOutputCopy16 12\n\nNoteIn the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 381\\s*A"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln(); // Read the end of line after n\n    vector<int> a = inf.readInts(n, 1, 1000); // Read n integers between 1 and 1000\n    inf.readEoln(); // Read the end of line after the numbers\n    // Check that all numbers are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All numbers must be distinct\");\n    inf.readEof(); // Ensure that we have reached the end of file\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln(); // Read the end of line after n\n    vector<int> a = inf.readInts(n, 1, 1000); // Read n integers between 1 and 1000\n    inf.readEoln(); // Read the end of line after the numbers\n    // Check that all numbers are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All numbers must be distinct\");\n    inf.readEof(); // Ensure that we have reached the end of file\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln(); // Read the end of line after n\n    vector<int> a = inf.readInts(n, 1, 1000); // Read n integers between 1 and 1000\n    inf.readEoln(); // Read the end of line after the numbers\n    // Check that all numbers are distinct\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All numbers must be distinct\");\n    inf.readEof(); // Ensure that we have reached the end of file\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> numbers;\n\n    if (type == \"n1\") {\n        n = 1;\n        numbers.push_back(rnd.next(1, 1000));\n    } else if (type == \"n2\") {\n        n = 2;\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    } else if (type == \"max_n\") {\n        n = 1000;\n        numbers.resize(n);\n        for (int i = 0; i < n; ++i) {\n            numbers[i] = i + 1;\n        }\n    } else if (type == \"asc\") {\n        numbers.resize(n);\n        for (int i = 0; i < n; ++i) {\n            numbers[i] = i + 1;\n        }\n    } else if (type == \"desc\") {\n        numbers.resize(n);\n        for (int i = 0; i < n; ++i) {\n            numbers[i] = 1000 - i;\n        }\n    } else if (type == \"alternate_high_low\") {\n        int high = 1000;\n        int low = 1;\n        while ((int)numbers.size() < n) {\n            numbers.push_back(high--);\n            if ((int)numbers.size() < n)\n                numbers.push_back(low++);\n        }\n    } else if (type == \"zigzag\") {\n        int mid = 500;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                numbers.push_back(mid + i / 2 + 1);\n            else\n                numbers.push_back(mid - (i + 1) / 2 + 1);\n        }\n    } else if (type == \"random_small_n\") {\n        n = rnd.next(1, 10);\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    } else if (type == \"random_large_n\") {\n        n = rnd.next(900, 1000);\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    } else {\n        // Default or \"random\"\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the numbers\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", numbers[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> numbers;\n\n    if (type == \"n1\") {\n        n = 1;\n        numbers.push_back(rnd.next(1, 1000));\n    } else if (type == \"n2\") {\n        n = 2;\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    } else if (type == \"max_n\") {\n        n = 1000;\n        numbers.resize(n);\n        for (int i = 0; i < n; ++i) {\n            numbers[i] = i + 1;\n        }\n    } else if (type == \"asc\") {\n        numbers.resize(n);\n        for (int i = 0; i < n; ++i) {\n            numbers[i] = i + 1;\n        }\n    } else if (type == \"desc\") {\n        numbers.resize(n);\n        for (int i = 0; i < n; ++i) {\n            numbers[i] = 1000 - i;\n        }\n    } else if (type == \"alternate_high_low\") {\n        int high = 1000;\n        int low = 1;\n        while ((int)numbers.size() < n) {\n            numbers.push_back(high--);\n            if ((int)numbers.size() < n)\n                numbers.push_back(low++);\n        }\n    } else if (type == \"zigzag\") {\n        int mid = 500;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                numbers.push_back(mid + i / 2 + 1);\n            else\n                numbers.push_back(mid - (i + 1) / 2 + 1);\n        }\n    } else if (type == \"random_small_n\") {\n        n = rnd.next(1, 10);\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    } else if (type == \"random_large_n\") {\n        n = rnd.next(900, 1000);\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    } else {\n        // Default or \"random\"\n        vector<int> all_numbers(1000);\n        for (int i = 0; i < 1000; ++i)\n            all_numbers[i] = i + 1;\n        shuffle(all_numbers.begin(), all_numbers.end());\n        numbers.assign(all_numbers.begin(), all_numbers.begin() + n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the numbers\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", numbers[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type n1\n./gen -n 2 -type n2\n./gen -n 10 -type asc\n./gen -n 10 -type desc\n./gen -n 20 -type random\n./gen -n 50 -type random_small_n\n./gen -n 100 -type random_small_n\n./gen -n 200 -type asc\n./gen -n 200 -type desc\n./gen -n 500 -type alternate_high_low\n./gen -n 500 -type zigzag\n./gen -n 999 -type random_large_n\n./gen -n 1000 -type max_n\n./gen -n 1000 -type random\n./gen -n 1000 -type asc\n./gen -n 1000 -type desc\n./gen -n 1000 -type alternate_high_low\n./gen -n 1000 -type zigzag\n./gen -n 1000 -type random_small_n\n./gen -n 1000 -type random_large_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:28.008203",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "381/B",
      "title": "B. Sereja and Stairs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer m (1 ≤ m ≤ 105) — the number of Sereja's cards. The second line contains m integers bi (1 ≤ bi ≤ 5000) — the numbers on the Sereja's cards.",
      "output_spec": "OutputIn the first line print the number of cards you can put on the table. In the second line print the resulting stairs.",
      "sample_tests": "ExamplesInputCopy51 2 3 4 5OutputCopy55 4 3 2 1InputCopy61 1 2 2 3 3OutputCopy51 2 3 2 1",
      "description": "B. Sereja and Stairs\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer m (1 ≤ m ≤ 105) — the number of Sereja's cards. The second line contains m integers bi (1 ≤ bi ≤ 5000) — the numbers on the Sereja's cards.\n\nOutputIn the first line print the number of cards you can put on the table. In the second line print the resulting stairs.\n\nInputCopy51 2 3 4 5OutputCopy55 4 3 2 1InputCopy61 1 2 2 3 3OutputCopy51 2 3 2 1\n\nInputCopy51 2 3 4 5\n\nOutputCopy55 4 3 2 1\n\nInputCopy61 1 2 2 3 3\n\nOutputCopy51 2 3 2 1",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 381\\s*B"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n  \n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 1, 5000, \"bi\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n  \n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 1, 5000, \"bi\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n  \n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 1, 5000, \"bi\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_stairs(const vector<int>& a) {\n    int k = a.size();\n    for (int i = 1; i <= k; ++i) {\n        bool ok = true;\n        // Increasing part from positions 0 to i-2\n        for (int j = 0; j < i - 1; ++j) {\n            if (a[j] >= a[j+1]) {\n                ok = false;\n                break;\n            }\n        }\n        if (!ok) continue;\n        // Decreasing part from positions i - 1 to k -2\n        for (int j = i - 1; j < k -1; ++j) {\n            if (a[j] <= a[j+1]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int m = inf.readInt();\n    vector<int> bi(m);\n    map<int, int> bi_counts;\n    for (int i = 0; i < m; ++i) {\n        bi[i] = inf.readInt(1, 5000, \"bi\");\n        bi_counts[bi[i]]++;\n    }\n\n    int jury_k = ans.readInt(0, m, \"jury_k\");\n\n    int participant_k = ouf.readInt(0, m, \"participant_k\");\n\n    if (participant_k < jury_k) {\n        quitf(_wa, \"participant's sequence length %d is less than maximum possible length %d\", participant_k, jury_k);\n    }\n    if (participant_k > jury_k) {\n        quitf(_fail, \"participant's sequence length %d is greater than maximum possible length %d\", participant_k, jury_k);\n    }\n    // participant_k == jury_k\n    vector<int> a(participant_k);\n    map<int, int> counts;\n    for (int i = 0; i < participant_k; ++i) {\n        a[i] = ouf.readInt(1, 5000, format(\"a[%d]\", i + 1).c_str());\n        counts[a[i]]++;\n        if (counts[a[i]] > bi_counts[a[i]]) {\n            quitf(_wa, \"number %d appears %d times, but only appears %d times in input\", a[i], counts[a[i]], bi_counts[a[i]]);\n        }\n    }\n    if (!is_stairs(a)) {\n        quitf(_wa, \"sequence is not a stairs sequence\");\n    }\n    quitf(_ok, \"participant's sequence of length %d is valid\", participant_k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    int max_value = opt<int>(\"max_value\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> nums;\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            nums.push_back(rnd.next(1, max_value));\n        }\n    }\n    else if (type == \"all_same\") {\n        int val = rnd.next(1, max_value);\n        nums.assign(m, val);\n    }\n    else if (type == \"increasing\") {\n        // Generate increasing sequence, possibly repeating numbers if m > max_value\n        int repeats = (m + max_value - 1) / max_value;\n        for (int r = 0; r < repeats && nums.size() < m; ++r) {\n            for (int i = 1; i <= max_value && nums.size() < m; ++i) {\n                nums.push_back(i);\n            }\n        }\n    }\n    else if (type == \"decreasing\") {\n        // Generate decreasing sequence, possibly repeating numbers if m > max_value\n        int repeats = (m + max_value - 1) / max_value;\n        for (int r = 0; r < repeats && nums.size() < m; ++r) {\n            for (int i = max_value; i >=1 && nums.size() < m; --i) {\n                nums.push_back(i);\n            }\n        }\n    }\n    else if (type == \"max_stairs\") {\n        // Maximize k such that total numbers needed <= m\n        int k = 1;\n        while ((2 * k - 1) <= m && k <= max_value) {\n            ++k;\n        }\n        --k;\n        map<int, int> num_counts;\n        for (int i = 1; i <= k; ++i) {\n            if (i == k) {\n                num_counts[i] = 1; // Peak\n            } else {\n                num_counts[i] = 2;\n            }\n        }\n        nums.clear();\n        for (auto& p : num_counts) {\n            for (int i = 0; i < p.second; ++i) {\n                nums.push_back(p.first);\n            }\n        }\n        // If m > nums.size(), add more numbers (duplicates) of smallest numbers\n        while (nums.size() < m) {\n            nums.push_back(rnd.next(1, k));\n        }\n        // Shuffle numbers\n        shuffle(nums.begin(), nums.end());\n    }\n    else if (type == \"min_stairs\") {\n        int val = rnd.next(1, max_value);\n        nums.assign(m, val);\n    }\n    else if (type == \"random_duplicates\") {\n        // Generate numbers with a lot of duplicates\n        for (int i = 0; i < m; ++i) {\n            nums.push_back(rnd.next(1, min(10, max_value)));\n        }\n    }\n    else if (type == \"big_numbers\") {\n        // Generate numbers near max_value\n        for (int i = 0; i < m; ++i) {\n            nums.push_back(rnd.next(max(1, max_value - 100), max_value));\n        }\n    }\n    else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output the numbers\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", nums[i]);\n        if (i != m - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    int max_value = opt<int>(\"max_value\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> nums;\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            nums.push_back(rnd.next(1, max_value));\n        }\n    }\n    else if (type == \"all_same\") {\n        int val = rnd.next(1, max_value);\n        nums.assign(m, val);\n    }\n    else if (type == \"increasing\") {\n        // Generate increasing sequence, possibly repeating numbers if m > max_value\n        int repeats = (m + max_value - 1) / max_value;\n        for (int r = 0; r < repeats && nums.size() < m; ++r) {\n            for (int i = 1; i <= max_value && nums.size() < m; ++i) {\n                nums.push_back(i);\n            }\n        }\n    }\n    else if (type == \"decreasing\") {\n        // Generate decreasing sequence, possibly repeating numbers if m > max_value\n        int repeats = (m + max_value - 1) / max_value;\n        for (int r = 0; r < repeats && nums.size() < m; ++r) {\n            for (int i = max_value; i >=1 && nums.size() < m; --i) {\n                nums.push_back(i);\n            }\n        }\n    }\n    else if (type == \"max_stairs\") {\n        // Maximize k such that total numbers needed <= m\n        int k = 1;\n        while ((2 * k - 1) <= m && k <= max_value) {\n            ++k;\n        }\n        --k;\n        map<int, int> num_counts;\n        for (int i = 1; i <= k; ++i) {\n            if (i == k) {\n                num_counts[i] = 1; // Peak\n            } else {\n                num_counts[i] = 2;\n            }\n        }\n        nums.clear();\n        for (auto& p : num_counts) {\n            for (int i = 0; i < p.second; ++i) {\n                nums.push_back(p.first);\n            }\n        }\n        // If m > nums.size(), add more numbers (duplicates) of smallest numbers\n        while (nums.size() < m) {\n            nums.push_back(rnd.next(1, k));\n        }\n        // Shuffle numbers\n        shuffle(nums.begin(), nums.end());\n    }\n    else if (type == \"min_stairs\") {\n        int val = rnd.next(1, max_value);\n        nums.assign(m, val);\n    }\n    else if (type == \"random_duplicates\") {\n        // Generate numbers with a lot of duplicates\n        for (int i = 0; i < m; ++i) {\n            nums.push_back(rnd.next(1, min(10, max_value)));\n        }\n    }\n    else if (type == \"big_numbers\") {\n        // Generate numbers near max_value\n        for (int i = 0; i < m; ++i) {\n            nums.push_back(rnd.next(max(1, max_value - 100), max_value));\n        }\n    }\n    else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output the numbers\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", nums[i]);\n        if (i != m - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 1 -type random\n./gen -m 2 -type random\n./gen -m 10 -type random\n./gen -m 50 -type random\n./gen -m 100 -type random\n./gen -m 500 -type random\n./gen -m 1000 -type random\n\n./gen -m 10000 -type random\n./gen -m 50000 -type random\n\n./gen -m 100000 -type random\n\n./gen -m 100000 -type random -max_value 1\n./gen -m 100000 -type random -max_value 2\n./gen -m 100000 -type random -max_value 10\n\n./gen -m 100000 -type all_same\n./gen -m 100000 -type all_same -max_value 1\n./gen -m 100000 -type all_same -max_value 5000\n\n./gen -m 5000 -type increasing\n./gen -m 100000 -type increasing -max_value 5000\n\n./gen -m 5000 -type decreasing\n./gen -m 100000 -type decreasing -max_value 5000\n\n./gen -m 100000 -type max_stairs\n./gen -m 50000 -type max_stairs\n./gen -m 99999 -type max_stairs\n\n./gen -m 100000 -type min_stairs\n./gen -m 3 -type min_stairs\n./gen -m 2 -type min_stairs\n./gen -m 1 -type min_stairs\n\n./gen -m 100000 -type random_duplicates\n./gen -m 100000 -type big_numbers\n./gen -m 100000 -type big_numbers -max_value 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:30.070689",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "381/C",
      "title": "C. Sereja and Prefixes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer m (1 ≤ m ≤ 105) — the number of stages to build a sequence. Next m lines contain the description of the stages in the order they follow. The first number in the line is a type of stage (1 or 2). Type 1 means adding one number to the end of the sequence, in this case the line contains integer xi (1 ≤ xi ≤ 105) — the number to add. Type 2 means copying a prefix of length li to the end ci times, in this case the line further contains two integers li, ci (1 ≤ li ≤ 105, 1 ≤ ci ≤ 104), li is the length of the prefix, ci is the number of copyings. It is guaranteed that the length of prefix li is never larger than the current length of the sequence.The next line contains integer n (1 ≤ n ≤ 105) — the number of elements Sereja is interested in. The next line contains the numbers of elements of the final sequence Sereja is interested in. The numbers are given in the strictly increasing order. It is guaranteed that all numbers are strictly larger than zero and do not exceed the length of the resulting sequence. Consider the elements of the final sequence numbered starting from 1 from the beginning to the end of the sequence.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint the elements that Sereja is interested in, in the order in which their numbers occur in the input.",
      "sample_tests": "ExamplesInputCopy61 11 22 2 11 32 5 21 4161 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16OutputCopy1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4",
      "description": "C. Sereja and Prefixes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer m (1 ≤ m ≤ 105) — the number of stages to build a sequence. Next m lines contain the description of the stages in the order they follow. The first number in the line is a type of stage (1 or 2). Type 1 means adding one number to the end of the sequence, in this case the line contains integer xi (1 ≤ xi ≤ 105) — the number to add. Type 2 means copying a prefix of length li to the end ci times, in this case the line further contains two integers li, ci (1 ≤ li ≤ 105, 1 ≤ ci ≤ 104), li is the length of the prefix, ci is the number of copyings. It is guaranteed that the length of prefix li is never larger than the current length of the sequence.The next line contains integer n (1 ≤ n ≤ 105) — the number of elements Sereja is interested in. The next line contains the numbers of elements of the final sequence Sereja is interested in. The numbers are given in the strictly increasing order. It is guaranteed that all numbers are strictly larger than zero and do not exceed the length of the resulting sequence. Consider the elements of the final sequence numbered starting from 1 from the beginning to the end of the sequence.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint the elements that Sereja is interested in, in the order in which their numbers occur in the input.\n\nInputCopy61 11 22 2 11 32 5 21 4161 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16OutputCopy1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4\n\nInputCopy61 11 22 2 11 32 5 21 4161 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nOutputCopy1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 381 和字母"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\"); // 1 ≤ m ≤ 1e5\n    inf.readEoln();\n\n    long long total_length = 0;\n\n    for (int i = 0; i < m; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int x = inf.readInt(1, 100000, \"x\"); // 1 ≤ x ≤ 1e5\n            inf.readEoln();\n            total_length += 1;\n            ensuref(total_length <= 1000000000000000000LL, \"Total length of sequence exceeds 1e18 at step %d\", i+1);\n        } else { // t == 2\n            inf.readSpace();\n            int l = inf.readInt(1, 100000, \"l\"); // 1 ≤ l ≤ 1e5\n            inf.readSpace();\n            int c = inf.readInt(1, 10000, \"c\");  // 1 ≤ c ≤ 1e4\n            inf.readEoln();\n            ensuref(l <= total_length, \"li (%d) can't be greater than current sequence length (%lld) at step %d\", l, total_length, i+1);\n            long long delta = (long long) l * c;\n            ensuref(delta <= 1000000000000000000LL, \"Increase in sequence length l * c exceeds 1e18 at step %d\", i+1);\n            total_length += delta;\n            ensuref(total_length <= 1000000000000000000LL, \"Total length of sequence exceeds 1e18 at step %d\", i+1);\n        }\n    }\n\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readEoln();\n\n    long long prev_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(1, total_length, \"ai\");\n        if (i > 0) {\n            ensuref(ai > prev_ai, \"The indices ai must be strictly increasing, ai[%d]=%lld, ai[%d]=%lld\", i, prev_ai, i+1, ai);\n        }\n        prev_ai = ai;\n        if (i < n - 1)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof(); // Ensure no extra input\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\"); // 1 ≤ m ≤ 1e5\n    inf.readEoln();\n\n    long long total_length = 0;\n\n    for (int i = 0; i < m; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int x = inf.readInt(1, 100000, \"x\"); // 1 ≤ x ≤ 1e5\n            inf.readEoln();\n            total_length += 1;\n            ensuref(total_length <= 1000000000000000000LL, \"Total length of sequence exceeds 1e18 at step %d\", i+1);\n        } else { // t == 2\n            inf.readSpace();\n            int l = inf.readInt(1, 100000, \"l\"); // 1 ≤ l ≤ 1e5\n            inf.readSpace();\n            int c = inf.readInt(1, 10000, \"c\");  // 1 ≤ c ≤ 1e4\n            inf.readEoln();\n            ensuref(l <= total_length, \"li (%d) can't be greater than current sequence length (%lld) at step %d\", l, total_length, i+1);\n            long long delta = (long long) l * c;\n            ensuref(delta <= 1000000000000000000LL, \"Increase in sequence length l * c exceeds 1e18 at step %d\", i+1);\n            total_length += delta;\n            ensuref(total_length <= 1000000000000000000LL, \"Total length of sequence exceeds 1e18 at step %d\", i+1);\n        }\n    }\n\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readEoln();\n\n    long long prev_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(1, total_length, \"ai\");\n        if (i > 0) {\n            ensuref(ai > prev_ai, \"The indices ai must be strictly increasing, ai[%d]=%lld, ai[%d]=%lld\", i, prev_ai, i+1, ai);\n        }\n        prev_ai = ai;\n        if (i < n - 1)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof(); // Ensure no extra input\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\"); // 1 ≤ m ≤ 1e5\n    inf.readEoln();\n\n    long long total_length = 0;\n\n    for (int i = 0; i < m; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int x = inf.readInt(1, 100000, \"x\"); // 1 ≤ x ≤ 1e5\n            inf.readEoln();\n            total_length += 1;\n            ensuref(total_length <= 1000000000000000000LL, \"Total length of sequence exceeds 1e18 at step %d\", i+1);\n        } else { // t == 2\n            inf.readSpace();\n            int l = inf.readInt(1, 100000, \"l\"); // 1 ≤ l ≤ 1e5\n            inf.readSpace();\n            int c = inf.readInt(1, 10000, \"c\");  // 1 ≤ c ≤ 1e4\n            inf.readEoln();\n            ensuref(l <= total_length, \"li (%d) can't be greater than current sequence length (%lld) at step %d\", l, total_length, i+1);\n            long long delta = (long long) l * c;\n            ensuref(delta <= 1000000000000000000LL, \"Increase in sequence length l * c exceeds 1e18 at step %d\", i+1);\n            total_length += delta;\n            ensuref(total_length <= 1000000000000000000LL, \"Total length of sequence exceeds 1e18 at step %d\", i+1);\n        }\n    }\n\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readEoln();\n\n    long long prev_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(1, total_length, \"ai\");\n        if (i > 0) {\n            ensuref(ai > prev_ai, \"The indices ai must be strictly increasing, ai[%d]=%lld, ai[%d]=%lld\", i, prev_ai, i+1, ai);\n        }\n        prev_ai = ai;\n        if (i < n - 1)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof(); // Ensure no extra input\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces a single test for the \"Sereja loves number sequences\" problem.\n    Usage example:\n        ./gen -m 10 -n 5 -type random\n    You may call it repeatedly with different parameters (m, n, type) to produce multiple tests.\n\n    Parameters:\n      - \"m\" (int): number of stages (1 <= m <= 100000). Default = 10.\n      - \"n\" (int): number of queries (1 <= n <= 100000). Default = 5.\n      - \"type\" (string): test pattern. Options in this sample generator:\n           1) \"small\"    : A small, fixed, handcrafted example.\n           2) \"only1\"    : All stages are type=1.\n           3) \"bigc\"     : Emphasize type=2 with large 'c' values (but still within constraints).\n           4) \"prefix1\"  : Emphasize copying just the first prefix (l=1).\n           5) \"fullpref\" : Emphasize copying the entire sequence each time (l = current length).\n           6) \"random\"   : A random mix of stage types.\n\n    Notes:\n      - We never set any random seed in the code. The seed is set outside by testlib automatically.\n      - We must ensure l <= current sequence length at each type=2 stage.\n      - We must ensure final sequence length >= maximum query index.\n      - The queries are generated in strictly increasing order.\n      - All constraints must be satisfied to avoid invalid tests.\n*/\n\nstatic const long long MAX_LENGTH = 200000000; // A safeguard limit for final sequence length.\n\nstruct Stage {\n    int t;      // 1 or 2\n    int x;      // If t=1, x is the appended number.\n                // If t=2, x is the prefix length l.\n    int c;      // If t=2, c is the number of repetitions.\n                // If t=1, c is unused (could be 0).\n};\n\n// Generate a small, fixed test. This is purely deterministic.\nvector<Stage> genSmallTest() {\n    // We will build a short sequence with a mix of type=1 and type=2\n    // ensuring the constraints are satisfied.\n    // This is just an example of a small test (m=6).\n    vector<Stage> stages;\n    // Start with an empty sequence, curLen=0\n\n    // Stage 1: t=1, x=5  => sequence becomes [5]\n    stages.push_back({1, 5, 0});\n\n    // Stage 2: t=1, x=10 => sequence becomes [5, 10]\n    stages.push_back({1, 10, 0});\n\n    // Stage 3: t=2, x=1, c=2 => copy the first 1 element 2 times => [5, 10, 5, 5]\n    stages.push_back({2, 1, 2});\n\n    // Stage 4: t=1, x=1 => [5, 10, 5, 5, 1]\n    stages.push_back({1, 1, 0});\n\n    // Stage 5: t=2, x=5, c=1 => copy the first 5 elements once => [5,10,5,5,1,(5,10,5,5,1)]\n    // Now the sequence length is 10\n    stages.push_back({2, 5, 1});\n\n    // Stage 6: t=1, x=99999 => [5,10,5,5,1,5,10,5,5,1,99999]\n    stages.push_back({1, 99999, 0});\n\n    return stages;\n}\n\n// Generate a test with all type=1 stages\nvector<Stage> genOnly1Test(int m) {\n    // All stages are t=1\n    // x in [1 .. 100000]\n    // final length will be exactly m\n    vector<Stage> stages;\n    for(int i = 0; i < m; i++){\n        int val = rnd.next(1, 100000);\n        stages.push_back({1, val, 0});\n    }\n    return stages;\n}\n\n// Generate a test focusing on big 'c' for type=2\nvector<Stage> genBigCTest(int m) {\n    // We'll mix type=1 and type=2 with large c, but keep an eye on final length.\n    // Start with an empty sequence.\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        // With some probability, do type=1 or type=2\n        if(curLen == 0) {\n            // We cannot do type=2 because l must be <= current length\n            // So we do type=1 for the first stage\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n\n        // Decide randomly which type\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            // type=1\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // type=2\n            // We'll try to pick a big c, but we must ensure we don't exceed MAX_LENGTH\n            int l = rnd.next(1, (int)curLen); \n            // pick c up to 10000, but that might explode the final length\n            // We'll pick a random up to 10000, but check we won't overflow.\n            int c = rnd.next(5000, 10000); \n            long long newLen = curLen + 1LL * l * c;\n            if(newLen > MAX_LENGTH) {\n                // If it exceeds limit, reduce c drastically, say up to 3\n                c = rnd.next(1, 3);\n                newLen = curLen + 1LL * l * c;\n            }\n            stages.push_back({2, l, c});\n            curLen = newLen;\n        }\n        // If we are close to MAX_LENGTH, we can break early\n        if(curLen > MAX_LENGTH) {\n            break;\n        }\n    }\n    return stages;\n}\n\n// Generate a test with type=2 always having l=1\nvector<Stage> genPrefix1Test(int m) {\n    // We'll create a sequence that repeatedly copies only the first element, or adds single elements.\n    // This ensures we test the boundary condition l=1 thoroughly.\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        if(curLen == 0) {\n            // must do type=1\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n        // random choice: 50% type=1, 50% type=2\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            // add single\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // copy the first 1 element\n            int c = rnd.next(1, 10); // keep c small\n            long long newLen = curLen + c;\n            if(newLen > MAX_LENGTH) {\n                c = 1; // fallback\n                newLen = curLen + 1;\n            }\n            stages.push_back({2, 1, c});\n            curLen = newLen;\n        }\n        if(curLen > MAX_LENGTH) break;\n    }\n    return stages;\n}\n\n// Generate a test with type=2 always having l = current length (copy the entire sequence).\nvector<Stage> genFullPrefixTest(int m) {\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        if(curLen == 0) {\n            // must do type=1 to start\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n        // random choice again\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // copy entire prefix\n            int l = curLen;  \n            // pick c up to 5 so that it doesn't blow up\n            int c = rnd.next(1, 5);\n            long long newLen = curLen + 1LL * l * c;\n            if(newLen > MAX_LENGTH) {\n                c = 1; \n                newLen = curLen + l;\n            }\n            stages.push_back({2, l, c});\n            curLen = newLen;\n        }\n        if(curLen > MAX_LENGTH) break;\n    }\n    return stages;\n}\n\n// Generate a random test with a balanced approach\nvector<Stage> genRandomTest(int m) {\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        // If no elements yet, the only valid stage is type=1\n        if(curLen == 0) {\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n        // Decide randomly\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            // type=1\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // type=2\n            int l = rnd.next(1, (int)curLen);\n            // pick c in [1..10]\n            int c = rnd.next(1, 10);\n            long long newLen = curLen + 1LL * l * c;\n            if(newLen > MAX_LENGTH) {\n                // fallback: do smaller c\n                c = 1;\n                newLen = curLen + l;\n            }\n            stages.push_back({2, l, c});\n            curLen = newLen;\n        }\n        if(curLen > MAX_LENGTH) break;\n    }\n    return stages;\n}\n\n// Given the stages, compute the final length of the sequence.\nlong long computeFinalLength(const vector<Stage> &stages) {\n    long long length = 0;\n    for(const auto &st : stages) {\n        if(st.t == 1) {\n            length += 1;\n        } else {\n            // st.t == 2\n            long long inc = 1LL * st.x * st.c; // x is the prefix length, c is the number of copy cycles\n            length += inc;\n        }\n    }\n    return length;\n}\n\n// Generate queries (positions) in strictly increasing order from 1..finalLen\n// We'll pick n distinct random positions, then sort them.\nvector<long long> genQueries(long long finalLen, int n) {\n    if(n > finalLen) {\n        // fallback: reduce n\n        n = (int)min<long long>(n, finalLen);\n    }\n    // We'll pick n distinct positions\n    // If finalLen is large, we do it carefully\n    // basic approach: random sample with a set\n    // but if n is close to finalLen, that might be expensive. We'll do a typical approach:\n    set<long long> used;\n    while((int)used.size() < n) {\n        long long pos = rnd.next((long long)1, finalLen);\n        used.insert(pos);\n    }\n    vector<long long> queries(used.begin(), used.end());\n    sort(queries.begin(), queries.end());\n    return queries;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\", 10);       // number of stages\n    int n = opt<int>(\"n\", 5);        // number of queries\n    string tp = opt<string>(\"type\", \"random\");\n\n    // Safety clamp\n    m = max(m, 1);\n    n = max(n, 1);\n\n    // Generate stages\n    vector<Stage> stages;\n    if(tp == \"small\") {\n        stages = genSmallTest(); // fixed example\n        // If user asked for \"small\" but also gave a different m, we won't forcibly adapt,\n        // because \"small\" is entirely fixed in this example.\n        // That is just a design choice for this tutorial generator.\n    }\n    else if(tp == \"only1\") {\n        stages = genOnly1Test(m);\n    }\n    else if(tp == \"bigc\") {\n        stages = genBigCTest(m);\n    }\n    else if(tp == \"prefix1\") {\n        stages = genPrefix1Test(m);\n    }\n    else if(tp == \"fullpref\") {\n        stages = genFullPrefixTest(m);\n    }\n    else {\n        // default: \"random\"\n        stages = genRandomTest(m);\n    }\n\n    // If we generated fewer than m stages (because we might have broken early),\n    // we can pad with type=1 to ensure we have exactly m stages in output.\n    // This is optional, but let's do it for consistency.\n    while((int)stages.size() < m) {\n        // Add type=1 stage\n        int val = rnd.next(1, 100000);\n        stages.push_back({1, val, 0});\n    }\n    // Or if we generated more than m stages, we can shrink:\n    if((int)stages.size() > m) {\n        stages.resize(m);\n    }\n\n    // Compute the final length after all stages\n    long long finalLen = computeFinalLength(stages);\n\n    // Generate queries\n    vector<long long> queries = genQueries(finalLen, n);\n\n    // Output\n    // 1) Print m\n    cout << m << \"\\n\";\n    // 2) Print each stage\n    //    Type 1 line: \"1 x\"\n    //    Type 2 line: \"2 l c\"\n    long long seqLengthSoFar = 0;\n    for(int i = 0; i < m; i++){\n        if(stages[i].t == 1) {\n            cout << 1 << \" \" << stages[i].x << \"\\n\";\n            seqLengthSoFar++;\n        } else {\n            cout << 2 << \" \" << stages[i].x << \" \" << stages[i].c << \"\\n\";\n            seqLengthSoFar += 1LL * stages[i].x * stages[i].c;\n        }\n    }\n\n    // 3) Print n\n    cout << n << \"\\n\";\n    // 4) Print the queries\n    for(int i = 0; i < n; i++){\n        cout << queries[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces a single test for the \"Sereja loves number sequences\" problem.\n    Usage example:\n        ./gen -m 10 -n 5 -type random\n    You may call it repeatedly with different parameters (m, n, type) to produce multiple tests.\n\n    Parameters:\n      - \"m\" (int): number of stages (1 <= m <= 100000). Default = 10.\n      - \"n\" (int): number of queries (1 <= n <= 100000). Default = 5.\n      - \"type\" (string): test pattern. Options in this sample generator:\n           1) \"small\"    : A small, fixed, handcrafted example.\n           2) \"only1\"    : All stages are type=1.\n           3) \"bigc\"     : Emphasize type=2 with large 'c' values (but still within constraints).\n           4) \"prefix1\"  : Emphasize copying just the first prefix (l=1).\n           5) \"fullpref\" : Emphasize copying the entire sequence each time (l = current length).\n           6) \"random\"   : A random mix of stage types.\n\n    Notes:\n      - We never set any random seed in the code. The seed is set outside by testlib automatically.\n      - We must ensure l <= current sequence length at each type=2 stage.\n      - We must ensure final sequence length >= maximum query index.\n      - The queries are generated in strictly increasing order.\n      - All constraints must be satisfied to avoid invalid tests.\n*/\n\nstatic const long long MAX_LENGTH = 200000000; // A safeguard limit for final sequence length.\n\nstruct Stage {\n    int t;      // 1 or 2\n    int x;      // If t=1, x is the appended number.\n                // If t=2, x is the prefix length l.\n    int c;      // If t=2, c is the number of repetitions.\n                // If t=1, c is unused (could be 0).\n};\n\n// Generate a small, fixed test. This is purely deterministic.\nvector<Stage> genSmallTest() {\n    // We will build a short sequence with a mix of type=1 and type=2\n    // ensuring the constraints are satisfied.\n    // This is just an example of a small test (m=6).\n    vector<Stage> stages;\n    // Start with an empty sequence, curLen=0\n\n    // Stage 1: t=1, x=5  => sequence becomes [5]\n    stages.push_back({1, 5, 0});\n\n    // Stage 2: t=1, x=10 => sequence becomes [5, 10]\n    stages.push_back({1, 10, 0});\n\n    // Stage 3: t=2, x=1, c=2 => copy the first 1 element 2 times => [5, 10, 5, 5]\n    stages.push_back({2, 1, 2});\n\n    // Stage 4: t=1, x=1 => [5, 10, 5, 5, 1]\n    stages.push_back({1, 1, 0});\n\n    // Stage 5: t=2, x=5, c=1 => copy the first 5 elements once => [5,10,5,5,1,(5,10,5,5,1)]\n    // Now the sequence length is 10\n    stages.push_back({2, 5, 1});\n\n    // Stage 6: t=1, x=99999 => [5,10,5,5,1,5,10,5,5,1,99999]\n    stages.push_back({1, 99999, 0});\n\n    return stages;\n}\n\n// Generate a test with all type=1 stages\nvector<Stage> genOnly1Test(int m) {\n    // All stages are t=1\n    // x in [1 .. 100000]\n    // final length will be exactly m\n    vector<Stage> stages;\n    for(int i = 0; i < m; i++){\n        int val = rnd.next(1, 100000);\n        stages.push_back({1, val, 0});\n    }\n    return stages;\n}\n\n// Generate a test focusing on big 'c' for type=2\nvector<Stage> genBigCTest(int m) {\n    // We'll mix type=1 and type=2 with large c, but keep an eye on final length.\n    // Start with an empty sequence.\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        // With some probability, do type=1 or type=2\n        if(curLen == 0) {\n            // We cannot do type=2 because l must be <= current length\n            // So we do type=1 for the first stage\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n\n        // Decide randomly which type\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            // type=1\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // type=2\n            // We'll try to pick a big c, but we must ensure we don't exceed MAX_LENGTH\n            int l = rnd.next(1, (int)curLen); \n            // pick c up to 10000, but that might explode the final length\n            // We'll pick a random up to 10000, but check we won't overflow.\n            int c = rnd.next(5000, 10000); \n            long long newLen = curLen + 1LL * l * c;\n            if(newLen > MAX_LENGTH) {\n                // If it exceeds limit, reduce c drastically, say up to 3\n                c = rnd.next(1, 3);\n                newLen = curLen + 1LL * l * c;\n            }\n            stages.push_back({2, l, c});\n            curLen = newLen;\n        }\n        // If we are close to MAX_LENGTH, we can break early\n        if(curLen > MAX_LENGTH) {\n            break;\n        }\n    }\n    return stages;\n}\n\n// Generate a test with type=2 always having l=1\nvector<Stage> genPrefix1Test(int m) {\n    // We'll create a sequence that repeatedly copies only the first element, or adds single elements.\n    // This ensures we test the boundary condition l=1 thoroughly.\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        if(curLen == 0) {\n            // must do type=1\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n        // random choice: 50% type=1, 50% type=2\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            // add single\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // copy the first 1 element\n            int c = rnd.next(1, 10); // keep c small\n            long long newLen = curLen + c;\n            if(newLen > MAX_LENGTH) {\n                c = 1; // fallback\n                newLen = curLen + 1;\n            }\n            stages.push_back({2, 1, c});\n            curLen = newLen;\n        }\n        if(curLen > MAX_LENGTH) break;\n    }\n    return stages;\n}\n\n// Generate a test with type=2 always having l = current length (copy the entire sequence).\nvector<Stage> genFullPrefixTest(int m) {\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        if(curLen == 0) {\n            // must do type=1 to start\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n        // random choice again\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // copy entire prefix\n            int l = curLen;  \n            // pick c up to 5 so that it doesn't blow up\n            int c = rnd.next(1, 5);\n            long long newLen = curLen + 1LL * l * c;\n            if(newLen > MAX_LENGTH) {\n                c = 1; \n                newLen = curLen + l;\n            }\n            stages.push_back({2, l, c});\n            curLen = newLen;\n        }\n        if(curLen > MAX_LENGTH) break;\n    }\n    return stages;\n}\n\n// Generate a random test with a balanced approach\nvector<Stage> genRandomTest(int m) {\n    vector<Stage> stages;\n    long long curLen = 0;\n\n    for(int i = 0; i < m; i++){\n        // If no elements yet, the only valid stage is type=1\n        if(curLen == 0) {\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n            continue;\n        }\n        // Decide randomly\n        int t = rnd.next(1, 2);\n        if(t == 1) {\n            // type=1\n            int val = rnd.next(1, 100000);\n            stages.push_back({1, val, 0});\n            curLen++;\n        } else {\n            // type=2\n            int l = rnd.next(1, (int)curLen);\n            // pick c in [1..10]\n            int c = rnd.next(1, 10);\n            long long newLen = curLen + 1LL * l * c;\n            if(newLen > MAX_LENGTH) {\n                // fallback: do smaller c\n                c = 1;\n                newLen = curLen + l;\n            }\n            stages.push_back({2, l, c});\n            curLen = newLen;\n        }\n        if(curLen > MAX_LENGTH) break;\n    }\n    return stages;\n}\n\n// Given the stages, compute the final length of the sequence.\nlong long computeFinalLength(const vector<Stage> &stages) {\n    long long length = 0;\n    for(const auto &st : stages) {\n        if(st.t == 1) {\n            length += 1;\n        } else {\n            // st.t == 2\n            long long inc = 1LL * st.x * st.c; // x is the prefix length, c is the number of copy cycles\n            length += inc;\n        }\n    }\n    return length;\n}\n\n// Generate queries (positions) in strictly increasing order from 1..finalLen\n// We'll pick n distinct random positions, then sort them.\nvector<long long> genQueries(long long finalLen, int n) {\n    if(n > finalLen) {\n        // fallback: reduce n\n        n = (int)min<long long>(n, finalLen);\n    }\n    // We'll pick n distinct positions\n    // If finalLen is large, we do it carefully\n    // basic approach: random sample with a set\n    // but if n is close to finalLen, that might be expensive. We'll do a typical approach:\n    set<long long> used;\n    while((int)used.size() < n) {\n        long long pos = rnd.next((long long)1, finalLen);\n        used.insert(pos);\n    }\n    vector<long long> queries(used.begin(), used.end());\n    sort(queries.begin(), queries.end());\n    return queries;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\", 10);       // number of stages\n    int n = opt<int>(\"n\", 5);        // number of queries\n    string tp = opt<string>(\"type\", \"random\");\n\n    // Safety clamp\n    m = max(m, 1);\n    n = max(n, 1);\n\n    // Generate stages\n    vector<Stage> stages;\n    if(tp == \"small\") {\n        stages = genSmallTest(); // fixed example\n        // If user asked for \"small\" but also gave a different m, we won't forcibly adapt,\n        // because \"small\" is entirely fixed in this example.\n        // That is just a design choice for this tutorial generator.\n    }\n    else if(tp == \"only1\") {\n        stages = genOnly1Test(m);\n    }\n    else if(tp == \"bigc\") {\n        stages = genBigCTest(m);\n    }\n    else if(tp == \"prefix1\") {\n        stages = genPrefix1Test(m);\n    }\n    else if(tp == \"fullpref\") {\n        stages = genFullPrefixTest(m);\n    }\n    else {\n        // default: \"random\"\n        stages = genRandomTest(m);\n    }\n\n    // If we generated fewer than m stages (because we might have broken early),\n    // we can pad with type=1 to ensure we have exactly m stages in output.\n    // This is optional, but let's do it for consistency.\n    while((int)stages.size() < m) {\n        // Add type=1 stage\n        int val = rnd.next(1, 100000);\n        stages.push_back({1, val, 0});\n    }\n    // Or if we generated more than m stages, we can shrink:\n    if((int)stages.size() > m) {\n        stages.resize(m);\n    }\n\n    // Compute the final length after all stages\n    long long finalLen = computeFinalLength(stages);\n\n    // Generate queries\n    vector<long long> queries = genQueries(finalLen, n);\n\n    // Output\n    // 1) Print m\n    cout << m << \"\\n\";\n    // 2) Print each stage\n    //    Type 1 line: \"1 x\"\n    //    Type 2 line: \"2 l c\"\n    long long seqLengthSoFar = 0;\n    for(int i = 0; i < m; i++){\n        if(stages[i].t == 1) {\n            cout << 1 << \" \" << stages[i].x << \"\\n\";\n            seqLengthSoFar++;\n        } else {\n            cout << 2 << \" \" << stages[i].x << \" \" << stages[i].c << \"\\n\";\n            seqLengthSoFar += 1LL * stages[i].x * stages[i].c;\n        }\n    }\n\n    // 3) Print n\n    cout << n << \"\\n\";\n    // 4) Print the queries\n    for(int i = 0; i < n; i++){\n        cout << queries[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20-30 example commands to run this generator.\n# Each command outputs ONE test case to standard output. All constraints are satisfied.\n\n./gen -m 1 -n 1 -type small\n./gen -m 3 -n 3 -type small\n./gen -m 6 -n 6 -type small\n\n./gen -m 5 -n 5 -type only1\n./gen -m 10 -n 5 -type only1\n./gen -m 20 -n 10 -type only1\n\n./gen -m 5 -n 5 -type bigc\n./gen -m 10 -n 5 -type bigc\n./gen -m 50 -n 10 -type bigc\n./gen -m 100 -n 20 -type bigc\n\n./gen -m 6 -n 5 -type prefix1\n./gen -m 12 -n 10 -type prefix1\n./gen -m 30 -n 15 -type prefix1\n\n./gen -m 6 -n 5 -type fullpref\n./gen -m 12 -n 10 -type fullpref\n./gen -m 25 -n 20 -type fullpref\n\n./gen -m 5 -n 5 -type random\n./gen -m 10 -n 5 -type random\n./gen -m 50 -n 10 -type random\n./gen -m 100 -n 20 -type random\n./gen -m 300 -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:32.194990",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "381/D",
      "title": "D. Sereja and Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 7000). Next m lines contain the descriptions of the operations. The operation of the first type is given by five integers: 1 t l r x (1 ≤ t ≤ n; 1 ≤ l ≤ r ≤ cnt[t]; 1 ≤ x ≤ 106). The operation of the second type is given by three integers: 2 t v (1 ≤ t ≤ n; 1 ≤ v ≤ cnt[t]).",
      "output_spec": "OutputFor each operation of the second type, print the answer on a single line.",
      "sample_tests": "ExamplesInputCopy4 51 4 4 7 11 3 1 2 22 1 12 4 12 3 3OutputCopy201",
      "description": "D. Sereja and Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 7000). Next m lines contain the descriptions of the operations. The operation of the first type is given by five integers: 1 t l r x (1 ≤ t ≤ n; 1 ≤ l ≤ r ≤ cnt[t]; 1 ≤ x ≤ 106). The operation of the second type is given by three integers: 2 t v (1 ≤ t ≤ n; 1 ≤ v ≤ cnt[t]).\n\nOutputFor each operation of the second type, print the answer on a single line.\n\nInputCopy4 51 4 4 7 11 3 1 2 22 1 12 4 12 3 3OutputCopy201\n\nInputCopy4 51 4 4 7 11 3 1 2 22 1 12 4 12 3 3\n\nOutputCopy201\n\nNoteYou can find the definitions that are used while working with root trees by this link: http://en.wikipedia.org/wiki/Tree_(graph_theory)You can see an example of a constructed tree at n = 4 below.",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Hello everyone!Codeforces Round #223 will take place on Sunday, January 12th at 19:30 MSK. This is my tenth Codeforces round and I hope not the last.I'd like to thank Gerald for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.This is the first round this year. Incidentally, the first round last year for both divisions was also mine (by statistics +1/-1 is was the coolest of rounds that I gave). I hope that this time the problems will be even more interesting for you. Will it? Will find it out after the round :)Gl & hf ! :)Problem point values will be standart for both divisions.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces",
          "content": "381A - Sereja and DimaSimply do the process described in the statment.381B - Sereja and StairsCalculate the amount of each number. For all the different numbers — maximum possible times of use isn't more than 2 times. For the maximum is is only — 1.380A - Sereja and PrefixesGenerate the first number 100000. Will in turn handle the requests, if the request gets to the point of adding one number, just print it. Otherwise see what element will meet our and just print it from precalculated array.380B - Sereja and TreeLets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check — whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n·m).380C - Sereja and BracketsWe will support the segments tree. At each vertex will be stored:av — the maximum length of the bracket subsequencebv — how many there it open brackets that sequence doesn't containcv — how many there it closed brackets that sequence doesn't containIf we want to combine two vertices with parameters (a1, b1, c1) and (a2, b2, c2), we can use the following rules:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Sereja and CinemaIn order that no one would be upset, every person except first should sitdown near someone else. Now when any human comes we know that for one side of him there will not be any people. Will use it. We will support the interval exactly occupied seats. If the first person is not known, it is possible that we have 2 such intervals. Now only remains to consider carefully all the cases that could be, because at each iteration we know exactly how many people will sit on some certain place.380E - Sereja and DividingNote that at any particular segment we are interested not more than 60 numbers. The greatest number enters with a coefficient of 1/2, the following — 1 /4, 1 /8, and so on. Thus to solve the problem we need to know for each number: how many segments to include it as a maximum , as a second maximum , a third , and so on until the 60th .What to know such information is sufficient to find 60 numbers large jobs left and right. This can be done carefully written the set or dsu.Now, with this information we can calculate by countind number of segments which contain our element. It is not difficult to do, knowing the positions of elements , large then current . Let the position of elements on the left: p1> p2> ... > Ps1. And positions right: q1 < q2 < ... < qs2. So we should add value .All details can be viewed in any accepted solution.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 381 和字母"
          },
          "content_length": 2842
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 1",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 2",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 3",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 4",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #223 — Tutorial - Codeforces - Code 5",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<int> cnt;\n\nbool isPowerOfTwo(int x) {\n    return x > 0 && (x & (x - 1)) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 7000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 7000, \"m\");\n    inf.readEoln();\n\n    cnt.resize(n + 2, 0);\n    cnt[1] = 1;\n    for(int level = 1; level <= n - 1; ++level) {\n        cnt[level + 1] = 0;\n        for(int position = 1; position <= cnt[level]; ++position) {\n            if (isPowerOfTwo(position)) {\n                cnt[level + 1] += 2;\n            } else {\n                cnt[level + 1] += 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int op = inf.readInt(1, 2, \"op\");\n        if (op == 1) {\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int l = inf.readInt(1, cnt[t], \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, cnt[t], \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000, \"x\");\n            inf.readEoln();\n        }\n        else {\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int v = inf.readInt(1, cnt[t], \"v\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<int> cnt;\n\nbool isPowerOfTwo(int x) {\n    return x > 0 && (x & (x - 1)) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 7000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 7000, \"m\");\n    inf.readEoln();\n\n    cnt.resize(n + 2, 0);\n    cnt[1] = 1;\n    for(int level = 1; level <= n - 1; ++level) {\n        cnt[level + 1] = 0;\n        for(int position = 1; position <= cnt[level]; ++position) {\n            if (isPowerOfTwo(position)) {\n                cnt[level + 1] += 2;\n            } else {\n                cnt[level + 1] += 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int op = inf.readInt(1, 2, \"op\");\n        if (op == 1) {\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int l = inf.readInt(1, cnt[t], \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, cnt[t], \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000, \"x\");\n            inf.readEoln();\n        }\n        else {\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int v = inf.readInt(1, cnt[t], \"v\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<int> cnt;\n\nbool isPowerOfTwo(int x) {\n    return x > 0 && (x & (x - 1)) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 7000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 7000, \"m\");\n    inf.readEoln();\n\n    cnt.resize(n + 2, 0);\n    cnt[1] = 1;\n    for(int level = 1; level <= n - 1; ++level) {\n        cnt[level + 1] = 0;\n        for(int position = 1; position <= cnt[level]; ++position) {\n            if (isPowerOfTwo(position)) {\n                cnt[level + 1] += 2;\n            } else {\n                cnt[level + 1] += 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int op = inf.readInt(1, 2, \"op\");\n        if (op == 1) {\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int l = inf.readInt(1, cnt[t], \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, cnt[t], \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000, \"x\");\n            inf.readEoln();\n        }\n        else {\n            inf.readSpace();\n            int t = inf.readInt(1, n, \"t\");\n            inf.readSpace();\n            int v = inf.readInt(1, cnt[t], \"v\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Check if a number is power of two\nbool isPowerOfTwo(int x) {\n    return x && (!(x&(x-1)));\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Compute cnt[1..n]\n    vector<int> cnt(n + 2);\n    cnt[1] = 1;\n    for (int level = 1; level <= n - 1; ++level) {\n        cnt[level + 1] = 0;\n        for (int position = 1; position <= cnt[level]; ++position) {\n            if (isPowerOfTwo(position)) {\n                // The node at (level, position) has both left and right children\n                cnt[level + 1] += 2;\n            } else {\n                // The node at (level, position) has only a right child\n                cnt[level + 1] += 1;\n            }\n        }\n    }\n\n    // Generate operations according to the specified type\n    vector<string> operations;\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                // Type 1 operation: \"1 t l r x\"\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                // Type 2 operation: \"2 t v\"\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"all-add\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int l = 1;\n            int r = cnt[t];\n            int x = rnd.next(1, 1000000);\n            operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n        }\n    } else if (type == \"all-query\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int v = rnd.next(1, cnt[t]);\n            operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n        }\n    } else if (type == \"edge\") {\n        // All operations on level 1, position 1\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 1 1 1 \" + to_string(x));\n            } else {\n                operations.push_back(\"2 1 1\");\n            }\n        }\n    } else if (type == \"deep\") {\n        // Operations on the deepest level\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = n;\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = n;\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"constant-x\") {\n        int x = rnd.next(1, 1000000);\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"unique-x\") {\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = i + 1; // Ensure unique x\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"large-subtree\") {\n        // Perform operations on nodes with large subtrees\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n / 2);\n                int l = 1;\n                int r = cnt[t];\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n / 2);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else {\n        // Default to random operations\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (auto &op : operations) {\n        printf(\"%s\\n\", op.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Check if a number is power of two\nbool isPowerOfTwo(int x) {\n    return x && (!(x&(x-1)));\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Compute cnt[1..n]\n    vector<int> cnt(n + 2);\n    cnt[1] = 1;\n    for (int level = 1; level <= n - 1; ++level) {\n        cnt[level + 1] = 0;\n        for (int position = 1; position <= cnt[level]; ++position) {\n            if (isPowerOfTwo(position)) {\n                // The node at (level, position) has both left and right children\n                cnt[level + 1] += 2;\n            } else {\n                // The node at (level, position) has only a right child\n                cnt[level + 1] += 1;\n            }\n        }\n    }\n\n    // Generate operations according to the specified type\n    vector<string> operations;\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                // Type 1 operation: \"1 t l r x\"\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                // Type 2 operation: \"2 t v\"\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"all-add\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int l = 1;\n            int r = cnt[t];\n            int x = rnd.next(1, 1000000);\n            operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n        }\n    } else if (type == \"all-query\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, n);\n            int v = rnd.next(1, cnt[t]);\n            operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n        }\n    } else if (type == \"edge\") {\n        // All operations on level 1, position 1\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 1 1 1 \" + to_string(x));\n            } else {\n                operations.push_back(\"2 1 1\");\n            }\n        }\n    } else if (type == \"deep\") {\n        // Operations on the deepest level\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = n;\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = n;\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"constant-x\") {\n        int x = rnd.next(1, 1000000);\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"unique-x\") {\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = i + 1; // Ensure unique x\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else if (type == \"large-subtree\") {\n        // Perform operations on nodes with large subtrees\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n / 2);\n                int l = 1;\n                int r = cnt[t];\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n / 2);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    } else {\n        // Default to random operations\n        for (int i = 0; i < m; ++i) {\n            int op_type = rnd.next(1, 2);\n            if (op_type == 1) {\n                int t = rnd.next(1, n);\n                int l = rnd.next(1, cnt[t]);\n                int r = rnd.next(l, cnt[t]);\n                int x = rnd.next(1, 1000000);\n                operations.push_back(\"1 \" + to_string(t) + \" \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                int t = rnd.next(1, n);\n                int v = rnd.next(1, cnt[t]);\n                operations.push_back(\"2 \" + to_string(t) + \" \" + to_string(v));\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (auto &op : operations) {\n        printf(\"%s\\n\", op.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type small-n\n./gen -n 2 -m 2 -type small-n\n./gen -n 10 -m 20 -type random\n./gen -n 50 -m 100 -type random\n./gen -n 100 -m 200 -type random\n\n./gen -n 1000 -m 2000 -type random\n./gen -n 5000 -m 7000 -type random\n./gen -n 7000 -m 7000 -type random\n\n./gen -n 7000 -m 7000 -type all-add\n./gen -n 7000 -m 7000 -type all-query\n./gen -n 7000 -m 7000 -type edge\n\n./gen -n 7000 -m 7000 -type deep\n./gen -n 7000 -m 7000 -type constant-x\n./gen -n 7000 -m 7000 -type unique-x\n./gen -n 7000 -m 7000 -type large-subtree\n\n./gen -n 1 -m 7000 -type all-query\n./gen -n 1 -m 7000 -type all-add\n\n./gen -n 7000 -m 1 -type all-query\n./gen -n 7000 -m 1 -type all-add\n\n./gen -n 5000 -m 5000 -type random\n./gen -n 6000 -m 6000 -type random\n./gen -n 7000 -m 7000 -type random\n./gen -n 7000 -m 7000 -type max-add\n./gen -n 7000 -m 7000 -type max-query\n./gen -n 7000 -m 7000 -type edge\n./gen -n 7000 -m 7000 -type deep\n./gen -n 7000 -m 7000 -type unique-x\n./gen -n 7000 -m 7000 -type large-subtree\n./gen -n 7000 -m 7000 -type constant-x\n\n./gen -n 1 -m 1 -type random\n./gen -n 7000 -m 7000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:34.121543",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "381/E",
      "title": "E. Сережа и скобочки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит последовательность символов без пробелов s1, s2, ..., sn (1 ≤ n ≤ 106). Каждый символ это либо «(», либо «)». Вторая строка содержит целое число m (1 ≤ m ≤ 105) количество запросов. Каждая из следующих m строк содержит пару целых чисел. В i-ой строке записаны числа li, ri (1 ≤ li ≤ ri ≤ n) — описание i-го запроса.",
      "output_spec": "Выходные данныеВыведите ответ на каждый запрос в отдельной строке. Ответы выводите в порядке следования запросов во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать())(())(())(71 12 31 21 128 125 112 10Выходные данныеСкопировать00210466",
      "description": "E. Сережа и скобочки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит последовательность символов без пробелов s1, s2, ..., sn (1 ≤ n ≤ 106). Каждый символ это либо «(», либо «)». Вторая строка содержит целое число m (1 ≤ m ≤ 105) количество запросов. Каждая из следующих m строк содержит пару целых чисел. В i-ой строке записаны числа li, ri (1 ≤ li ≤ ri ≤ n) — описание i-го запроса.\n\nВходные данные\n\nВыходные данныеВыведите ответ на каждый запрос в отдельной строке. Ответы выводите в порядке следования запросов во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать())(())(())(71 12 31 21 128 125 112 10Выходные данныеСкопировать00210466\n\nВходные данныеСкопировать())(())(())(71 12 31 21 128 125 112 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00210466\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПодпоследовательностью длины |x| строки s = s1s2... s|s| (где |s| — длина строки s) называется строка x = sk1sk2... sk|x| (1 ≤ k1 < k2 < ... < k|x| ≤ |s|).Правильной скобочной последовательностью называется скобочная последовательность, которую можно преобразовать в корректное арифметическое выражение путем вставок между ее символами символов «1» и «+». Например, скобочные последовательности «()()», «(())» — правильные (полученные выражения: «(1)+(1)», «((1+1)+1)»), а «)(» и «(» — нет.Для третьего запроса искомая последовательность будет «()».Для четвертого запроса искомая последовательность будет «()(())(())».",
      "solutions": [
        {
          "title": "Codeforces Round #223 - Codeforces",
          "content": "Всем привет!Совсем скоро, 12 января в 19:30 MSK состоится Codeforces Round #223, автором которого являюсь я. Это мой десятый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Это первый раунд в этом году. Кстати, в прошлом году первый раунд для двух дивизионов тоже был мой(а по статистике +1/-1, оказался самым крутым из тех, что я давал). Надеюсь, что в этот раз задачи окажутся еще более интересными для Вас. Получится ли? Узнаем после окончания раунда :)Gl & hf ! :)Разбалловка в обоих дивизионах стандартная.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 689
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces",
          "content": "381A - Сережа и ДимаПросто проделаем все операции описанные в условии.381B - Сережа и лесенкаПосчитаем количества каждого числа. Все различные числа, кроме максимального можно использовать не более 2-х раз. Максимальное же — только 1.380A - Сережа и префиксыСгенерируем первые 100000 чисел. Будем по очереди обратывать запросы, если запрос попадает в точку доабвления 1 числа, то просто выведем его. Иначе посмотрим, какому элементу будет соотвествовать наш, и просто выведм его из предподсчитаного массива.380B - Сережа и деревоСгенерируем дерево, как описано в условии. Для каждого запроса на добавление элементов. Просто для уровня будем добавлять отрезок. На запрос количества элементов будем просто проходить по всем нижним уровням, считая самую левую и самую правую вершину в поддереве. Далее для каждого уровня будем проходить по отрезкам, которые ему принадлежат и для каждого проверять — пересекается ли он с тем, что у нас сгенерирован на текущем этапе. Если да, то просто добавим элемент в множество. Сложность решения O(n·m).380C - Сережа и скобочкиБудем поддерживать дерево отрезков, в каждой вершине будем хранить:av — максимальную длину скобочной подпоследовательностиbv — сколько вне нее есть открытых скобокcv — сколько вне нее есть закрытых скобокЕсли нам нужно объединить две вершины с параметрами (a1, b1, c1) и (a2, b2, c2), то можно пользоваться следующими правилами:t = min(b1, c2)a = a1 + a2 + tb = b1 + b2 - tc = c1 + c2 - t 380D - Сережа и кинотеатрДля того, что бы никто не обиделся достаточно, что бы все кроме первого человека содились возле уже сидящего. Теперь когда приходит любой челвек мы точно знаем, что по одну сторону от него никто не сидит. Будем использовать это. Будем поддерживать интервал точно занятых мест. Если первый человек не известен, то таких возможных интервала будет 2. Теперь лишь осталось аккуратно рассмотреть все случаи того как могли заходить люди, ведь на каждой итерации мы точно знаем сколько людей куда сядут.380E - Сережа и делениеЗаметим, что на любом конкретном отрезке нас интересует не более 60 чисел. Самое большое войдет в ответ с коэфициентом 1/2, следующее — 1/4, 1/8 и так далее. Таким образом для решения нужно для каждого числа знать: в сколько отрезков оно входит как максимум, как второй максимум, третий, и так далее до 60ого.Что бы знать такую информацию достаточно найти 60 чисел больше заданого слева и справа. Это можно делать аккуратно написаным set-ом, или dsu. Теперь имея такую информацию можно посчитать величину, которую элемент несет в ответ. Это не сложно сделать, зная позиции элементов, больших текущего. Пускай позиции элементов слева p1 > p2 > ... > ps1. А позиций справа q1 < q2 < ... < qs2. .Все детали можно посмотреть в любом прошедшем решении.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 381 和字母"
          },
          "content_length": 2741
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #223 - Codeforces - Code 1",
          "code": "9 января в 19:30 MSK",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 - Codeforces - Code 2",
          "code": "Получится ли? Узнаем после окончания раунда :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10334",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 1",
          "code": "max(0, -minimum_balance)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 2",
          "code": "b[l] + b[r] - 2*min",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 3",
          "code": "r' выступает за r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 4",
          "code": "это граница после уменьшения её до тех пор, пока она не влезет.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 5",
          "code": "length_of_sequence - b - c",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 6",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 7",
          "code": "for (q in queries):\n  events[R[q]].add(q);\n\n//will store the indexes of the brackets waiting for a match\nopenBrackets := empty_stack()\n\nfor(i=0, i < line.size(); i++):\n  if(line[i] == ')' && sizeof(openBrackets) > 0):\n    add(openBrackets.top()) // adds 1 to the index of the last opened bracket\n    openBrackets.pop();\n  else if(line[i] == '('):\n    openBrackets.push(i);\n  // goes through all the queries that ends in 'i'\n  for(q in events[i]):\n    ans[q] = rsq(L[q],R[q])\n\n// Prints the answers. Multiply it by 2, since the value stored in \"ans\" is \n// the number of pairs of matching brackets\nfor(q in queries):\n  print 2*ans[q] + '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 8",
          "code": "cin>>s;\ns=\" \"+s;\nint n=sz(s);\nn--;\nsegtree=vector<Info*>(4*(n));\nfo(i,4*(n)) segtree[i]=new Info(0,0,0);\nbuild(1,1,n);\nint m;\ncin>>m;\nwhile(m--){\n    int a,b;\n    cin>>a>>b;\n    cout<<(query(1,1,n,a,b)->full)*2<<\"\\n\";\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 9",
          "code": "this gives a memory limit exceeded but",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 10",
          "code": "this gives a memory limit exceeded but",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 11",
          "code": "cin>>s;\ns=\" \"+s;\nint n=sz(s);\nn--;\nsegtree=vector<Info*>(4*(n),new Info(0,0,0));\nbuild(1,1,n);\nint m;\ncin>>m;\nwhile(m--){\n    int a,b;\n    cin>>a>>b;\n    cout<<(query(1,1,n,a,b)->full)*2<<\"\\n\";\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 12",
          "code": "vector<vector<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #223 — Разбор - Codeforces - Code 13",
          "code": "vector<node>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[()]{1,1000000}\", \"s\");\n    inf.readEoln();\n\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[()]{1,1000000}\", \"s\");\n    inf.readEoln();\n\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[()]{1,1000000}\", \"s\");\n    inf.readEoln();\n\n    int n = s.length();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string bracket_type = opt<string>(\"bracket_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate bracket sequence s\n    string s;\n    if (bracket_type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? '(' : ')';\n        }\n    } else if (bracket_type == \"all_open\") {\n        s = string(n, '(');\n    } else if (bracket_type == \"all_close\") {\n        s = string(n, ')');\n    } else if (bracket_type == \"alternating\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2) == 0 ? '(' : ')';\n        }\n    } else if (bracket_type == \"balanced\") {\n        // Generate a balanced bracket sequence as much as possible\n        int pairs = n / 2;\n        s = \"\";\n        for (int i = 0; i < pairs; ++i) {\n            s += '(';\n        }\n        for (int i = 0; i < pairs; ++i) {\n            s += ')';\n        }\n        if (n % 2 != 0) {\n            s += '('; // Add an extra '('\n        }\n    } else {\n        // Unknown bracket type\n        cerr << \"Unknown bracket_type: \" << bracket_type << endl;\n        return 1;\n    }\n\n    // Generate m queries\n    vector<pair<int, int>> queries;\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries.emplace_back(l, r);\n        }\n    } else if (query_type == \"full\") {\n        // Each query covers the entire sequence\n        for (int i = 0; i < m; ++i) {\n            queries.emplace_back(1, n);\n        }\n    } else if (query_type == \"single\") {\n        // Each query is of length 1\n        for (int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            queries.emplace_back(pos, pos);\n        }\n    } else if (query_type == \"prefix\") {\n        // Queries are prefixes of the sequence\n        for (int i = 0; i < m; ++i) {\n            int r = rnd.next(1, n);\n            queries.emplace_back(1, r);\n        }\n    } else if (query_type == \"suffix\") {\n        // Queries are suffixes of the sequence\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            queries.emplace_back(l, n);\n        }\n    } else if (query_type == \"same\") {\n        // All queries are the same\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        for (int i = 0; i < m; ++i) {\n            queries.emplace_back(l, r);\n        }\n    } else if (query_type == \"corner\") {\n        // Queries include corner positions\n        queries.emplace_back(1, 1);\n        queries.emplace_back(n, n);\n        queries.emplace_back(1, n);\n        for (int i = 3; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.emplace_back(l, r);\n        }\n    } else {\n        cerr << \"Unknown query_type: \" << query_type << endl;\n        return 1;\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output queries\n    for (const auto& q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string bracket_type = opt<string>(\"bracket_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate bracket sequence s\n    string s;\n    if (bracket_type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? '(' : ')';\n        }\n    } else if (bracket_type == \"all_open\") {\n        s = string(n, '(');\n    } else if (bracket_type == \"all_close\") {\n        s = string(n, ')');\n    } else if (bracket_type == \"alternating\") {\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2) == 0 ? '(' : ')';\n        }\n    } else if (bracket_type == \"balanced\") {\n        // Generate a balanced bracket sequence as much as possible\n        int pairs = n / 2;\n        s = \"\";\n        for (int i = 0; i < pairs; ++i) {\n            s += '(';\n        }\n        for (int i = 0; i < pairs; ++i) {\n            s += ')';\n        }\n        if (n % 2 != 0) {\n            s += '('; // Add an extra '('\n        }\n    } else {\n        // Unknown bracket type\n        cerr << \"Unknown bracket_type: \" << bracket_type << endl;\n        return 1;\n    }\n\n    // Generate m queries\n    vector<pair<int, int>> queries;\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries.emplace_back(l, r);\n        }\n    } else if (query_type == \"full\") {\n        // Each query covers the entire sequence\n        for (int i = 0; i < m; ++i) {\n            queries.emplace_back(1, n);\n        }\n    } else if (query_type == \"single\") {\n        // Each query is of length 1\n        for (int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            queries.emplace_back(pos, pos);\n        }\n    } else if (query_type == \"prefix\") {\n        // Queries are prefixes of the sequence\n        for (int i = 0; i < m; ++i) {\n            int r = rnd.next(1, n);\n            queries.emplace_back(1, r);\n        }\n    } else if (query_type == \"suffix\") {\n        // Queries are suffixes of the sequence\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            queries.emplace_back(l, n);\n        }\n    } else if (query_type == \"same\") {\n        // All queries are the same\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        for (int i = 0; i < m; ++i) {\n            queries.emplace_back(l, r);\n        }\n    } else if (query_type == \"corner\") {\n        // Queries include corner positions\n        queries.emplace_back(1, 1);\n        queries.emplace_back(n, n);\n        queries.emplace_back(1, n);\n        for (int i = 3; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.emplace_back(l, r);\n        }\n    } else {\n        cerr << \"Unknown query_type: \" << query_type << endl;\n        return 1;\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output queries\n    for (const auto& q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -bracket_type random -query_type random\n./gen -n 10 -m 5 -bracket_type all_open -query_type random\n./gen -n 10 -m 5 -bracket_type all_close -query_type random\n./gen -n 10 -m 5 -bracket_type balanced -query_type random\n./gen -n 10 -m 5 -bracket_type alternating -query_type random\n\n./gen -n 1000 -m 500 -bracket_type random -query_type random\n./gen -n 1000 -m 500 -bracket_type balanced -query_type full\n./gen -n 1000 -m 500 -bracket_type random -query_type full\n./gen -n 1000 -m 500 -bracket_type balanced -query_type single\n./gen -n 1000 -m 500 -bracket_type random -query_type single\n\n./gen -n 200000 -m 1000 -bracket_type random -query_type random\n./gen -n 200000 -m 100000 -bracket_type balanced -query_type random\n./gen -n 200000 -m 100000 -bracket_type alternating -query_type random\n\n./gen -n 1000000 -m 100000 -bracket_type random -query_type random\n./gen -n 1000000 -m 100000 -bracket_type balanced -query_type random\n./gen -n 1000000 -m 100000 -bracket_type all_open -query_type full\n./gen -n 1000000 -m 100000 -bracket_type all_close -query_type full\n\n./gen -n 1000000 -m 1 -bracket_type balanced -query_type full\n./gen -n 1000000 -m 1 -bracket_type balanced -query_type single\n./gen -n 1000000 -m 100000 -bracket_type alternating -query_type prefix\n./gen -n 1000000 -m 100000 -bracket_type alternating -query_type suffix\n./gen -n 1000000 -m 100000 -bracket_type balanced -query_type same\n\n./gen -n 500000 -m 500000 -bracket_type balanced -query_type random\n./gen -n 500000 -m 500000 -bracket_type random -query_type random\n\n./gen -n 1 -m 1 -bracket_type random -query_type random\n\n./gen -n 2 -m 4 -bracket_type random -query_type corner\n\n./gen -n 1000000 -m 100000 -bracket_type random -query_type corner\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:36.118574",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "382/A",
      "title": "A. Ksenia and Pan Scales",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line has a non-empty sequence of characters describing the scales. In this sequence, an uppercase English letter indicates a weight, and the symbol \"|\" indicates the delimiter (the character occurs in the sequence exactly once). All weights that are recorded in the sequence before the delimiter are initially on the left pan of the scale. All weights that are recorded in the sequence after the delimiter are initially on the right pan of the scale. The second line contains a non-empty sequence containing uppercase English letters. Each letter indicates a weight which is not used yet. It is guaranteed that all the English letters in the input data are different. It is guaranteed that the input does not contain any extra characters.",
      "output_spec": "OutputIf you cannot put all the weights on the scales so that the scales were in equilibrium, print string \"Impossible\". Otherwise, print the description of the resulting scales, copy the format of the input.If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopyAC|TLOutputCopyAC|TLInputCopy|ABCXYZOutputCopyXYZ|ABCInputCopyW|TFOutputCopyImpossibleInputCopyABC|DOutputCopyImpossible",
      "description": "A. Ksenia and Pan Scales\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line has a non-empty sequence of characters describing the scales. In this sequence, an uppercase English letter indicates a weight, and the symbol \"|\" indicates the delimiter (the character occurs in the sequence exactly once). All weights that are recorded in the sequence before the delimiter are initially on the left pan of the scale. All weights that are recorded in the sequence after the delimiter are initially on the right pan of the scale. The second line contains a non-empty sequence containing uppercase English letters. Each letter indicates a weight which is not used yet. It is guaranteed that all the English letters in the input data are different. It is guaranteed that the input does not contain any extra characters.\n\nOutputIf you cannot put all the weights on the scales so that the scales were in equilibrium, print string \"Impossible\". Otherwise, print the description of the resulting scales, copy the format of the input.If there are multiple answers, print any of them.\n\nInputCopyAC|TLOutputCopyAC|TLInputCopy|ABCXYZOutputCopyXYZ|ABCInputCopyW|TFOutputCopyImpossibleInputCopyABC|DOutputCopyImpossible\n\nInputCopyAC|TL\n\nOutputCopyAC|TL\n\nInputCopy|ABCXYZ\n\nOutputCopyXYZ|ABC\n\nInputCopyW|TF\n\nOutputCopyImpossible\n\nInputCopyABC|D\n\nOutputCopyImpossible",
      "solutions": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces",
          "content": "Good day everybody)Welcome to regular Codeforces round #224 for Div.2 participants, first Div2 Only in new 2014 year:). As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). I can't already remember exactly in how many rounds I participate as author, co-author of just active assistant) Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be dynamic, but the problems will be in supposed order of increasing complexity. The first dynamic round in this year)We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, we hope you enjoy it) the editorial is already here)Congratulations to winners:1) tankmagiciangirl2) NagaiNatsuyasumi3) lijian32564) TankKiller5) dashabi",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10423",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 934
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces",
          "content": "382A - Ksenia and Pan ScalesThis problem is just a technic problem. So, you should take weights one by one and place the current one into the side of the scales that contains lower number of weights. At the end you should output answer in the correct format.382B - Number BustersIn the problem you should understand, what is the structure of Artur's operation. You can see that this operation is near operation (b + x) % w (To see that just apply b = w - b - 1). There is nothing hard to get the formula of changing a during the operation. So, if you have k operations, you can see, that b = (b + k·x) % w, a = a - (b + k·x) / w, c = c - k. When you've got all the formulas, you can solve the problem using binary search.382C - Arithmetic ProgressionThis problem is about considering cases:1) If n = 1, the answer is -1. Because of any two numbers is arithmetical progression.2) If array is constant, the answer if that constant.3) If you have arithmetical progression initially, you can compute its difference d. In this case you should just to output minVal - d, and maxVal + d, where minVal is minimum value among a[i], and maxVal is maximum value among a[i]. But in case of n = 2, also you should check (a[0] + a[1]) / 2. If this number is integer, it is needed to be output.4) Else, the answer has at most one integer. You find this integer you should sort the sequence, and find the place where the number is missed. If such a place exists you should add the corresponding number to the sequence, else, the answer is 0.5) In all other cases the answer is 0.382D - Ksenia and PawnsIn this problem from every cell except # there is one next cell. That's why this graph is almost functional graph. If this graph contains a cycle, then answer is -1 because the length of the cycle is at least two.In the other case, there are no cycles in the graph. Let's find the longest path in it, denote is as len. Then is answer is at least 2·len - 1 because we can put the two pawns in the first two cells of this path.But in some cases we could get the answer 2·len if there are two non-intersecting by vertices (not #) paths of length len. They are non-intersecting because if they intersect in some cell then they will be equal to the end (and the statement says that such moves are invalid).So, we should check if the graph contains two non-intersecting by vertices (not #) paths of length len. It could be done in any way. For example, using dfs searches.382E - Ksenia and CombinatoricsIn this problem you should count trees with some properties. It can be done using dynamic programming. The main idea is that the maximum mathing in tree can be found using simple dynamic dp[v][used] (v -- vertex, used — was this vertex used in matching). So you should to count the trees tou should include in state of the dynamic values dp[v][0]$ and dp[v][1]. In other words, you should use dynamic programming z[n][dp0][dp1] — number of rooted trees with n vertices and values of dynamic in root dp[root][0] = dp0 and dp[root][1] = dp1. But in simple implementation this solution will get TL. There are two ways to get AC. The first is to opltimize code and make precalc. The second is to optimize asymptotics.The author's solution uses the second way. To optimize solution you should mark that values dp0 and dp1 differs at most by one. That is dp0 = dp1, or dp0 = dp1 + 1. So the first dynamic becomes r[n][dp0][add]. Another optimization is there are not so many triples (n, dp0, add) with non-negative values (about 250), so you can you use lazy programming to calculate this dynamic.Comments that describe other solutions: http://codeforces.com/blog/entry/10423#comment-158177http://codeforces.com/blog/entry/10423#comment-158182",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 382\\s*A"
          },
          "content_length": 3720
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 1",
          "code": "next[b][i] = after 2^i step what will be b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 2",
          "code": "add[b][i] = after 2^i step how many time a will decrease",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 3",
          "code": "O(log MAX_ANSWER)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 4",
          "code": "O(log MAX_ANSWER)^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 5",
          "code": "let f(x) = after x steps what will be new a value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 6",
          "code": "let g(x) = after x steps what will be new c value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 7",
          "code": "let df(x) = f(x) - f(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 8",
          "code": "let dg(x) = g(x) - g(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 9",
          "code": "t[i].reserve(2000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 10",
          "code": "char t[2000][2000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "(a[0] + a[1]) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "n( Required number of terms) = (l-a)/d+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "and Sum of all terms = [n*(l+a)]/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_uppercase_letter(char c) {\n    return 'A' <= c && c <= 'Z';\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"^[A-Z|]+$\", \"s1\");\n    string s2 = inf.readLine(\"^[A-Z]+$\", \"s2\");\n    inf.readEof();\n\n    // Check that s1 contains exactly one '|' character\n    int cnt_sep = count(s1.begin(), s1.end(), '|');\n    ensuref(cnt_sep == 1, \"First line must contain exactly one '|' character\");\n\n    // Split s1 into left pan and right pan\n    size_t pos = s1.find('|');\n    ensuref(pos != string::npos, \"Separator '|' not found\");\n\n    string left_pan = s1.substr(0, pos);\n    string right_pan = s1.substr(pos + 1);\n\n    // Ensure that left_pan and right_pan contain only uppercase letters\n    for (char c : left_pan) {\n        ensuref(is_uppercase_letter(c), \"Left pan contains invalid character '%c'\", c);\n    }\n    for (char c : right_pan) {\n        ensuref(is_uppercase_letter(c), \"Right pan contains invalid character '%c'\", c);\n    }\n\n    // Collect all letters from s1 and s2 (excluding '|') and check uniqueness\n    vector<char> letters;\n    for (char c : left_pan) letters.push_back(c);\n    for (char c : right_pan) letters.push_back(c);\n    for (char c : s2) letters.push_back(c);\n\n    // Check that all letters are uppercase letters and are unique\n    set<char> letter_set;\n    for (char c : letters) {\n        ensuref(is_uppercase_letter(c), \"Invalid character '%c' found\", c);\n        letter_set.insert(c);\n    }\n    ensuref((int)letter_set.size() == (int)letters.size(), \"Duplicate letters found\");\n\n    // Ensure that total number of letters does not exceed 26\n    ensuref((int)letter_set.size() <= 26, \"Total number of letters exceeds 26\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_uppercase_letter(char c) {\n    return 'A' <= c && c <= 'Z';\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"^[A-Z|]+$\", \"s1\");\n    string s2 = inf.readLine(\"^[A-Z]+$\", \"s2\");\n    inf.readEof();\n\n    // Check that s1 contains exactly one '|' character\n    int cnt_sep = count(s1.begin(), s1.end(), '|');\n    ensuref(cnt_sep == 1, \"First line must contain exactly one '|' character\");\n\n    // Split s1 into left pan and right pan\n    size_t pos = s1.find('|');\n    ensuref(pos != string::npos, \"Separator '|' not found\");\n\n    string left_pan = s1.substr(0, pos);\n    string right_pan = s1.substr(pos + 1);\n\n    // Ensure that left_pan and right_pan contain only uppercase letters\n    for (char c : left_pan) {\n        ensuref(is_uppercase_letter(c), \"Left pan contains invalid character '%c'\", c);\n    }\n    for (char c : right_pan) {\n        ensuref(is_uppercase_letter(c), \"Right pan contains invalid character '%c'\", c);\n    }\n\n    // Collect all letters from s1 and s2 (excluding '|') and check uniqueness\n    vector<char> letters;\n    for (char c : left_pan) letters.push_back(c);\n    for (char c : right_pan) letters.push_back(c);\n    for (char c : s2) letters.push_back(c);\n\n    // Check that all letters are uppercase letters and are unique\n    set<char> letter_set;\n    for (char c : letters) {\n        ensuref(is_uppercase_letter(c), \"Invalid character '%c' found\", c);\n        letter_set.insert(c);\n    }\n    ensuref((int)letter_set.size() == (int)letters.size(), \"Duplicate letters found\");\n\n    // Ensure that total number of letters does not exceed 26\n    ensuref((int)letter_set.size() <= 26, \"Total number of letters exceeds 26\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_uppercase_letter(char c) {\n    return 'A' <= c && c <= 'Z';\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s1 = inf.readLine(\"^[A-Z|]+$\", \"s1\");\n    string s2 = inf.readLine(\"^[A-Z]+$\", \"s2\");\n    inf.readEof();\n\n    // Check that s1 contains exactly one '|' character\n    int cnt_sep = count(s1.begin(), s1.end(), '|');\n    ensuref(cnt_sep == 1, \"First line must contain exactly one '|' character\");\n\n    // Split s1 into left pan and right pan\n    size_t pos = s1.find('|');\n    ensuref(pos != string::npos, \"Separator '|' not found\");\n\n    string left_pan = s1.substr(0, pos);\n    string right_pan = s1.substr(pos + 1);\n\n    // Ensure that left_pan and right_pan contain only uppercase letters\n    for (char c : left_pan) {\n        ensuref(is_uppercase_letter(c), \"Left pan contains invalid character '%c'\", c);\n    }\n    for (char c : right_pan) {\n        ensuref(is_uppercase_letter(c), \"Right pan contains invalid character '%c'\", c);\n    }\n\n    // Collect all letters from s1 and s2 (excluding '|') and check uniqueness\n    vector<char> letters;\n    for (char c : left_pan) letters.push_back(c);\n    for (char c : right_pan) letters.push_back(c);\n    for (char c : s2) letters.push_back(c);\n\n    // Check that all letters are uppercase letters and are unique\n    set<char> letter_set;\n    for (char c : letters) {\n        ensuref(is_uppercase_letter(c), \"Invalid character '%c' found\", c);\n        letter_set.insert(c);\n    }\n    ensuref((int)letter_set.size() == (int)letters.size(), \"Duplicate letters found\");\n\n    // Ensure that total number of letters does not exceed 26\n    ensuref((int)letter_set.size() <= 26, \"Total number of letters exceeds 26\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read from input file\n    string scales = inf.readLine();\n    string unused = inf.readLine();\n\n    // Parse initial scales\n    size_t pos = scales.find('|');\n    if (pos == string::npos) {\n        quitf(_fail, \"Invalid input: no '|' in scales\");\n    }\n    string initial_left = scales.substr(0, pos);\n    string initial_right = scales.substr(pos + 1);\n\n    // Total number of letters\n    int n_left = initial_left.size();\n    int n_right = initial_right.size();\n    int n_unused = unused.size();\n    int total_letters = n_left + n_right + n_unused;\n\n    // Determine if balancing is possible\n    bool possible = true;\n    if (total_letters % 2 != 0) {\n        possible = false;\n    } else {\n        int target = total_letters / 2;\n        int needed_left = target - n_left;\n        int needed_right = target - n_right;\n        if (needed_left < 0 || needed_right < 0 || needed_left + needed_right != n_unused) {\n            possible = false;\n        }\n    }\n\n    // Read contestant's output\n    string contestant_output = ouf.readLine();\n\n    if (contestant_output == \"Impossible\") {\n        if (possible) {\n            quitf(_wa, \"Balancing is possible, but contestant reports Impossible\");\n        } else {\n            quitf(_ok, \"Correctly reported Impossible\");\n        }\n    } else {\n        if (!possible) {\n            quitf(_wa, \"Balancing is impossible, but contestant outputs a configuration\");\n        }\n\n        // Parse contestant's scales\n        size_t pos_c = contestant_output.find('|');\n        if (pos_c == string::npos) {\n            quitf(_wa, \"Contestant output does not contain '|'\");\n        }\n        string left_c = contestant_output.substr(0, pos_c);\n        string right_c = contestant_output.substr(pos_c + 1);\n\n        // Check that initial letters remain in the same order and on the same pans\n        if (left_c.substr(0, initial_left.size()) != initial_left) {\n            quitf(_wa, \"Initial left pan letters are modified\");\n        }\n        if (right_c.substr(0, initial_right.size()) != initial_right) {\n            quitf(_wa, \"Initial right pan letters are modified\");\n        }\n\n        // Compute target pan size\n        int target = total_letters / 2;\n\n        // Check that both pans have the correct number of letters\n        if ((int)left_c.size() != target) {\n            quitf(_wa, \"Left pan must have %d letters, but has %d\", target, (int)left_c.size());\n        }\n        if ((int)right_c.size() != target) {\n            quitf(_wa, \"Right pan must have %d letters, but has %d\", target, (int)right_c.size());\n        }\n\n        // Collect unused letters\n        set<char> unused_set(unused.begin(), unused.end());\n\n        // Verify that the added letters are from unused letters and are uppercase\n        string added_left = left_c.substr(initial_left.size());\n        string added_right = right_c.substr(initial_right.size());\n\n        // Check that letters are uppercase English letters\n        for (char c : added_left + added_right) {\n            if (c < 'A' || c > 'Z') {\n                quitf(_wa, \"Invalid character '%c' in added letters\", c);\n            }\n        }\n\n        // Check that added letters are from the unused letters\n        for (char c : added_left) {\n            if (unused_set.count(c)) {\n                unused_set.erase(c);\n            } else {\n                quitf(_wa, \"Invalid or duplicate letter '%c' added to left pan\", c);\n            }\n        }\n        for (char c : added_right) {\n            if (unused_set.count(c)) {\n                unused_set.erase(c);\n            } else {\n                quitf(_wa, \"Invalid or duplicate letter '%c' added to right pan\", c);\n            }\n        }\n\n        // Ensure all unused letters are used\n        if (!unused_set.empty()) {\n            quitf(_wa, \"Not all unused letters are used\");\n        }\n\n        // Verify that there are no duplicate letters\n        set<char> total_letters_set;\n        for (char c : initial_left + initial_right + added_left + added_right) {\n            if (total_letters_set.count(c)) {\n                quitf(_wa, \"Duplicate letter '%c' detected in output\", c);\n            }\n            total_letters_set.insert(c);\n        }\n\n        // All checks passed\n        quitf(_ok, \"Correct output\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int L = opt<int>(\"L\");\n    int R = opt<int>(\"R\");\n    int U = opt<int>(\"U\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    ensure(L >= 0 && R >= 0 && U >= 0);\n    ensure(L + R + U <= 26);\n    int total_letters = L + R + U;\n\n    vector<char> letters(26);\n    for(int i = 0; i < 26; ++i)\n        letters[i] = 'A' + i;\n    shuffle(letters.begin(), letters.end());\n\n    int adjusted_U = U;\n    int adjusted_L = L;\n    int adjusted_R = R;\n\n    if (type == \"possible\") {\n        int delta = R - L + U;\n        if (delta % 2 != 0) {\n            if (U > 0) {\n                adjusted_U -= 1;\n                total_letters -= 1;\n            } else if (L + R + U + 1 <= 26) {\n                adjusted_U +=1;\n                total_letters += 1;\n            } else {\n                ensure(false); // Cannot adjust U\n            }\n        }\n        delta = adjusted_R - adjusted_L + adjusted_U;\n        int l = delta / 2;\n        if (l < 0 || l > adjusted_U) {\n            ensure(false); // Cannot satisfy possible condition\n        }\n    } else if (type == \"impossible\") {\n        int delta = R - L + U;\n        if (delta % 2 == 0) {\n            if (U > 0) {\n                adjusted_U -= 1;\n                total_letters -= 1;\n            } else if (L + R + U + 1 <= 26) {\n                adjusted_U +=1;\n                total_letters += 1;\n            } else {\n                ensure(false); // Cannot adjust U\n            }\n        }\n    } else {\n        ensure(false); // Invalid type\n    }\n\n    ensure(adjusted_L >= 0 && adjusted_R >= 0 && adjusted_U >= 0);\n    ensure(adjusted_L + adjusted_R + adjusted_U <= 26);\n\n    // Re-shuffle letters in case total_letters changed\n    letters.resize(26);\n    for(int i = 0; i < 26; ++i)\n        letters[i] = 'A' + i;\n    shuffle(letters.begin(), letters.end());\n\n    vector<char> left_pan(letters.begin(), letters.begin() + adjusted_L);\n    vector<char> right_pan(letters.begin() + adjusted_L, letters.begin() + adjusted_L + adjusted_R);\n    vector<char> unused(letters.begin() + adjusted_L + adjusted_R, letters.begin() + adjusted_L + adjusted_R + adjusted_U);\n\n    // Output the initial sequence\n    for(char c : left_pan)\n        printf(\"%c\", c);\n    printf(\"|\");\n    for(char c : right_pan)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n    // Output the unused letters\n    for(char c : unused)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int L = opt<int>(\"L\");\n    int R = opt<int>(\"R\");\n    int U = opt<int>(\"U\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    ensure(L >= 0 && R >= 0 && U >= 0);\n    ensure(L + R + U <= 26);\n    int total_letters = L + R + U;\n\n    vector<char> letters(26);\n    for(int i = 0; i < 26; ++i)\n        letters[i] = 'A' + i;\n    shuffle(letters.begin(), letters.end());\n\n    int adjusted_U = U;\n    int adjusted_L = L;\n    int adjusted_R = R;\n\n    if (type == \"possible\") {\n        int delta = R - L + U;\n        if (delta % 2 != 0) {\n            if (U > 0) {\n                adjusted_U -= 1;\n                total_letters -= 1;\n            } else if (L + R + U + 1 <= 26) {\n                adjusted_U +=1;\n                total_letters += 1;\n            } else {\n                ensure(false); // Cannot adjust U\n            }\n        }\n        delta = adjusted_R - adjusted_L + adjusted_U;\n        int l = delta / 2;\n        if (l < 0 || l > adjusted_U) {\n            ensure(false); // Cannot satisfy possible condition\n        }\n    } else if (type == \"impossible\") {\n        int delta = R - L + U;\n        if (delta % 2 == 0) {\n            if (U > 0) {\n                adjusted_U -= 1;\n                total_letters -= 1;\n            } else if (L + R + U + 1 <= 26) {\n                adjusted_U +=1;\n                total_letters += 1;\n            } else {\n                ensure(false); // Cannot adjust U\n            }\n        }\n    } else {\n        ensure(false); // Invalid type\n    }\n\n    ensure(adjusted_L >= 0 && adjusted_R >= 0 && adjusted_U >= 0);\n    ensure(adjusted_L + adjusted_R + adjusted_U <= 26);\n\n    // Re-shuffle letters in case total_letters changed\n    letters.resize(26);\n    for(int i = 0; i < 26; ++i)\n        letters[i] = 'A' + i;\n    shuffle(letters.begin(), letters.end());\n\n    vector<char> left_pan(letters.begin(), letters.begin() + adjusted_L);\n    vector<char> right_pan(letters.begin() + adjusted_L, letters.begin() + adjusted_L + adjusted_R);\n    vector<char> unused(letters.begin() + adjusted_L + adjusted_R, letters.begin() + adjusted_L + adjusted_R + adjusted_U);\n\n    // Output the initial sequence\n    for(char c : left_pan)\n        printf(\"%c\", c);\n    printf(\"|\");\n    for(char c : right_pan)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n    // Output the unused letters\n    for(char c : unused)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -L 1 -R 1 -U 2 -type possible\n./gen -L 2 -R 1 -U 1 -type possible\n./gen -L 0 -R 0 -U 1 -type impossible\n./gen -L 1 -R 2 -U 2 -type possible\n./gen -L 5 -R 5 -U 5 -type possible\n./gen -L 3 -R 2 -U 1 -type impossible\n./gen -L 10 -R 5 -U 9 -type possible\n./gen -L 0 -R 0 -U 0 -type impossible\n./gen -L 13 -R 13 -U 0 -type possible\n./gen -L 12 -R 13 -U 1 -type possible\n./gen -L 12 -R 13 -U 1 -type impossible\n./gen -L 7 -R 8 -U 5 -type possible\n./gen -L 2 -R 3 -U 5 -type impossible\n./gen -L 6 -R 6 -U 14 -type possible\n./gen -L 0 -R 0 -U 26 -type possible\n./gen -L 0 -R 0 -U 26 -type impossible\n./gen -L 1 -R 0 -U 1 -type impossible\n./gen -L 0 -R 1 -U 1 -type impossible\n./gen -L 1 -R 1 -U 0 -type possible\n./gen -L 1 -R 0 -U 0 -type impossible\n./gen -L 5 -R 4 -U 1 -type possible\n./gen -L 5 -R 4 -U 1 -type impossible\n./gen -L 7 -R 0 -U 19 -type possible\n./gen -L 8 -R 8 -U 8 -type possible\n./gen -L 5 -R 5 -U 6 -type impossible\n./gen -L 10 -R 9 -U 7 -type possible\n./gen -L 10 -R 9 -U 7 -type impossible\n./gen -L 0 -R 25 -U 1 -type impossible\n./gen -L 25 -R 0 -U 1 -type impossible\n./gen -L 12 -R 12 -U 2 -type possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:38.199029",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "382/B",
      "title": "B. Number Busters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers a, b, w, x, c (1 ≤ a ≤ 2·109, 1 ≤ w ≤ 1000, 0 ≤ b < w, 0 < x < w, 1 ≤ c ≤ 2·109).",
      "output_spec": "OutputPrint a single integer — the minimum time in seconds Alexander needs to get ahead of Arthur. You can prove that the described situation always occurs within the problem's limits.",
      "sample_tests": "ExamplesInputCopy4 2 3 1 6OutputCopy2InputCopy4 2 3 1 7OutputCopy4InputCopy1 2 3 2 6OutputCopy13InputCopy1 1 2 1 1OutputCopy0",
      "description": "B. Number Busters\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers a, b, w, x, c (1 ≤ a ≤ 2·109, 1 ≤ w ≤ 1000, 0 ≤ b < w, 0 < x < w, 1 ≤ c ≤ 2·109).\n\nOutputPrint a single integer — the minimum time in seconds Alexander needs to get ahead of Arthur. You can prove that the described situation always occurs within the problem's limits.\n\nInputCopy4 2 3 1 6OutputCopy2InputCopy4 2 3 1 7OutputCopy4InputCopy1 2 3 2 6OutputCopy13InputCopy1 1 2 1 1OutputCopy0\n\nInputCopy4 2 3 1 6\n\nOutputCopy2\n\nInputCopy4 2 3 1 7\n\nOutputCopy4\n\nInputCopy1 2 3 2 6\n\nOutputCopy13\n\nInputCopy1 1 2 1 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces",
          "content": "Good day everybody)Welcome to regular Codeforces round #224 for Div.2 participants, first Div2 Only in new 2014 year:). As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). I can't already remember exactly in how many rounds I participate as author, co-author of just active assistant) Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be dynamic, but the problems will be in supposed order of increasing complexity. The first dynamic round in this year)We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, we hope you enjoy it) the editorial is already here)Congratulations to winners:1) tankmagiciangirl2) NagaiNatsuyasumi3) lijian32564) TankKiller5) dashabi",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10423",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 934
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces",
          "content": "382A - Ksenia and Pan ScalesThis problem is just a technic problem. So, you should take weights one by one and place the current one into the side of the scales that contains lower number of weights. At the end you should output answer in the correct format.382B - Number BustersIn the problem you should understand, what is the structure of Artur's operation. You can see that this operation is near operation (b + x) % w (To see that just apply b = w - b - 1). There is nothing hard to get the formula of changing a during the operation. So, if you have k operations, you can see, that b = (b + k·x) % w, a = a - (b + k·x) / w, c = c - k. When you've got all the formulas, you can solve the problem using binary search.382C - Arithmetic ProgressionThis problem is about considering cases:1) If n = 1, the answer is -1. Because of any two numbers is arithmetical progression.2) If array is constant, the answer if that constant.3) If you have arithmetical progression initially, you can compute its difference d. In this case you should just to output minVal - d, and maxVal + d, where minVal is minimum value among a[i], and maxVal is maximum value among a[i]. But in case of n = 2, also you should check (a[0] + a[1]) / 2. If this number is integer, it is needed to be output.4) Else, the answer has at most one integer. You find this integer you should sort the sequence, and find the place where the number is missed. If such a place exists you should add the corresponding number to the sequence, else, the answer is 0.5) In all other cases the answer is 0.382D - Ksenia and PawnsIn this problem from every cell except # there is one next cell. That's why this graph is almost functional graph. If this graph contains a cycle, then answer is -1 because the length of the cycle is at least two.In the other case, there are no cycles in the graph. Let's find the longest path in it, denote is as len. Then is answer is at least 2·len - 1 because we can put the two pawns in the first two cells of this path.But in some cases we could get the answer 2·len if there are two non-intersecting by vertices (not #) paths of length len. They are non-intersecting because if they intersect in some cell then they will be equal to the end (and the statement says that such moves are invalid).So, we should check if the graph contains two non-intersecting by vertices (not #) paths of length len. It could be done in any way. For example, using dfs searches.382E - Ksenia and CombinatoricsIn this problem you should count trees with some properties. It can be done using dynamic programming. The main idea is that the maximum mathing in tree can be found using simple dynamic dp[v][used] (v -- vertex, used — was this vertex used in matching). So you should to count the trees tou should include in state of the dynamic values dp[v][0]$ and dp[v][1]. In other words, you should use dynamic programming z[n][dp0][dp1] — number of rooted trees with n vertices and values of dynamic in root dp[root][0] = dp0 and dp[root][1] = dp1. But in simple implementation this solution will get TL. There are two ways to get AC. The first is to opltimize code and make precalc. The second is to optimize asymptotics.The author's solution uses the second way. To optimize solution you should mark that values dp0 and dp1 differs at most by one. That is dp0 = dp1, or dp0 = dp1 + 1. So the first dynamic becomes r[n][dp0][add]. Another optimization is there are not so many triples (n, dp0, add) with non-negative values (about 250), so you can you use lazy programming to calculate this dynamic.Comments that describe other solutions: http://codeforces.com/blog/entry/10423#comment-158177http://codeforces.com/blog/entry/10423#comment-158182",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 382\\s*B"
          },
          "content_length": 3720
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 1",
          "code": "next[b][i] = after 2^i step what will be b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 2",
          "code": "add[b][i] = after 2^i step how many time a will decrease",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 3",
          "code": "O(log MAX_ANSWER)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 4",
          "code": "O(log MAX_ANSWER)^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 5",
          "code": "let f(x) = after x steps what will be new a value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 6",
          "code": "let g(x) = after x steps what will be new c value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 7",
          "code": "let df(x) = f(x) - f(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 8",
          "code": "let dg(x) = g(x) - g(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 9",
          "code": "t[i].reserve(2000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 10",
          "code": "char t[2000][2000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "(a[0] + a[1]) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "n( Required number of terms) = (l-a)/d+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "and Sum of all terms = [n*(l+a)]/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read a\n    int a = inf.readInt(1, 2000000000, \"a\"); // 1 ≤ a ≤ 2·10^9\n    inf.readSpace();\n    // Read b\n    int b = inf.readInt(0, 999, \"b\"); // 0 ≤ b ≤ 999 (we'll check b < w later)\n    inf.readSpace();\n    // Read w\n    int w = inf.readInt(1, 1000, \"w\"); // 1 ≤ w ≤ 1000\n    inf.readSpace();\n    // Read x\n    int x = inf.readInt(1, 999, \"x\"); // 1 ≤ x ≤ 999 (we'll check x < w later)\n    inf.readSpace();\n    // Read c\n    int c = inf.readInt(1, 2000000000, \"c\"); // 1 ≤ c ≤ 2·10^9\n    inf.readEoln();\n    \n    // Now check the constraints\n    ensuref(b < w, \"b must satisfy 0 ≤ b < w, but b=%d, w=%d\", b, w);\n    ensuref(x < w, \"x must satisfy 0 < x < w, but x=%d, w=%d\", x, w);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read a\n    int a = inf.readInt(1, 2000000000, \"a\"); // 1 ≤ a ≤ 2·10^9\n    inf.readSpace();\n    // Read b\n    int b = inf.readInt(0, 999, \"b\"); // 0 ≤ b ≤ 999 (we'll check b < w later)\n    inf.readSpace();\n    // Read w\n    int w = inf.readInt(1, 1000, \"w\"); // 1 ≤ w ≤ 1000\n    inf.readSpace();\n    // Read x\n    int x = inf.readInt(1, 999, \"x\"); // 1 ≤ x ≤ 999 (we'll check x < w later)\n    inf.readSpace();\n    // Read c\n    int c = inf.readInt(1, 2000000000, \"c\"); // 1 ≤ c ≤ 2·10^9\n    inf.readEoln();\n    \n    // Now check the constraints\n    ensuref(b < w, \"b must satisfy 0 ≤ b < w, but b=%d, w=%d\", b, w);\n    ensuref(x < w, \"x must satisfy 0 < x < w, but x=%d, w=%d\", x, w);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read a\n    int a = inf.readInt(1, 2000000000, \"a\"); // 1 ≤ a ≤ 2·10^9\n    inf.readSpace();\n    // Read b\n    int b = inf.readInt(0, 999, \"b\"); // 0 ≤ b ≤ 999 (we'll check b < w later)\n    inf.readSpace();\n    // Read w\n    int w = inf.readInt(1, 1000, \"w\"); // 1 ≤ w ≤ 1000\n    inf.readSpace();\n    // Read x\n    int x = inf.readInt(1, 999, \"x\"); // 1 ≤ x ≤ 999 (we'll check x < w later)\n    inf.readSpace();\n    // Read c\n    int c = inf.readInt(1, 2000000000, \"c\"); // 1 ≤ c ≤ 2·10^9\n    inf.readEoln();\n    \n    // Now check the constraints\n    ensuref(b < w, \"b must satisfy 0 ≤ b < w, but b=%d, w=%d\", b, w);\n    ensuref(x < w, \"x must satisfy 0 < x < w, but x=%d, w=%d\", x, w);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    // Read optional parameters\n    long long a_val = opt<long long>(\"a_val\", -1);\n    int b_val = opt<int>(\"b_val\", -1);\n    int w_val = opt<int>(\"w_val\", -1);\n    int x_val = opt<int>(\"x_val\", -1);\n    long long c_val = opt<long long>(\"c_val\", -1);\n\n    // Declare variables\n    long long a, c;\n    int b, w, x;\n\n    if (test_type == \"minimal\") {\n        a = (a_val != -1) ? a_val : 1;\n        w = (w_val != -1) ? w_val : 2;\n        x = (x_val != -1) ? x_val : 1;\n        b = (b_val != -1) ? b_val : 0;\n        c = (c_val != -1) ? c_val : 1;\n    } else if (test_type == \"maximal\") {\n        w = (w_val != -1) ? w_val : 1000;\n        a = (a_val != -1) ? a_val : 2000000000;\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(0, w - 1);\n        c = (c_val != -1) ? c_val : 2000000000;\n    } else if (test_type == \"zero_time\") {\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : rnd.next(1LL, a);\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(0, w - 1);\n    } else if (test_type == \"arthur_constant_a\") {\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(x, w - 1);\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : a + rnd.next(1, 1000000); // c > a\n    } else if (test_type == \"arthur_dec_a_every_time\") {\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(0, x - 1);\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : a + rnd.next(1, 1000000); // c > a\n    } else if (test_type == \"arthur_dec_a_once\") {\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : x;\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : a + rnd.next(1, 1000000);\n    } else { // random\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        b = (b_val != -1) ? b_val : rnd.next(0, w - 1);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        c = (c_val != -1) ? c_val : rnd.next(1LL, 2000000000LL);\n    }\n\n    // Ensure variables are within constraints\n    assert(1 <= a && a <= 2000000000LL);\n    assert(1 <= w && w <= 1000);\n    assert(0 <= b && b < w);\n    assert(1 <= x && x < w);\n    assert(1 <= c && c <= 2000000000LL);\n\n    // Output the test case\n    printf(\"%lld %d %d %d %lld\\n\", a, b, w, x, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    // Read optional parameters\n    long long a_val = opt<long long>(\"a_val\", -1);\n    int b_val = opt<int>(\"b_val\", -1);\n    int w_val = opt<int>(\"w_val\", -1);\n    int x_val = opt<int>(\"x_val\", -1);\n    long long c_val = opt<long long>(\"c_val\", -1);\n\n    // Declare variables\n    long long a, c;\n    int b, w, x;\n\n    if (test_type == \"minimal\") {\n        a = (a_val != -1) ? a_val : 1;\n        w = (w_val != -1) ? w_val : 2;\n        x = (x_val != -1) ? x_val : 1;\n        b = (b_val != -1) ? b_val : 0;\n        c = (c_val != -1) ? c_val : 1;\n    } else if (test_type == \"maximal\") {\n        w = (w_val != -1) ? w_val : 1000;\n        a = (a_val != -1) ? a_val : 2000000000;\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(0, w - 1);\n        c = (c_val != -1) ? c_val : 2000000000;\n    } else if (test_type == \"zero_time\") {\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : rnd.next(1LL, a);\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(0, w - 1);\n    } else if (test_type == \"arthur_constant_a\") {\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(x, w - 1);\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : a + rnd.next(1, 1000000); // c > a\n    } else if (test_type == \"arthur_dec_a_every_time\") {\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : rnd.next(0, x - 1);\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : a + rnd.next(1, 1000000); // c > a\n    } else if (test_type == \"arthur_dec_a_once\") {\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        b = (b_val != -1) ? b_val : x;\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        c = (c_val != -1) ? c_val : a + rnd.next(1, 1000000);\n    } else { // random\n        a = (a_val != -1) ? a_val : rnd.next(1LL, 2000000000LL);\n        w = (w_val != -1) ? w_val : rnd.next(2, 1000);\n        b = (b_val != -1) ? b_val : rnd.next(0, w - 1);\n        x = (x_val != -1) ? x_val : rnd.next(1, w - 1);\n        c = (c_val != -1) ? c_val : rnd.next(1LL, 2000000000LL);\n    }\n\n    // Ensure variables are within constraints\n    assert(1 <= a && a <= 2000000000LL);\n    assert(1 <= w && w <= 1000);\n    assert(0 <= b && b < w);\n    assert(1 <= x && x < w);\n    assert(1 <= c && c <= 2000000000LL);\n\n    // Output the test case\n    printf(\"%lld %d %d %d %lld\\n\", a, b, w, x, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -test_type minimal\n./gen -test_type maximal\n./gen -test_type zero_time\n./gen -test_type zero_time -a_val 1 -c_val 1\n./gen -test_type zero_time -a_val 2000000000 -c_val 1\n./gen -test_type arthur_constant_a\n./gen -test_type arthur_constant_a -w_val 1000 -x_val 1\n./gen -test_type arthur_constant_a -w_val 1000 -x_val 999\n./gen -test_type arthur_constant_a -a_val 10000 -c_val 10005\n./gen -test_type arthur_dec_a_every_time\n./gen -test_type arthur_dec_a_every_time -a_val 1000000 -c_val 1000001\n./gen -test_type arthur_dec_a_once\n./gen -test_type arthur_dec_a_once -w_val 1000 -x_val 500\n./gen -test_type arthur_dec_a_once -w_val 2 -x_val 1\n./gen -test_type random\n./gen -test_type random\n./gen -test_type random\n./gen -test_type random\n./gen -test_type arthur_constant_a -c_val 1\n./gen -test_type arthur_dec_a_every_time -c_val 1\n./gen -test_type arthur_dec_a_every_time -a_val 2000000000 -c_val 1999999999\n./gen -test_type arthur_constant_a -a_val 1 -c_val 2\n./gen -test_type arthur_dec_a_every_time -a_val 1 -c_val 2\n./gen -test_type zero_time\n./gen -test_type zero_time -a_val 1000000000 -c_val 1000000000\n./gen -test_type zero_time -a_val 2000000000 -c_val 2000000000\n./gen -test_type arthur_dec_a_every_time -a_val 1 -c_val 2000000000\n./gen -test_type arthur_constant_a -a_val 2000000000 -c_val 2000000000\n./gen -test_type maximal -w_val 2\n./gen -test_type maximal -w_val 2 -x_val 1\n./gen -test_type maximal -w_val 1000 -x_val 1\n./gen -test_type maximal -w_val 1000 -x_val 999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:40.325327",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "382/C",
      "title": "C. Arithmetic Progression",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.",
      "output_spec": "OutputIf Arthur can write infinitely many distinct integers on the card, print on a single line -1.Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).",
      "sample_tests": "ExamplesInputCopy34 1 7OutputCopy2-2 10InputCopy110OutputCopy-1InputCopy41 3 5 9OutputCopy17InputCopy44 3 4 5OutputCopy0InputCopy22 4OutputCopy30 3 6",
      "description": "C. Arithmetic Progression\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.\n\nOutputIf Arthur can write infinitely many distinct integers on the card, print on a single line -1.Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).\n\nInputCopy34 1 7OutputCopy2-2 10InputCopy110OutputCopy-1InputCopy41 3 5 9OutputCopy17InputCopy44 3 4 5OutputCopy0InputCopy22 4OutputCopy30 3 6\n\nInputCopy34 1 7\n\nOutputCopy2-2 10\n\nInputCopy110\n\nOutputCopy-1\n\nInputCopy41 3 5 9\n\nOutputCopy17\n\nInputCopy44 3 4 5\n\nOutputCopy0\n\nInputCopy22 4\n\nOutputCopy30 3 6",
      "solutions": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces",
          "content": "Good day everybody)Welcome to regular Codeforces round #224 for Div.2 participants, first Div2 Only in new 2014 year:). As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). I can't already remember exactly in how many rounds I participate as author, co-author of just active assistant) Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be dynamic, but the problems will be in supposed order of increasing complexity. The first dynamic round in this year)We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, we hope you enjoy it) the editorial is already here)Congratulations to winners:1) tankmagiciangirl2) NagaiNatsuyasumi3) lijian32564) TankKiller5) dashabi",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10423",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 934
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces",
          "content": "382A - Ksenia and Pan ScalesThis problem is just a technic problem. So, you should take weights one by one and place the current one into the side of the scales that contains lower number of weights. At the end you should output answer in the correct format.382B - Number BustersIn the problem you should understand, what is the structure of Artur's operation. You can see that this operation is near operation (b + x) % w (To see that just apply b = w - b - 1). There is nothing hard to get the formula of changing a during the operation. So, if you have k operations, you can see, that b = (b + k·x) % w, a = a - (b + k·x) / w, c = c - k. When you've got all the formulas, you can solve the problem using binary search.382C - Arithmetic ProgressionThis problem is about considering cases:1) If n = 1, the answer is -1. Because of any two numbers is arithmetical progression.2) If array is constant, the answer if that constant.3) If you have arithmetical progression initially, you can compute its difference d. In this case you should just to output minVal - d, and maxVal + d, where minVal is minimum value among a[i], and maxVal is maximum value among a[i]. But in case of n = 2, also you should check (a[0] + a[1]) / 2. If this number is integer, it is needed to be output.4) Else, the answer has at most one integer. You find this integer you should sort the sequence, and find the place where the number is missed. If such a place exists you should add the corresponding number to the sequence, else, the answer is 0.5) In all other cases the answer is 0.382D - Ksenia and PawnsIn this problem from every cell except # there is one next cell. That's why this graph is almost functional graph. If this graph contains a cycle, then answer is -1 because the length of the cycle is at least two.In the other case, there are no cycles in the graph. Let's find the longest path in it, denote is as len. Then is answer is at least 2·len - 1 because we can put the two pawns in the first two cells of this path.But in some cases we could get the answer 2·len if there are two non-intersecting by vertices (not #) paths of length len. They are non-intersecting because if they intersect in some cell then they will be equal to the end (and the statement says that such moves are invalid).So, we should check if the graph contains two non-intersecting by vertices (not #) paths of length len. It could be done in any way. For example, using dfs searches.382E - Ksenia and CombinatoricsIn this problem you should count trees with some properties. It can be done using dynamic programming. The main idea is that the maximum mathing in tree can be found using simple dynamic dp[v][used] (v -- vertex, used — was this vertex used in matching). So you should to count the trees tou should include in state of the dynamic values dp[v][0]$ and dp[v][1]. In other words, you should use dynamic programming z[n][dp0][dp1] — number of rooted trees with n vertices and values of dynamic in root dp[root][0] = dp0 and dp[root][1] = dp1. But in simple implementation this solution will get TL. There are two ways to get AC. The first is to opltimize code and make precalc. The second is to optimize asymptotics.The author's solution uses the second way. To optimize solution you should mark that values dp0 and dp1 differs at most by one. That is dp0 = dp1, or dp0 = dp1 + 1. So the first dynamic becomes r[n][dp0][add]. Another optimization is there are not so many triples (n, dp0, add) with non-negative values (about 250), so you can you use lazy programming to calculate this dynamic.Comments that describe other solutions: http://codeforces.com/blog/entry/10423#comment-158177http://codeforces.com/blog/entry/10423#comment-158182",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 382\\s*C"
          },
          "content_length": 3720
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 1",
          "code": "next[b][i] = after 2^i step what will be b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 2",
          "code": "add[b][i] = after 2^i step how many time a will decrease",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 3",
          "code": "O(log MAX_ANSWER)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 4",
          "code": "O(log MAX_ANSWER)^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 5",
          "code": "let f(x) = after x steps what will be new a value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 6",
          "code": "let g(x) = after x steps what will be new c value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 7",
          "code": "let df(x) = f(x) - f(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 8",
          "code": "let dg(x) = g(x) - g(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 9",
          "code": "t[i].reserve(2000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 10",
          "code": "char t[2000][2000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "(a[0] + a[1]) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "n( Required number of terms) = (l-a)/d+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "and Sum of all terms = [n*(l+a)]/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readEoln(); // End of line after n\n    vector<int> a = inf.readInts(n, 1, 100000000); // 1 ≤ a_i ≤ 1e8\n    inf.readEoln(); // End of line after reading a_i\n    inf.readEof(); // Ensure no extra input\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readEoln(); // End of line after n\n    vector<int> a = inf.readInts(n, 1, 100000000); // 1 ≤ a_i ≤ 1e8\n    inf.readEoln(); // End of line after reading a_i\n    inf.readEof(); // Ensure no extra input\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readEoln(); // End of line after n\n    vector<int> a = inf.readInts(n, 1, 100000000); // 1 ≤ a_i ≤ 1e8\n    inf.readEoln(); // End of line after reading a_i\n    inf.readEof(); // Ensure no extra input\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_VAL = 1e8;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n random integers between 1 and MAX_VAL\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    } else if (type == \"arithmetic_progression\") {\n        // Generate an arithmetic progression\n        int start = rnd.next(1, MAX_VAL);\n        int d = rnd.next(-MAX_VAL, MAX_VAL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + d * i;\n        }\n    } else if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, MAX_VAL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"zero_solutions\") {\n        // Generate a sequence where there are zero possible numbers to add\n        // Create conflicting differences\n        if (n < 3) {\n            // Can't create conflicting differences with less than 3 elements\n            n = 3;\n        }\n        // First three numbers with conflicting differences\n        a[0] = rnd.next(1, MAX_VAL);\n        int diff1 = rnd.next(1, MAX_VAL);\n        int diff2 = diff1 + rnd.next(1, MAX_VAL);\n        a[1] = a[0] + diff1;\n        a[2] = a[1] + diff2;\n        for (int i = 3; i < n; ++i) {\n            // Add random numbers to further confuse any pattern\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    } else if (type == \"infinite_solutions\") {\n        // Set n = 1\n        n = 1;\n        a.resize(n);\n        a[0] = rnd.next(1, MAX_VAL);\n    } else if (type == \"one_solution\") {\n        // Generate a sequence where there is exactly one number that can be added\n        int start = rnd.next(1, MAX_VAL / 2);\n        int d = rnd.next(1, MAX_VAL / (n + 2));\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = start + i * d;\n        }\n        // Skip one term to create a missing element\n        a[n - 1] = start + (n) * d;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"multiple_solutions\") {\n        // Generate a sequence where there are multiple numbers that can be added\n        if (n < 2) {\n            n = 2;\n        }\n        a.resize(n);\n        int val1 = rnd.next(1, MAX_VAL);\n        int delta = rnd.next(1, MAX_VAL / 2);\n        a[0] = val1;\n        a[1] = val1 + delta;\n        for (int i = 2; i < n; ++i) {\n            // Randomly choose between extending the progression or adding noise\n            if (rnd.next(0, 1)) {\n                a[i] = a[i - 1] + delta;\n            } else {\n                a[i] = rnd.next(1, MAX_VAL);\n            }\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"big_numbers\") {\n        // Generate random big numbers close to MAX_VAL\n        for (int i = 0; i < n; ++i) {\n            a[i] = MAX_VAL - rnd.next(0, 1000);\n        }\n    } else if (type == \"small_numbers\") {\n        // Generate random small numbers close to 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Unknown type, default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_VAL = 1e8;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n random integers between 1 and MAX_VAL\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    } else if (type == \"arithmetic_progression\") {\n        // Generate an arithmetic progression\n        int start = rnd.next(1, MAX_VAL);\n        int d = rnd.next(-MAX_VAL, MAX_VAL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + d * i;\n        }\n    } else if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, MAX_VAL);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"zero_solutions\") {\n        // Generate a sequence where there are zero possible numbers to add\n        // Create conflicting differences\n        if (n < 3) {\n            // Can't create conflicting differences with less than 3 elements\n            n = 3;\n        }\n        // First three numbers with conflicting differences\n        a[0] = rnd.next(1, MAX_VAL);\n        int diff1 = rnd.next(1, MAX_VAL);\n        int diff2 = diff1 + rnd.next(1, MAX_VAL);\n        a[1] = a[0] + diff1;\n        a[2] = a[1] + diff2;\n        for (int i = 3; i < n; ++i) {\n            // Add random numbers to further confuse any pattern\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    } else if (type == \"infinite_solutions\") {\n        // Set n = 1\n        n = 1;\n        a.resize(n);\n        a[0] = rnd.next(1, MAX_VAL);\n    } else if (type == \"one_solution\") {\n        // Generate a sequence where there is exactly one number that can be added\n        int start = rnd.next(1, MAX_VAL / 2);\n        int d = rnd.next(1, MAX_VAL / (n + 2));\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = start + i * d;\n        }\n        // Skip one term to create a missing element\n        a[n - 1] = start + (n) * d;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"multiple_solutions\") {\n        // Generate a sequence where there are multiple numbers that can be added\n        if (n < 2) {\n            n = 2;\n        }\n        a.resize(n);\n        int val1 = rnd.next(1, MAX_VAL);\n        int delta = rnd.next(1, MAX_VAL / 2);\n        a[0] = val1;\n        a[1] = val1 + delta;\n        for (int i = 2; i < n; ++i) {\n            // Randomly choose between extending the progression or adding noise\n            if (rnd.next(0, 1)) {\n                a[i] = a[i - 1] + delta;\n            } else {\n                a[i] = rnd.next(1, MAX_VAL);\n            }\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"big_numbers\") {\n        // Generate random big numbers close to MAX_VAL\n        for (int i = 0; i < n; ++i) {\n            a[i] = MAX_VAL - rnd.next(0, 1000);\n        }\n    } else if (type == \"small_numbers\") {\n        // Generate random small numbers close to 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Unknown type, default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random sequence\n./gen -n 1 -type infinite_solutions\n./gen -n 1 -type random\n\n# n = 2, multiple solutions\n./gen -n 2 -type multiple_solutions\n./gen -n 2 -type zero_solutions\n\n# Small n, one solution\n./gen -n 3 -type one_solution\n./gen -n 5 -type one_solution\n\n# Small n, zero solutions\n./gen -n 4 -type zero_solutions\n\n# Small n, random arithmetic progression\n./gen -n 10 -type arithmetic_progression\n./gen -n 10 -type constant\n\n# Medium n, random sequences\n./gen -n 100 -type random\n./gen -n 100 -type small_numbers\n./gen -n 100 -type big_numbers\n\n# Medium n, arithmetic progression\n./gen -n 1000 -type arithmetic_progression\n./gen -n 1000 -type multiple_solutions\n\n# Medium n, zero solutions\n./gen -n 1000 -type zero_solutions\n\n# Large n, random sequences\n./gen -n 10000 -type random\n./gen -n 10000 -type small_numbers\n./gen -n 10000 -type big_numbers\n\n# Large n, arithmetic progression\n./gen -n 50000 -type arithmetic_progression\n./gen -n 50000 -type constant\n\n# Large n, multiple solutions\n./gen -n 100000 -type multiple_solutions\n\n# Large n, zero solutions\n./gen -n 100000 -type zero_solutions\n\n# Edge cases\n./gen -n 99999 -type one_solution\n./gen -n 100000 -type big_numbers\n\n# Maximum n, random sequence\n./gen -n 100000 -type random\n\n# Maximum n, small numbers\n./gen -n 100000 -type small_numbers\n\n# Maximum n, infinite solutions (n will be set to 1)\n./gen -n 100000 -type infinite_solutions\n\n# Additional tests\n./gen -n 2 -type constant\n./gen -n 2 -type arithmetic_progression\n./gen -n 2 -type one_solution\n\n./gen -n 3 -type multiple_solutions\n./gen -n 4 -type zero_solutions\n\n./gen -n 1000 -type one_solution\n./gen -n 1000 -type zero_solutions\n\n./gen -n 50000 -type small_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:42.500613",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "382/D",
      "title": "D. Ксюша и пешки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 2000) — размеры доски. В каждой из следующих n строк записано по m символов — описание доски. Каждый символ — это один из символов: «<», «>», «^», «v», «#».Гарантируется, что граничные клетки доски — это заблокированные клетки (с символом «#»).",
      "output_spec": "Выходные данныеЕсли Ксюша может заработать бесконечно большое количество очков, выведите -1. Иначе выведите максимальное количество очков, которое она может заработать.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1#Выходные данныеСкопировать0Входные данныеСкопировать3 4#####>^#####Выходные данныеСкопировать3Входные данныеСкопировать3 4#####><#####Выходные данныеСкопировать-1Входные данныеСкопировать7 5#######v####v#########^####^#######Выходные данныеСкопировать4Входные данныеСкопировать7 5#######v####v####<####^####^#######Выходные данныеСкопировать5",
      "description": "D. Ксюша и пешки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 2000) — размеры доски. В каждой из следующих n строк записано по m символов — описание доски. Каждый символ — это один из символов: «<», «>», «^», «v», «#».Гарантируется, что граничные клетки доски — это заблокированные клетки (с символом «#»).\n\nВходные данные\n\nВыходные данныеЕсли Ксюша может заработать бесконечно большое количество очков, выведите -1. Иначе выведите максимальное количество очков, которое она может заработать.\n\nВыходные данные\n\nВходные данныеСкопировать1 1#Выходные данныеСкопировать0Входные данныеСкопировать3 4#####>^#####Выходные данныеСкопировать3Входные данныеСкопировать3 4#####><#####Выходные данныеСкопировать-1Входные данныеСкопировать7 5#######v####v#########^####^#######Выходные данныеСкопировать4Входные данныеСкопировать7 5#######v####v####<####^####^#######Выходные данныеСкопировать5\n\nВходные данныеСкопировать1 1#\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4#####>^#####\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4#####><#####\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 5#######v####v#########^####^#######\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 5#######v####v####<####^####^#######\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток)Приглашаем вас на очередной раунд Codeforces #224 для участников Div. 2, первый Div2 Only в новом 2014 году:) Как обычно, участники Div. 1 могут поучаствовать в этом соревновании вне конкурса.Задачи для вас готовили авторы Павел Холкин (HolkinPV) и Геральд Агапов (Gerald). Уже давно сбился со счета в скольких раундах я принимал участие в качестве автора, соавтора или просто активного помощника) Традиционно мы говорим слова благодарности Михаилу Мирзаянову (MikeMirzayanov) за отличные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод условий задач. UPD: Распределение баллов по задачам будет динамическим, однако задачи будут расположены в предполагаемом порядке возрастания сложности. Первый динамический раунд в этом году)Желаем всем участникам удачи, высокого рейтинга и удовольствия от решения задач)UPD2: соревнование завершилось, надеемся оно вам понравилось) разбор задач уже здесь)Поздравляем победителей:1) tankmagiciangirl2) NagaiNatsuyasumi3) lijian32564) TankKiller5) dashabi",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10423",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1042
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Разбор Задач - Codeforces",
          "content": "382A - Ксюша и чашечные весыВ этой задаче нужно было совсем немного техники программирования. Можно было брать свободные гирьки по одной и добавлять на ту чашу весов, где сейчас меньше гирек. После этого требовалось просто вывести ответ в правильном формате.382B - Разрушители чиселВ этой задаче нужно было понять, что из себя представляет хитрая операция Артура. На самом деле, если перед выполнением всех действий сделать присвоение b = w - b - 1 (то есть как бы перевернуть ситуацию), то операция аналогична присвоению b = (b + x) % w. Причем если происходит переполнение через w, то дополнительно происходит присвоение a = a - 1.Таким образом, если выполнить k таких операций, то переменные изменятся так: b = (b + k·x) % w, a = a - (b + k·x) / w, c = c - k. Зная это, легко решить задачу бинарным поиском по ответу.382C - Арифметическая прогрессияВ этой задаче нужно было разобрать несколько несложных случаев:1) если n = 1, то ответ: -1, потому что любые два числа будут являться арифметической прогрессией;2) если массив состоит целиком из одного числа, то ответ: эта единственная константа;3) если вам уже дана арифметическая прогрессия, то ответ это 2 числа: minVal - d, maxVal + d, где minVal — минимум, maxVal — максимум, d — разность прогрессии.Однако, если n = 2, то в этом случае ответ бывает 3 числа (как, например, в последнем тестовом примере, когда разность (a[1] - a[0]) четна); 4) иначе, возможно, в прогрессии пропущено ровно одно число и его можно аккуратно найти двигаясь по исходному массиву (предварительно его удобнее отcортировать). Разность прогрессии можно вычислить, как d = min(a[i + 1] - a[i]) (если n > 2);5) во всех иных случаях ответ 0;382D - Ксюша и пешкиВ этой задаче из всех клеток кроме # один переход. Поэтому граф на клетках является почти фунцкиональным графом. Если в этом графе есть цикл, то очевидно ответ -1, потому что этот цикл имеет длину не менее 2 и мы можем разместить на нем две наши пешки.Иначе в графе нет циклов. Найдем в нем самый длинный путь, пусть его длина len. Тогда если мы расположим две наши пешки в первую и вторую клетку пути, то ответ на задачу уже будет 2·len - 1.Однако, иногда можно получить ответ 2·len, если в этом графе есть два непересекающихся по вершинам пути (вершины, не являющиеся #). Непересекающиеся они будут потому, что если вдруг они пересеклись в какой-то клетке, то дальше они будут совпадать (а по условию задачи такие ходы совершать нельзя).Остается проверить есть ли в этом графе два непересекающихся по вершинам (не #) пути длины len. Это можно сделать как угодно. Например, посчитать для каждого истока v величину d[v] длины пути из него. После серией поисков в глубину из всех истоков с максимальным d[v] = len проверить найдутся для два непересекающихся пути. (если очередной поиск в глубину не находит поюзанной вершины, значит этот путь новый).382E - Ксения и комбинаторикаЧтобы решить задачу, нужно было посчитать количество деревьев с заданными свойствами. Сделать это можно с помощью динамического программирования. Основная идея динамического программирования в том, что размер максимального паросочетания в дереве ищется простой линейной динамикой dp[v][used] (v —- вершина, used —- уже использована она в паросочетании или нет), поэтому для подсчета количества деревьев достаточно включить в состояние динамики два значения dp[v][0] и dp[v][1].Другими словами, нужно написать динамику z[n][dp0][dp1], значение которой — это количество подвешенных деревьев, состоящих из n вершин, в корне которых динамика dp[root][0] = dp0, а dp[root][1] = dp1. Если просто написать такую динамику она будет получить TL по времени. Из этого положения можно выйти двумя способами. Либо посчитать все значения динамики прекалком, немного оптимизировав код, либо ассимптотически оптимизировать динамику.Авторское решение использует второй подход. Для того, чтобы оптимизировать динамику достаточно заметить, что значение dp0 отличается от значения dp1 не больше чем на 1. То есть либо dp0 = dp1, либо dp0 = dp1 + 1. Тогда динамика превращается в динамику r[n][dp0][add], которая работает сильно быстрее. Другая важная оптимизация состоит в том, что возможных троек (n, dp0, add), для которых значение r[n][dp0][add] ненулевое очень мало (около 250). Это значит, что достижимых состояний динамики не много, поэтому если написать ее \"лениво\" с отсечениями, программа будет работать в несколько раз быстрее.Комментарии, которые описывают решения (некоторые отличаются): http://codeforces.com/blog/entry/10423#comment-158177http://codeforces.com/blog/entry/10423#comment-158182",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 382\\s*D"
          },
          "content_length": 4555
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 1",
          "code": "next[b][i] = after 2^i step what will be b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 2",
          "code": "add[b][i] = after 2^i step how many time a will decrease",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 3",
          "code": "O(log MAX_ANSWER)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 4",
          "code": "O(log MAX_ANSWER)^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 5",
          "code": "let f(x) = after x steps what will be new a value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 6",
          "code": "let g(x) = after x steps what will be new c value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 7",
          "code": "let df(x) = f(x) - f(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 8",
          "code": "let dg(x) = g(x) - g(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 9",
          "code": "t[i].reserve(2000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 10",
          "code": "char t[2000][2000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 11",
          "code": "Превышено ограничение памяти на тесте 35,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 12",
          "code": "Превышено ограничение памяти на тесте 35,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "(a[0] + a[1]) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "n( Required number of terms) = (l-a)/d+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "and Sum of all terms = [n*(l+a)]/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string row = inf.readLine();\n        ensuref((int)row.size() == m, \"Row %d should have exactly %d characters, but has %d\", i + 1, m, (int)row.size());\n        for (int j = 0; j < m; ++j) {\n            char c = row[j];\n            ensuref(c == '<' || c == '>' || c == '^' || c == 'v' || c == '#',\n                    \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n        }\n        if (i == 0 || i == n - 1) {\n            // First or last row, all characters should be '#'\n            for (int j = 0; j < m; ++j) {\n                ensuref(row[j] == '#', \"Border row %d should contain only '#', but found '%c' at column %d\", i + 1, row[j], j + 1);\n            }\n        } else {\n            // First and last character should be '#'\n            ensuref(row[0] == '#', \"Row %d first character should be '#'\", i + 1);\n            ensuref(row[m - 1] == '#', \"Row %d last character should be '#'\", i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string row = inf.readLine();\n        ensuref((int)row.size() == m, \"Row %d should have exactly %d characters, but has %d\", i + 1, m, (int)row.size());\n        for (int j = 0; j < m; ++j) {\n            char c = row[j];\n            ensuref(c == '<' || c == '>' || c == '^' || c == 'v' || c == '#',\n                    \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n        }\n        if (i == 0 || i == n - 1) {\n            // First or last row, all characters should be '#'\n            for (int j = 0; j < m; ++j) {\n                ensuref(row[j] == '#', \"Border row %d should contain only '#', but found '%c' at column %d\", i + 1, row[j], j + 1);\n            }\n        } else {\n            // First and last character should be '#'\n            ensuref(row[0] == '#', \"Row %d first character should be '#'\", i + 1);\n            ensuref(row[m - 1] == '#', \"Row %d last character should be '#'\", i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string row = inf.readLine();\n        ensuref((int)row.size() == m, \"Row %d should have exactly %d characters, but has %d\", i + 1, m, (int)row.size());\n        for (int j = 0; j < m; ++j) {\n            char c = row[j];\n            ensuref(c == '<' || c == '>' || c == '^' || c == 'v' || c == '#',\n                    \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n        }\n        if (i == 0 || i == n - 1) {\n            // First or last row, all characters should be '#'\n            for (int j = 0; j < m; ++j) {\n                ensuref(row[j] == '#', \"Border row %d should contain only '#', but found '%c' at column %d\", i + 1, row[j], j + 1);\n            }\n        } else {\n            // First and last character should be '#'\n            ensuref(row[0] == '#', \"Row %d first character should be '#'\", i + 1);\n            ensuref(row[m - 1] == '#', \"Row %d last character should be '#'\", i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst char directions[] = {'<', '>', '^', 'v'};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> board(n, string(m, '#'));\n\n    if (type == \"random\") {\n        // Generate random board\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m - 1; j++) {\n                int rnd_val = rnd.next(5);\n                if (rnd_val < 4) {\n                    board[i][j] = directions[rnd_val];\n                } else {\n                    board[i][j] = '#';\n                }\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Generate a board with a cycle\n        // For simplicity, create a simple cycle in the center\n        for (int i = 1; i < n -1; i++) {\n            for (int j = 1; j < m -1; j++) {\n                board[i][j] = directions[rnd.next(0,3)];\n            }\n        }\n        if (n >= 3 && m >= 3) {\n            int ci = n / 2;\n            int cj = m / 2;\n            // Create a simple 4-cell cycle\n            board[ci][cj] = 'v';\n            board[ci+1][cj] = '<';\n            board[ci+1][cj-1] = '^';\n            board[ci][cj-1] = '>';\n        }\n    } else if (type == \"path\") {\n        // Generate a path without cycles\n        int i = 1, j = 1;\n        while (i < n - 1) {\n            board[i][j] = 'v';\n            i++;\n        }\n        if (j < m - 2) {\n            board[i][j] = '>';\n            j++;\n            while (j < m - 1) {\n                board[i][j] = '>';\n                j++;\n            }\n        }\n    } else if (type == \"blocked\") {\n        // All inner cells are blocked\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m - 1; j++) {\n                board[i][j] = '#';\n            }\n        }\n    } else if (type == \"spiral\") {\n        // Create a spiral path\n        int left = 1, right = m - 2, top = 1, bottom = n - 2;\n        char dir = '>';\n        while (left <= right && top <= bottom) {\n            for (int i = left; i <= right; i++) board[top][i] = dir;\n            top++;\n            dir = 'v';\n            for (int i = top; i <= bottom; i++) board[i][right] = dir;\n            right--;\n            dir = '<';\n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) board[bottom][i] = dir;\n                bottom--;\n            }\n            dir = '^';\n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) board[i][left] = dir;\n                left++;\n            }\n            dir = '>';\n        }\n    } else {\n        // default random\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m -1; j++) {\n                int rnd_val = rnd.next(5);\n                if (rnd_val < 4) {\n                    board[i][j] = directions[rnd_val];\n                } else {\n                    board[i][j] = '#';\n                }\n            }\n        }\n    }\n\n    // Output the board\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", board[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst char directions[] = {'<', '>', '^', 'v'};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> board(n, string(m, '#'));\n\n    if (type == \"random\") {\n        // Generate random board\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m - 1; j++) {\n                int rnd_val = rnd.next(5);\n                if (rnd_val < 4) {\n                    board[i][j] = directions[rnd_val];\n                } else {\n                    board[i][j] = '#';\n                }\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Generate a board with a cycle\n        // For simplicity, create a simple cycle in the center\n        for (int i = 1; i < n -1; i++) {\n            for (int j = 1; j < m -1; j++) {\n                board[i][j] = directions[rnd.next(0,3)];\n            }\n        }\n        if (n >= 3 && m >= 3) {\n            int ci = n / 2;\n            int cj = m / 2;\n            // Create a simple 4-cell cycle\n            board[ci][cj] = 'v';\n            board[ci+1][cj] = '<';\n            board[ci+1][cj-1] = '^';\n            board[ci][cj-1] = '>';\n        }\n    } else if (type == \"path\") {\n        // Generate a path without cycles\n        int i = 1, j = 1;\n        while (i < n - 1) {\n            board[i][j] = 'v';\n            i++;\n        }\n        if (j < m - 2) {\n            board[i][j] = '>';\n            j++;\n            while (j < m - 1) {\n                board[i][j] = '>';\n                j++;\n            }\n        }\n    } else if (type == \"blocked\") {\n        // All inner cells are blocked\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m - 1; j++) {\n                board[i][j] = '#';\n            }\n        }\n    } else if (type == \"spiral\") {\n        // Create a spiral path\n        int left = 1, right = m - 2, top = 1, bottom = n - 2;\n        char dir = '>';\n        while (left <= right && top <= bottom) {\n            for (int i = left; i <= right; i++) board[top][i] = dir;\n            top++;\n            dir = 'v';\n            for (int i = top; i <= bottom; i++) board[i][right] = dir;\n            right--;\n            dir = '<';\n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) board[bottom][i] = dir;\n                bottom--;\n            }\n            dir = '^';\n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) board[i][left] = dir;\n                left++;\n            }\n            dir = '>';\n        }\n    } else {\n        // default random\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m -1; j++) {\n                int rnd_val = rnd.next(5);\n                if (rnd_val < 4) {\n                    board[i][j] = directions[rnd_val];\n                } else {\n                    board[i][j] = '#';\n                }\n            }\n        }\n    }\n\n    // Output the board\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", board[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random small boards\n./gen -n 3 -m 3 -type random\n./gen -n 4 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n\n# Random medium boards\n./gen -n 200 -m 300 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 1000 -m 1000 -type random\n\n# Random large boards\n./gen -n 2000 -m 2000 -type random\n./gen -n 1999 -m 1999 -type random\n\n# Cycle small boards\n./gen -n 3 -m 3 -type cycle\n./gen -n 5 -m 5 -type cycle\n./gen -n 10 -m 10 -type cycle\n\n# Cycle large boards\n./gen -n 1000 -m 1000 -type cycle\n./gen -n 2000 -m 2000 -type cycle\n\n# Path small boards\n./gen -n 5 -m 5 -type path\n./gen -n 10 -m 10 -type path\n\n# Path narrow tall board\n./gen -n 2000 -m 5 -type path\n\n# Path wide short board\n./gen -n 5 -m 2000 -type path\n\n# Blocked small boards\n./gen -n 3 -m 3 -type blocked\n./gen -n 10 -m 10 -type blocked\n\n# Blocked large boards\n./gen -n 1000 -m 1000 -type blocked\n./gen -n 2000 -m 2000 -type blocked\n\n# Spiral small boards\n./gen -n 5 -m 5 -type spiral\n./gen -n 10 -m 10 -type spiral\n\n# Spiral large boards\n./gen -n 1000 -m 1000 -type spiral\n./gen -n 2000 -m 2000 -type spiral\n\n# Edge cases\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type blocked\n./gen -n 2 -m 2 -type cycle\n./gen -n 2 -m 2 -type path\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:45.094772",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "382/E",
      "title": "E. Ksenia and Combinatorics",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n, k ≤ 50).",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy0InputCopy2 1OutputCopy1InputCopy3 1OutputCopy3InputCopy4 2OutputCopy12",
      "description": "E. Ksenia and Combinatorics\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, k (1 ≤ n, k ≤ 50).\n\nOutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy1 1OutputCopy0InputCopy2 1OutputCopy1InputCopy3 1OutputCopy3InputCopy4 2OutputCopy12\n\nInputCopy1 1\n\nOutputCopy0\n\nInputCopy2 1\n\nOutputCopy1\n\nInputCopy3 1\n\nOutputCopy3\n\nInputCopy4 2\n\nOutputCopy12\n\nNoteIf you aren't familiar with matchings, please, read the following link: http://en.wikipedia.org/wiki/Matching_(graph_theory).",
      "solutions": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces",
          "content": "Good day everybody)Welcome to regular Codeforces round #224 for Div.2 participants, first Div2 Only in new 2014 year:). As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). I can't already remember exactly in how many rounds I participate as author, co-author of just active assistant) Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be dynamic, but the problems will be in supposed order of increasing complexity. The first dynamic round in this year)We wish everyone good luck, high rating and excellent mood)UPD2: the contest is over, we hope you enjoy it) the editorial is already here)Congratulations to winners:1) tankmagiciangirl2) NagaiNatsuyasumi3) lijian32564) TankKiller5) dashabi",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10423",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 934
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces",
          "content": "382A - Ksenia and Pan ScalesThis problem is just a technic problem. So, you should take weights one by one and place the current one into the side of the scales that contains lower number of weights. At the end you should output answer in the correct format.382B - Number BustersIn the problem you should understand, what is the structure of Artur's operation. You can see that this operation is near operation (b + x) % w (To see that just apply b = w - b - 1). There is nothing hard to get the formula of changing a during the operation. So, if you have k operations, you can see, that b = (b + k·x) % w, a = a - (b + k·x) / w, c = c - k. When you've got all the formulas, you can solve the problem using binary search.382C - Arithmetic ProgressionThis problem is about considering cases:1) If n = 1, the answer is -1. Because of any two numbers is arithmetical progression.2) If array is constant, the answer if that constant.3) If you have arithmetical progression initially, you can compute its difference d. In this case you should just to output minVal - d, and maxVal + d, where minVal is minimum value among a[i], and maxVal is maximum value among a[i]. But in case of n = 2, also you should check (a[0] + a[1]) / 2. If this number is integer, it is needed to be output.4) Else, the answer has at most one integer. You find this integer you should sort the sequence, and find the place where the number is missed. If such a place exists you should add the corresponding number to the sequence, else, the answer is 0.5) In all other cases the answer is 0.382D - Ksenia and PawnsIn this problem from every cell except # there is one next cell. That's why this graph is almost functional graph. If this graph contains a cycle, then answer is -1 because the length of the cycle is at least two.In the other case, there are no cycles in the graph. Let's find the longest path in it, denote is as len. Then is answer is at least 2·len - 1 because we can put the two pawns in the first two cells of this path.But in some cases we could get the answer 2·len if there are two non-intersecting by vertices (not #) paths of length len. They are non-intersecting because if they intersect in some cell then they will be equal to the end (and the statement says that such moves are invalid).So, we should check if the graph contains two non-intersecting by vertices (not #) paths of length len. It could be done in any way. For example, using dfs searches.382E - Ksenia and CombinatoricsIn this problem you should count trees with some properties. It can be done using dynamic programming. The main idea is that the maximum mathing in tree can be found using simple dynamic dp[v][used] (v -- vertex, used — was this vertex used in matching). So you should to count the trees tou should include in state of the dynamic values dp[v][0]$ and dp[v][1]. In other words, you should use dynamic programming z[n][dp0][dp1] — number of rooted trees with n vertices and values of dynamic in root dp[root][0] = dp0 and dp[root][1] = dp1. But in simple implementation this solution will get TL. There are two ways to get AC. The first is to opltimize code and make precalc. The second is to optimize asymptotics.The author's solution uses the second way. To optimize solution you should mark that values dp0 and dp1 differs at most by one. That is dp0 = dp1, or dp0 = dp1 + 1. So the first dynamic becomes r[n][dp0][add]. Another optimization is there are not so many triples (n, dp0, add) with non-negative values (about 250), so you can you use lazy programming to calculate this dynamic.Comments that describe other solutions: http://codeforces.com/blog/entry/10423#comment-158177http://codeforces.com/blog/entry/10423#comment-158182",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 382\\s*E"
          },
          "content_length": 3720
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 1",
          "code": "next[b][i] = after 2^i step what will be b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 2",
          "code": "add[b][i] = after 2^i step how many time a will decrease",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 3",
          "code": "O(log MAX_ANSWER)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 4",
          "code": "O(log MAX_ANSWER)^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 5",
          "code": "let f(x) = after x steps what will be new a value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 6",
          "code": "let g(x) = after x steps what will be new c value",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 7",
          "code": "let df(x) = f(x) - f(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 8",
          "code": "let dg(x) = g(x) - g(x - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 9",
          "code": "t[i].reserve(2000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) - Codeforces - Code 10",
          "code": "char t[2000][2000]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10423",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "(a[0] + a[1]) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "n( Required number of terms) = (l-a)/d+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #224 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "and Sum of all terms = [n*(l+a)]/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string k_input = opt<string>(\"k\", \"-1\");\n\n    if (n == -1) {\n        n = rnd.next(1, 50); // Random n between 1 and 50\n    } else {\n        n = max(1, min(50, n)); // Ensure n is within [1, 50]\n    }\n\n    int k = -1;\n    if (k_input == \"-1\") {\n        // k not provided, generate random valid k\n        int max_matching = n / 2;\n        k = rnd.next(0, max_matching);\n    } else if (k_input == \"max\") {\n        // Set k to maximum possible matching size\n        k = n / 2;\n    } else if (k_input == \"invalid\") {\n        // Set k to an invalid value (greater than floor(n/2))\n        int max_matching = n / 2;\n        if (max_matching + 1 <= 50) {\n            k = rnd.next(max_matching + 1, 50);\n        } else {\n            k = 50;\n        }\n    } else {\n        k = atoi(k_input.c_str()); // Convert k_input to integer\n    }\n\n    // Ensure k is within [0, 50]\n    k = max(0, min(50, k));\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string k_input = opt<string>(\"k\", \"-1\");\n\n    if (n == -1) {\n        n = rnd.next(1, 50); // Random n between 1 and 50\n    } else {\n        n = max(1, min(50, n)); // Ensure n is within [1, 50]\n    }\n\n    int k = -1;\n    if (k_input == \"-1\") {\n        // k not provided, generate random valid k\n        int max_matching = n / 2;\n        k = rnd.next(0, max_matching);\n    } else if (k_input == \"max\") {\n        // Set k to maximum possible matching size\n        k = n / 2;\n    } else if (k_input == \"invalid\") {\n        // Set k to an invalid value (greater than floor(n/2))\n        int max_matching = n / 2;\n        if (max_matching + 1 <= 50) {\n            k = rnd.next(max_matching + 1, 50);\n        } else {\n            k = 50;\n        }\n    } else {\n        k = atoi(k_input.c_str()); // Convert k_input to integer\n    }\n\n    // Ensure k is within [0, 50]\n    k = max(0, min(50, k));\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0\n./gen -n 1 -k 1\n./gen -n 1 -k invalid\n\n./gen -n 2 -k 0\n./gen -n 2 -k 1\n./gen -n 2 -k 2\n\n./gen -n 3 -k 0\n./gen -n 3 -k 1\n./gen -n 3 -k 2\n\n./gen -n 50 -k 0\n./gen -n 50 -k 1\n./gen -n 50 -k 25\n./gen -n 50 -k 26\n./gen -n 50 -k invalid\n\n./gen -n 49 -k 24\n./gen -n 49 -k 25\n\n./gen -n 4 -k invalid\n./gen -n 5 -k invalid\n\n./gen -n 10 -k max\n./gen -n 15 -k max\n./gen -n 20 -k invalid\n./gen -n 25 -k invalid\n./gen -n 40 -k max\n\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:46.795843",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "383/A",
      "title": "A. Milking cows",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 200000). The second line contains n integers a1, a2, ..., an, where ai is 0 if the cow number i is facing left, and 1 if it is facing right.",
      "output_spec": "OutputPrint a single integer, the minimum amount of lost milk.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy40 0 1 0OutputCopy1InputCopy51 0 1 0 1OutputCopy3",
      "description": "A. Milking cows\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 200000). The second line contains n integers a1, a2, ..., an, where ai is 0 if the cow number i is facing left, and 1 if it is facing right.\n\nOutputPrint a single integer, the minimum amount of lost milk.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy40 0 1 0OutputCopy1InputCopy51 0 1 0 1OutputCopy3\n\nInputCopy40 0 1 0\n\nOutputCopy1\n\nInputCopy51 0 1 0 1\n\nOutputCopy3\n\nNoteIn the first sample Iahub milks the cows in the following order: cow 3, cow 4, cow 2, cow 1. When he milks cow 3, cow 4 loses 1 unit of milk. After that, no more milk is lost.",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 383 和字母"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_left\") {\n        /* All cows face left */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_right\") {\n        /* All cows face right */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternate\") {\n        /* Cows face left and right alternately */\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"random\") {\n        /* Randomly assign facing directions */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0,1);\n    } else if (type == \"one_left\") {\n        /* All cows face right except one cow faces left */\n        fill(a.begin(), a.end(), 1);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 0;\n    } else if (type == \"one_right\") {\n        /* All cows face left except one cow faces right */\n        fill(a.begin(), a.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    } else {\n        /* Unknown type */\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    /* Output the test case */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 != n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_left\") {\n        /* All cows face left */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_right\") {\n        /* All cows face right */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternate\") {\n        /* Cows face left and right alternately */\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"random\") {\n        /* Randomly assign facing directions */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0,1);\n    } else if (type == \"one_left\") {\n        /* All cows face right except one cow faces left */\n        fill(a.begin(), a.end(), 1);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 0;\n    } else if (type == \"one_right\") {\n        /* All cows face left except one cow faces right */\n        fill(a.begin(), a.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    } else {\n        /* Unknown type */\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    /* Output the test case */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 != n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_left\n./gen -n 1 -type all_right\n./gen -n 2 -type alternate\n./gen -n 2 -type one_left\n./gen -n 2 -type one_right\n./gen -n 5 -type random\n./gen -n 5 -type alternate\n\n./gen -n 10 -type random\n./gen -n 10 -type all_left\n./gen -n 10 -type all_right\n\n./gen -n 50 -type random\n./gen -n 50 -type one_left\n./gen -n 50 -type one_right\n\n./gen -n 100 -type all_left\n./gen -n 100 -type all_right\n./gen -n 100 -type alternate\n\n./gen -n 500 -type random\n./gen -n 500 -type one_left\n./gen -n 500 -type one_right\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_left\n./gen -n 1000 -type all_right\n./gen -n 1000 -type alternate\n\n./gen -n 10000 -type random\n\n./gen -n 200000 -type random\n./gen -n 200000 -type all_left\n./gen -n 200000 -type all_right\n./gen -n 200000 -type alternate\n./gen -n 200000 -type one_left\n./gen -n 200000 -type one_right\n\n./gen -n 199999 -type random\n\n./gen -n 199999 -type alternate\n\n./gen -n 123456 -type random\n\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:48.504292",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "383/B",
      "title": "B. Volcanoes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n (1 ≤ n ≤ 109) and m (1 ≤ m ≤ 105). Each of the next m lines contains a pair of integers, x and y (1 ≤ x, y ≤ n), representing the coordinates of the volcanoes.Consider matrix rows are numbered from 1 to n from top to bottom, and matrix columns are numbered from 1 to n from left to right. There is no volcano in cell (1, 1). No two volcanoes occupy the same location.",
      "output_spec": "OutputPrint one integer, the minimum time in which Iahub can arrive at cell (n, n). If no solution exists (there is no path to the final cell), print -1.",
      "sample_tests": "ExamplesInputCopy4 21 31 4OutputCopy6InputCopy7 81 62 63 53 64 35 15 25 3OutputCopy12InputCopy2 21 22 1OutputCopy-1",
      "description": "B. Volcanoes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n (1 ≤ n ≤ 109) and m (1 ≤ m ≤ 105). Each of the next m lines contains a pair of integers, x and y (1 ≤ x, y ≤ n), representing the coordinates of the volcanoes.Consider matrix rows are numbered from 1 to n from top to bottom, and matrix columns are numbered from 1 to n from left to right. There is no volcano in cell (1, 1). No two volcanoes occupy the same location.\n\nOutputPrint one integer, the minimum time in which Iahub can arrive at cell (n, n). If no solution exists (there is no path to the final cell), print -1.\n\nInputCopy4 21 31 4OutputCopy6InputCopy7 81 62 63 53 64 35 15 25 3OutputCopy12InputCopy2 21 22 1OutputCopy-1\n\nInputCopy4 21 31 4\n\nOutputCopy6\n\nInputCopy7 81 62 63 53 64 35 15 25 3\n\nOutputCopy12\n\nInputCopy2 21 22 1\n\nOutputCopy-1\n\nNoteConsider the first sample. A possible road is: (1, 1)  →  (1, 2)  →  (2, 2)  →  (2, 3)  →  (3, 3)  →  (3, 4)  →  (4, 4).",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 383 和字母"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> volcanoes;\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y\");\n        inf.readEoln();\n\n        ensuref(!(x == 1 && y == 1), \"No volcano at position (1,1)\");\n\n        pair<int, int> pos = make_pair(x, y);\n        ensuref(volcanoes.count(pos) == 0, \"Duplicate volcano at position (%d, %d)\", x, y);\n        volcanoes.insert(pos);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> volcanoes;\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y\");\n        inf.readEoln();\n\n        ensuref(!(x == 1 && y == 1), \"No volcano at position (1,1)\");\n\n        pair<int, int> pos = make_pair(x, y);\n        ensuref(volcanoes.count(pos) == 0, \"Duplicate volcano at position (%d, %d)\", x, y);\n        volcanoes.insert(pos);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> volcanoes;\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y\");\n        inf.readEoln();\n\n        ensuref(!(x == 1 && y == 1), \"No volcano at position (1,1)\");\n\n        pair<int, int> pos = make_pair(x, y);\n        ensuref(volcanoes.count(pos) == 0, \"Duplicate volcano at position (%d, %d)\", x, y);\n        volcanoes.insert(pos);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 10); // default n=10\n    int m = opt<int>(\"m\", 0); // default m=0\n    string type = opt<string>(\"type\", \"random\");\n    \n    set<pair<int, int>> volcanoes;\n    \n    if (type == \"random\") {\n        // Adjust m if necessary\n        m = min(m, n * n - 1);\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == 1 && y == 1) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"block_start\") {\n        // Block (1,2) and (2,1)\n        volcanoes.insert(make_pair(1, 2));\n        volcanoes.insert(make_pair(2, 1));\n        m = max(m, 2); // m must be at least 2\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if ((x == 1 && y == 1) || volcanoes.count(make_pair(x, y))) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"block_end\") {\n        // Block positions near (n,n)\n        volcanoes.insert(make_pair(n - 1, n));\n        volcanoes.insert(make_pair(n, n - 1));\n        m = max(m, 2);\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if ((x == 1 && y == 1) || volcanoes.count(make_pair(x, y))) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"block_path\") {\n        // Block the entire second row to make path impossible\n        int k = min(m, n - 1);\n        for (int i = 2; i <= k + 1; ++i) {\n            volcanoes.insert(make_pair(1, i));\n        }\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if ((x == 1 && y == 1) || volcanoes.count(make_pair(x, y))) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"maximal\") {\n        // Maximal n and m\n        n = 1000000000;\n        m = 100000; // Max m according to constraints\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == 1 && y == 1) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"minimal\") {\n        n = 1;\n        m = 0;\n        // No volcanoes\n    } else if (type == \"corner_case\") {\n        // Custom designed to test specific edge cases\n        n = 2;\n        volcanoes.insert(make_pair(1, 2));\n        volcanoes.insert(make_pair(2, 1));\n        m = 2;\n    } else if (type == \"large_n_small_m\") {\n        n = 1000000000;\n        m = opt<int>(\"m\", 1); // default m=1\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == 1 && y == 1) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"small_n_large_m\") {\n        n = opt<int>(\"n\", 1000);\n        m = min(n * n - 1, 100000); // Constraints\n        int cnt = 0;\n        for (int x = 1; x <= n && cnt < m; x++) {\n            for (int y = 1; y <= n && cnt < m; y++) {\n                if (x == 1 && y == 1) continue;\n                cnt++;\n                volcanoes.insert(make_pair(x, y));\n            }\n        }\n    }\n    \n    printf(\"%d %d\\n\", n, (int)volcanoes.size());\n    for (auto &v : volcanoes) {\n        printf(\"%d %d\\n\", v.first, v.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 10); // default n=10\n    int m = opt<int>(\"m\", 0); // default m=0\n    string type = opt<string>(\"type\", \"random\");\n    \n    set<pair<int, int>> volcanoes;\n    \n    if (type == \"random\") {\n        // Adjust m if necessary\n        m = min(m, n * n - 1);\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == 1 && y == 1) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"block_start\") {\n        // Block (1,2) and (2,1)\n        volcanoes.insert(make_pair(1, 2));\n        volcanoes.insert(make_pair(2, 1));\n        m = max(m, 2); // m must be at least 2\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if ((x == 1 && y == 1) || volcanoes.count(make_pair(x, y))) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"block_end\") {\n        // Block positions near (n,n)\n        volcanoes.insert(make_pair(n - 1, n));\n        volcanoes.insert(make_pair(n, n - 1));\n        m = max(m, 2);\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if ((x == 1 && y == 1) || volcanoes.count(make_pair(x, y))) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"block_path\") {\n        // Block the entire second row to make path impossible\n        int k = min(m, n - 1);\n        for (int i = 2; i <= k + 1; ++i) {\n            volcanoes.insert(make_pair(1, i));\n        }\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if ((x == 1 && y == 1) || volcanoes.count(make_pair(x, y))) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"maximal\") {\n        // Maximal n and m\n        n = 1000000000;\n        m = 100000; // Max m according to constraints\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == 1 && y == 1) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"minimal\") {\n        n = 1;\n        m = 0;\n        // No volcanoes\n    } else if (type == \"corner_case\") {\n        // Custom designed to test specific edge cases\n        n = 2;\n        volcanoes.insert(make_pair(1, 2));\n        volcanoes.insert(make_pair(2, 1));\n        m = 2;\n    } else if (type == \"large_n_small_m\") {\n        n = 1000000000;\n        m = opt<int>(\"m\", 1); // default m=1\n        while ((int)volcanoes.size() < m) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == 1 && y == 1) continue;\n            volcanoes.insert(make_pair(x, y));\n        }\n    } else if (type == \"small_n_large_m\") {\n        n = opt<int>(\"n\", 1000);\n        m = min(n * n - 1, 100000); // Constraints\n        int cnt = 0;\n        for (int x = 1; x <= n && cnt < m; x++) {\n            for (int y = 1; y <= n && cnt < m; y++) {\n                if (x == 1 && y == 1) continue;\n                cnt++;\n                volcanoes.insert(make_pair(x, y));\n            }\n        }\n    }\n    \n    printf(\"%d %d\\n\", n, (int)volcanoes.size());\n    for (auto &v : volcanoes) {\n        printf(\"%d %d\\n\", v.first, v.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type minimal\n./gen -n 1 -m 0 -type random\n./gen -n 2 -m 2 -type corner_case\n./gen -n 2 -m 1 -type block_start\n./gen -n 2 -m 1 -type block_end\n./gen -n 3 -m 1 -type block_start\n./gen -n 3 -m 1 -type block_end\n./gen -n 5 -m 3 -type block_start\n./gen -n 5 -m 3 -type block_end\n./gen -n 5 -m 3 -type block_path\n./gen -n 5 -m 5 -type random\n./gen -n 50 -m 5 -type block_path\n./gen -n 50 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 5000 -type random\n./gen -n 1000 -type small_n_large_m\n./gen -n 10000 -type small_n_large_m\n./gen -n 1000000000 -m 1 -type large_n_small_m\n./gen -n 1000000000 -m 50000 -type random\n./gen -n 1000000000 -m 99999 -type block_path\n./gen -n 1000000000 -m 100000 -type maximal\n./gen -n 1000000000 -m 100000 -type block_start\n./gen -n 1000000000 -m 100000 -type block_end\n./gen -n 1000000000 -m 100000 -type random\n./gen -n 999999999 -m 99999 -type random\n./gen -n 1000000000 -m 0 -type minimal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:51.165069",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "383/C",
      "title": "C. Propagating tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000). Each of the next n–1 lines contains two integers vi and ui (1 ≤ vi, ui ≤ n), meaning that there is an edge between nodes vi and ui.Each of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.",
      "output_spec": "OutputFor each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.",
      "sample_tests": "ExamplesInputCopy5 51 2 1 1 21 21 32 42 51 2 31 1 22 12 22 4OutputCopy330",
      "description": "C. Propagating tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000). Each of the next n–1 lines contains two integers vi and ui (1 ≤ vi, ui ≤ n), meaning that there is an edge between nodes vi and ui.Each of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.\n\nOutputFor each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.\n\nInputCopy5 51 2 1 1 21 21 32 42 51 2 31 1 22 12 22 4OutputCopy330\n\nInputCopy5 51 2 1 1 21 21 32 42 51 2 31 1 22 12 22 4\n\nOutputCopy330\n\nNoteThe values of the nodes are [1, 2, 1, 1, 2] at the beginning.Then value 3 is added to node 2. It propagates and value -3 is added to it's sons, node 4 and node 5. Then it cannot propagate any more. So the values of the nodes are [1, 5, 1,  - 2,  - 1].Then value 2 is added to node 1. It propagates and value -2 is added to it's sons, node 2 and node 3. From node 2 it propagates again, adding value 2 to it's sons, node 4 and node 5. Node 3 has no sons, so it cannot propagate from there. The values of the nodes are [3, 3,  - 1, 0, 1].You can see all the definitions about the tree at the following link: http://en.wikipedia.org/wiki/Tree_(graph_theory)",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 383 和字母"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readEoln();\n\n    // Read the sequence a_i\n    vector<int> a(n);\n    a[0] = inf.readInt(1, 1000, \"a_1\");\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        a[i] = inf.readInt(1, 1000, \"a_\" + to_string(i + 1));\n    }\n    inf.readEoln();\n\n    // Read n - 1 edges\n    vector<vector<int>> adj(n);\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge can't connect a node to itself at line %d\", i + 3);\n        u--, v--;\n        edges.emplace_back(u, v);\n    }\n\n    // Check that the edges form a tree\n    // Use Union-Find (Disjoint Set Union) to detect cycles\n    vector<int> parent(n, -1);\n    function<int(int)> find = [&](int x) {\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\n    };\n    auto unite = [&](int x, int y) -> bool {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false; // Cycle detected\n        if (parent[x] > parent[y]) swap(x, y);\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n    };\n    for (const auto& e : edges) {\n        int u = e.first, v = e.second;\n        ensuref(unite(u, v), \"Graph is not a tree (contains a cycle)\");\n    }\n\n    // Verify that all nodes are connected (tree is connected)\n    int root = find(0);\n    for (int i = 0; i < n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        string queryType = inf.readToken();\n        ensuref(queryType == \"1\" || queryType == \"2\", \"Invalid query type in query %d\", i + 1);\n        if (queryType == \"1\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in query \" + to_string(i + 1));\n            inf.readSpace();\n            int val = inf.readInt(1, 1000, \"val in query \" + to_string(i + 1));\n            inf.readEoln();\n        } else { // queryType == \"2\"\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in query \" + to_string(i + 1));\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readEoln();\n\n    // Read the sequence a_i\n    vector<int> a(n);\n    a[0] = inf.readInt(1, 1000, \"a_1\");\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        a[i] = inf.readInt(1, 1000, \"a_\" + to_string(i + 1));\n    }\n    inf.readEoln();\n\n    // Read n - 1 edges\n    vector<vector<int>> adj(n);\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge can't connect a node to itself at line %d\", i + 3);\n        u--, v--;\n        edges.emplace_back(u, v);\n    }\n\n    // Check that the edges form a tree\n    // Use Union-Find (Disjoint Set Union) to detect cycles\n    vector<int> parent(n, -1);\n    function<int(int)> find = [&](int x) {\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\n    };\n    auto unite = [&](int x, int y) -> bool {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false; // Cycle detected\n        if (parent[x] > parent[y]) swap(x, y);\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n    };\n    for (const auto& e : edges) {\n        int u = e.first, v = e.second;\n        ensuref(unite(u, v), \"Graph is not a tree (contains a cycle)\");\n    }\n\n    // Verify that all nodes are connected (tree is connected)\n    int root = find(0);\n    for (int i = 0; i < n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        string queryType = inf.readToken();\n        ensuref(queryType == \"1\" || queryType == \"2\", \"Invalid query type in query %d\", i + 1);\n        if (queryType == \"1\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in query \" + to_string(i + 1));\n            inf.readSpace();\n            int val = inf.readInt(1, 1000, \"val in query \" + to_string(i + 1));\n            inf.readEoln();\n        } else { // queryType == \"2\"\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in query \" + to_string(i + 1));\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readEoln();\n\n    // Read the sequence a_i\n    vector<int> a(n);\n    a[0] = inf.readInt(1, 1000, \"a_1\");\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        a[i] = inf.readInt(1, 1000, \"a_\" + to_string(i + 1));\n    }\n    inf.readEoln();\n\n    // Read n - 1 edges\n    vector<vector<int>> adj(n);\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge can't connect a node to itself at line %d\", i + 3);\n        u--, v--;\n        edges.emplace_back(u, v);\n    }\n\n    // Check that the edges form a tree\n    // Use Union-Find (Disjoint Set Union) to detect cycles\n    vector<int> parent(n, -1);\n    function<int(int)> find = [&](int x) {\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\n    };\n    auto unite = [&](int x, int y) -> bool {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false; // Cycle detected\n        if (parent[x] > parent[y]) swap(x, y);\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n    };\n    for (const auto& e : edges) {\n        int u = e.first, v = e.second;\n        ensuref(unite(u, v), \"Graph is not a tree (contains a cycle)\");\n    }\n\n    // Verify that all nodes are connected (tree is connected)\n    int root = find(0);\n    for (int i = 0; i < n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        string queryType = inf.readToken();\n        ensuref(queryType == \"1\" || queryType == \"2\", \"Invalid query type in query %d\", i + 1);\n        if (queryType == \"1\") {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in query \" + to_string(i + 1));\n            inf.readSpace();\n            int val = inf.readInt(1, 1000, \"val in query \" + to_string(i + 1));\n            inf.readEoln();\n        } else { // queryType == \"2\"\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in query \" + to_string(i + 1));\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"mixed\");\n    string val_type = opt<string>(\"val_type\", \"random\");\n    int fixed_node = opt<int>(\"fixed_node\", -1); // Use -1 if not specified\n\n    // Generate the tree based on the specified tree_type\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // Binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle the edges for randomness\n    shuffle(edges.begin(), edges.end());\n\n    // Generate initial node values based on ai_type\n    vector<int> ai(n + 1);\n    if (ai_type == \"min\") {\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (ai_type == \"max\") {\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = 1000;\n        }\n    } else if (ai_type == \"alternating\") {\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = (i % 2 == 1) ? 1 : 1000;\n        }\n    } else {\n        // Random ai values\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Generate queries based on query_type and val_type\n    vector<string> queries;\n    for (int i = 0; i < m; ++i) {\n        int x = (fixed_node != -1) ? fixed_node : rnd.next(1, n);\n        if (query_type == \"all_updates\") {\n            int val = (val_type == \"min\") ? 1 : (val_type == \"max\") ? 1000 : rnd.next(1, 1000);\n            queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n        } else if (query_type == \"all_prints\") {\n            queries.push_back(\"2 \" + to_string(x));\n        } else if (query_type == \"mixed_alternate\") {\n            int type = (i % 2 == 0) ? 1 : 2;\n            if (type == 1) {\n                int val = (val_type == \"min\") ? 1 : (val_type == \"max\") ? 1000 : rnd.next(1, 1000);\n                queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n            } else {\n                queries.push_back(\"2 \" + to_string(x));\n            }\n        } else {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int val = (val_type == \"min\") ? 1 : (val_type == \"max\") ? 1000 : rnd.next(1, 1000);\n                queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n            } else {\n                queries.push_back(\"2 \" + to_string(x));\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", ai[i], (i == n) ? '\\n' : ' ');\n    }\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    for (const auto& q : queries) {\n        printf(\"%s\\n\", q.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"mixed\");\n    string val_type = opt<string>(\"val_type\", \"random\");\n    int fixed_node = opt<int>(\"fixed_node\", -1); // Use -1 if not specified\n\n    // Generate the tree based on the specified tree_type\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // Binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle the edges for randomness\n    shuffle(edges.begin(), edges.end());\n\n    // Generate initial node values based on ai_type\n    vector<int> ai(n + 1);\n    if (ai_type == \"min\") {\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (ai_type == \"max\") {\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = 1000;\n        }\n    } else if (ai_type == \"alternating\") {\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = (i % 2 == 1) ? 1 : 1000;\n        }\n    } else {\n        // Random ai values\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Generate queries based on query_type and val_type\n    vector<string> queries;\n    for (int i = 0; i < m; ++i) {\n        int x = (fixed_node != -1) ? fixed_node : rnd.next(1, n);\n        if (query_type == \"all_updates\") {\n            int val = (val_type == \"min\") ? 1 : (val_type == \"max\") ? 1000 : rnd.next(1, 1000);\n            queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n        } else if (query_type == \"all_prints\") {\n            queries.push_back(\"2 \" + to_string(x));\n        } else if (query_type == \"mixed_alternate\") {\n            int type = (i % 2 == 0) ? 1 : 2;\n            if (type == 1) {\n                int val = (val_type == \"min\") ? 1 : (val_type == \"max\") ? 1000 : rnd.next(1, 1000);\n                queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n            } else {\n                queries.push_back(\"2 \" + to_string(x));\n            }\n        } else {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int val = (val_type == \"min\") ? 1 : (val_type == \"max\") ? 1000 : rnd.next(1, 1000);\n                queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n            } else {\n                queries.push_back(\"2 \" + to_string(x));\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", ai[i], (i == n) ? '\\n' : ' ');\n    }\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    for (const auto& q : queries) {\n        printf(\"%s\\n\", q.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -tree_type chain -ai_type min -query_type all_prints -val_type min\n./gen -n 5 -m 5 -tree_type star -ai_type max -query_type all_updates -val_type max\n\n./gen -n 10 -m 10 -tree_type random -ai_type alternating -query_type mixed -val_type random\n\n./gen -n 1000 -m 1000 -tree_type chain -ai_type min -query_type all_prints -val_type min\n./gen -n 1000 -m 1000 -tree_type star -ai_type max -query_type all_updates -val_type max\n./gen -n 1000 -m 1000 -tree_type binary -ai_type random -query_type mixed -val_type random\n./gen -n 1000 -m 1000 -tree_type random -ai_type alternating -query_type mixed -val_type random\n\n./gen -n 200000 -m 200000 -tree_type chain -ai_type min -query_type all_prints -val_type min\n./gen -n 200000 -m 200000 -tree_type chain -ai_type min -query_type all_updates -val_type max\n./gen -n 200000 -m 200000 -tree_type chain -ai_type min -query_type mixed -val_type random\n\n./gen -n 200000 -m 200000 -tree_type star -ai_type max -query_type all_prints -val_type min\n./gen -n 200000 -m 200000 -tree_type star -ai_type max -query_type all_updates -val_type max\n./gen -n 200000 -m 200000 -tree_type star -ai_type max -query_type mixed -val_type random\n\n./gen -n 200000 -m 200000 -tree_type binary -ai_type alternating -query_type all_prints -val_type min\n./gen -n 200000 -m 200000 -tree_type binary -ai_type alternating -query_type all_updates -val_type max\n./gen -n 200000 -m 200000 -tree_type binary -ai_type alternating -query_type mixed -val_type random\n\n./gen -n 200000 -m 200000 -tree_type random -ai_type random -query_type all_prints -val_type min\n./gen -n 200000 -m 200000 -tree_type random -ai_type random -query_type all_updates -val_type max\n./gen -n 200000 -m 200000 -tree_type random -ai_type random -query_type mixed -val_type random\n\n# Special cases to test potential contestant errors\n\n# All queries are updates with maximum val, initial ai are minimum\n./gen -n 100000 -m 100000 -tree_type chain -ai_type min -query_type all_updates -val_type max\n\n# All updates target the same node\n./gen -n 50000 -m 200000 -tree_type star -ai_type random -query_type all_updates -val_type random -fixed_node 1\n\n# All prints target the same node\n./gen -n 50000 -m 200000 -tree_type star -ai_type random -query_type all_prints -val_type random -fixed_node 1\n\n# Mixed queries alternating between updates and prints\n./gen -n 100000 -m 200000 -tree_type random -ai_type random -query_type mixed_alternate -val_type random\n\n# Small n but large m to test efficiency\n./gen -n 100 -m 200000 -tree_type chain -ai_type random -query_type mixed -val_type random\n\n# Updates with minimum val only\n./gen -n 200000 -m 200000 -tree_type random -ai_type random -query_type all_updates -val_type min\n\n# Updates and prints targeting specific nodes\n./gen -n 200000 -m 200000 -tree_type star -ai_type max -query_type all_updates -val_type max -fixed_node 1\n./gen -n 200000 -m 200000 -tree_type chain -ai_type min -query_type all_prints -val_type min -fixed_node 200000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:53.940642",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "383/D",
      "title": "D. Antimatter",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000).The sum a1 + a2 + ... + an will be less than or equal to 10000.",
      "output_spec": "OutputOutput a single integer, the number of ways Iahub can take a photo, modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy41 1 1 1OutputCopy12",
      "description": "D. Antimatter\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000).The sum a1 + a2 + ... + an will be less than or equal to 10000.\n\nOutputOutput a single integer, the number of ways Iahub can take a photo, modulo 1000000007 (109 + 7).\n\nInputCopy41 1 1 1OutputCopy12\n\nInputCopy41 1 1 1\n\nOutputCopy12\n\nNoteThe possible photos are [1+, 2-], [1-, 2+], [2+, 3-], [2-, 3+], [3+, 4-], [3-, 4+], [1+, 2+, 3-, 4-], [1+, 2-, 3+, 4-], [1+, 2-, 3-, 4+], [1-, 2+, 3+, 4-], [1-, 2+, 3-, 4+] and [1-, 2-, 3+, 4+], where \"i+\" means that the i-th element produces matter, and \"i-\" means that the i-th element produces antimatter.",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 383\\s*D"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    ensuref(sum <= 10000, \"Sum of a_i must be <= 10000, but found %lld\", sum);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    ensuref(sum <= 10000, \"Sum of a_i must be <= 10000, but found %lld\", sum);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    ensuref(sum <= 10000, \"Sum of a_i must be <= 10000, but found %lld\", sum);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    int max_sum = 10000;\n\n    if (type == \"random\") {\n        int remaining_sum = max_sum;\n        for (int i = 0; i < n; ++i) {\n            int min_ai = 1;\n            int max_ai = min(1000, remaining_sum - (n - i - 1)*1);\n            if (max_ai < min_ai) max_ai = min_ai;\n            a[i] = rnd.next(min_ai, max_ai);\n            remaining_sum -= a[i];\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"allsame\") {\n        int ai_value = min(1000, max_sum / n);\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n    } else if (type == \"increasing\") {\n        int min_ai = 1;\n        int max_ai = min(1000, 2 * (max_sum - min_ai * n) / n + min_ai);\n        if (max_ai < min_ai) max_ai = min_ai;\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai + ((max_ai - min_ai) * i) / (n -1);\n        }\n        int sum_ai = accumulate(a.begin(), a.end(), 0);\n        int i = n-1;\n        while (sum_ai > max_sum && i >= 0) {\n            int diff = min(a[i]-1, sum_ai - max_sum);\n            a[i] -= diff;\n            sum_ai -= diff;\n            i--;\n        }\n        i = 0;\n        while (sum_ai < max_sum && i < n) {\n            int diff = min(1000 - a[i], max_sum - sum_ai);\n            a[i] += diff;\n            sum_ai += diff;\n            i++;\n        }\n    } else if (type == \"decreasing\") {\n        int min_ai = 1;\n        int max_ai = min(1000, 2 * (max_sum - min_ai * n) / n + min_ai);\n        if (max_ai < min_ai) max_ai = min_ai;\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai - ((max_ai - min_ai) * i) / (n -1);\n        }\n        int sum_ai = accumulate(a.begin(), a.end(), 0);\n        int i = n-1;\n        while (sum_ai > max_sum && i >= 0) {\n            int diff = min(a[i]-1, sum_ai - max_sum);\n            a[i] -= diff;\n            sum_ai -= diff;\n            i--;\n        }\n        i = 0;\n        while (sum_ai < max_sum && i < n) {\n            int diff = min(1000 - a[i], max_sum - sum_ai);\n            a[i] += diff;\n            sum_ai += diff;\n            i++;\n        }\n    } else if (type == \"alternating\") {\n        int sum_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i%2 == 0)\n                a[i] = 1;\n            else\n                a[i] = min(1000, max_sum - sum_ai - (n - i -1)*1);\n            sum_ai += a[i];\n        }\n    } else if (type == \"maxsum\") {\n        int ai_value = 1000;\n        while (ai_value * n > max_sum)\n            ai_value--;\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n        int sum_ai = ai_value * n;\n        int i = 0;\n        while (sum_ai < max_sum && i < n) {\n            int diff = min(1000 - a[i], max_sum - sum_ai);\n            a[i] += diff;\n            sum_ai += diff;\n            i++;\n        }\n    } else if (type == \"minsum\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else {\n        int remaining_sum = max_sum;\n        for (int i = 0; i < n; ++i) {\n            int min_ai = 1;\n            int max_ai = min(1000, remaining_sum - (n - i - 1)*1);\n            if (max_ai < min_ai) max_ai = min_ai;\n            a[i] = rnd.next(min_ai, max_ai);\n            remaining_sum -= a[i];\n        }\n        shuffle(a.begin(), a.end());\n    }\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    int max_sum = 10000;\n\n    if (type == \"random\") {\n        int remaining_sum = max_sum;\n        for (int i = 0; i < n; ++i) {\n            int min_ai = 1;\n            int max_ai = min(1000, remaining_sum - (n - i - 1)*1);\n            if (max_ai < min_ai) max_ai = min_ai;\n            a[i] = rnd.next(min_ai, max_ai);\n            remaining_sum -= a[i];\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"allsame\") {\n        int ai_value = min(1000, max_sum / n);\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n    } else if (type == \"increasing\") {\n        int min_ai = 1;\n        int max_ai = min(1000, 2 * (max_sum - min_ai * n) / n + min_ai);\n        if (max_ai < min_ai) max_ai = min_ai;\n        for (int i = 0; i < n; ++i) {\n            a[i] = min_ai + ((max_ai - min_ai) * i) / (n -1);\n        }\n        int sum_ai = accumulate(a.begin(), a.end(), 0);\n        int i = n-1;\n        while (sum_ai > max_sum && i >= 0) {\n            int diff = min(a[i]-1, sum_ai - max_sum);\n            a[i] -= diff;\n            sum_ai -= diff;\n            i--;\n        }\n        i = 0;\n        while (sum_ai < max_sum && i < n) {\n            int diff = min(1000 - a[i], max_sum - sum_ai);\n            a[i] += diff;\n            sum_ai += diff;\n            i++;\n        }\n    } else if (type == \"decreasing\") {\n        int min_ai = 1;\n        int max_ai = min(1000, 2 * (max_sum - min_ai * n) / n + min_ai);\n        if (max_ai < min_ai) max_ai = min_ai;\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai - ((max_ai - min_ai) * i) / (n -1);\n        }\n        int sum_ai = accumulate(a.begin(), a.end(), 0);\n        int i = n-1;\n        while (sum_ai > max_sum && i >= 0) {\n            int diff = min(a[i]-1, sum_ai - max_sum);\n            a[i] -= diff;\n            sum_ai -= diff;\n            i--;\n        }\n        i = 0;\n        while (sum_ai < max_sum && i < n) {\n            int diff = min(1000 - a[i], max_sum - sum_ai);\n            a[i] += diff;\n            sum_ai += diff;\n            i++;\n        }\n    } else if (type == \"alternating\") {\n        int sum_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i%2 == 0)\n                a[i] = 1;\n            else\n                a[i] = min(1000, max_sum - sum_ai - (n - i -1)*1);\n            sum_ai += a[i];\n        }\n    } else if (type == \"maxsum\") {\n        int ai_value = 1000;\n        while (ai_value * n > max_sum)\n            ai_value--;\n        for (int i = 0; i < n; ++i)\n            a[i] = ai_value;\n        int sum_ai = ai_value * n;\n        int i = 0;\n        while (sum_ai < max_sum && i < n) {\n            int diff = min(1000 - a[i], max_sum - sum_ai);\n            a[i] += diff;\n            sum_ai += diff;\n            i++;\n        }\n    } else if (type == \"minsum\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else {\n        int remaining_sum = max_sum;\n        for (int i = 0; i < n; ++i) {\n            int min_ai = 1;\n            int max_ai = min(1000, remaining_sum - (n - i - 1)*1);\n            if (max_ai < min_ai) max_ai = min_ai;\n            a[i] = rnd.next(min_ai, max_ai);\n            remaining_sum -= a[i];\n        }\n        shuffle(a.begin(), a.end());\n    }\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minsum\n./gen -n 1 -type maxsum\n./gen -n 1 -type random\n\n./gen -n 10 -type random\n./gen -n 10 -type allsame\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type allsame\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n\n./gen -n 500 -type maxsum\n./gen -n 500 -type minsum\n\n./gen -n 1000 -type random\n./gen -n 1000 -type allsame\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type alternating\n./gen -n 1000 -type maxsum\n./gen -n 1000 -type minsum\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:56.225724",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "383/E",
      "title": "E. Vowels",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer, n (1 ≤ n ≤ 104). Each of the next n lines contains a 3-word consisting of 3 lowercase letters. There will be no two identical 3-words.",
      "output_spec": "OutputPrint one number, the xor of the squared answers to the queries.",
      "sample_tests": "ExamplesInputCopy5abcaaaadabcddefOutputCopy0",
      "description": "time limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer, n (1 ≤ n ≤ 104). Each of the next n lines contains a 3-word consisting of 3 lowercase letters. There will be no two identical 3-words.\n\nOutputPrint one number, the xor of the squared answers to the queries.\n\nInputCopy5abcaaaadabcddefOutputCopy0\n\nInputCopy5abcaaaadabcddef\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 383\\s*E"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    \n    set<string> words;\n    \n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() == 3, \"Word on line %d should have exactly 3 characters, got length %d\", i + 2, (int)s.length());\n\n        for (int j = 0; j < 3; ++j) {\n            ensuref(s[j] >= 'a' && s[j] <= 'x', \"Word on line %d contains invalid character '%c'\", i + 2, s[j]);\n        }\n\n        ensuref(words.count(s) == 0, \"Duplicate word '%s' found on line %d\", s.c_str(), i + 2);\n        words.insert(s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    \n    set<string> words;\n    \n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() == 3, \"Word on line %d should have exactly 3 characters, got length %d\", i + 2, (int)s.length());\n\n        for (int j = 0; j < 3; ++j) {\n            ensuref(s[j] >= 'a' && s[j] <= 'x', \"Word on line %d contains invalid character '%c'\", i + 2, s[j]);\n        }\n\n        ensuref(words.count(s) == 0, \"Duplicate word '%s' found on line %d\", s.c_str(), i + 2);\n        words.insert(s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    \n    set<string> words;\n    \n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() == 3, \"Word on line %d should have exactly 3 characters, got length %d\", i + 2, (int)s.length());\n\n        for (int j = 0; j < 3; ++j) {\n            ensuref(s[j] >= 'a' && s[j] <= 'x', \"Word on line %d contains invalid character '%c'\", i + 2, s[j]);\n        }\n\n        ensuref(words.count(s) == 0, \"Duplicate word '%s' found on line %d\", s.c_str(), i + 2);\n        words.insert(s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0); // For types that require 'k'\n\n    vector<string> words;\n\n    if (type == \"random\") {\n        // Generate all possible words\n        vector<string> all_words;\n        for (char c1 = 'a'; c1 <= 'x'; ++c1)\n            for (char c2 = 'a'; c2 <= 'x'; ++c2)\n                for (char c3 = 'a'; c3 <= 'x'; ++c3)\n                    all_words.push_back(string() + c1 + c2 + c3);\n        shuffle(all_words.begin(), all_words.end());\n        if (n > (int)all_words.size())\n            n = all_words.size(); // Adjust n if necessary\n        for (int i = 0; i < n; ++i)\n            words.push_back(all_words[i]);\n    } else if (type == \"few_letters\") {\n        if (k == 0 || k > 24) {\n            // Adjust k if invalid\n            k = 10;\n        }\n        vector<char> letters;\n        for (char c = 'a'; c <= 'x'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        letters.resize(k);\n        vector<string> possible_words;\n        for (int i = 0; i < letters.size(); ++i)\n            for (int j = 0; j < letters.size(); ++j)\n                for (int l = 0; l < letters.size(); ++l)\n                    possible_words.push_back(string() + letters[i] + letters[j] + letters[l]);\n        shuffle(possible_words.begin(), possible_words.end());\n        if (n > (int)possible_words.size())\n            n = possible_words.size(); // Adjust n if necessary\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else if (type == \"same_letter\") {\n        vector<string> possible_words;\n        for (char c = 'a'; c <= 'x'; ++c)\n            possible_words.push_back(string() + c + c + c);\n        if (n > (int)possible_words.size())\n            n = possible_words.size(); // n cannot be more than 24\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else if (type == \"palindrome\") {\n        vector<string> possible_words;\n        for (char c1 = 'a'; c1 <= 'x'; ++c1)\n            for (char c2 = 'a'; c2 <= 'x'; ++c2)\n                possible_words.push_back(string() + c1 + c2 + c1);\n        shuffle(possible_words.begin(), possible_words.end());\n        if (n > (int)possible_words.size())\n            n = possible_words.size();\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else if (type == \"edge_letters\") {\n        vector<char> letters = {'a', 'x'};\n        vector<string> possible_words;\n        for (int i = 0; i < letters.size(); ++i)\n            for (int j = 0; j < letters.size(); ++j)\n                for (int l = 0; l < letters.size(); ++l)\n                    possible_words.push_back(string() + letters[i] + letters[j] + letters[l]);\n        shuffle(possible_words.begin(), possible_words.end());\n        if (n > (int)possible_words.size())\n            n = possible_words.size();\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else {\n        // Default to random if type is unknown\n        // Generate all possible words\n        vector<string> all_words;\n        for (char c1 = 'a'; c1 <= 'x'; ++c1)\n            for (char c2 = 'a'; c2 <= 'x'; ++c2)\n                for (char c3 = 'a'; c3 <= 'x'; ++c3)\n                    all_words.push_back(string() + c1 + c2 + c3);\n        shuffle(all_words.begin(), all_words.end());\n        if (n > (int)all_words.size())\n            n = all_words.size(); // Adjust n if necessary\n        for (int i = 0; i < n; ++i)\n            words.push_back(all_words[i]);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", words[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0); // For types that require 'k'\n\n    vector<string> words;\n\n    if (type == \"random\") {\n        // Generate all possible words\n        vector<string> all_words;\n        for (char c1 = 'a'; c1 <= 'x'; ++c1)\n            for (char c2 = 'a'; c2 <= 'x'; ++c2)\n                for (char c3 = 'a'; c3 <= 'x'; ++c3)\n                    all_words.push_back(string() + c1 + c2 + c3);\n        shuffle(all_words.begin(), all_words.end());\n        if (n > (int)all_words.size())\n            n = all_words.size(); // Adjust n if necessary\n        for (int i = 0; i < n; ++i)\n            words.push_back(all_words[i]);\n    } else if (type == \"few_letters\") {\n        if (k == 0 || k > 24) {\n            // Adjust k if invalid\n            k = 10;\n        }\n        vector<char> letters;\n        for (char c = 'a'; c <= 'x'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        letters.resize(k);\n        vector<string> possible_words;\n        for (int i = 0; i < letters.size(); ++i)\n            for (int j = 0; j < letters.size(); ++j)\n                for (int l = 0; l < letters.size(); ++l)\n                    possible_words.push_back(string() + letters[i] + letters[j] + letters[l]);\n        shuffle(possible_words.begin(), possible_words.end());\n        if (n > (int)possible_words.size())\n            n = possible_words.size(); // Adjust n if necessary\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else if (type == \"same_letter\") {\n        vector<string> possible_words;\n        for (char c = 'a'; c <= 'x'; ++c)\n            possible_words.push_back(string() + c + c + c);\n        if (n > (int)possible_words.size())\n            n = possible_words.size(); // n cannot be more than 24\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else if (type == \"palindrome\") {\n        vector<string> possible_words;\n        for (char c1 = 'a'; c1 <= 'x'; ++c1)\n            for (char c2 = 'a'; c2 <= 'x'; ++c2)\n                possible_words.push_back(string() + c1 + c2 + c1);\n        shuffle(possible_words.begin(), possible_words.end());\n        if (n > (int)possible_words.size())\n            n = possible_words.size();\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else if (type == \"edge_letters\") {\n        vector<char> letters = {'a', 'x'};\n        vector<string> possible_words;\n        for (int i = 0; i < letters.size(); ++i)\n            for (int j = 0; j < letters.size(); ++j)\n                for (int l = 0; l < letters.size(); ++l)\n                    possible_words.push_back(string() + letters[i] + letters[j] + letters[l]);\n        shuffle(possible_words.begin(), possible_words.end());\n        if (n > (int)possible_words.size())\n            n = possible_words.size();\n        for (int i = 0; i < n; ++i)\n            words.push_back(possible_words[i]);\n    } else {\n        // Default to random if type is unknown\n        // Generate all possible words\n        vector<string> all_words;\n        for (char c1 = 'a'; c1 <= 'x'; ++c1)\n            for (char c2 = 'a'; c2 <= 'x'; ++c2)\n                for (char c3 = 'a'; c3 <= 'x'; ++c3)\n                    all_words.push_back(string() + c1 + c2 + c3);\n        shuffle(all_words.begin(), all_words.end());\n        if (n > (int)all_words.size())\n            n = all_words.size(); // Adjust n if necessary\n        for (int i = 0; i < n; ++i)\n            words.push_back(all_words[i]);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", words[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 100 -type random\n./gen -n 10000 -type random\n./gen -n 10000 -type few_letters -k 2\n./gen -n 10000 -type few_letters -k 3\n./gen -n 10000 -type few_letters -k 4\n./gen -n 10000 -type few_letters -k 5\n./gen -n 10000 -type few_letters -k 10\n./gen -n 24 -type same_letter\n./gen -n 576 -type palindrome\n./gen -n 5000 -type palindrome\n./gen -n 10000 -type edge_letters\n./gen -n 5000 -type edge_letters\n./gen -n 10000 -type random\n./gen -n 10000 -type random\n./gen -n 10000 -type random\n./gen -n 13824 -type random\n./gen -n 10000 -type few_letters -k 1\n./gen -n 1 -type few_letters -k 1\n./gen -n 13824 -type random\n./gen -n 10000 -type random\n./gen -n 5000 -type edge_letters\n./gen -n 10000 -type few_letters -k 24\n./gen -n 10000 -type random\n./gen -n 10000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:18:58.293409",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "384/A",
      "title": "A. Coder",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1000).",
      "output_spec": "OutputOn the first line print an integer, the maximum number of Coders that can be placed on the chessboard.On each of the next n lines print n characters, describing the configuration of the Coders. For an empty cell print an '.', and for a Coder print a 'C'.If there are multiple correct answers, you can print any.",
      "sample_tests": "ExamplesInputCopy2OutputCopy2C..C",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1000).\n\nOutputOn the first line print an integer, the maximum number of Coders that can be placed on the chessboard.On each of the next n lines print n characters, describing the configuration of the Coders. For an empty cell print an '.', and for a Coder print a 'C'.If there are multiple correct answers, you can print any.\n\nInputCopy2OutputCopy2C..C\n\nOutputCopy2C..C",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 384\\s*A"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 1000);\n    int maxCoders = (n * n + 1) / 2;\n\n    int k = ouf.readInt(0, n * n, \"k\");\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = ouf.readToken(format(\"[C\\\\.]{%d}\", n).c_str(), format(\"grid row %d\", i + 1).c_str());\n    }\n\n    int cCount = 0;\n\n    for (int i = 0; i < n; i++) {\n        if ((int)grid[i].length() != n)\n            ouf.quitf(_wa, \"Length of line %d is not equal to n.\", i + 1);\n\n        for (int j = 0; j < n; j++) {\n            char ch = grid[i][j];\n            if (ch == 'C') {\n                cCount++;\n                // check adjacent cells\n                if (i + 1 < n && grid[i + 1][j] == 'C')\n                    ouf.quitf(_wa, \"Coders at (%d,%d) and (%d,%d) attack each other.\", i + 1, j + 1, i + 2, j + 1);\n                if (j + 1 < n && grid[i][j + 1] == 'C')\n                    ouf.quitf(_wa, \"Coders at (%d,%d) and (%d,%d) attack each other.\", i + 1, j + 1, i + 1, j + 2);\n            } else if (ch != '.') {\n                ouf.quitf(_wa, \"Invalid character '%c' at position (%d,%d).\", ch, i + 1, j + 1);\n            }\n        }\n    }\n\n    if (cCount != k)\n        ouf.quitf(_wa, \"Number of 'C's in grid (%d) does not match k (%d).\", cCount, k);\n\n    if (k != maxCoders)\n        ouf.quitf(_wa, \"k (%d) is not maximum possible number of 'Coders' (%d).\", k, maxCoders);\n\n    quitf(_ok, \"Correct answer with maximum number of 'Coders' (%d).\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    // Ensure that n is within the bounds [1, 1000]\n    ensure(1 <= n && n <= 1000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    // Ensure that n is within the bounds [1, 1000]\n    ensure(1 <= n && n <= 1000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 16\n./gen -n 17\n./gen -n 31\n./gen -n 32\n./gen -n 63\n./gen -n 64\n./gen -n 99\n./gen -n 100\n./gen -n 256\n./gen -n 512\n./gen -n 999\n./gen -n 1000\n# Random values within bounds\n./gen -n 37\n./gen -n 73\n./gen -n 123\n./gen -n 456\n./gen -n 789\n./gen -n 987\n./gen -n 654\n./gen -n 321\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:00.523174",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "384/B",
      "title": "B. Multitasking",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n (1 ≤  n ≤ 1000), m (1 ≤ m ≤  100) and k. Integer k is 0 if the arrays must be sorted in ascending order, and 1 if the arrays must be sorted in descending order. Each line i of the next n lines contains m integers separated by a space, representing the i-th array. For each element x of the array i, 1 ≤ x ≤ 106 holds.",
      "output_spec": "OutputOn the first line of the output print an integer p, the size of the array (p can be at most ). Each of the next p lines must contain two distinct integers i and j (1 ≤ i, j ≤ m, i ≠ j), representing the chosen indices.If there are multiple correct answers, you can print any.",
      "sample_tests": "ExamplesInputCopy2 5 01 3 2 5 41 4 3 2 5OutputCopy32 42 34 5InputCopy3 2 11 22 33 4OutputCopy12 1",
      "description": "B. Multitasking\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n (1 ≤  n ≤ 1000), m (1 ≤ m ≤  100) and k. Integer k is 0 if the arrays must be sorted in ascending order, and 1 if the arrays must be sorted in descending order. Each line i of the next n lines contains m integers separated by a space, representing the i-th array. For each element x of the array i, 1 ≤ x ≤ 106 holds.\n\nOutputOn the first line of the output print an integer p, the size of the array (p can be at most ). Each of the next p lines must contain two distinct integers i and j (1 ≤ i, j ≤ m, i ≠ j), representing the chosen indices.If there are multiple correct answers, you can print any.\n\nInputCopy2 5 01 3 2 5 41 4 3 2 5OutputCopy32 42 34 5InputCopy3 2 11 22 33 4OutputCopy12 1\n\nInputCopy2 5 01 3 2 5 41 4 3 2 5\n\nOutputCopy32 42 34 5\n\nInputCopy3 2 11 22 33 4\n\nOutputCopy12 1\n\nNoteConsider the first sample. After the first operation, the arrays become [1, 3, 2, 5, 4] and [1, 2, 3, 4, 5]. After the second operation, the arrays become [1, 2, 3, 5, 4] and [1, 2, 3, 4, 5]. After the third operation they become [1, 2, 3, 4, 5] and [1, 2, 3, 4, 5].",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 384\\s*B"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1, \"k\");\n    inf.readEoln();\n    char varName[100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            sprintf(varName, \"array[%d][%d]\", i+1, j+1);\n            int x = inf.readInt(1, 1000000, varName);\n            if (j+1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1, \"k\");\n    inf.readEoln();\n    char varName[100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            sprintf(varName, \"array[%d][%d]\", i+1, j+1);\n            int x = inf.readInt(1, 1000000, varName);\n            if (j+1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1, \"k\");\n    inf.readEoln();\n    char varName[100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            sprintf(varName, \"array[%d][%d]\", i+1, j+1);\n            int x = inf.readInt(1, 1000000, varName);\n            if (j+1 < m)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nvector<vector<int>> a;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input from inf\n\n    n = inf.readInt(); // n\n    m = inf.readInt(); // m\n    k = inf.readInt(0, 1); // k\n\n    // Read n arrays of m integers\n    a.resize(n, vector<int>(m));\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            a[i][j] = inf.readInt(1, 1000000);\n        }\n    }\n\n    // Read contestant's output\n    int p = ouf.readInt(0, m * m, \"p\");\n\n    vector<pair<int, int>> swaps;\n\n    for(int step = 0; step < p; ++step) {\n        int i = ouf.readInt(1, m, format(\"swap %d: i\", step + 1).c_str());\n        int j = ouf.readInt(1, m, format(\"swap %d: j\", step + 1).c_str());\n        if(i == j) {\n            ouf.quitf(_wa, \"Swap indices must be different at step %d: i = %d, j = %d\", step + 1, i, j);\n        }\n        swaps.push_back({i-1, j-1}); // Convert to 0-based indexing for arrays\n    }\n\n    // Simulate swaps\n    for(auto& s : swaps) {\n        int i = s.first;\n        int j = s.second;\n        for(int idx = 0; idx < n; ++idx) {\n            if(a[idx][i] > a[idx][j]) {\n                swap(a[idx][i], a[idx][j]);\n            }\n        }\n    }\n\n    // Now check if arrays are sorted\n    for(int idx = 0; idx < n; ++idx) {\n        bool sorted = true;\n        for(int j = 0; j < m - 1; ++j) {\n            if(k == 0) { // Ascending order\n                if(a[idx][j] > a[idx][j+1]) {\n                    sorted = false;\n                    break;\n                }\n            } else { // k == 1, Descending order\n                if(a[idx][j] < a[idx][j+1]) {\n                    sorted = false;\n                    break;\n                }\n            }\n        }\n        if(!sorted) {\n            ouf.quitf(_wa, \"Array %d is not sorted in %s order after applying swaps\", idx + 1, k == 0 ? \"ascending\" : \"descending\");\n        }\n    }\n\n    // If we reach here, the answer is accepted\n    quitf(_ok, \"All arrays sorted in %s order\", k == 0 ? \"ascending\" : \"descending\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    for (int arr = 0; arr < n; ++arr) {\n        vector<int> a(m);\n        if (type == \"sorted\") {\n            if (k == 0) {\n                // ascending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = i+1;\n            } else {\n                // descending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = m - i;\n            }\n        } else if (type == \"reverse\") {\n            if (k == 0) {\n                // descending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = m - i;\n            } else {\n                // ascending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = i+1;\n            }\n        } else if (type == \"random\") {\n            for (int i = 0; i < m; ++i)\n                a[i] = rnd.next(1, 1000000);\n        } else if (type == \"all_equal\") {\n            int val = rnd.next(1,1000000);\n            for (int i = 0; i < m; ++i)\n                a[i] = val;\n        } else if (type == \"duplicates\") {\n            int num_values = rnd.next(1, min(10, m));\n            vector<int> values;\n            for (int i = 0; i < num_values; ++i)\n                values.push_back(rnd.next(1, 1000000));\n            for (int i = 0; i < m; ++i)\n                a[i] = values[rnd.next(0, num_values - 1)];\n        } else if (type == \"max_elements\") {\n            int val = 1000000;\n            for (int i = 0; i < m; ++i)\n                a[i] = val;\n        } else if (type == \"min_elements\") {\n            int val = 1;\n            for (int i = 0; i < m; ++i)\n                a[i] = val;\n        } else if (type == \"worst_case\") {\n            // Generate arrays in reverse order to required sort order\n            if (k == 0) {\n                // descending order, so arrays are reverse sorted\n                for (int i = 0; i < m; ++i)\n                    a[i] = m - i;\n            } else {\n                // ascending order, so arrays are sorted ascending\n                for (int i = 0; i < m; ++i)\n                    a[i] = i+1;\n            }\n        } else if (type == \"random_permutation\") {\n            // Random permutation of 1..m\n            vector<int> perm(m);\n            for (int i = 0; i < m; ++i)\n                perm[i] = i+1;\n            shuffle(perm.begin(), perm.end());\n            for (int i = 0; i < m; ++i)\n                a[i] = perm[i];\n        } else {\n            // default to random\n            for (int i = 0; i < m; ++i)\n                a[i] = rnd.next(1, 1000000);\n        }\n\n        // Output this array\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", a[i]);\n            if (i+1 == m) printf(\"\\n\");\n            else printf(\" \");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    for (int arr = 0; arr < n; ++arr) {\n        vector<int> a(m);\n        if (type == \"sorted\") {\n            if (k == 0) {\n                // ascending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = i+1;\n            } else {\n                // descending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = m - i;\n            }\n        } else if (type == \"reverse\") {\n            if (k == 0) {\n                // descending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = m - i;\n            } else {\n                // ascending order\n                for (int i = 0; i < m; ++i)\n                    a[i] = i+1;\n            }\n        } else if (type == \"random\") {\n            for (int i = 0; i < m; ++i)\n                a[i] = rnd.next(1, 1000000);\n        } else if (type == \"all_equal\") {\n            int val = rnd.next(1,1000000);\n            for (int i = 0; i < m; ++i)\n                a[i] = val;\n        } else if (type == \"duplicates\") {\n            int num_values = rnd.next(1, min(10, m));\n            vector<int> values;\n            for (int i = 0; i < num_values; ++i)\n                values.push_back(rnd.next(1, 1000000));\n            for (int i = 0; i < m; ++i)\n                a[i] = values[rnd.next(0, num_values - 1)];\n        } else if (type == \"max_elements\") {\n            int val = 1000000;\n            for (int i = 0; i < m; ++i)\n                a[i] = val;\n        } else if (type == \"min_elements\") {\n            int val = 1;\n            for (int i = 0; i < m; ++i)\n                a[i] = val;\n        } else if (type == \"worst_case\") {\n            // Generate arrays in reverse order to required sort order\n            if (k == 0) {\n                // descending order, so arrays are reverse sorted\n                for (int i = 0; i < m; ++i)\n                    a[i] = m - i;\n            } else {\n                // ascending order, so arrays are sorted ascending\n                for (int i = 0; i < m; ++i)\n                    a[i] = i+1;\n            }\n        } else if (type == \"random_permutation\") {\n            // Random permutation of 1..m\n            vector<int> perm(m);\n            for (int i = 0; i < m; ++i)\n                perm[i] = i+1;\n            shuffle(perm.begin(), perm.end());\n            for (int i = 0; i < m; ++i)\n                a[i] = perm[i];\n        } else {\n            // default to random\n            for (int i = 0; i < m; ++i)\n                a[i] = rnd.next(1, 1000000);\n        }\n\n        // Output this array\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", a[i]);\n            if (i+1 == m) printf(\"\\n\");\n            else printf(\" \");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 0 -type sorted\n./gen -n 1 -m 1 -k 1 -type sorted\n./gen -n 1 -m 1 -k 0 -type random\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 2 -m 2 -k 0 -type sorted\n./gen -n 2 -m 2 -k 1 -type sorted\n./gen -n 2 -m 2 -k 0 -type reverse\n./gen -n 2 -m 2 -k 1 -type reverse\n./gen -n 2 -m 2 -k 0 -type random\n./gen -n 2 -m 2 -k 1 -type random\n\n./gen -n 10 -m 20 -k 0 -type random\n./gen -n 10 -m 20 -k 1 -type random\n./gen -n 10 -m 20 -k 0 -type all_equal\n./gen -n 10 -m 20 -k 1 -type all_equal\n./gen -n 10 -m 20 -k 0 -type duplicates\n./gen -n 10 -m 20 -k 1 -type duplicates\n\n./gen -n 100 -m 100 -k 0 -type random\n./gen -n 100 -m 100 -k 1 -type random\n./gen -n 100 -m 100 -k 0 -type sorted\n./gen -n 100 -m 100 -k 1 -type sorted\n./gen -n 100 -m 100 -k 0 -type reverse\n./gen -n 100 -m 100 -k 1 -type reverse\n\n./gen -n 1000 -m 100 -k 0 -type random\n./gen -n 1000 -m 100 -k 1 -type random\n./gen -n 1000 -m 100 -k 0 -type worst_case\n./gen -n 1000 -m 100 -k 1 -type worst_case\n\n./gen -n 1000 -m 100 -k 0 -type max_elements\n./gen -n 1000 -m 100 -k 1 -type min_elements\n./gen -n 1000 -m 100 -k 0 -type duplicates\n./gen -n 1000 -m 100 -k 1 -type duplicates\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:02.337463",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "384/C",
      "title": "C. Доим коров",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 200000). Вторая строка содержит n целых чисел a1, a2, ..., an, где ai равняется 0, если корова номер i смотрит налево и 1, если корова смотрит направо.",
      "output_spec": "Выходные данныеВыведите единственное целое число, минимальное количество потерянного молока.Пожалуйста, не используйте спецификатор %lld для чтения и записи 64 битных целых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать40 0 1 0Выходные данныеСкопировать1Входные данныеСкопировать51 0 1 0 1Выходные данныеСкопировать3",
      "description": "C. Доим коров\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 200000). Вторая строка содержит n целых чисел a1, a2, ..., an, где ai равняется 0, если корова номер i смотрит налево и 1, если корова смотрит направо.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число, минимальное количество потерянного молока.Пожалуйста, не используйте спецификатор %lld для чтения и записи 64 битных целых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать40 0 1 0Выходные данныеСкопировать1Входные данныеСкопировать51 0 1 0 1Выходные данныеСкопировать3\n\nВходные данныеСкопировать40 0 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 0 1 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере Яхуб доит коров в следующем порядке: корова 3, корова 4, корова 2, корова 1. Когда он доит корову 3, корова 4 теряет 1 единицу молока. Больше молоко не теряется.",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Привет всем!Мы приглашаем вас поучаствовать в Codeforces Round #225, который состоится в понедельник 20-го января в 19:30 по московскому времени. Это третий раунд, где я участвую в качестве автора (другие два: Codeforces Round #198 и Codeforces Round #191 (Div. 2)).Если вы посмотрите мои прошлые раунды, то увидите, что главный герой задач — Яхуб. Один из авторов этого раунда — ... Яхуб... реальный человек, с которого взят главный герой задач. Знакомьтесь, Rares Buhai (rares.buhai), он же Яхуб. Он является автором задач Div. 2 C / Div. 1 A, Div. 1 D и Div. 1 E. Скорей всего, задачи покажутся вам интересными, поскольку их автор два раза становился золотым медалистом IOI (и он может участвовать еще два раза). Все остальные задачи готовил я. Они мне нравятся, но я буду не объективным, если скажу, что они интересные. Посмотрим, что скажут участники после контеста :)Как и в прошлый раз, будет небольшой спойлер по поводу задач. Мы постарались сделать задачи разнообразными, насколько это возможно. Чтобы занять высокое место, человек должен уметь решать задачи типа “ad-hoc”, а также иметь хорошие алгоритмические знания.Как обычно, мы благодарим MikeMirzayanov за Codeforces, Delinur за перводы задач, Gerald за помощь в подготовке раунда и DamianS и ll931110 за тестирование.Желаем вам высокого рейтинга и фана от задач!UPD Распределение баллов Дивизион 1: 500 — 1500 — 1500 — 2000 — 2500Дивизион 2: 500 — 1000 — 1500 — 2500 — 2500UPD Контест закончился! Спасибо всем, кто участвовал! Должен сказать, что мы были сильно удивлены вашими необычными решениями задачи D в первом дивизионе.Победители Div. 1: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Победители Div. 2: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1748
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 384\\s*C"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_left\") {\n        /* All cows facing left */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_right\") {\n        /* All cows facing right */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternate\") {\n        /* Alternate facing cows */\n        for(int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"blocks\") {\n        /* Cows facing in blocks */\n        int block_size = max(1, n / 4);\n        for(int i = 0; i < n; ++i)\n            a[i] = (i / block_size) % 2;\n    } else if (type == \"front_left\") {\n        /* First k cows facing left, rest random */\n        int k = opt<int>(\"k\", n / 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = i < k ? 0 : rnd.next(0, 1);\n    } else if (type == \"front_right\") {\n        /* First k cows facing right, rest random */\n        int k = opt<int>(\"k\", n / 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = i < k ? 1 : rnd.next(0, 1);\n    } else {\n        /* Random orientations */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output a_i */\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_left\") {\n        /* All cows facing left */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_right\") {\n        /* All cows facing right */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternate\") {\n        /* Alternate facing cows */\n        for(int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"blocks\") {\n        /* Cows facing in blocks */\n        int block_size = max(1, n / 4);\n        for(int i = 0; i < n; ++i)\n            a[i] = (i / block_size) % 2;\n    } else if (type == \"front_left\") {\n        /* First k cows facing left, rest random */\n        int k = opt<int>(\"k\", n / 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = i < k ? 0 : rnd.next(0, 1);\n    } else if (type == \"front_right\") {\n        /* First k cows facing right, rest random */\n        int k = opt<int>(\"k\", n / 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = i < k ? 1 : rnd.next(0, 1);\n    } else {\n        /* Random orientations */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output a_i */\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_left\n./gen -n 1 -type all_right\n./gen -n 2 -type alternate\n./gen -n 2 -type random\n./gen -n 10 -type all_left\n./gen -n 10 -type all_right\n./gen -n 10 -type alternate\n./gen -n 10 -type blocks\n./gen -n 10 -type random\n\n./gen -n 100 -type all_left\n./gen -n 100 -type all_right\n./gen -n 100 -type alternate\n./gen -n 100 -type blocks\n./gen -n 100 -type random\n\n./gen -n 1000 -type all_left\n./gen -n 1000 -type all_right\n./gen -n 1000 -type alternate\n./gen -n 1000 -type blocks\n./gen -n 1000 -type random\n\n./gen -n 10000 -type all_left\n./gen -n 10000 -type all_right\n./gen -n 10000 -type alternate\n./gen -n 10000 -type blocks\n./gen -n 10000 -type random\n\n./gen -n 100000 -type all_left\n./gen -n 100000 -type all_right\n./gen -n 100000 -type alternate\n./gen -n 100000 -type blocks\n./gen -n 100000 -type random\n\n./gen -n 200000 -type all_left\n./gen -n 200000 -type all_right\n./gen -n 200000 -type alternate\n./gen -n 200000 -type blocks\n./gen -n 200000 -type front_left -k 100000\n./gen -n 200000 -type front_right -k 100000\n./gen -n 200000 -type random\n\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:04.545902",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "384/D",
      "title": "D. Volcanoes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n (1 ≤ n ≤ 109) and m (1 ≤ m ≤ 105). Each of the next m lines contains a pair of integers, x and y (1 ≤ x, y ≤ n), representing the coordinates of the volcanoes.Consider matrix rows are numbered from 1 to n from top to bottom, and matrix columns are numbered from 1 to n from left to right. There is no volcano in cell (1, 1). No two volcanoes occupy the same location.",
      "output_spec": "OutputPrint one integer, the minimum time in which Iahub can arrive at cell (n, n). If no solution exists (there is no path to the final cell), print -1.",
      "sample_tests": "ExamplesInputCopy4 21 31 4OutputCopy6InputCopy7 81 62 63 53 64 35 15 25 3OutputCopy12InputCopy2 21 22 1OutputCopy-1",
      "description": "D. Volcanoes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n (1 ≤ n ≤ 109) and m (1 ≤ m ≤ 105). Each of the next m lines contains a pair of integers, x and y (1 ≤ x, y ≤ n), representing the coordinates of the volcanoes.Consider matrix rows are numbered from 1 to n from top to bottom, and matrix columns are numbered from 1 to n from left to right. There is no volcano in cell (1, 1). No two volcanoes occupy the same location.\n\nOutputPrint one integer, the minimum time in which Iahub can arrive at cell (n, n). If no solution exists (there is no path to the final cell), print -1.\n\nInputCopy4 21 31 4OutputCopy6InputCopy7 81 62 63 53 64 35 15 25 3OutputCopy12InputCopy2 21 22 1OutputCopy-1\n\nInputCopy4 21 31 4\n\nOutputCopy6\n\nInputCopy7 81 62 63 53 64 35 15 25 3\n\nOutputCopy12\n\nInputCopy2 21 22 1\n\nOutputCopy-1\n\nNoteConsider the first sample. A possible road is: (1, 1)  →  (1, 2)  →  (2, 2)  →  (2, 3)  →  (3, 3)  →  (3, 4)  →  (4, 4).",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 384\\s*D"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > volcanoes;\n\n    for (int i = 0; i < m; ++i) {\n        int x_i = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x_i != 1 || y_i != 1, \"There is a volcano at position (1,1)\");\n\n        auto p = make_pair(x_i, y_i);\n        ensuref(volcanoes.find(p) == volcanoes.end(), \"Volcano at position (%d,%d) appears more than once\", x_i, y_i);\n\n        volcanoes.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > volcanoes;\n\n    for (int i = 0; i < m; ++i) {\n        int x_i = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x_i != 1 || y_i != 1, \"There is a volcano at position (1,1)\");\n\n        auto p = make_pair(x_i, y_i);\n        ensuref(volcanoes.find(p) == volcanoes.end(), \"Volcano at position (%d,%d) appears more than once\", x_i, y_i);\n\n        volcanoes.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > volcanoes;\n\n    for (int i = 0; i < m; ++i) {\n        int x_i = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x_i != 1 || y_i != 1, \"There is a volcano at position (1,1)\");\n\n        auto p = make_pair(x_i, y_i);\n        ensuref(volcanoes.find(p) == volcanoes.end(), \"Volcano at position (%d,%d) appears more than once\", x_i, y_i);\n\n        volcanoes.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<long long, long long> > volcanoes;\n\n    if (type == \"no_volcanoes\") {\n        // No volcanoes, m = 0\n        m = 0;\n    } else if (type == \"block_initial\") {\n        // Place volcanoes blocking movement from the start\n        volcanoes.insert({1, 2});\n        volcanoes.insert({2, 1});\n        m = volcanoes.size();\n    } else if (type == \"block_final\") {\n        // Place volcano blocking the destination\n        volcanoes.insert({n, n});\n        m = volcanoes.size();\n    } else if (type == \"no_solution_small\") {\n        // For small n, block all possible paths by blocking row 1 and column 1\n        if (n > 500) {\n            fprintf(stderr, \"n is too large for 'no_solution_small' type (max n = 500)\\n\");\n            exit(1);\n        }\n        for (long long i = 2; i <= n; ++i) {\n            volcanoes.insert({1, i}); // Block row 1\n            volcanoes.insert({i, 1}); // Block column 1\n        }\n        m = volcanoes.size();\n    } else if (type == \"max_m\") {\n        // Set m to the maximum possible, considering the limits\n        long long max_m = min(n * n - 1, (long long)1e5);\n        m = max_m;\n        // Generate m random volcano positions, not including (1,1)\n        while (volcanoes.size() < m) {\n            long long x = rnd.next(1LL, n);\n            long long y = rnd.next(1LL, n);\n            if (x == 1 && y == 1)\n                continue;\n            volcanoes.insert({x, y});\n        }\n    } else if (type == \"random\") {\n        // Use provided m, adjusted to limits\n        long long max_m = min((long long)m, n * n - 1);\n        m = max_m;\n        while (volcanoes.size() < m) {\n            long long x = rnd.next(1LL, n);\n            long long y = rnd.next(1LL, n);\n            if (x == 1 && y == 1)\n                continue;\n            volcanoes.insert({x, y});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%lld %d\\n\", n, m);\n\n    // Output volcano positions\n    for (auto &p : volcanoes) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<long long, long long> > volcanoes;\n\n    if (type == \"no_volcanoes\") {\n        // No volcanoes, m = 0\n        m = 0;\n    } else if (type == \"block_initial\") {\n        // Place volcanoes blocking movement from the start\n        volcanoes.insert({1, 2});\n        volcanoes.insert({2, 1});\n        m = volcanoes.size();\n    } else if (type == \"block_final\") {\n        // Place volcano blocking the destination\n        volcanoes.insert({n, n});\n        m = volcanoes.size();\n    } else if (type == \"no_solution_small\") {\n        // For small n, block all possible paths by blocking row 1 and column 1\n        if (n > 500) {\n            fprintf(stderr, \"n is too large for 'no_solution_small' type (max n = 500)\\n\");\n            exit(1);\n        }\n        for (long long i = 2; i <= n; ++i) {\n            volcanoes.insert({1, i}); // Block row 1\n            volcanoes.insert({i, 1}); // Block column 1\n        }\n        m = volcanoes.size();\n    } else if (type == \"max_m\") {\n        // Set m to the maximum possible, considering the limits\n        long long max_m = min(n * n - 1, (long long)1e5);\n        m = max_m;\n        // Generate m random volcano positions, not including (1,1)\n        while (volcanoes.size() < m) {\n            long long x = rnd.next(1LL, n);\n            long long y = rnd.next(1LL, n);\n            if (x == 1 && y == 1)\n                continue;\n            volcanoes.insert({x, y});\n        }\n    } else if (type == \"random\") {\n        // Use provided m, adjusted to limits\n        long long max_m = min((long long)m, n * n - 1);\n        m = max_m;\n        while (volcanoes.size() < m) {\n            long long x = rnd.next(1LL, n);\n            long long y = rnd.next(1LL, n);\n            if (x == 1 && y == 1)\n                continue;\n            volcanoes.insert({x, y});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%lld %d\\n\", n, m);\n\n    // Output volcano positions\n    for (auto &p : volcanoes) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, no volcanoes\n./gen -n 2 -type no_volcanoes\n\n# Small n, random volcanoes\n./gen -n 3 -m 1 -type random\n./gen -n 10 -m 5 -type random\n\n# Small n, block initial position\n./gen -n 5 -type block_initial\n\n# Small n, block final position\n./gen -n 5 -type block_final\n\n# Small n, no solution\n./gen -n 3 -type no_solution_small\n./gen -n 10 -type no_solution_small\n\n# Medium n, random volcanoes\n./gen -n 1000 -m 500 -type random\n\n# Medium n, max m\n./gen -n 1000 -type max_m\n\n# Large n, no volcanoes\n./gen -n 1000000000 -type no_volcanoes\n\n# Large n, block initial\n./gen -n 1000000000 -type block_initial\n\n# Large n, block final\n./gen -n 1000000000 -type block_final\n\n# Large n, max m\n./gen -n 1000000000 -type max_m\n\n# Large n, random volcanoes\n./gen -n 1000000000 -m 100000 -type random\n\n# Edge cases\n./gen -n 1 -type no_volcanoes\n./gen -n 1 -type block_final\n./gen -n 1 -type block_initial\n\n# n is large, m is zero\n./gen -n 1000000000 -type no_volcanoes\n\n# n is small, m is zero\n./gen -n 5 -type no_volcanoes\n\n# n is small, m is small\n./gen -n 10 -m 20 -type random\n\n# n is medium, m is medium\n./gen -n 100000 -m 100000 -type random\n\n# n is large, m is large\n./gen -n 1000000000 -m 100000 -type random\n\n# Test possible overflows\n./gen -n 1000000000 -type no_volcanoes\n\n# Another overflows test\n./gen -n 999999999 -type no_volcanoes\n\n# Test with maximal m\n./gen -n 1000 -type max_m\n\n# Test with minimal n and m\n./gen -n 1 -m 0 -type random\n\n# Test with m exceeding total possible positions\n./gen -n 10 -m 200 -type random\n\n# Test with m zero\n./gen -n 1000000000 -m 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:07.310204",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "384/E",
      "title": "E. Propagating tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000). Each of the next n–1 lines contains two integers vi and ui (1 ≤ vi, ui ≤ n), meaning that there is an edge between nodes vi and ui.Each of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.",
      "output_spec": "OutputFor each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.",
      "sample_tests": "ExamplesInputCopy5 51 2 1 1 21 21 32 42 51 2 31 1 22 12 22 4OutputCopy330",
      "description": "E. Propagating tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000). Each of the next n–1 lines contains two integers vi and ui (1 ≤ vi, ui ≤ n), meaning that there is an edge between nodes vi and ui.Each of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.\n\nOutputFor each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.\n\nInputCopy5 51 2 1 1 21 21 32 42 51 2 31 1 22 12 22 4OutputCopy330\n\nInputCopy5 51 2 1 1 21 21 32 42 51 2 31 1 22 12 22 4\n\nOutputCopy330\n\nNoteThe values of the nodes are [1, 2, 1, 1, 2] at the beginning.Then value 3 is added to node 2. It propagates and value -3 is added to it's sons, node 4 and node 5. Then it cannot propagate any more. So the values of the nodes are [1, 5, 1,  - 2,  - 1].Then value 2 is added to node 1. It propagates and value -2 is added to it's sons, node 2 and node 3. From node 2 it propagates again, adding value 2 to it's sons, node 4 and node 5. Node 3 has no sons, so it cannot propagate from there. The values of the nodes are [3, 3,  - 1, 0, 1].You can see all the definitions about the tree at the following link: http://en.wikipedia.org/wiki/Tree_(graph_theory)",
      "solutions": [
        {
          "title": "Codeforces Round #225 - Codeforces",
          "content": "Hello everyone!We invite you to participate at Codeforces Round #225, scheduled Monday, 20th January at 7:30 PM MSK. This is the third round I coauthor, along with Codeforces Round 198 (Div. 1) (and of course Div. 2 version of contest) and Codeforces Round 191 (Div. 2). If you recall my old rounds, you'll see that main character is Iahub. The other writer of this round is... Iahub... the real person corresponding to \"Iahub\" character. Let me introduce you to Rares Buhai (rares.buhai). He's the author of Div. 2 C / Div. 1 A, Div. 1 D and Div. 1 E. You can expect those problems to be interesting, coming from a 2 times IOI gold medalist (being allowed to participate 2 more times). All other problems are created by me. I like them, but I wouldn't be objective if I said that they're interesting. Let's see if someone will think so after the contest :)Like last time, I'll give you a little spoiler about the tasks. We tried to make the problem set as varied as possible. In order to get a good rank, one needs to be good at \"ad hoc\" problems as well as have good algorithmic knowledge.As always, thanks to MikeMirzayanov for Codeforces platform, to Delinur for translating tasks, to Gerald for helping us prepare the round and to DamianS and ll931110 for testing it.We wish everyone high rating and to have fun!UPD Score distribution:Division 1: 500 — 1500 — 1500 — 2000 — 2500Division 2: 500 — 1000 — 1500 — 2500 — 2500UPD Contest is over! Thanks for everyone who participated! I need to say we're impressed of your creative and totally unexpected solutions for Division 1 D.Div. 1 winners: yeputons Arcueid Dmitry_Egorov ACMonster scott_wu Div. 2 winners: Sick_coder akaring c0d3junki3 raihatneloy sky0917 UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10448",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1727
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces",
          "content": "384A - CoderUsually, when you don’t have any idea how to approach a problem, a good try is to take some small examples.So let’s see how it looks for N = 1, 2, 3, 4 and 5. With C I noted the coder and with * I noted an empty cell.By now you should note that answer is N ^ 2 / 2 when N is even and (N ^ 2 + 1) / 2 when N is odd. Good. Generally, after you find a possible solution by taking examples, you need to prove it, then you can code it.In order to proof it, one needs to do following steps:1/ prove you can always build a solution having N ^ 2 / 2 (or (N ^ 2 + 1) / 2) pieces.2/ prove that N ^ 2 / 2 (or (N ^ 2 + 1) / 2) is maximal number – no other bigger solution can be obtained.For proof 1/ imagine you do coloring like in a chess table.The key observation is that by placing all coders on black squares of table, no two coders will attack. Why? Because a piece placed at a black square can attack only a piece placed at a white square. Again, why? Suppose chess table is 1-based. Then, a square (i, j) is black if and only if i + j is even. A piece placed at (i, j) can attack (i + 1, j), (i – 1, j) (i, j + 1) or (i, j – 1). The sum of those cells is i + j + 1 or i + j – 1. But since i + j is even, i + j + 1 and i + j – 1 are odd, hence white cells.Depending on parity of N, number of black cells is either N ^ 2 / 2 or (N ^ 2 + 1) / 2. For N even, one can observe that there are equal amount of black and white cells. Total number of cells is N ^ 2, so number of black cells is N ^ 2 / 2. For N odd, number of black cells is number of white cells + 1. We can imaginary add a white cell to the board. Now, number of black cells will be also equal to number of white cells, so answer is (N ^ 2 + 1) / 2.2/ Two coders attack each other if they are placed at two adjacent cells, one black and other one white. One needs to prove that adding more than number from 1/ will cause this to happen. If you place a coder at a white cell, you won’t be able to place at least one coder at a black cell, so in best case you don’t win anything by doing this. Hence, it’s optimally to place all coders on same color cells. Since cells colored in black are always more or equal to white ones, it’s always optimally to choose black color. But number from 1/ is the number of cells having black color. Adding one more piece will force you to add it to a white color cell. Now, you’ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell, so two coders will attack. Hence, we can’t place more than number from 1/ pieces.Code: http://pastie.org/8651801384B - MultitaskingLet’s start by saying when array A[] is sorted:1/ is sorted in ascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j and A[i] > A[j].2/ is sorted in descending order when i > j and A[i] <= A[j]. It is NOT sorted when i > j and A[i] > A[j].Iahub can choose 2 indices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he’ll ignore operation. Hence, if he wants to sort all arrays in ascending order, he chooses indices i, j when i < j and perform operation. Otherwise, in all his operations he uses indices i, j such as i > j. A “good” operation is when choosing indices i < j for ascending order sorting and i > j for descending order sorting. By doing only good operations, after an array is sorted, it will stay sorted forever (for a sorted array, all good operations will be ignored).From here we get our first idea: use any sorting algorithm you know and sort each array individually. When print swaps done by sorting algorithm chosen, print them as good operations. However, sorting each array individually can cause exceeding M * (M — 1) / 2 operations limit. Another possible solution would be, after you did an operation to an array, to update the operation to all arrays (you printed it, so it counts to M * (M — 1) / 2 operations limit; making it to all arrays will help sometimes and in worst case it won’t change anything). However, you need to code it very careful in order to make this algorithm pass the time limit. Doing this in a contest is not the best idea, especially when implementation could be complicated and you have no guarantee it will pass time limit.So what else can we do? We can think out of box. Instead of sorting specific N arrays, you can sort all possible arrays of length M. Find a sequence of good operations such as, anyhow I’d choose an array of size M, it will get sorted ascending / descending.I’ll show firstly how to do for ascending sorting. At position 1 it needs to be minimal element. Can we bring minimal element there using good operations? Yes. Just do “1 2” “1 3” “1 4” ... “1 M”. It basically compares element from position 1 to any other element from array. When other element has smaller value, swap is done. After comparing with all M elements, minimal value will be at position 1. By now on I’ll ignore position 1 and move to position 2. Suppose array starts from position 2. It also needs minimal value from array, except value from position 1 (which is no longer in array). Hence doing “2 3” “2 4” “2 5” ... “2 M” is enough, by similar reasons. For a position i, I need minimal value from array, except positions 1, 2, ..., i – 1. I simply do “i i+1” “i i+2” ... “i M-1” “i M”. By arriving at position i, array will be sorted ascending. The algorithm is simply:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << i << “ “ << j << “\\n”;This algorithm does exactly M * (M — 1) / 2 moves.Can you find out how to sort array in descending order? Try to think yourself, then if you don’t get it read next. At first position of a descending array it needs to be maximal value. Similarly to ascending order, we can do “2 1” “3 1” “4 1” ... “M 1”. When I’m at a position i and I compare its value to value from position 1, doing operation “i 1” checks if A[i] > A[1]. If so, it swaps A[i] and A[1], so position 1 will contain now the maximum value so far. Similarly to logic from ascending order, when I’m at position i, I need maximum value from array except positions 1, 2, ..., i – 1, so I do “i+1 i” “i+2 i” ... “M i”. Algorithm is:for (int i = 1; i < M; ++i)for (int j = i + 1; j <= M; ++j)cout << j << “ “ << i << “\\n”;Obviously, this does as well M * (M — 1) / 2 operations worst case. All algorithm is about 10 lines of code, much better than other solution, which requires two manually sorts and also has a chance to exceed TL.Code: http://pastie.org/8651809384C - Milking cowsA good strategy to approach this problem is to think how optimal ordering should look like. For this, let’s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j. As we’ll show, having this information will be enough to build optimal ordering. It is enough to consider only cases when i < j, case when i > j is exactly the opposite of case i < j. For formality, I’ll call the optimal ordering permutation and lost milk the cost of permutation.So, for an optimal permutation P let’s take 2 numbers i < j and see in which cases i should appear before j in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we’ll call i is after j). We have 4 possible cases:1/ A[i] = 0 and A[j] = 0If we put i before j, no additional cost will be added. Since j is in right of i and i only adds cost when it finds elements in left of i, j won’t be affected when processing i. When processing j, i will be already deleted so it won’t affect the cost either. Hence, we can put i before j and no cost will be added.2/ A[i] = 0 and A[j] = 1Here, i and j can appear in arbitrary order in permutation (i can be before or after j). No matter how we choose them, they won’t affect each other and cost will remain the same.3/ A[i] = 1 and A[j] = 0As well, here i and j can appear in arbitrary order. If we choose i first, j will be in right of it, so cost of permutation will increase by one. If we choose j first, i will be in left of it so cost of permutation will increase as well. No matter what we do, in this case cost of permutation increases by 1.4/ A[i] = 1 and A[j] = 1Here, i needs to be after j. This adds 0 cost. Taking i before j will add 1 cost to permutation (since j is in right of i).Those 4 cases show us how a minimal cost permutation should look. In a permutation like this, only case 3/ contributes to final cost, so we need to count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a permutation following all rules exists, task reduces to (*).By cases 2/ and 3/ it follows that in an optimal permutation, it only matters order of elements having same value in A[]. We can put firstly all elements having value 0 in A[], then all elements having value 1 in A[]. We can order elements having value 0 by case 1/ and elements having value 1 by case 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always be built.Hence, task reduces to (*): count number of indices i, j such as i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N) algorithm to do this. Let’s build an array cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We can easily implement it by going backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.Code: http://pastie.org/8651813384D - VolcanoesOur first observation is that if there is a path from (1, 1) to (N, N), then the length of path is 2 * N – 2. Since all paths have length 2 * N – 2, it follows that if there is at least one path, the answer is 2 * N – 2 and if there isn’t, the answer is -1. How to prove it? Every path from (1, 1) to (N, N) has exactly N – 1 down directions and exactly N – 1 right directions. So, total length for each path is N – 1 + N – 1 = 2 * N – 2. So we reduced our problem to determine if there is at least one path from (1, 1) to (N, N). This is the challenging part of this task, considering that N <= 10 ^ 9. How would you do it for a decently small N, let’s say N <= 10^3 . One possible approach would be, for each row, keep a set of reachable columns. We could easily solve this one by doing this: if (i, j) denotes element from ith row and jth column, then (i, j) is (is not) reachable if:if (i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if at least one of (i – 1, j) and (i, j – 1) is reachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.What’s the main problem of this approach? It needs to keep track of 10^9 lines and in worst case, each of those lines can have 10^9 reachable elements. So, worst case we need 10^9 * 10^9 = 10^18 operations and memory.Can we optimize it? We can note for beginning that we don’t need to keep track of 10^9 lines, only m lines are really necessarily. We need only lines containing at least one obstacle (in worst case when each line contains only one obstacle, we need m lines). How to solve it this way? Suppose line number x contains some obstacles and lines x + 1, x + 2, x + 3 do not contain any obstacle. Suppose we calculated set S = {y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding to lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is minimal value from set S. Then, we can also reach {ymin + 1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1, ..., N}. How do S2 and S3 look? It’s easy to see that they’ll be as well {ymin, ymin + 1, ..., N}. So we get following optimization: suppose set of lines containing at least one obstacle is {L1, L2, ..., Lk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ..., Lk, Lk + 1.It looks like we didn’t make anything with this optimization. Even if we calculate for m lines, each line can still have 10^9 reachable positions. So worst case we perform 10^14 operations. We need something better for managing information from a line. You can note that for a given line y, there are a lot of positions having consecutive values. There are a lot of positions (x, y) and (x, y + 1) both reachable. This should give us following idea: what if instead of keeping reachable positions, we keep reachable ranges? That is, for each line x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <= k <= b are reachable}. How many ranges can it be for a line? If the line contains m obstacles, there are m + 1 ranges. Suppose for line x all cells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x + 1, N – 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4, 4], [6, N – 2] and [N, N]. By now, we get worst case m lines and worst case each line having m elements, so in worst case we’d have to handle m * m = 10 ^ 10 events. This may still look too much, but happily this bound is over estimated. If a line has o obstacles, there can be at most o + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles, there’ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... + ok = m and also k is at most m (proved above why we’re interested in at most m lines), so in worst case we get m + m = 2 * m ranges. Yaay, finally a decent number of states for this problem :)So, we iterate each line we’re interested in. Let’s find set of ranges for this line, thinking that all cells from line above are reachable. This is easy to do. After we get our ranges like all cells from above can be visited, let’s think how having obstacles above can influence current ranges. After adding ranges from above, current ranges can’t increase (obviously), they can only decrease, remain the same or some of them can become empty. So, let’s take each range [a, b] from current line and see how it will transform after adding ranges from previous line. Given range [a, b], it can transform only in [a’ , b] with a’ >= a. If a’ > b, then obviously range is empty. Why second number of range keeps constant? Let a’ smallest reachable column from current line which is in range [a, b]. It’s enough to check a’ >= a, as if a’ > b, range will be empty. It’s obviously why we need to keep a’ smallest value possible >= a: we’re interested to keep range as big as possible and as less as we cut from left, as big it is. Once we’ve found a’ in range [a, b] (or a’ > b if range is empty) all cells {a’ + 1, a’ + 2, ..., b} are reachable as well by going right from a’, so if interval is not empty, then second number defining it remains b.Next question is how to find a’ fast enough. In order a point a’ to be reachable on current range, it also needs to exist a range on previous line containing it. If the range from previous line is [pa, pb] then a’ needs to follow 3 conditions:a’ minimal such aspa <= a’ <= pba’ >= aWhat if instead of finding a’ we find [pa, pb]? Then a’ is max(pa, a). In order a’ to be as small as possible, since a is constant, pa needs to be as small as possible. So we reduced it to:pa minimal pb >= a’ >= a <=> pb >= aIntervals from previous line are disjoint, no 2 intervals cross each other. It means that if pb is minimal, than pa is minimal too (if we increase pb, then pa will increase too, so it won’t be minimal). Hence, you need to find an interval [pa, pb] such as pb is minimal and pb >= a. Then, a’ is max(a, pa). This is easy to do if we sort all intervals from previous line increasing by second value (pb), then we binary search for value a. Finally, after running algorithm for all lines, last range from last line has second number N (assuming ranges are sorted increasing by second value), then there exist a path, otherwise there does not exist. This algorithm should run O(m * logm) worst case, good enough to pass. Code: http://pastie.org/8651817384E - Propagating treeThis is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.Now suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added –val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a –val. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added –val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.From here we have the idea to split nodes of tree in 2 sets – those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?The answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Let’s build 3 arrays now – discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = what’s last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3Discover is {1, 5, 6, 7, 4, 2, 3}.begin is {1, 6, 7, 5, 2, 3, 4}.end is {7, 6, 7, 7, 2, 7, 4}.What’s subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see it’s correct and take more examples if you want :)Now, we reduced problem to: you’re given an array A. you can perform 2 operations:1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)2/ what’s current value of an element from position pos.Those who solved “Iahub and Xors” from my last round, CF 198, should probably say they saw something similar before. If you didn’t solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you don’t know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.I’ll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, I’ll keep just an auxiliary information. So what algorithm proposed does:Let A an array, initially with all elements 0.When you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.When you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].Implemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.It may not be very clear why this algorithm works. Let’s take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, let’s see if algorithm handles it correctly:1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it won’t matter at all I did that update – at least not for this query.2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x] – in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I’ll have to consider A[x]).3/ pos > y. Here I don’t have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value –val I’ll just cancel the value previously added.Code (actually we use just one Fenwick tree instead of 2, can you think why it works? :) ) : http://pastie.org/8651824383D - AntimatterAuthor's solutionThe problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.Let’s solve an easier problem first. This won’t immediately solve the harder version, but it will be useful later. Suppose you’ve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.An immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j – 1]. Hence, instead of adding N elements, it’s enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didn’t solve some problems with this technique before. It’s hard to come with an approach without practicing this kind of tasks. But don’t worry, as much as you practice them, as easily you’ll solve those problems.We’ll solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:1/ i <= med j <= med2/ i > med j > med3/ i <= med j > medWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right – left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, you’ll see later why it’s so :) ).Let’s denote by i1 last i1 elements from subarray [left, med]. Also, let’s note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, “left” subarray is {2, 3} and “right” subarray is {4}. By iterating i1 from 1 to med – left + 1 and i2 from 1 to right – med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Let’s denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.Suppose we fixed i1, i2, j1 and j2. When it’s the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med – i1 + 1] + value[med – i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2 – 1] + value[med + i2]). Now it’s time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:2 * j1 + 2 * j2 — sum_of_elements_from_i1 — sum_of_elements_from_i2 = 02 * j1 – sum_of_elements_from_i1 = sum_of_elements_from_i2 – 2 * j2 = combination_valueThis relation is the key of solving problem. You can see now that relation is independent in “left” and “right” side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Let’s calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2 – 2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, let’s fix a sum (i1, j1) in the left side. We’re interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of “left” is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as it’s in the left. It’s not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1 – sum_of_elements_from_i1]. This takes O((right – left) * M) time.The only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, let’s round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:For level 1, there’ll be 1 node performing N * M operations.For level 2, there’ll be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).For level 3, there’ll be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.and so on.So for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).Code: http://pastie.org/8651826Solution fount by contestantsThis was totally unexpected to us :) Good job finding it, you guys are really smart. We observe that x units of antimatter is the same thing as -x units of matter. Then we can consider that an element produces either x or -x units of matter. A valid substring is one that can have the sum of the elements 0. The problem is reduced to finding how many different substrings can we have with sum 0 (a substring is different than another one if it has different indices, or if at least one element produces matter in one and antimatter in the other).This problem can be solved with dynamic programming. We will hold D[i][j] = the number of substrings that end in element i, and have sum j. It's easy to see that D[i + 1][j] = D[i][j — x] + D[i][j + x], where x is the value of the current element (we can put either -x or x). After we finish computing all the values for current i, we add to the solution D[i][0] (how many valid substrings do we have). After that, we add 1 to D[i][0], meaning that there is an empty substring starting at position i (however, we don't need to add it to the answer).For a code, check passing submissions during contest. 383E - VowelsAuthor's solutionLet's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).Suppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. We’ll denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:number_of_words_covered = |x1| + |x2| + .. + |xk| — |x1, x2| — |x1, x3| — .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence can’t contain 4 or more vowels). Example:Suppose words are abc, abd and bcd. |a| = 2 (first 2 words both contain character a).|a, b| = 2 (as well, first 2 words contain characters a and b).|b| = 3 (all 3 words contain character b).|a, b, d| = 1 (only second word contains all 3 characters).Also, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b| — |a, b| = 2 + 3 – 2. Indeed, answer is 3.We divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step – number_from_2nd_step. If you followed me, you’ll see that we want to compute results for each subproblem in O(queryLetters).First subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, I’ll take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but there’s no need, since other subproblems allow only an O(queryLetters) solution. For second and third subproblems it’s a little more difficult. I’ll present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).Similarly to first step, I’ll define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.Note, if we’d have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when1/ c1 and c2 belong to first 12 letters2/ c1 and c2 belong to last 12 letters3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). We’ll remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks). How to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2]. Third subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], we’ll have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:1/ c1, c2, c3 belong to first half2/ c1, c2, c3 belong to second half3/ c1, c2 belong to first half and c3 to second half4/ c1 belongs to first half and c2, c3 to second half1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes: mixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half and mixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half. Those can also be calculated in O(2 ^ 12 * 12^3).So precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.For calculate answering queries complexity, take all numbers from 0 to 2^24 — 1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds. Code: http://pastie.org/8651829Solution fount by contestantsLike in D1 D task, official solution was over complicated. This solution is more simple to understand, code and it's more elegant. If someone wants to complicate his life, (s)he can code also official solution :)Let's start by assigning a bitmask to each word in following way: ith bit is 1 if and only if letter ('a' + i) appears in the current word. For example, for word acd, its bitmask is 2^0 + 2^2 + 2 ^ 3 = 13 and for word aab its bitmask is 2^0 + 2^1 = 3. After reading the words from dictionary, we store a matrix cnt[mask] = how many words from dictionary correspond to mask?We iterate bitmasks from 0 to 2^24 — 1, this time corresponding to each possible question of Iahubina. Let's focus on a bitmask X. We need to get sum of cnt[mask], when mask and X share at least one common bit having value 1 (formally (X AND mask) > 0). In order to do this, we need a reduction which may be not so obvious. What if instead of counting all words containing at least one of vowels {w1, w2, ..., wk} we count all words which don't contain ANY of vowels {w1, w2, ..., wk}? Suppose this number is ret. Then, all words containing at least one of vowels is N — ret. From all words, we erase those words which do not contain any vowels from set {w1, w2, ..., wk} (and which obviously are wrong words). Obviously, it's left only words containing at least one vowel, so good words. Now, for a word not to contain any of vowels {w1, w2, ..., wk} it needs to contains ONLY vowels from set {\"a\", \"b\", \"c\", ..., \"x\"} \\ {w1, w2, ..., wk} (set of allowed letters from which we erased vowels w1, w2, ..., wk}. And this is reduction we needed. For a bitmask X we need to calculate sum of cnt[mask], where mask is a subset of X (we can set some bits from X from 1 to 0 in order to obtain mask). For a mask, let's keep this sum in res[mask]. We can calculate res array using divide and conquer.Let's make a function solve(left, right), which completes array res in the way described above, if we consider only elements cnt[k] with left <= k < right (for simplicity, I'll consider elements which do not lie in this range to be equal to 0). Now we need to solve for a range [left, right]. Let's have in res1[] = solve(left, med) and in res2[] = solve(med, right), where med = (left + right) / 2. We need to put together res1[] and res2[] in order to obtain res[].for (int i = left; i < med; ++i) res[i] = res1[i];Numbers in [left, med] have most significant bit equal to 0. We can only keep it 0 and add what we calculated before. We can't add any element from res2[], because those elements have most significant bit equal to 1 and we're not allowed to change bit 0 into bit 1.for (int i = med; i < right; ++i) res[i] = res1[i — med] + res2[i];Here, most significant bit is 1. Adding res1[] corresponds to changing bit from 1 to 0, adding res2[] corresponds to leaving bit 1.Of course, we need to threat the base case here, too. When left + 1 = right, res[left] = cnt[left]. We can keep only one array res[] instead of 3, I explained it this way only for simplicity. Also, there is no need for keeping separate arrays for res[] and cnt[], one can solve all task with only one array. In order to get res[], we simply call solve(0, 2^24).Complexity of solution is O(2 ^ 24 * 24). I leave the proof homework, it's almost identical to complexity proof of D1 D \"Author solution\" (that with building a binary tree).For a reference solution, check Endagorion's AC source during contest.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10476",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 384\\s*E"
          },
          "content_length": 38059
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #225 - Codeforces - Code 1",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 2",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 3",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 4",
          "code": "......\n#.....\n......\n.#####\n......\n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 5",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 6",
          "code": ".#...\n.#.#.\n.#.#.\n.#.#.\n...#.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 7",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 - Codeforces - Code 8",
          "code": "initial state :\n1 3 2 5 4\n1 4 3 2 5\nstep 1 (pair 2 3):\n1 2 3 5 4\n1 3 4 2 5\nstep 2 (pair 2 4):\n1 2 3 5 4 ( 5 > 2 no swap)\n1 2 4 3 5\nstep 3 (pair 4 5):\n1 2 3 4 5 (sorted)\n1 2 4 3 5 ( 5 > 3 no swap)\n\nthe second array is not sorted at the end !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10448",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 1",
          "code": "c++ void forward2(vt<int>&dp){   rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i)){         dp[j^(1<<i)] += dp[j];       }     }   } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 2",
          "code": "c++ void forward(vt<int>&dp){    rep(i , 0 , 24){     rep(j , 0 , dp.size()){       if(j & (1<<i) ){          dp[j] += dp[j ^ (1<<i)];       }     }    } }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 3",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 4",
          "code": "scanf(\"%d\",&n);\n    LL cnt=0,sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        cnt+=(LL)x;\n        if(!x)sum+=cnt;\n    }\n    printf(\"%I64d\\n\",sum);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 5",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 6",
          "code": "cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 7",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 8",
          "code": "for (int i = 0  ; i <  number ; i ++ )  { \n    \t\tfor (int k = 0 ; k < number ; k ++ ) { \n    \t\t\tif (flag) {\n    \t\t\t\tif ( k % 2 == 1) out.print('.');\n    \t\t\t\tif( k% 2 == 0 ) out.print('C');\n    \t\t\t} else {\n        \t\t\tif ( k % 2 == 1) out.print('C');\n        \t\t\tif( k% 2 == 0 ) out.print('.');\t\n    \t\t\t}\n    \t\t}\n    \t\tif (flag) flag = false;\n    \t\telse flag = true;\n    \t\tout.print(\"\\n\");\n    \t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #225 — Editorial - Codeforces - Code 10",
          "code": "for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++)\n        if ((i + j) & 1)\n            out.print('.');\n        else \n            out.print('C');\n    out.print('\\n');\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10476",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 200000;\n    const int MAX_A = 1000;\n\n    // Read n and m\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_N, \"m\");\n    inf.readEoln();\n\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, MAX_A, \"a_i\");\n    inf.readEoln();\n\n    // Read edges and check for cycles using DSU\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u){\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph is not a tree (contains a cycle)\");\n        parent[pu] = pv;\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not reachable from node 1\", i);\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int val = inf.readInt(1, MAX_A, \"val\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 200000;\n    const int MAX_A = 1000;\n\n    // Read n and m\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_N, \"m\");\n    inf.readEoln();\n\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, MAX_A, \"a_i\");\n    inf.readEoln();\n\n    // Read edges and check for cycles using DSU\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u){\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph is not a tree (contains a cycle)\");\n        parent[pu] = pv;\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not reachable from node 1\", i);\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int val = inf.readInt(1, MAX_A, \"val\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 200000;\n    const int MAX_A = 1000;\n\n    // Read n and m\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_N, \"m\");\n    inf.readEoln();\n\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, MAX_A, \"a_i\");\n    inf.readEoln();\n\n    // Read edges and check for cycles using DSU\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u){\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph is not a tree (contains a cycle)\");\n        parent[pu] = pv;\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not reachable from node 1\", i);\n    }\n\n    // Read m queries\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int val = inf.readInt(1, MAX_A, \"val\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n    int amin = opt<int>(\"amin\", 1);\n    int amax = opt<int>(\"amax\", 1000);\n    int valmin = opt<int>(\"valmin\", 1);\n    int valmax = opt<int>(\"valmax\", 1000);\n    int updateratio = opt<int>(\"updateratio\", 50); // percentage of updates\n\n    // Generate tree according to 'type'\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i-1, i});\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Build a binary tree\n        int cnt = 2;\n        queue<int> q;\n        q.push(1);\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < 2 && cnt <= n; ++i) {\n                int v = cnt++;\n                edges.push_back({u, v});\n                q.push(v);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i-1);\n            edges.push_back({p, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Generate initial values a_i\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = rnd.next(amin, amax);\n    }\n\n    // Generate queries\n    vector<string> queries;\n    if (qtype == \"all_update\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int val = rnd.next(valmin, valmax);\n            queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n        }\n    } else if (qtype == \"all_query\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            queries.push_back(\"2 \" + to_string(x));\n        }\n    } else if (qtype == \"random\") {\n        // Generate random mix of queries\n        for (int i = 0; i < m; ++i) {\n            int t = (rnd.next(100) < updateratio) ? 1 : 2;\n            if (t == 1) {\n                // Update\n                int x = rnd.next(1, n);\n                int val = rnd.next(valmin, valmax);\n                queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n            } else {\n                // Query\n                int x = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(x));\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown qtype: %s\\n\", qtype.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output edges\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    // Output queries\n    for (auto q : queries) {\n        printf(\"%s\\n\", q.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n    int amin = opt<int>(\"amin\", 1);\n    int amax = opt<int>(\"amax\", 1000);\n    int valmin = opt<int>(\"valmin\", 1);\n    int valmax = opt<int>(\"valmax\", 1000);\n    int updateratio = opt<int>(\"updateratio\", 50); // percentage of updates\n\n    // Generate tree according to 'type'\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i-1, i});\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Build a binary tree\n        int cnt = 2;\n        queue<int> q;\n        q.push(1);\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < 2 && cnt <= n; ++i) {\n                int v = cnt++;\n                edges.push_back({u, v});\n                q.push(v);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i-1);\n            edges.push_back({p, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Generate initial values a_i\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = rnd.next(amin, amax);\n    }\n\n    // Generate queries\n    vector<string> queries;\n    if (qtype == \"all_update\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int val = rnd.next(valmin, valmax);\n            queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n        }\n    } else if (qtype == \"all_query\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            queries.push_back(\"2 \" + to_string(x));\n        }\n    } else if (qtype == \"random\") {\n        // Generate random mix of queries\n        for (int i = 0; i < m; ++i) {\n            int t = (rnd.next(100) < updateratio) ? 1 : 2;\n            if (t == 1) {\n                // Update\n                int x = rnd.next(1, n);\n                int val = rnd.next(valmin, valmax);\n                queries.push_back(\"1 \" + to_string(x) + \" \" + to_string(val));\n            } else {\n                // Query\n                int x = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(x));\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown qtype: %s\\n\", qtype.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output edges\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    // Output queries\n    for (auto q : queries) {\n        printf(\"%s\\n\", q.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test cases\n./gen -n 1 -m 1 -type chain -qtype all_query\n./gen -n 1 -m 1 -type chain -qtype all_update\n\n# Small test cases\n./gen -n 5 -m 5 -type chain -qtype random -updateratio 50\n./gen -n 5 -m 5 -type star -qtype random -updateratio 50\n./gen -n 5 -m 5 -type binary -qtype random -updateratio 50\n./gen -n 5 -m 5 -type random -qtype random -updateratio 50\n\n# All initial a_i = 1\n./gen -n 10 -m 10 -type random -qtype random -amin 1 -amax 1\n\n# All initial a_i = 1000\n./gen -n 10 -m 10 -type random -qtype random -amin 1000 -amax 1000\n\n# All val in queries = 1\n./gen -n 10 -m 10 -type random -qtype all_update -valmin 1 -valmax 1\n\n# All val in queries = 1000\n./gen -n 10 -m 10 -type random -qtype all_update -valmin 1000 -valmax 1000\n\n# Large test cases with different tree types\n./gen -n 200000 -m 200000 -type chain -qtype random -updateratio 50\n./gen -n 200000 -m 200000 -type star -qtype random -updateratio 50\n./gen -n 200000 -m 200000 -type binary -qtype random -updateratio 50\n./gen -n 200000 -m 200000 -type random -qtype random -updateratio 50\n\n# Test case with all updates\n./gen -n 200000 -m 200000 -type random -qtype all_update\n\n# Test case with all queries\n./gen -n 200000 -m 200000 -type random -qtype all_query\n\n# Edge case to test overflows with maximum updates\n./gen -n 100000 -m 100000 -type random -qtype all_update -valmin 1000 -valmax 1000\n\n# Edge case with maximal initial values and updates\n./gen -n 100000 -m 100000 -type random -amin 1000 -amax 1000 -qtype all_update -valmin 1000 -valmax 1000\n\n# Chain tree with large updates at root\n./gen -n 100000 -m 100000 -type chain -qtype all_update -valmin 1000 -valmax 1000\n\n# Star tree with large updates at root\n./gen -n 100000 -m 100000 -type star -qtype all_update -valmin 1000 -valmax 1000\n\n# Test where initial a_i are small and updates are large\n./gen -n 100000 -m 50000 -type random -amin 1 -amax 1 -qtype all_update -valmin 1000 -valmax 1000\n\n# Test with small m and large n\n./gen -n 200000 -m 1 -type random -qtype all_query\n\n# Test with maximal m and minimal a_i\n./gen -n 200000 -m 200000 -type random -amin 1 -amax 1 -qtype random -updateratio 50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:09.370133",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "385/A",
      "title": "A. Bear and Raspberry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers, n and c (2 ≤ n ≤ 100, 0 ≤ c ≤ 100), — the number of days and the number of kilos of raspberry that the bear should give for borrowing the barrel.The second line contains n space-separated integers x1, x2, ..., xn (0 ≤ xi ≤ 100), the price of a honey barrel on day i.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy5 15 10 7 3 20OutputCopy3InputCopy6 2100 1 10 40 10 40OutputCopy97InputCopy3 01 2 3OutputCopy0",
      "description": "A. Bear and Raspberry\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers, n and c (2 ≤ n ≤ 100, 0 ≤ c ≤ 100), — the number of days and the number of kilos of raspberry that the bear should give for borrowing the barrel.The second line contains n space-separated integers x1, x2, ..., xn (0 ≤ xi ≤ 100), the price of a honey barrel on day i.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy5 15 10 7 3 20OutputCopy3InputCopy6 2100 1 10 40 10 40OutputCopy97InputCopy3 01 2 3OutputCopy0\n\nInputCopy5 15 10 7 3 20\n\nOutputCopy3\n\nInputCopy6 2100 1 10 40 10 40\n\nOutputCopy97\n\nInputCopy3 01 2 3\n\nOutputCopy0\n\nNoteIn the first sample the bear will lend a honey barrel at day 3 and then sell it for 7. Then the bear will buy a barrel for 3 and return it to the friend. So, the profit is (7 - 3 - 1) = 3.In the second sample bear will lend a honey barrel at day 1 and then sell it for 100. Then the bear buy the barrel for 1 at the day 2. So, the profit is (100 - 1 - 2) = 97.",
      "solutions": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces",
          "content": "Hello!Soon, on January 24th at 19:30 MSK, you are lucky to participate in Codeforces Round #226 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Aleksey Chesnokov (CleRIC), Kirill Butin (KirillB) and Ivan Popovich (NVAL). This is the first round prepared by us and we hope that everything will be OK.During the round you will be helping to the hero of the problems — usual bear.We want to thank Gerald, Delinur, Aksenov239 and MikeMirzayanov for the system.Scoring: 500-1000-1500-2000-2500.Good Luck!UPD: Round rescheduled for 5 minutes laterUPD: EditorialUPD: We hope that you liked round.Congratulations to winners: cptbtptp SquirrelDetected MahooshojoNHB Dong5k yada",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10512",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 749
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces",
          "content": "385A - Bear and RaspberryIn this task required to understand that the answer max(a[i] - a[i - 1] - c),i = 2..n and don't forget that the answer not negative as Bear can not borrow in the debt barrel of honey.385B - Bear and StringsIn this problem you could write a better solution than the naive. To do this, you can iterate through the first cycle of the left index l considered substring and the second cycle of the right index r considered substring (l ≤ r). If any position has been substring \"bear\", means all the strings x(l, j) (i ≤ j), also contain \"bear\" as a substring. So we can add to the answer |s| - j + 1 and exit from the second cycle. Also needed to understand, that if the string x(l, j) was not a substring \"bear\", then in row x(l, j + 1) substring \"bear\" could appear only in the last four characters.385C - Bear and Prime NumbersIn order to solve given problem, contestant should solve several subproblems :1) First one is to compute amount of entries of each natural number between 2 and 107 in given list. This subproblem can be solved by creating array count of 107 elements and increasing corresponding element when scanning input.2) Second one is to compute f(n).First of all, we need to find all primes less than 107 and then for each prime n compute f(n).How to compute f(2)? We should sum count[2],count[4],count[6],count[8],...How to compute f(5)? We should sum count[5],count[10],count[15],count[20],...How to compute f(n)? We should sum count[n],count[2·n],count[3·n],count[4·n],...It can be seen that given algo is very similar to Sieve of Eratosthenes. (Info here http://e-maxx.ru/algo/eratosthenes_sieve) So we can use this algo if we change it a little bit. Also, we will store results of calculation in array, e.g. pre. Namely, pre[n] = f(n).3) Now we can calculate partial sums of pre array. It can be made in a single pass just adding pre[i - 1] to pre[i].4) If we know partial sums of array then we can calculate sum of array elements between l and r in time proportional O(1), just calculate pre[r] - pre[l - 1].5) Now we can read queries and immediately response to them. You shouldn't forget that right boundaries of intervals can be greater than 107, so you can always decrease it to 107, because all numbers in given list are less than 107.385D - Bear and FloodlightIn this task, it is crucial to understand that whether there is lighted part of road with length dist then next part should be lit in a such way that leftmost lighted point is touching with dist.Let's suppose that road is lit from l to d. How we can find rightmost point on X axis that would be lit by next floodlight?We can just use concepts of vector and rotation matrix.Let's find vector (dx, dy) from floodlight to point on X axis (d, 0). (dx, dy) = (d - x, 0 - y).Next point to rotate vector by angle degrees. We can use rotation matrix for this purpose.(dx, dy) = (dx·cos(angle) - dy·sin(angle), dx·sin(angle) + dy·cos(angle))Next, we should make second component dy of (dx, dy) equal to 1 by multiplying on coefficient k.Now we can determine rightmost lighted point of X axis. It is x - y·dx.You shouldn't forget that there is possibility for rightmost point to be infinitely far point.From now on we can forget about geometry in this task.Let's find fast way to determine optimal order of floodlights.To achieve this goal, we can use dynamic programming approach. Namely, let's calculate answer for subsets of floodlights. Each subset would be represented as integer where k bit would be 1 if k floodlight is presented in subset and 0 if it is not, i.e. so named binary mask.For example, dp[6] — (6 — 1102) is optimal answer for subset from 2 and 3 floodlight.Now, let's look through subsets i in dp[i]. In subset i let's go through absent floodlights j and update result for subset where j floodlight is present, i.e. dp[ i or 2j ] = max(dp[ i or 2j], dp[ i ] + calc_rightmost_lighted_point() ). As we can calculate rightmost lighted point, so updating of answer shouldn't be a problem.385E - Bear in the FieldIn this task there are several problems that should be concerned:1) Simple modeling of bear movement would cause TLE due to t  ≤  1018.2) Task can't be solved by separating x and y axes because x and y depends on each other.3) Also, we can't use standart method of cycle finding via modeling for a short time and checking on collisions because coordinates limitations are very large.Let's say we have matrix (xi, yi, dxi, dyi, ti, 1).If we multiply previous matrix by following matrix long long base[6][6] = {{2,1,1,1,0,0},{1,2,1,1,0,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,1,1,0},{0,0,2,2,1,1} };we will have get parameters on next step.Where did the matrix? Let us write out how to change parameters with each step and see the similarity matrix.x = 2·x + 1·y + 1·dx + 0·dy + 0·t + 0·1.y = 1·x + 2·y + 0·dx + 1·dy + 0·t + 0·1.dx = 1·x + 1·y + 1·dx + 0·dy + 1·t + 2·1.dy = 1·x + 1·y + 0·dx + 1·dy + 1·t + 2·1.t = 0·x + 0·y + 0·dx + 0·dy + 1·t + 1·1.1 = 0·x + 0·y + 0·dx + 0·dy + 0·t + 1·1.So if we calculate t - 1 power of base and then multiply (sx, sy, dx, dy, t, 1) by it we will calculate parameters at moment t.Power of matrix can be calculated via binary power modulo algo due to associativity of matrix multiplication. More info at http://e-maxx.ru/algo/binary_powUsing trivial matrix multiplication algo we will solve this task in time proportional 63·log(t).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 385\\s*A"
          },
          "content_length": 5395
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 1",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 2",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 3",
          "code": "for(;i<mx;i++) if(!notp[i]) update(i,cnt[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 4",
          "code": "cout << s.size() - 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 5",
          "code": "unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 6",
          "code": "(unsigned int - int) -> unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 7",
          "code": "i+1<v.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 8",
          "code": "i<v.size()-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int c = inf.readInt(0, 100, \"c\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 100, \"x_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int c = inf.readInt(0, 100, \"c\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 100, \"x_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int c = inf.readInt(0, 100, \"c\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 100, \"x_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n);\n\n    if (type == \"inc\") {\n        int start = opt<int>(\"start\", 0);\n        int end = opt<int>(\"end\", 100);\n        if (start > end) swap(start, end);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start + (end - start) * i / (n - 1);\n        }\n    } else if (type == \"dec\") {\n        int start = opt<int>(\"start\", 100);\n        int end = opt<int>(\"end\", 0);\n        if (start < end) swap(start, end);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start - (start - end) * i / (n - 1);\n        }\n    } else if (type == \"const\") {\n        int val = opt<int>(\"val\", 50);\n        for (int i = 0; i < n; ++i) {\n            x[i] = val;\n        }\n    } else if (type == \"random\") {\n        int minV = opt<int>(\"minV\", 0);\n        int maxV = opt<int>(\"maxV\", 100);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(minV, maxV);\n        }\n    } else if (type == \"peak\") {\n        int start = opt<int>(\"start\", 0);\n        int peak = opt<int>(\"peak\", 100);\n        int end = opt<int>(\"end\", 0);\n        for (int i = 0; i < n; ++i) {\n            if (i <= n / 2)\n                x[i] = start + (peak - start) * i / (n / 2);\n            else\n                x[i] = peak - (peak - end) * (i - n / 2 - 1) / (n - n / 2 - 1);\n        }\n    } else if (type == \"valley\") {\n        int start = opt<int>(\"start\", 100);\n        int trough = opt<int>(\"trough\", 0);\n        int end = opt<int>(\"end\", 100);\n        for (int i = 0; i < n; ++i) {\n            if (i <= n / 2)\n                x[i] = start - (start - trough) * i / (n / 2);\n            else\n                x[i] = trough + (end - trough) * (i - n / 2 -1) / (n - n / 2 -1);\n        }\n    } else if (type == \"zigzag\") {\n        int minV = opt<int>(\"minV\", 0);\n        int maxV = opt<int>(\"maxV\", 100);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                x[i] = minV;\n            else\n                x[i] = maxV;\n        }\n    } else {\n        // Default to random\n        int minV = opt<int>(\"minV\", 0);\n        int maxV = opt<int>(\"maxV\", 100);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(minV, maxV);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, c);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n);\n\n    if (type == \"inc\") {\n        int start = opt<int>(\"start\", 0);\n        int end = opt<int>(\"end\", 100);\n        if (start > end) swap(start, end);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start + (end - start) * i / (n - 1);\n        }\n    } else if (type == \"dec\") {\n        int start = opt<int>(\"start\", 100);\n        int end = opt<int>(\"end\", 0);\n        if (start < end) swap(start, end);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start - (start - end) * i / (n - 1);\n        }\n    } else if (type == \"const\") {\n        int val = opt<int>(\"val\", 50);\n        for (int i = 0; i < n; ++i) {\n            x[i] = val;\n        }\n    } else if (type == \"random\") {\n        int minV = opt<int>(\"minV\", 0);\n        int maxV = opt<int>(\"maxV\", 100);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(minV, maxV);\n        }\n    } else if (type == \"peak\") {\n        int start = opt<int>(\"start\", 0);\n        int peak = opt<int>(\"peak\", 100);\n        int end = opt<int>(\"end\", 0);\n        for (int i = 0; i < n; ++i) {\n            if (i <= n / 2)\n                x[i] = start + (peak - start) * i / (n / 2);\n            else\n                x[i] = peak - (peak - end) * (i - n / 2 - 1) / (n - n / 2 - 1);\n        }\n    } else if (type == \"valley\") {\n        int start = opt<int>(\"start\", 100);\n        int trough = opt<int>(\"trough\", 0);\n        int end = opt<int>(\"end\", 100);\n        for (int i = 0; i < n; ++i) {\n            if (i <= n / 2)\n                x[i] = start - (start - trough) * i / (n / 2);\n            else\n                x[i] = trough + (end - trough) * (i - n / 2 -1) / (n - n / 2 -1);\n        }\n    } else if (type == \"zigzag\") {\n        int minV = opt<int>(\"minV\", 0);\n        int maxV = opt<int>(\"maxV\", 100);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                x[i] = minV;\n            else\n                x[i] = maxV;\n        }\n    } else {\n        // Default to random\n        int minV = opt<int>(\"minV\", 0);\n        int maxV = opt<int>(\"maxV\", 100);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(minV, maxV);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, c);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -c 0 -type const -val 0\n./gen -n 2 -c 0 -type const -val 100\n./gen -n 2 -c 100 -type const -val 0\n./gen -n 2 -c 100 -type const -val 100\n\n./gen -n 2 -c 0 -type inc -start 0 -end 100\n./gen -n 2 -c 100 -type inc -start 0 -end 100\n\n./gen -n 2 -c 0 -type dec -start 100 -end 0\n./gen -n 2 -c 100 -type dec -start 100 -end 0\n\n./gen -n 2 -c 0 -type random -minV 0 -maxV 100\n./gen -n 2 -c 100 -type random -minV 0 -maxV 100\n\n./gen -n 2 -c 50 -type zigzag -minV 0 -maxV 100\n\n./gen -n 100 -c 0 -type const -val 0\n./gen -n 100 -c 100 -type const -val 0\n./gen -n 100 -c 0 -type const -val 100\n./gen -n 100 -c 100 -type const -val 100\n\n./gen -n 100 -c 50 -type inc -start 0 -end 100\n./gen -n 100 -c 50 -type dec -start 100 -end 0\n\n./gen -n 100 -c 0 -type random -minV 0 -maxV 100\n./gen -n 100 -c 100 -type random -minV 0 -maxV 100\n\n./gen -n 100 -c 50 -type peak -start 0 -peak 100 -end 0\n./gen -n 100 -c 50 -type valley -start 100 -trough 0 -end 100\n\n./gen -n 100 -c 0 -type zigzag -minV 0 -maxV 100\n./gen -n 100 -c 100 -type zigzag -minV 0 -maxV 100\n\n./gen -n 100 -c 50 -type random -minV 0 -maxV 50\n./gen -n 100 -c 50 -type random -minV 50 -maxV 100\n\n./gen -n 2 -c 50 -type peak -start 0 -peak 100 -end 0\n./gen -n 2 -c 50 -type valley -start 100 -trough 0 -end 100\n\n./gen -n 100 -c 50 -type const -val 0\n./gen -n 100 -c 50 -type const -val 100\n\n./gen -n 100 -c 50 -type zigzag -minV 0 -maxV 100\n\n./gen -n 100 -c 50 -type random -minV 50 -maxV 50\n\n./gen -n 100 -c 50 -type random -minV 48 -maxV 52\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:11.840103",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "385/B",
      "title": "B. Bear and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty string s (1 ≤ |s| ≤ 5000). It is guaranteed that the string only consists of lowercase English letters.",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopybearbtearOutputCopy6InputCopybearaabearcOutputCopy20",
      "description": "B. Bear and Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string s (1 ≤ |s| ≤ 5000). It is guaranteed that the string only consists of lowercase English letters.\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopybearbtearOutputCopy6InputCopybearaabearcOutputCopy20\n\nInputCopybearbtear\n\nOutputCopy6\n\nInputCopybearaabearc\n\nOutputCopy20\n\nNoteIn the first sample, the following pairs (i, j) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).In the second sample, the following pairs (i, j) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",
      "solutions": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces",
          "content": "Hello!Soon, on January 24th at 19:30 MSK, you are lucky to participate in Codeforces Round #226 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Aleksey Chesnokov (CleRIC), Kirill Butin (KirillB) and Ivan Popovich (NVAL). This is the first round prepared by us and we hope that everything will be OK.During the round you will be helping to the hero of the problems — usual bear.We want to thank Gerald, Delinur, Aksenov239 and MikeMirzayanov for the system.Scoring: 500-1000-1500-2000-2500.Good Luck!UPD: Round rescheduled for 5 minutes laterUPD: EditorialUPD: We hope that you liked round.Congratulations to winners: cptbtptp SquirrelDetected MahooshojoNHB Dong5k yada",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10512",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 749
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces",
          "content": "385A - Bear and RaspberryIn this task required to understand that the answer max(a[i] - a[i - 1] - c),i = 2..n and don't forget that the answer not negative as Bear can not borrow in the debt barrel of honey.385B - Bear and StringsIn this problem you could write a better solution than the naive. To do this, you can iterate through the first cycle of the left index l considered substring and the second cycle of the right index r considered substring (l ≤ r). If any position has been substring \"bear\", means all the strings x(l, j) (i ≤ j), also contain \"bear\" as a substring. So we can add to the answer |s| - j + 1 and exit from the second cycle. Also needed to understand, that if the string x(l, j) was not a substring \"bear\", then in row x(l, j + 1) substring \"bear\" could appear only in the last four characters.385C - Bear and Prime NumbersIn order to solve given problem, contestant should solve several subproblems :1) First one is to compute amount of entries of each natural number between 2 and 107 in given list. This subproblem can be solved by creating array count of 107 elements and increasing corresponding element when scanning input.2) Second one is to compute f(n).First of all, we need to find all primes less than 107 and then for each prime n compute f(n).How to compute f(2)? We should sum count[2],count[4],count[6],count[8],...How to compute f(5)? We should sum count[5],count[10],count[15],count[20],...How to compute f(n)? We should sum count[n],count[2·n],count[3·n],count[4·n],...It can be seen that given algo is very similar to Sieve of Eratosthenes. (Info here http://e-maxx.ru/algo/eratosthenes_sieve) So we can use this algo if we change it a little bit. Also, we will store results of calculation in array, e.g. pre. Namely, pre[n] = f(n).3) Now we can calculate partial sums of pre array. It can be made in a single pass just adding pre[i - 1] to pre[i].4) If we know partial sums of array then we can calculate sum of array elements between l and r in time proportional O(1), just calculate pre[r] - pre[l - 1].5) Now we can read queries and immediately response to them. You shouldn't forget that right boundaries of intervals can be greater than 107, so you can always decrease it to 107, because all numbers in given list are less than 107.385D - Bear and FloodlightIn this task, it is crucial to understand that whether there is lighted part of road with length dist then next part should be lit in a such way that leftmost lighted point is touching with dist.Let's suppose that road is lit from l to d. How we can find rightmost point on X axis that would be lit by next floodlight?We can just use concepts of vector and rotation matrix.Let's find vector (dx, dy) from floodlight to point on X axis (d, 0). (dx, dy) = (d - x, 0 - y).Next point to rotate vector by angle degrees. We can use rotation matrix for this purpose.(dx, dy) = (dx·cos(angle) - dy·sin(angle), dx·sin(angle) + dy·cos(angle))Next, we should make second component dy of (dx, dy) equal to 1 by multiplying on coefficient k.Now we can determine rightmost lighted point of X axis. It is x - y·dx.You shouldn't forget that there is possibility for rightmost point to be infinitely far point.From now on we can forget about geometry in this task.Let's find fast way to determine optimal order of floodlights.To achieve this goal, we can use dynamic programming approach. Namely, let's calculate answer for subsets of floodlights. Each subset would be represented as integer where k bit would be 1 if k floodlight is presented in subset and 0 if it is not, i.e. so named binary mask.For example, dp[6] — (6 — 1102) is optimal answer for subset from 2 and 3 floodlight.Now, let's look through subsets i in dp[i]. In subset i let's go through absent floodlights j and update result for subset where j floodlight is present, i.e. dp[ i or 2j ] = max(dp[ i or 2j], dp[ i ] + calc_rightmost_lighted_point() ). As we can calculate rightmost lighted point, so updating of answer shouldn't be a problem.385E - Bear in the FieldIn this task there are several problems that should be concerned:1) Simple modeling of bear movement would cause TLE due to t  ≤  1018.2) Task can't be solved by separating x and y axes because x and y depends on each other.3) Also, we can't use standart method of cycle finding via modeling for a short time and checking on collisions because coordinates limitations are very large.Let's say we have matrix (xi, yi, dxi, dyi, ti, 1).If we multiply previous matrix by following matrix long long base[6][6] = {{2,1,1,1,0,0},{1,2,1,1,0,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,1,1,0},{0,0,2,2,1,1} };we will have get parameters on next step.Where did the matrix? Let us write out how to change parameters with each step and see the similarity matrix.x = 2·x + 1·y + 1·dx + 0·dy + 0·t + 0·1.y = 1·x + 2·y + 0·dx + 1·dy + 0·t + 0·1.dx = 1·x + 1·y + 1·dx + 0·dy + 1·t + 2·1.dy = 1·x + 1·y + 0·dx + 1·dy + 1·t + 2·1.t = 0·x + 0·y + 0·dx + 0·dy + 1·t + 1·1.1 = 0·x + 0·y + 0·dx + 0·dy + 0·t + 1·1.So if we calculate t - 1 power of base and then multiply (sx, sy, dx, dy, t, 1) by it we will calculate parameters at moment t.Power of matrix can be calculated via binary power modulo algo due to associativity of matrix multiplication. More info at http://e-maxx.ru/algo/binary_powUsing trivial matrix multiplication algo we will solve this task in time proportional 63·log(t).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 385\\s*B"
          },
          "content_length": 5395
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 1",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 2",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 3",
          "code": "for(;i<mx;i++) if(!notp[i]) update(i,cnt[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 4",
          "code": "cout << s.size() - 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 5",
          "code": "unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 6",
          "code": "(unsigned int - int) -> unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 7",
          "code": "i+1<v.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 8",
          "code": "i<v.size()-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"no_bear\") {\n        // Generate a string of length n with no 'bear' substring\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(0, 25);\n            // Ensure characters do not form 'bear'\n            while (c == 'b' || c == 'e' || c == 'a' || c == 'r') {\n                c = 'a' + rnd.next(0, 25);\n            }\n            s += c;\n        }\n    } else if (type == \"single_bear\") {\n        // Generate a string of length n with exactly one 'bear'\n        if (n < 4) {\n            // If n < 4, fill with random letters excluding 'b', 'e', 'a', 'r'\n            for (int i = 0; i < n; ++i) {\n                char c = 'a' + rnd.next(0, 25);\n                while (c == 'b' || c == 'e' || c == 'a' || c == 'r') {\n                    c = 'a' + rnd.next(0, 25);\n                }\n                s += c;\n            }\n        } else {\n            s.resize(n);\n            int pos = rnd.next(0, n - 4); // Position to insert 'bear'\n            s.replace(pos, 4, \"bear\");\n            // Fill the rest with random letters excluding 'b', 'e', 'a', 'r'\n            for (int i = 0; i < n; ++i) {\n                if (i >= pos && i < pos + 4) continue;\n                char c = 'a' + rnd.next(0, 25);\n                while (c == 'b' || c == 'e' || c == 'a' || c == 'r') {\n                    c = 'a' + rnd.next(0, 25);\n                }\n                s[i] = c;\n            }\n        }\n    } else if (type == \"all_bear\") {\n        // Generate a string where every substring of length 4 is 'bear'\n        if (n <= 4) {\n            s = \"bear\";\n            s = s.substr(0, n);\n        } else {\n            s = string(n, ' ');\n            for (int i = 0; i <= n - 4; ++i) {\n                s[i] = 'b'; s[i + 1] = 'e'; s[i + 2] = 'a'; s[i + 3] = 'r';\n            }\n            for (int i = n - 3; i < n; ++i) {\n                if (s[i] == ' ') s[i] = 'a' + rnd.next(0, 25);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random string of length n\n        for (int i = 0; i < n; ++i) {\n            s += 'a' + rnd.next(0, 25);\n        }\n    } else if (type == \"max_bear\") {\n        // Generate a string to maximize the number of substrings containing 'bear'\n        s = \"\";\n        while ((int)s.length() < n) {\n            s += \"bear\";\n        }\n        s = s.substr(0, n);\n    } else if (type == \"overlapping_bear\") {\n        // Generate a string with overlapping 'bear's\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += \"bear\"[i % 4];\n        }\n    } else {\n        // Default to random string\n        for (int i = 0; i < n; ++i) {\n            s += 'a' + rnd.next(0, 25);\n        }\n    }\n\n    // Output the generated string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"no_bear\") {\n        // Generate a string of length n with no 'bear' substring\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(0, 25);\n            // Ensure characters do not form 'bear'\n            while (c == 'b' || c == 'e' || c == 'a' || c == 'r') {\n                c = 'a' + rnd.next(0, 25);\n            }\n            s += c;\n        }\n    } else if (type == \"single_bear\") {\n        // Generate a string of length n with exactly one 'bear'\n        if (n < 4) {\n            // If n < 4, fill with random letters excluding 'b', 'e', 'a', 'r'\n            for (int i = 0; i < n; ++i) {\n                char c = 'a' + rnd.next(0, 25);\n                while (c == 'b' || c == 'e' || c == 'a' || c == 'r') {\n                    c = 'a' + rnd.next(0, 25);\n                }\n                s += c;\n            }\n        } else {\n            s.resize(n);\n            int pos = rnd.next(0, n - 4); // Position to insert 'bear'\n            s.replace(pos, 4, \"bear\");\n            // Fill the rest with random letters excluding 'b', 'e', 'a', 'r'\n            for (int i = 0; i < n; ++i) {\n                if (i >= pos && i < pos + 4) continue;\n                char c = 'a' + rnd.next(0, 25);\n                while (c == 'b' || c == 'e' || c == 'a' || c == 'r') {\n                    c = 'a' + rnd.next(0, 25);\n                }\n                s[i] = c;\n            }\n        }\n    } else if (type == \"all_bear\") {\n        // Generate a string where every substring of length 4 is 'bear'\n        if (n <= 4) {\n            s = \"bear\";\n            s = s.substr(0, n);\n        } else {\n            s = string(n, ' ');\n            for (int i = 0; i <= n - 4; ++i) {\n                s[i] = 'b'; s[i + 1] = 'e'; s[i + 2] = 'a'; s[i + 3] = 'r';\n            }\n            for (int i = n - 3; i < n; ++i) {\n                if (s[i] == ' ') s[i] = 'a' + rnd.next(0, 25);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random string of length n\n        for (int i = 0; i < n; ++i) {\n            s += 'a' + rnd.next(0, 25);\n        }\n    } else if (type == \"max_bear\") {\n        // Generate a string to maximize the number of substrings containing 'bear'\n        s = \"\";\n        while ((int)s.length() < n) {\n            s += \"bear\";\n        }\n        s = s.substr(0, n);\n    } else if (type == \"overlapping_bear\") {\n        // Generate a string with overlapping 'bear's\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += \"bear\"[i % 4];\n        }\n    } else {\n        // Default to random string\n        for (int i = 0; i < n; ++i) {\n            s += 'a' + rnd.next(0, 25);\n        }\n    }\n\n    // Output the generated string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type no_bear\n./gen -n 1 -type single_bear\n./gen -n 1 -type random\n./gen -n 4 -type no_bear\n./gen -n 4 -type single_bear\n./gen -n 4 -type all_bear\n./gen -n 4 -type random\n./gen -n 10 -type no_bear\n./gen -n 10 -type single_bear\n./gen -n 10 -type max_bear\n./gen -n 10 -type overlapping_bear\n./gen -n 10 -type random\n./gen -n 50 -type no_bear\n./gen -n 50 -type single_bear\n./gen -n 50 -type max_bear\n./gen -n 50 -type overlapping_bear\n./gen -n 50 -type random\n./gen -n 100 -type no_bear\n./gen -n 100 -type single_bear\n./gen -n 100 -type max_bear\n./gen -n 100 -type overlapping_bear\n./gen -n 100 -type random\n./gen -n 500 -type no_bear\n./gen -n 500 -type single_bear\n./gen -n 500 -type max_bear\n./gen -n 500 -type overlapping_bear\n./gen -n 500 -type random\n./gen -n 5000 -type no_bear\n./gen -n 5000 -type single_bear\n./gen -n 5000 -type max_bear\n./gen -n 5000 -type overlapping_bear\n./gen -n 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:13.488851",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "385/C",
      "title": "C. Bear and Prime Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106). The second line contains n integers x1, x2, ..., xn (2 ≤ xi ≤ 107). The numbers are not necessarily distinct.The third line contains integer m (1 ≤ m ≤ 50000). Each of the following m lines contains a pair of space-separated integers, li and ri (2 ≤ li ≤ ri ≤ 2·109) — the numbers that characterize the current query.",
      "output_spec": "OutputPrint m integers — the answers to the queries on the order the queries appear in the input.",
      "sample_tests": "ExamplesInputCopy65 5 7 10 14 1532 113 124 4OutputCopy970InputCopy72 3 5 7 11 4 828 102 123OutputCopy07",
      "description": "C. Bear and Prime Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 106). The second line contains n integers x1, x2, ..., xn (2 ≤ xi ≤ 107). The numbers are not necessarily distinct.The third line contains integer m (1 ≤ m ≤ 50000). Each of the following m lines contains a pair of space-separated integers, li and ri (2 ≤ li ≤ ri ≤ 2·109) — the numbers that characterize the current query.\n\nOutputPrint m integers — the answers to the queries on the order the queries appear in the input.\n\nInputCopy65 5 7 10 14 1532 113 124 4OutputCopy970InputCopy72 3 5 7 11 4 828 102 123OutputCopy07\n\nInputCopy65 5 7 10 14 1532 113 124 4\n\nOutputCopy970\n\nInputCopy72 3 5 7 11 4 828 102 123\n\nOutputCopy07\n\nNoteConsider the first sample. Overall, the first sample has 3 queries.  The first query l = 2, r = 11 comes. You need to count f(2) + f(3) + f(5) + f(7) + f(11) = 2 + 1 + 4 + 2 + 0 = 9.  The second query comes l = 3, r = 12. You need to count f(3) + f(5) + f(7) + f(11) = 1 + 4 + 2 + 0 = 7.  The third query comes l = 4, r = 4. As this interval has no prime numbers, then the sum equals 0.",
      "solutions": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces",
          "content": "Hello!Soon, on January 24th at 19:30 MSK, you are lucky to participate in Codeforces Round #226 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Aleksey Chesnokov (CleRIC), Kirill Butin (KirillB) and Ivan Popovich (NVAL). This is the first round prepared by us and we hope that everything will be OK.During the round you will be helping to the hero of the problems — usual bear.We want to thank Gerald, Delinur, Aksenov239 and MikeMirzayanov for the system.Scoring: 500-1000-1500-2000-2500.Good Luck!UPD: Round rescheduled for 5 minutes laterUPD: EditorialUPD: We hope that you liked round.Congratulations to winners: cptbtptp SquirrelDetected MahooshojoNHB Dong5k yada",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10512",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 749
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces",
          "content": "385A - Bear and RaspberryIn this task required to understand that the answer max(a[i] - a[i - 1] - c),i = 2..n and don't forget that the answer not negative as Bear can not borrow in the debt barrel of honey.385B - Bear and StringsIn this problem you could write a better solution than the naive. To do this, you can iterate through the first cycle of the left index l considered substring and the second cycle of the right index r considered substring (l ≤ r). If any position has been substring \"bear\", means all the strings x(l, j) (i ≤ j), also contain \"bear\" as a substring. So we can add to the answer |s| - j + 1 and exit from the second cycle. Also needed to understand, that if the string x(l, j) was not a substring \"bear\", then in row x(l, j + 1) substring \"bear\" could appear only in the last four characters.385C - Bear and Prime NumbersIn order to solve given problem, contestant should solve several subproblems :1) First one is to compute amount of entries of each natural number between 2 and 107 in given list. This subproblem can be solved by creating array count of 107 elements and increasing corresponding element when scanning input.2) Second one is to compute f(n).First of all, we need to find all primes less than 107 and then for each prime n compute f(n).How to compute f(2)? We should sum count[2],count[4],count[6],count[8],...How to compute f(5)? We should sum count[5],count[10],count[15],count[20],...How to compute f(n)? We should sum count[n],count[2·n],count[3·n],count[4·n],...It can be seen that given algo is very similar to Sieve of Eratosthenes. (Info here http://e-maxx.ru/algo/eratosthenes_sieve) So we can use this algo if we change it a little bit. Also, we will store results of calculation in array, e.g. pre. Namely, pre[n] = f(n).3) Now we can calculate partial sums of pre array. It can be made in a single pass just adding pre[i - 1] to pre[i].4) If we know partial sums of array then we can calculate sum of array elements between l and r in time proportional O(1), just calculate pre[r] - pre[l - 1].5) Now we can read queries and immediately response to them. You shouldn't forget that right boundaries of intervals can be greater than 107, so you can always decrease it to 107, because all numbers in given list are less than 107.385D - Bear and FloodlightIn this task, it is crucial to understand that whether there is lighted part of road with length dist then next part should be lit in a such way that leftmost lighted point is touching with dist.Let's suppose that road is lit from l to d. How we can find rightmost point on X axis that would be lit by next floodlight?We can just use concepts of vector and rotation matrix.Let's find vector (dx, dy) from floodlight to point on X axis (d, 0). (dx, dy) = (d - x, 0 - y).Next point to rotate vector by angle degrees. We can use rotation matrix for this purpose.(dx, dy) = (dx·cos(angle) - dy·sin(angle), dx·sin(angle) + dy·cos(angle))Next, we should make second component dy of (dx, dy) equal to 1 by multiplying on coefficient k.Now we can determine rightmost lighted point of X axis. It is x - y·dx.You shouldn't forget that there is possibility for rightmost point to be infinitely far point.From now on we can forget about geometry in this task.Let's find fast way to determine optimal order of floodlights.To achieve this goal, we can use dynamic programming approach. Namely, let's calculate answer for subsets of floodlights. Each subset would be represented as integer where k bit would be 1 if k floodlight is presented in subset and 0 if it is not, i.e. so named binary mask.For example, dp[6] — (6 — 1102) is optimal answer for subset from 2 and 3 floodlight.Now, let's look through subsets i in dp[i]. In subset i let's go through absent floodlights j and update result for subset where j floodlight is present, i.e. dp[ i or 2j ] = max(dp[ i or 2j], dp[ i ] + calc_rightmost_lighted_point() ). As we can calculate rightmost lighted point, so updating of answer shouldn't be a problem.385E - Bear in the FieldIn this task there are several problems that should be concerned:1) Simple modeling of bear movement would cause TLE due to t  ≤  1018.2) Task can't be solved by separating x and y axes because x and y depends on each other.3) Also, we can't use standart method of cycle finding via modeling for a short time and checking on collisions because coordinates limitations are very large.Let's say we have matrix (xi, yi, dxi, dyi, ti, 1).If we multiply previous matrix by following matrix long long base[6][6] = {{2,1,1,1,0,0},{1,2,1,1,0,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,1,1,0},{0,0,2,2,1,1} };we will have get parameters on next step.Where did the matrix? Let us write out how to change parameters with each step and see the similarity matrix.x = 2·x + 1·y + 1·dx + 0·dy + 0·t + 0·1.y = 1·x + 2·y + 0·dx + 1·dy + 0·t + 0·1.dx = 1·x + 1·y + 1·dx + 0·dy + 1·t + 2·1.dy = 1·x + 1·y + 0·dx + 1·dy + 1·t + 2·1.t = 0·x + 0·y + 0·dx + 0·dy + 1·t + 1·1.1 = 0·x + 0·y + 0·dx + 0·dy + 0·t + 1·1.So if we calculate t - 1 power of base and then multiply (sx, sy, dx, dy, t, 1) by it we will calculate parameters at moment t.Power of matrix can be calculated via binary power modulo algo due to associativity of matrix multiplication. More info at http://e-maxx.ru/algo/binary_powUsing trivial matrix multiplication algo we will solve this task in time proportional 63·log(t).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 385\\s*C"
          },
          "content_length": 5395
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 1",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 2",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 3",
          "code": "for(;i<mx;i++) if(!notp[i]) update(i,cnt[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 4",
          "code": "cout << s.size() - 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 5",
          "code": "unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 6",
          "code": "(unsigned int - int) -> unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 7",
          "code": "i+1<v.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 8",
          "code": "i<v.size()-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 2, 10000000, \"x_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(2, 2000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 2000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 2, 10000000, \"x_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(2, 2000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 2000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 2, 10000000, \"x_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        int li = inf.readInt(2, 2000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 2000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> primes;\nvector<int> composites;\nvector<char> is_prime(10000001, true);\n\nvoid init_primes() {\n    int N = 10000000;\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= N; ++i) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            if(1LL * i * i <= N) {\n                for(int j = i * i; j <= N; j += i)\n                    is_prime[j] = false;\n            }\n        } else {\n            composites.push_back(i);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string x_type = opt<string>(\"x_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n    int x_value = opt<int>(\"x_value\", 2);\n\n    vector<int> xi(n);\n\n    if (x_type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, 10000000); // xi in [2, 1e7]\n    } else if (x_type == \"all_same\") {\n        if (x_value < 2 || x_value > 10000000)\n            x_value = 2;\n        for(int i = 0; i < n; ++i)\n            xi[i] = x_value;\n    } else if (x_type == \"all_primes\") {\n        init_primes(); // Initialize the list of primes up to 1e7\n        for(int i = 0; i < n; ++i)\n            xi[i] = primes[rnd.next((int)primes.size())];\n    } else if (x_type == \"all_composite\") {\n        init_primes(); // Initialize the lists\n        for(int i = 0; i < n; ++i)\n            xi[i] = composites[rnd.next((int)composites.size())];\n    } else if (x_type == \"small_numbers\") {\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, 100); // xi in [2,100]\n    } else if (x_type == \"large_numbers\") {\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(10000000 - 1000, 10000000); // xi in [1e7-1000,1e7]\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, 10000000); // xi in [2, 1e7]\n    }\n\n    // Now generate m queries\n    vector<pair<int, int>> queries(m);\n\n    if (q_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"small_ranges\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 1000);\n            int ri = rnd.next(li, min(li + 100, 2000000000));\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"large_ranges\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2000000000 - 1000, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"no_primes\") {\n        // Generate ranges with no primes\n        for(int i = 0; i < m; ++i) {\n            int num;\n            do {\n                num = rnd.next(4, 2000000000);\n            } while (num % 2 != 0);\n            queries[i] = make_pair(num, num);\n        }\n    } else if (q_type == \"no_factors\") {\n        // Generate ranges with primes that do not divide any xi\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(100000000, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"li_eq_ri\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 2000000000);\n            queries[i] = make_pair(li, li);\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi's\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> primes;\nvector<int> composites;\nvector<char> is_prime(10000001, true);\n\nvoid init_primes() {\n    int N = 10000000;\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= N; ++i) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            if(1LL * i * i <= N) {\n                for(int j = i * i; j <= N; j += i)\n                    is_prime[j] = false;\n            }\n        } else {\n            composites.push_back(i);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string x_type = opt<string>(\"x_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n    int x_value = opt<int>(\"x_value\", 2);\n\n    vector<int> xi(n);\n\n    if (x_type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, 10000000); // xi in [2, 1e7]\n    } else if (x_type == \"all_same\") {\n        if (x_value < 2 || x_value > 10000000)\n            x_value = 2;\n        for(int i = 0; i < n; ++i)\n            xi[i] = x_value;\n    } else if (x_type == \"all_primes\") {\n        init_primes(); // Initialize the list of primes up to 1e7\n        for(int i = 0; i < n; ++i)\n            xi[i] = primes[rnd.next((int)primes.size())];\n    } else if (x_type == \"all_composite\") {\n        init_primes(); // Initialize the lists\n        for(int i = 0; i < n; ++i)\n            xi[i] = composites[rnd.next((int)composites.size())];\n    } else if (x_type == \"small_numbers\") {\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, 100); // xi in [2,100]\n    } else if (x_type == \"large_numbers\") {\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(10000000 - 1000, 10000000); // xi in [1e7-1000,1e7]\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(2, 10000000); // xi in [2, 1e7]\n    }\n\n    // Now generate m queries\n    vector<pair<int, int>> queries(m);\n\n    if (q_type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"small_ranges\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 1000);\n            int ri = rnd.next(li, min(li + 100, 2000000000));\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"large_ranges\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2000000000 - 1000, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"no_primes\") {\n        // Generate ranges with no primes\n        for(int i = 0; i < m; ++i) {\n            int num;\n            do {\n                num = rnd.next(4, 2000000000);\n            } while (num % 2 != 0);\n            queries[i] = make_pair(num, num);\n        }\n    } else if (q_type == \"no_factors\") {\n        // Generate ranges with primes that do not divide any xi\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(100000000, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if (q_type == \"li_eq_ri\") {\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 2000000000);\n            queries[i] = make_pair(li, li);\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < m; ++i) {\n            int li = rnd.next(2, 2000000000);\n            int ri = rnd.next(li, 2000000000);\n            queries[i] = make_pair(li, ri);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi's\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -x_type random -q_type random\n./gen -n 1000 -m 500 -x_type random -q_type random\n./gen -n 1000000 -m 50000 -x_type random -q_type random\n\n./gen -n 1000000 -m 50000 -x_type all_same -x_value 2 -q_type random\n./gen -n 1000000 -m 50000 -x_type all_same -x_value 9999991 -q_type random\n\n./gen -n 100000 -m 1000 -x_type all_primes -q_type random\n./gen -n 100000 -m 1000 -x_type all_composite -q_type random\n\n./gen -n 1000000 -m 50000 -x_type small_numbers -q_type small_ranges\n./gen -n 1000000 -m 50000 -x_type large_numbers -q_type large_ranges\n\n./gen -n 1000000 -m 50000 -x_type random -q_type no_primes\n./gen -n 1000000 -m 50000 -x_type random -q_type no_factors\n./gen -n 1000000 -m 50000 -x_type random -q_type li_eq_ri\n\n./gen -n 1000000 -m 50000 -x_type small_numbers -q_type li_eq_ri\n\n./gen -n 1000000 -m 1 -x_type random -q_type large_ranges\n./gen -n 1000000 -m 1 -x_type random -q_type small_ranges\n\n./gen -n 1 -m 50000 -x_type random -q_type random\n./gen -n 1 -m 50000 -x_type random -q_type large_ranges\n./gen -n 1 -m 50000 -x_type random -q_type small_ranges\n\n./gen -n 1000000 -m 1 -x_type random -q_type li_eq_ri\n./gen -n 1000000 -m 1 -x_type all_same -x_value 99991 -q_type li_eq_ri\n./gen -n 1000000 -m 1 -x_type all_same -x_value 2 -q_type li_eq_ri\n\n./gen -n 1000000 -m 50000 -x_type large_numbers -q_type no_primes\n./gen -n 1000000 -m 50000 -x_type small_numbers -q_type no_primes\n./gen -n 1000000 -m 50000 -x_type small_numbers -q_type no_factors\n./gen -n 1000000 -m 50000 -x_type large_numbers -q_type no_factors\n\n./gen -n 1000000 -m 50000 -x_type all_composite -q_type no_primes\n./gen -n 1000000 -m 50000 -x_type all_primes -q_type no_factors\n\n./gen -n 1000000 -m 1000 -x_type random -q_type small_ranges\n./gen -n 1000000 -m 1000 -x_type random -q_type large_ranges\n\n./gen -n 1000000 -m 50000 -x_type small_numbers -q_type random\n./gen -n 1000000 -m 50000 -x_type large_numbers -q_type random\n\n./gen -n 500000 -m 25000 -x_type all_same -x_value 5 -q_type small_ranges\n./gen -n 500000 -m 25000 -x_type all_same -x_value 10000000 -q_type large_ranges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:15.350566",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "385/D",
      "title": "D. Bear and Floodlight",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, l, r (1 ≤ n ≤ 20;  - 105 ≤ l ≤ r ≤ 105). The i-th of the next n lines contain three space-separated integers xi, yi, ai ( - 1000 ≤ xi ≤ 1000; 1 ≤ yi ≤ 1000; 1 ≤ ai ≤ 90) — the floodlights' description. Note that two floodlights can be at the same point of the plane.",
      "output_spec": "OutputPrint a single real number — the answer to the problem. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy2 3 53 1 455 1 45OutputCopy2.000000000InputCopy1 0 11 1 30OutputCopy0.732050808InputCopy1 0 11 1 45OutputCopy1.000000000InputCopy1 0 20 2 90OutputCopy2.000000000",
      "description": "D. Bear and Floodlight\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, l, r (1 ≤ n ≤ 20;  - 105 ≤ l ≤ r ≤ 105). The i-th of the next n lines contain three space-separated integers xi, yi, ai ( - 1000 ≤ xi ≤ 1000; 1 ≤ yi ≤ 1000; 1 ≤ ai ≤ 90) — the floodlights' description. Note that two floodlights can be at the same point of the plane.\n\nOutputPrint a single real number — the answer to the problem. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.\n\nInputCopy2 3 53 1 455 1 45OutputCopy2.000000000InputCopy1 0 11 1 30OutputCopy0.732050808InputCopy1 0 11 1 45OutputCopy1.000000000InputCopy1 0 20 2 90OutputCopy2.000000000\n\nInputCopy2 3 53 1 455 1 45\n\nOutputCopy2.000000000\n\nInputCopy1 0 11 1 30\n\nOutputCopy0.732050808\n\nInputCopy1 0 11 1 45\n\nOutputCopy1.000000000\n\nInputCopy1 0 20 2 90\n\nOutputCopy2.000000000\n\nNoteIn the first sample, one of the possible solutions is:   In the second sample, a single solution is:   In the third sample, a single solution is:",
      "solutions": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces",
          "content": "Hello!Soon, on January 24th at 19:30 MSK, you are lucky to participate in Codeforces Round #226 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Aleksey Chesnokov (CleRIC), Kirill Butin (KirillB) and Ivan Popovich (NVAL). This is the first round prepared by us and we hope that everything will be OK.During the round you will be helping to the hero of the problems — usual bear.We want to thank Gerald, Delinur, Aksenov239 and MikeMirzayanov for the system.Scoring: 500-1000-1500-2000-2500.Good Luck!UPD: Round rescheduled for 5 minutes laterUPD: EditorialUPD: We hope that you liked round.Congratulations to winners: cptbtptp SquirrelDetected MahooshojoNHB Dong5k yada",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10512",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 749
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces",
          "content": "385A - Bear and RaspberryIn this task required to understand that the answer max(a[i] - a[i - 1] - c),i = 2..n and don't forget that the answer not negative as Bear can not borrow in the debt barrel of honey.385B - Bear and StringsIn this problem you could write a better solution than the naive. To do this, you can iterate through the first cycle of the left index l considered substring and the second cycle of the right index r considered substring (l ≤ r). If any position has been substring \"bear\", means all the strings x(l, j) (i ≤ j), also contain \"bear\" as a substring. So we can add to the answer |s| - j + 1 and exit from the second cycle. Also needed to understand, that if the string x(l, j) was not a substring \"bear\", then in row x(l, j + 1) substring \"bear\" could appear only in the last four characters.385C - Bear and Prime NumbersIn order to solve given problem, contestant should solve several subproblems :1) First one is to compute amount of entries of each natural number between 2 and 107 in given list. This subproblem can be solved by creating array count of 107 elements and increasing corresponding element when scanning input.2) Second one is to compute f(n).First of all, we need to find all primes less than 107 and then for each prime n compute f(n).How to compute f(2)? We should sum count[2],count[4],count[6],count[8],...How to compute f(5)? We should sum count[5],count[10],count[15],count[20],...How to compute f(n)? We should sum count[n],count[2·n],count[3·n],count[4·n],...It can be seen that given algo is very similar to Sieve of Eratosthenes. (Info here http://e-maxx.ru/algo/eratosthenes_sieve) So we can use this algo if we change it a little bit. Also, we will store results of calculation in array, e.g. pre. Namely, pre[n] = f(n).3) Now we can calculate partial sums of pre array. It can be made in a single pass just adding pre[i - 1] to pre[i].4) If we know partial sums of array then we can calculate sum of array elements between l and r in time proportional O(1), just calculate pre[r] - pre[l - 1].5) Now we can read queries and immediately response to them. You shouldn't forget that right boundaries of intervals can be greater than 107, so you can always decrease it to 107, because all numbers in given list are less than 107.385D - Bear and FloodlightIn this task, it is crucial to understand that whether there is lighted part of road with length dist then next part should be lit in a such way that leftmost lighted point is touching with dist.Let's suppose that road is lit from l to d. How we can find rightmost point on X axis that would be lit by next floodlight?We can just use concepts of vector and rotation matrix.Let's find vector (dx, dy) from floodlight to point on X axis (d, 0). (dx, dy) = (d - x, 0 - y).Next point to rotate vector by angle degrees. We can use rotation matrix for this purpose.(dx, dy) = (dx·cos(angle) - dy·sin(angle), dx·sin(angle) + dy·cos(angle))Next, we should make second component dy of (dx, dy) equal to 1 by multiplying on coefficient k.Now we can determine rightmost lighted point of X axis. It is x - y·dx.You shouldn't forget that there is possibility for rightmost point to be infinitely far point.From now on we can forget about geometry in this task.Let's find fast way to determine optimal order of floodlights.To achieve this goal, we can use dynamic programming approach. Namely, let's calculate answer for subsets of floodlights. Each subset would be represented as integer where k bit would be 1 if k floodlight is presented in subset and 0 if it is not, i.e. so named binary mask.For example, dp[6] — (6 — 1102) is optimal answer for subset from 2 and 3 floodlight.Now, let's look through subsets i in dp[i]. In subset i let's go through absent floodlights j and update result for subset where j floodlight is present, i.e. dp[ i or 2j ] = max(dp[ i or 2j], dp[ i ] + calc_rightmost_lighted_point() ). As we can calculate rightmost lighted point, so updating of answer shouldn't be a problem.385E - Bear in the FieldIn this task there are several problems that should be concerned:1) Simple modeling of bear movement would cause TLE due to t  ≤  1018.2) Task can't be solved by separating x and y axes because x and y depends on each other.3) Also, we can't use standart method of cycle finding via modeling for a short time and checking on collisions because coordinates limitations are very large.Let's say we have matrix (xi, yi, dxi, dyi, ti, 1).If we multiply previous matrix by following matrix long long base[6][6] = {{2,1,1,1,0,0},{1,2,1,1,0,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,1,1,0},{0,0,2,2,1,1} };we will have get parameters on next step.Where did the matrix? Let us write out how to change parameters with each step and see the similarity matrix.x = 2·x + 1·y + 1·dx + 0·dy + 0·t + 0·1.y = 1·x + 2·y + 0·dx + 1·dy + 0·t + 0·1.dx = 1·x + 1·y + 1·dx + 0·dy + 1·t + 2·1.dy = 1·x + 1·y + 0·dx + 1·dy + 1·t + 2·1.t = 0·x + 0·y + 0·dx + 0·dy + 1·t + 1·1.1 = 0·x + 0·y + 0·dx + 0·dy + 0·t + 1·1.So if we calculate t - 1 power of base and then multiply (sx, sy, dx, dy, t, 1) by it we will calculate parameters at moment t.Power of matrix can be calculated via binary power modulo algo due to associativity of matrix multiplication. More info at http://e-maxx.ru/algo/binary_powUsing trivial matrix multiplication algo we will solve this task in time proportional 63·log(t).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 385\\s*D"
          },
          "content_length": 5395
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 1",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 2",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 3",
          "code": "for(;i<mx;i++) if(!notp[i]) update(i,cnt[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 4",
          "code": "cout << s.size() - 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 5",
          "code": "unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 6",
          "code": "(unsigned int - int) -> unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 7",
          "code": "i+1<v.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 8",
          "code": "i<v.size()-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(-100000, 100000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(-100000, 100000, \"r\");\n    inf.readEoln();\n\n    ensuref(l <= r, \"l should be less than or equal to r, but l=%d > r=%d\", l, r);\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 90, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(-100000, 100000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(-100000, 100000, \"r\");\n    inf.readEoln();\n\n    ensuref(l <= r, \"l should be less than or equal to r, but l=%d > r=%d\", l, r);\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 90, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(-100000, 100000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(-100000, 100000, \"r\");\n    inf.readEoln();\n\n    ensuref(l <= r, \"l should be less than or equal to r, but l=%d > r=%d\", l, r);\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 90, \"ai\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure l ≤ r\n    if (l > r) swap(l, r);\n\n    // Initialize vectors for floodlight properties\n    vector<int> xi(n), yi(n), ai(n);\n\n    if (type == \"random\") {\n        // Generate random floodlights\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);  // xi ∈ [-1000, 1000]\n            yi[i] = rnd.next(1, 1000);      // yi ∈ [1, 1000]\n            ai[i] = rnd.next(1, 90);        // ai ∈ [1, 90]\n        }\n    } else if (type == \"full_cover\") {\n        // Place floodlights to cover the entire segment\n        xi[0] = (l + r) / 2;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = 90;  // Max angle to ensure full coverage\n        for (int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"partial_cover\") {\n        // Floodlights covering part of the segment\n        int mid = (l + r) / 2;\n        xi[0] = (l + mid) / 2;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(30, 60);  // Moderate angle for partial coverage\n        for (int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"no_cover\") {\n        // Floodlights unable to cover the segment\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, -500);  // Far from the segment\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = 1;  // Minimum angle\n        }\n    } else if (type == \"max_angle\") {\n        // Floodlights with maximum angle\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = 90;\n        }\n    } else if (type == \"min_angle\") {\n        // Floodlights with minimum angle\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = 1;\n        }\n    } else if (type == \"edge_case\") {\n        // Floodlights at the edges of the segment\n        xi[0] = l;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(1, 90);\n        xi[1 % n] = r;\n        yi[1 % n] = rnd.next(1, 1000);\n        ai[1 % n] = rnd.next(1, 90);\n        for (int i = 2; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"same_position\") {\n        // All floodlights at the same position\n        xi[0] = rnd.next(-1000, 1000);\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(1, 90);\n        for (int i = 1; i < n; ++i) {\n            xi[i] = xi[0];\n            yi[i] = yi[0];\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"zero_length_segment\") {\n        // Segment of zero length (l == r)\n        l = r = rnd.next(-100000, 100000);\n        xi[0] = l;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = 90;  // Ensure the point is lit\n        for (int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"min_n\") {\n        // Minimum number of floodlights\n        n = 1;\n        xi.resize(n);\n        yi.resize(n);\n        ai.resize(n);\n        xi[0] = rnd.next(-1000, 1000);\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(1, 90);\n    } else if (type == \"max_n\") {\n        // Maximum number of floodlights\n        n = 20;\n        xi.resize(n);\n        yi.resize(n);\n        ai.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else {\n        // Default random floodlights\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, l, r);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], yi[i], ai[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure l ≤ r\n    if (l > r) swap(l, r);\n\n    // Initialize vectors for floodlight properties\n    vector<int> xi(n), yi(n), ai(n);\n\n    if (type == \"random\") {\n        // Generate random floodlights\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);  // xi ∈ [-1000, 1000]\n            yi[i] = rnd.next(1, 1000);      // yi ∈ [1, 1000]\n            ai[i] = rnd.next(1, 90);        // ai ∈ [1, 90]\n        }\n    } else if (type == \"full_cover\") {\n        // Place floodlights to cover the entire segment\n        xi[0] = (l + r) / 2;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = 90;  // Max angle to ensure full coverage\n        for (int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"partial_cover\") {\n        // Floodlights covering part of the segment\n        int mid = (l + r) / 2;\n        xi[0] = (l + mid) / 2;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(30, 60);  // Moderate angle for partial coverage\n        for (int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"no_cover\") {\n        // Floodlights unable to cover the segment\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, -500);  // Far from the segment\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = 1;  // Minimum angle\n        }\n    } else if (type == \"max_angle\") {\n        // Floodlights with maximum angle\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = 90;\n        }\n    } else if (type == \"min_angle\") {\n        // Floodlights with minimum angle\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = 1;\n        }\n    } else if (type == \"edge_case\") {\n        // Floodlights at the edges of the segment\n        xi[0] = l;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(1, 90);\n        xi[1 % n] = r;\n        yi[1 % n] = rnd.next(1, 1000);\n        ai[1 % n] = rnd.next(1, 90);\n        for (int i = 2; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"same_position\") {\n        // All floodlights at the same position\n        xi[0] = rnd.next(-1000, 1000);\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(1, 90);\n        for (int i = 1; i < n; ++i) {\n            xi[i] = xi[0];\n            yi[i] = yi[0];\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"zero_length_segment\") {\n        // Segment of zero length (l == r)\n        l = r = rnd.next(-100000, 100000);\n        xi[0] = l;\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = 90;  // Ensure the point is lit\n        for (int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else if (type == \"min_n\") {\n        // Minimum number of floodlights\n        n = 1;\n        xi.resize(n);\n        yi.resize(n);\n        ai.resize(n);\n        xi[0] = rnd.next(-1000, 1000);\n        yi[0] = rnd.next(1, 1000);\n        ai[0] = rnd.next(1, 90);\n    } else if (type == \"max_n\") {\n        // Maximum number of floodlights\n        n = 20;\n        xi.resize(n);\n        yi.resize(n);\n        ai.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    } else {\n        // Default random floodlights\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-1000, 1000);\n            yi[i] = rnd.next(1, 1000);\n            ai[i] = rnd.next(1, 90);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, l, r);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], yi[i], ai[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l -100000 -r 100000 -type random\n./gen -n 20 -l -100000 -r 100000 -type random\n./gen -n 10 -l 0 -r 0 -type zero_length_segment\n\n./gen -n 5 -l -100000 -r 100000 -type full_cover\n./gen -n 5 -l -100000 -r 100000 -type partial_cover\n./gen -n 5 -l -100000 -r 100000 -type no_cover\n\n./gen -n 10 -l -50000 -r 50000 -type max_angle\n./gen -n 10 -l -50000 -r 50000 -type min_angle\n./gen -n 20 -l -50000 -r 50000 -type edge_case\n\n./gen -n 20 -l 0 -r 100000 -type same_position\n./gen -n 1 -l 0 -r 100000 -type min_n\n./gen -n 20 -l -100000 -r -50000 -type max_n\n\n./gen -n 5 -l 100 -r 200 -type random\n./gen -n 18 -l -200 -r -100 -type random\n./gen -n 15 -l 0 -r 1 -type random\n\n./gen -n 2 -l 99999 -r 100000 -type random\n./gen -n 3 -l -100000 -r -99999 -type random\n./gen -n 4 -l 12345 -r 12345 -type zero_length_segment\n\n./gen -n 5 -l -100000 -r 100000 -type random\n./gen -n 6 -l -100000 -r 100000 -type same_position\n./gen -n 7 -l 0 -r 100000 -type edge_case\n\n./gen -n 8 -l -100000 -r 0 -type edge_case\n./gen -n 9 -l -1 -r 1 -type random\n./gen -n 10 -l -1000 -r 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:18.034080",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "385/E",
      "title": "E. Bear in the Field",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains six space-separated integers: n, sx, sy, dx, dy, t (1 ≤ n ≤ 109; 1 ≤ sx, sy ≤ n;  - 100 ≤ dx, dy ≤ 100; 0 ≤ t ≤ 1018).",
      "output_spec": "OutputPrint two integers — the coordinates of the cell the bear will end up in after t seconds.",
      "sample_tests": "ExamplesInputCopy5 1 2 0 1 2OutputCopy3 1InputCopy1 1 1 -1 -1 2OutputCopy1 1",
      "description": "E. Bear in the Field\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains six space-separated integers: n, sx, sy, dx, dy, t (1 ≤ n ≤ 109; 1 ≤ sx, sy ≤ n;  - 100 ≤ dx, dy ≤ 100; 0 ≤ t ≤ 1018).\n\nOutputPrint two integers — the coordinates of the cell the bear will end up in after t seconds.\n\nInputCopy5 1 2 0 1 2OutputCopy3 1InputCopy1 1 1 -1 -1 2OutputCopy1 1\n\nInputCopy5 1 2 0 1 2\n\nOutputCopy3 1\n\nInputCopy1 1 1 -1 -1 2\n\nOutputCopy1 1\n\nNoteOperation a mod b means taking the remainder after dividing a by b. Note that the result of the operation is always non-negative. For example, ( - 1) mod 3 = 2.In the first sample before the first move the speed vector will equal (3,4) and the bear will get to cell (4,1). Before the second move the speed vector will equal (9,10) and he bear will get to cell (3,1). Don't forget that at the second move, the number of berry bushes increased by 1.In the second sample before the first move the speed vector will equal (1,1) and the bear will get to cell (1,1). Before the second move, the speed vector will equal (4,4) and the bear will get to cell (1,1). Don't forget that at the second move, the number of berry bushes increased by 1.",
      "solutions": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces",
          "content": "Hello!Soon, on January 24th at 19:30 MSK, you are lucky to participate in Codeforces Round #226 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Aleksey Chesnokov (CleRIC), Kirill Butin (KirillB) and Ivan Popovich (NVAL). This is the first round prepared by us and we hope that everything will be OK.During the round you will be helping to the hero of the problems — usual bear.We want to thank Gerald, Delinur, Aksenov239 and MikeMirzayanov for the system.Scoring: 500-1000-1500-2000-2500.Good Luck!UPD: Round rescheduled for 5 minutes laterUPD: EditorialUPD: We hope that you liked round.Congratulations to winners: cptbtptp SquirrelDetected MahooshojoNHB Dong5k yada",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10512",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 749
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces",
          "content": "385A - Bear and RaspberryIn this task required to understand that the answer max(a[i] - a[i - 1] - c),i = 2..n and don't forget that the answer not negative as Bear can not borrow in the debt barrel of honey.385B - Bear and StringsIn this problem you could write a better solution than the naive. To do this, you can iterate through the first cycle of the left index l considered substring and the second cycle of the right index r considered substring (l ≤ r). If any position has been substring \"bear\", means all the strings x(l, j) (i ≤ j), also contain \"bear\" as a substring. So we can add to the answer |s| - j + 1 and exit from the second cycle. Also needed to understand, that if the string x(l, j) was not a substring \"bear\", then in row x(l, j + 1) substring \"bear\" could appear only in the last four characters.385C - Bear and Prime NumbersIn order to solve given problem, contestant should solve several subproblems :1) First one is to compute amount of entries of each natural number between 2 and 107 in given list. This subproblem can be solved by creating array count of 107 elements and increasing corresponding element when scanning input.2) Second one is to compute f(n).First of all, we need to find all primes less than 107 and then for each prime n compute f(n).How to compute f(2)? We should sum count[2],count[4],count[6],count[8],...How to compute f(5)? We should sum count[5],count[10],count[15],count[20],...How to compute f(n)? We should sum count[n],count[2·n],count[3·n],count[4·n],...It can be seen that given algo is very similar to Sieve of Eratosthenes. (Info here http://e-maxx.ru/algo/eratosthenes_sieve) So we can use this algo if we change it a little bit. Also, we will store results of calculation in array, e.g. pre. Namely, pre[n] = f(n).3) Now we can calculate partial sums of pre array. It can be made in a single pass just adding pre[i - 1] to pre[i].4) If we know partial sums of array then we can calculate sum of array elements between l and r in time proportional O(1), just calculate pre[r] - pre[l - 1].5) Now we can read queries and immediately response to them. You shouldn't forget that right boundaries of intervals can be greater than 107, so you can always decrease it to 107, because all numbers in given list are less than 107.385D - Bear and FloodlightIn this task, it is crucial to understand that whether there is lighted part of road with length dist then next part should be lit in a such way that leftmost lighted point is touching with dist.Let's suppose that road is lit from l to d. How we can find rightmost point on X axis that would be lit by next floodlight?We can just use concepts of vector and rotation matrix.Let's find vector (dx, dy) from floodlight to point on X axis (d, 0). (dx, dy) = (d - x, 0 - y).Next point to rotate vector by angle degrees. We can use rotation matrix for this purpose.(dx, dy) = (dx·cos(angle) - dy·sin(angle), dx·sin(angle) + dy·cos(angle))Next, we should make second component dy of (dx, dy) equal to 1 by multiplying on coefficient k.Now we can determine rightmost lighted point of X axis. It is x - y·dx.You shouldn't forget that there is possibility for rightmost point to be infinitely far point.From now on we can forget about geometry in this task.Let's find fast way to determine optimal order of floodlights.To achieve this goal, we can use dynamic programming approach. Namely, let's calculate answer for subsets of floodlights. Each subset would be represented as integer where k bit would be 1 if k floodlight is presented in subset and 0 if it is not, i.e. so named binary mask.For example, dp[6] — (6 — 1102) is optimal answer for subset from 2 and 3 floodlight.Now, let's look through subsets i in dp[i]. In subset i let's go through absent floodlights j and update result for subset where j floodlight is present, i.e. dp[ i or 2j ] = max(dp[ i or 2j], dp[ i ] + calc_rightmost_lighted_point() ). As we can calculate rightmost lighted point, so updating of answer shouldn't be a problem.385E - Bear in the FieldIn this task there are several problems that should be concerned:1) Simple modeling of bear movement would cause TLE due to t  ≤  1018.2) Task can't be solved by separating x and y axes because x and y depends on each other.3) Also, we can't use standart method of cycle finding via modeling for a short time and checking on collisions because coordinates limitations are very large.Let's say we have matrix (xi, yi, dxi, dyi, ti, 1).If we multiply previous matrix by following matrix long long base[6][6] = {{2,1,1,1,0,0},{1,2,1,1,0,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,1,1,0},{0,0,2,2,1,1} };we will have get parameters on next step.Where did the matrix? Let us write out how to change parameters with each step and see the similarity matrix.x = 2·x + 1·y + 1·dx + 0·dy + 0·t + 0·1.y = 1·x + 2·y + 0·dx + 1·dy + 0·t + 0·1.dx = 1·x + 1·y + 1·dx + 0·dy + 1·t + 2·1.dy = 1·x + 1·y + 0·dx + 1·dy + 1·t + 2·1.t = 0·x + 0·y + 0·dx + 0·dy + 1·t + 1·1.1 = 0·x + 0·y + 0·dx + 0·dy + 0·t + 1·1.So if we calculate t - 1 power of base and then multiply (sx, sy, dx, dy, t, 1) by it we will calculate parameters at moment t.Power of matrix can be calculated via binary power modulo algo due to associativity of matrix multiplication. More info at http://e-maxx.ru/algo/binary_powUsing trivial matrix multiplication algo we will solve this task in time proportional 63·log(t).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 385\\s*E"
          },
          "content_length": 5395
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 1",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 2",
          "code": "// So far I go...\n   |  1 0 1 0 1 0 |     | sx |\n   |  0 1 0 1 1 0 |     | sy |\n   |  1 1 1 0 1 0 |  *  | dx | \n   |  1 1 0 1 1 0 |     | dy |\n   |  0 0 0 0 1 1 |     | M  |   M= Number of moves so far\n   |  0 0 0 0 0 1 |     | 1  |   1= Constant term to increase M",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 3",
          "code": "for(;i<mx;i++) if(!notp[i]) update(i,cnt[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 4",
          "code": "cout << s.size() - 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 5",
          "code": "unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 6",
          "code": "(unsigned int - int) -> unsigned int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 7",
          "code": "i+1<v.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) - Codeforces - Code 8",
          "code": "i<v.size()-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10512",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #226 (Div. 2) — Editorial - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int sx = inf.readInt(1, n, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(1, n, \"sy\");\n    inf.readSpace();\n    int dx = inf.readInt(-100, 100, \"dx\");\n    inf.readSpace();\n    int dy = inf.readInt(-100, 100, \"dy\");\n    inf.readSpace();\n    long long t = inf.readLong(0LL, 1000000000000000000LL, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int sx = inf.readInt(1, n, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(1, n, \"sy\");\n    inf.readSpace();\n    int dx = inf.readInt(-100, 100, \"dx\");\n    inf.readSpace();\n    int dy = inf.readInt(-100, 100, \"dy\");\n    inf.readSpace();\n    long long t = inf.readLong(0LL, 1000000000000000000LL, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int sx = inf.readInt(1, n, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(1, n, \"sy\");\n    inf.readSpace();\n    int dx = inf.readInt(-100, 100, \"dx\");\n    inf.readSpace();\n    int dy = inf.readInt(-100, 100, \"dy\");\n    inf.readSpace();\n    long long t = inf.readLong(0LL, 1000000000000000000LL, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long n_max = opt<long long>(\"n_max\", 1000000000LL);\n    long long t_max = opt<long long>(\"t_max\", 1000000000000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n;\n    int sx, sy;\n    int dx, dy;\n    long long t;\n\n    if(type == \"random_small\") {\n        n = rnd.next(1LL, min(n_max, 1000LL));\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(0LL, min(t_max, 1000LL));\n    } else if (type == \"random_large\") {\n        n = rnd.next(max(1LL, n_max/2), n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(max(0LL, t_max - 100000000000000000LL), t_max);\n    } else if(type == \"zero_t\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = 0LL;\n    } else if(type == \"n_one\") {\n        n = 1LL;\n        sx = 1;\n        sy = 1;\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"neg_speed\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, -1);\n        dy = rnd.next(-100, -1);\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"zero_speed\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = 0;\n        dy = 0;\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"max_speed\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = (rnd.next(0,1) == 0)? -100 : 100;\n        dy = (rnd.next(0,1) == 0)? -100 : 100;\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"mod_edge\") {\n        n = rnd.next(1LL, n_max);\n        sx = 1;\n        sy = 1;\n        dx = rnd.next(-100, -1);\n        dy = rnd.next(-100, -1);\n        t = rnd.next(0LL, t_max);\n    } else {\n        // Default random\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(0LL, t_max);\n    }\n\n    printf(\"%lld %d %d %d %d %lld\\n\", n, sx, sy, dx, dy, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long n_max = opt<long long>(\"n_max\", 1000000000LL);\n    long long t_max = opt<long long>(\"t_max\", 1000000000000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n;\n    int sx, sy;\n    int dx, dy;\n    long long t;\n\n    if(type == \"random_small\") {\n        n = rnd.next(1LL, min(n_max, 1000LL));\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(0LL, min(t_max, 1000LL));\n    } else if (type == \"random_large\") {\n        n = rnd.next(max(1LL, n_max/2), n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(max(0LL, t_max - 100000000000000000LL), t_max);\n    } else if(type == \"zero_t\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = 0LL;\n    } else if(type == \"n_one\") {\n        n = 1LL;\n        sx = 1;\n        sy = 1;\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"neg_speed\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, -1);\n        dy = rnd.next(-100, -1);\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"zero_speed\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = 0;\n        dy = 0;\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"max_speed\") {\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = (rnd.next(0,1) == 0)? -100 : 100;\n        dy = (rnd.next(0,1) == 0)? -100 : 100;\n        t = rnd.next(0LL, t_max);\n    } else if(type == \"mod_edge\") {\n        n = rnd.next(1LL, n_max);\n        sx = 1;\n        sy = 1;\n        dx = rnd.next(-100, -1);\n        dy = rnd.next(-100, -1);\n        t = rnd.next(0LL, t_max);\n    } else {\n        // Default random\n        n = rnd.next(1LL, n_max);\n        sx = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        sy = rnd.next(1, (int)min(n, (long long)INT_MAX));\n        dx = rnd.next(-100, 100);\n        dy = rnd.next(-100, 100);\n        t = rnd.next(0LL, t_max);\n    }\n\n    printf(\"%lld %d %d %d %d %lld\\n\", n, sx, sy, dx, dy, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and t, random data\n./gen -n_max 10 -t_max 10 -type random_small\n./gen -n_max 10 -t_max 10 -type zero_t\n./gen -n_max 10 -t_max 10 -type n_one\n./gen -n_max 10 -t_max 10 -type neg_speed\n./gen -n_max 10 -t_max 10 -type zero_speed\n./gen -n_max 10 -t_max 10 -type max_speed\n./gen -n_max 10 -t_max 10 -type mod_edge\n\n# Moderate n and t, random data\n./gen -n_max 100 -t_max 1000 -type random_small\n./gen -n_max 100 -t_max 1000 -type zero_t\n./gen -n_max 100 -t_max 1000 -type n_one\n./gen -n_max 100 -t_max 1000 -type neg_speed\n./gen -n_max 100 -t_max 1000 -type zero_speed\n./gen -n_max 100 -t_max 1000 -type max_speed\n./gen -n_max 100 -t_max 1000 -type mod_edge\n\n# Larger n and t, random data\n./gen -n_max 1000 -t_max 1000000 -type random_small\n./gen -n_max 1000 -t_max 1000000 -type zero_t\n./gen -n_max 1000 -t_max 1000000 -type n_one\n./gen -n_max 1000 -t_max 1000000 -type neg_speed\n./gen -n_max 1000 -t_max 1000000 -type zero_speed\n./gen -n_max 1000 -t_max 1000000 -type max_speed\n./gen -n_max 1000 -t_max 1000000 -type mod_edge\n\n# Very large n and t, testing performance\n./gen -n_max 1000000 -t_max 1000000000000 -type random_large\n./gen -n_max 1000000 -t_max 1000000000000 -type n_one\n./gen -n_max 1000000 -t_max 1000000000000 -type neg_speed\n./gen -n_max 1000000 -t_max 1000000000000 -type zero_speed\n./gen -n_max 1000000 -t_max 1000000000000 -type max_speed\n./gen -n_max 1000000 -t_max 1000000000000 -type mod_edge\n\n# Maximum n and t, stressing the limits\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type random_large\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type random_large\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type random_large\n\n# Edge cases with maximum values\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type neg_speed\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type zero_speed\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type max_speed\n./gen -n_max 1000000000 -t_max 1000000000000000000 -type mod_edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:20.045936",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "386/A",
      "title": "A. Аукцион второй цены",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 1000) — количество участников аукциона. Вторая строка содержит n целых чисел p1, p2, ... pn, разделенных одиночными пробелами (1 ≤ pi ≤ 10000). Число pi означает цену, предложенную участником с номером i. Гарантируется, что все предложенные цены различны.",
      "output_spec": "Выходные данныеВ единственной строке выходного файла выведите два целых числа, разделенных пробелом: номер участника, победившего в аукционе, и сумму, которую он должен уплатить.",
      "sample_tests": "ПримерыВходные данныеСкопировать25 7Выходные данныеСкопировать2 5Входные данныеСкопировать310 2 8Выходные данныеСкопировать1 8Входные данныеСкопировать63 8 2 9 4 14Выходные данныеСкопировать6 9",
      "description": "A. Аукцион второй цены\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 1000) — количество участников аукциона. Вторая строка содержит n целых чисел p1, p2, ... pn, разделенных одиночными пробелами (1 ≤ pi ≤ 10000). Число pi означает цену, предложенную участником с номером i. Гарантируется, что все предложенные цены различны.\n\nВходные данные\n\nВыходные данныеВ единственной строке выходного файла выведите два целых числа, разделенных пробелом: номер участника, победившего в аукционе, и сумму, которую он должен уплатить.\n\nВыходные данные\n\nВходные данныеСкопировать25 7Выходные данныеСкопировать2 5Входные данныеСкопировать310 2 8Выходные данныеСкопировать1 8Входные данныеСкопировать63 8 2 9 4 14Выходные данныеСкопировать6 9\n\nВходные данныеСкопировать25 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать310 2 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать63 8 2 9 4 14\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6 9\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Testing Round #9 - Codeforces",
          "content": "Если вы не спите в час ночи и не знаете чем заняться, то у меня есть для вас хорошие новости. В час ночи 17-го января 2014 г. состоится Testing Round 9, цель которого протестировать хорошенько платформу перед завтрашним раундом. Мы порелизили большое количество внутренних изменений, которые не видны пользователям, но влияют на всевозможную функциональность системы.Раунд будет неофициальным, нерейтинговым. Мы постараемся дать вам новые задачи, уверен, многие из вас получат удовольствие от их решения.Если вы видите какие-то изменения в функциональности, то пишите о них в комментариях.Спасибо.UPD. Контест закончен. Спасибо всем, кто принял участие.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10422",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 653
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, 10000, \"p\");\n    inf.readEoln();\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All bid prices must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, 10000, \"p\");\n    inf.readEoln();\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All bid prices must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, 10000, \"p\");\n    inf.readEoln();\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All bid prices must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_price = opt<int>(\"max_price\", 10000);\n\n    vector<int> prices(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random prices between 1 and max_price\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n    } else if (type == \"increasing\") {\n        // Generate n distinct random prices and sort them in increasing order\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        sort(prices.begin(), prices.end());\n    } else if (type == \"decreasing\") {\n        // Generate n distinct random prices and sort them in decreasing order\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        sort(prices.begin(), prices.end(), greater<int>());\n    } else if (type == \"first_winner\") {\n        // The first bidder has the highest bid\n        prices[0] = max_price;\n        set<int> used;\n        used.insert(max_price);\n        for(int i = 1; i < n; ) {\n            int val = rnd.next(1, max_price - 1);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle positions except the first one\n        shuffle(prices.begin() + 1, prices.end());\n    } else if (type == \"last_winner\") {\n        // The last bidder has the highest bid\n        prices[n - 1] = max_price;\n        set<int> used;\n        used.insert(max_price);\n        for(int i = 0; i < n - 1; ) {\n            int val = rnd.next(1, max_price - 1);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle positions except the last one\n        shuffle(prices.begin(), prices.end() - 1);\n    } else if (type == \"small_gap\") {\n        // The highest and second-highest bids are close\n        int h = rnd.next(max_price / 2, max_price);\n        prices[0] = h;\n        prices[1] = h - 1;\n        set<int> used;\n        used.insert(h);\n        used.insert(h - 1);\n        for(int i = 2; i < n; ) {\n            int val = rnd.next(1, h - 2);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle all positions\n        shuffle(prices.begin(), prices.end());\n    } else if (type == \"large_gap\") {\n        // The highest bid is much larger than the rest\n        prices[0] = max_price;\n        prices[1] = max_price / 2;\n        set<int> used;\n        used.insert(prices[0]);\n        used.insert(prices[1]);\n        for(int i = 2; i < n; ) {\n            int val = rnd.next(1, prices[1] - 1);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle all positions\n        shuffle(prices.begin(), prices.end());\n    } else {\n        // Default to random\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output prices\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", prices[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_price = opt<int>(\"max_price\", 10000);\n\n    vector<int> prices(n);\n\n    if (type == \"random\") {\n        // Generate n distinct random prices between 1 and max_price\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n    } else if (type == \"increasing\") {\n        // Generate n distinct random prices and sort them in increasing order\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        sort(prices.begin(), prices.end());\n    } else if (type == \"decreasing\") {\n        // Generate n distinct random prices and sort them in decreasing order\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        sort(prices.begin(), prices.end(), greater<int>());\n    } else if (type == \"first_winner\") {\n        // The first bidder has the highest bid\n        prices[0] = max_price;\n        set<int> used;\n        used.insert(max_price);\n        for(int i = 1; i < n; ) {\n            int val = rnd.next(1, max_price - 1);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle positions except the first one\n        shuffle(prices.begin() + 1, prices.end());\n    } else if (type == \"last_winner\") {\n        // The last bidder has the highest bid\n        prices[n - 1] = max_price;\n        set<int> used;\n        used.insert(max_price);\n        for(int i = 0; i < n - 1; ) {\n            int val = rnd.next(1, max_price - 1);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle positions except the last one\n        shuffle(prices.begin(), prices.end() - 1);\n    } else if (type == \"small_gap\") {\n        // The highest and second-highest bids are close\n        int h = rnd.next(max_price / 2, max_price);\n        prices[0] = h;\n        prices[1] = h - 1;\n        set<int> used;\n        used.insert(h);\n        used.insert(h - 1);\n        for(int i = 2; i < n; ) {\n            int val = rnd.next(1, h - 2);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle all positions\n        shuffle(prices.begin(), prices.end());\n    } else if (type == \"large_gap\") {\n        // The highest bid is much larger than the rest\n        prices[0] = max_price;\n        prices[1] = max_price / 2;\n        set<int> used;\n        used.insert(prices[0]);\n        used.insert(prices[1]);\n        for(int i = 2; i < n; ) {\n            int val = rnd.next(1, prices[1] - 1);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n        // Shuffle all positions\n        shuffle(prices.begin(), prices.end());\n    } else {\n        // Default to random\n        set<int> used;\n        for(int i = 0; i < n; ) {\n            int val = rnd.next(1, max_price);\n            if (used.insert(val).second) {\n                prices[i++] = val;\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output prices\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", prices[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type first_winner\n./gen -n 2 -type last_winner\n./gen -n 2 -type small_gap\n./gen -n 2 -type large_gap\n\n./gen -n 3 -type random\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type first_winner\n./gen -n 3 -type last_winner\n./gen -n 3 -type small_gap\n./gen -n 3 -type large_gap\n\n./gen -n 10 -type random\n./gen -n 10 -type first_winner\n./gen -n 10 -type last_winner\n./gen -n 10 -type small_gap\n./gen -n 10 -type large_gap\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type first_winner\n./gen -n 100 -type last_winner\n./gen -n 100 -type small_gap\n./gen -n 100 -type large_gap\n\n./gen -n 500 -type random\n./gen -n 500 -type first_winner\n./gen -n 500 -type last_winner\n./gen -n 500 -type small_gap\n./gen -n 500 -type large_gap\n\n./gen -n 999 -type random\n./gen -n 999 -type first_winner\n./gen -n 999 -type last_winner\n./gen -n 999 -type small_gap\n./gen -n 999 -type large_gap\n\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type first_winner\n./gen -n 1000 -type last_winner\n./gen -n 1000 -type small_gap\n./gen -n 1000 -type large_gap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:21.953016",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "386/B",
      "title": "B. Fly, freebies, fly!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 100), where n — the number of students shouted \"Fly, freebie, fly!\" The second line contains n positive integers ti (1 ≤ ti ≤ 1000).The last line contains integer T (1 ≤ T ≤ 1000) — the time interval during which the freebie was near the dormitory.",
      "output_spec": "OutputPrint a single integer — the largest number of people who will pass exam tomorrow because of the freebie visit.",
      "sample_tests": "ExamplesInputCopy64 1 7 8 3 81OutputCopy3",
      "description": "B. Fly, freebies, fly!\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 100), where n — the number of students shouted \"Fly, freebie, fly!\" The second line contains n positive integers ti (1 ≤ ti ≤ 1000).The last line contains integer T (1 ≤ T ≤ 1000) — the time interval during which the freebie was near the dormitory.\n\nOutputPrint a single integer — the largest number of people who will pass exam tomorrow because of the freebie visit.\n\nInputCopy64 1 7 8 3 81OutputCopy3\n\nInputCopy64 1 7 8 3 81\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Testing Round #9 - Codeforces",
          "content": "The contest Testing Round 9 is a special contest to test recent Codeforces internal improvements. Please, take part in it to help us to be ready for Codeforces Round 224 (Div. 2).The Testing Round 9 will be completely unofficial and unrated. We will use problems from some Saratov contests, they will be new for many of you.If you see any issues in Codeforces behaviour, write a comment here.Thank you!UPD. The contest completed. Thanks to all the participants.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10422",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 461
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> t = inf.readInts(n, 1, 1000, \"t_i\");\n    inf.readEoln();\n\n    int T = inf.readInt(1, 1000, \"T\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> t = inf.readInts(n, 1, 1000, \"t_i\");\n    inf.readEoln();\n\n    int T = inf.readInt(1, 1000, \"T\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> t = inf.readInts(n, 1, 1000, \"t_i\");\n    inf.readEoln();\n\n    int T = inf.readInt(1, 1000, \"T\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ti(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ti[i] = rnd.next(1, 1000);\n    } else if (type == \"same_times\") {\n        int time = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            ti[i] = time;\n    } else if (type == \"max_interval\") {\n        int start_time = rnd.next(1, 1000 - T + 1);\n        for (int i = 0; i < n; ++i)\n            ti[i] = rnd.next(start_time, start_time + T - 1);\n    } else if (type == \"min_interval\") {\n        for (int i = 0; i < n; ++i)\n            ti[i] = i * (T + 1) + 1;\n    } else if (type == \"duplicates\") {\n        int distinct_times = rnd.next(1, n);\n        vector<int> times(distinct_times);\n        for (int i = 0; i < distinct_times; ++i)\n            times[i] = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            ti[i] = times[rnd.next(0, distinct_times - 1)];\n    } else if (type == \"edge_cases\") {\n        // Edge cases like n=1, T=1 or T=1000\n        if (n == 1) {\n            ti[0] = rnd.next(1, 1000);\n        } else {\n            if (T == 1) {\n                ti[0] = rnd.next(1, 1000);\n                for (int i = 1; i < n; ++i)\n                    ti[i] = ti[i - 1] + T + 1;\n            } else if (T == 1000) {\n                for (int i = 0; i < n; ++i)\n                    ti[i] = rnd.next(1, 1000);\n            } else {\n                for (int i = 0; i < n; ++i)\n                    ti[i] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"ascending\") {\n        ti[0] = rnd.next(1, 1000);\n        for (int i = 1; i < n; ++i)\n            ti[i] = min(ti[i - 1] + rnd.next(1, 10), 1000);\n    } else if (type == \"descending\") {\n        ti[0] = rnd.next(1, 1000);\n        for (int i = 1; i < n; ++i)\n            ti[i] = max(ti[i - 1] - rnd.next(1, 10), 1);\n    } else {\n        for (int i = 0; i < n; ++i)\n            ti[i] = rnd.next(1, 1000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ti\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ti[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    // Output T\n    printf(\"%d\\n\", T);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ti(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ti[i] = rnd.next(1, 1000);\n    } else if (type == \"same_times\") {\n        int time = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            ti[i] = time;\n    } else if (type == \"max_interval\") {\n        int start_time = rnd.next(1, 1000 - T + 1);\n        for (int i = 0; i < n; ++i)\n            ti[i] = rnd.next(start_time, start_time + T - 1);\n    } else if (type == \"min_interval\") {\n        for (int i = 0; i < n; ++i)\n            ti[i] = i * (T + 1) + 1;\n    } else if (type == \"duplicates\") {\n        int distinct_times = rnd.next(1, n);\n        vector<int> times(distinct_times);\n        for (int i = 0; i < distinct_times; ++i)\n            times[i] = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            ti[i] = times[rnd.next(0, distinct_times - 1)];\n    } else if (type == \"edge_cases\") {\n        // Edge cases like n=1, T=1 or T=1000\n        if (n == 1) {\n            ti[0] = rnd.next(1, 1000);\n        } else {\n            if (T == 1) {\n                ti[0] = rnd.next(1, 1000);\n                for (int i = 1; i < n; ++i)\n                    ti[i] = ti[i - 1] + T + 1;\n            } else if (T == 1000) {\n                for (int i = 0; i < n; ++i)\n                    ti[i] = rnd.next(1, 1000);\n            } else {\n                for (int i = 0; i < n; ++i)\n                    ti[i] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"ascending\") {\n        ti[0] = rnd.next(1, 1000);\n        for (int i = 1; i < n; ++i)\n            ti[i] = min(ti[i - 1] + rnd.next(1, 10), 1000);\n    } else if (type == \"descending\") {\n        ti[0] = rnd.next(1, 1000);\n        for (int i = 1; i < n; ++i)\n            ti[i] = max(ti[i - 1] - rnd.next(1, 10), 1);\n    } else {\n        for (int i = 0; i < n; ++i)\n            ti[i] = rnd.next(1, 1000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ti\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ti[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    // Output T\n    printf(\"%d\\n\", T);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 100 -T 1 -type same_times\n./gen -n 100 -T 1000 -type same_times\n./gen -n 1 -T 1 -type edge_cases\n./gen -n 1 -T 1000 -type edge_cases\n./gen -n 100 -T 1 -type min_interval\n./gen -n 100 -T 1000 -type min_interval\n./gen -n 100 -T 500 -type max_interval\n./gen -n 100 -T 1000 -type max_interval\n./gen -n 100 -T 1 -type random\n./gen -n 100 -T 500 -type random\n./gen -n 100 -T 1000 -type random\n./gen -n 100 -T 1000 -type duplicates\n./gen -n 100 -T 1 -type duplicates\n./gen -n 100 -T 1000 -type ascending\n./gen -n 100 -T 1000 -type descending\n./gen -n 100 -T 1 -type ascending\n./gen -n 50 -T 500 -type random\n./gen -n 99 -T 1000 -type max_interval\n./gen -n 80 -T 700 -type duplicates\n./gen -n 70 -T 300 -type min_interval\n./gen -n 25 -T 250 -type edge_cases\n./gen -n 100 -T 1 -type edge_cases\n./gen -n 100 -T 1000 -type edge_cases\n./gen -n 2 -T 500 -type random\n./gen -n 3 -T 750 -type duplicates\n./gen -n 50 -T 1000 -type same_times\n./gen -n 50 -T 500 -type max_interval\n./gen -n 100 -T 1 -type min_interval\n./gen -n 1 -T 1 -type ascending\n./gen -n 1 -T 1000 -type descending\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:23.981133",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "386/C",
      "title": "C. Diverse Substrings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of a single line containing s. It contains only lowercase Latin letters, the length of s is from 1 to 3·105.",
      "output_spec": "OutputPrint to the first line the value d(s). Print sequence t1, t2, ..., td(s) to the following lines, where ti is the number of substrings of s having diversity of exactly i.",
      "sample_tests": "ExamplesInputCopyabcaOutputCopy3433InputCopyaabacaabbadOutputCopy41419285",
      "description": "C. Diverse Substrings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of a single line containing s. It contains only lowercase Latin letters, the length of s is from 1 to 3·105.\n\nOutputPrint to the first line the value d(s). Print sequence t1, t2, ..., td(s) to the following lines, where ti is the number of substrings of s having diversity of exactly i.\n\nInputCopyabcaOutputCopy3433InputCopyaabacaabbadOutputCopy41419285\n\nInputCopyabca\n\nOutputCopy3433\n\nInputCopyaabacaabbad\n\nOutputCopy41419285\n\nNoteConsider the first example.We denote by s(i, j) a substring of \"abca\" with the indices in the segment [i, j].  s(1, 1) =  \"a\", d(\"a\") = 1  s(2, 2) =  \"b\", d(\"b\") = 1  s(3, 3) =  \"c\", d(\"c\") = 1  s(4, 4) =  \"a\", d(\"a\") = 1  s(1, 2) =  \"ab\", d(\"ab\") = 2  s(2, 3) =  \"bc\", d(\"bc\") = 2  s(3, 4) =  \"ca\", d(\"ca\") = 2  s(1, 3) =  \"abc\", d(\"abc\") = 3  s(2, 4) =  \"bca\", d(\"bca\") = 3  s(1, 4) =  \"abca\", d(\"abca\") = 3 Total number of substring with diversity 1 is 4, with diversity 2 equals 3, 3 diversity is 3.",
      "solutions": [
        {
          "title": "Testing Round #9 - Codeforces",
          "content": "The contest Testing Round 9 is a special contest to test recent Codeforces internal improvements. Please, take part in it to help us to be ready for Codeforces Round 224 (Div. 2).The Testing Round 9 will be completely unofficial and unrated. We will use problems from some Saratov contests, they will be new for many of you.If you see any issues in Codeforces behaviour, write a comment here.Thank you!UPD. The contest completed. Thanks to all the participants.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10422",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 461
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the string s from the input\n    string s = inf.readLine();\n    // Ensure that after reading s, we have reached EOF\n    inf.readEof();\n    // Check that the length of s is within the specified bounds\n    int n = s.length();\n    ensuref(1 <= n && n <= 300000, \"The length of s must be between 1 and 3e5, but found %d\", n);\n    // Check that s consists only of lowercase Latin letters\n    for (int i = 0; i < n; ++i) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"Character s[%d]=%c is not a lowercase Latin letter\", i+1, s[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the string s from the input\n    string s = inf.readLine();\n    // Ensure that after reading s, we have reached EOF\n    inf.readEof();\n    // Check that the length of s is within the specified bounds\n    int n = s.length();\n    ensuref(1 <= n && n <= 300000, \"The length of s must be between 1 and 3e5, but found %d\", n);\n    // Check that s consists only of lowercase Latin letters\n    for (int i = 0; i < n; ++i) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"Character s[%d]=%c is not a lowercase Latin letter\", i+1, s[i]);\n    }\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read the string s from the input\n    string s = inf.readLine();\n    // Ensure that after reading s, we have reached EOF\n    inf.readEof();\n    // Check that the length of s is within the specified bounds\n    int n = s.length();\n    ensuref(1 <= n && n <= 300000, \"The length of s must be between 1 and 3e5, but found %d\", n);\n    // Check that s consists only of lowercase Latin letters\n    for (int i = 0; i < n; ++i) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"Character s[%d]=%c is not a lowercase Latin letter\", i+1, s[i]);\n    }\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k < 1 || k > 26) {\n        cerr << \"Parameter k must be between 1 and 26.\" << endl;\n        exit(1);\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        // Random string of length n, using k distinct letters\n        string letters = \"\";\n        for (int i = 0; i < k; ++i)\n            letters += 'a' + i;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(0, k - 1)];\n    } else if (type == \"repeating\") {\n        // String of length n, repeating a single character\n        char c = 'a';\n        s = string(n, c);\n    } else if (type == \"blocks\") {\n        // String of length n, blocks of same characters\n        s = \"\";\n        int block_size = opt<int>(\"block_size\", 1);\n        if (block_size <= 0) {\n            cerr << \"block_size must be positive.\" << endl;\n            exit(1);\n        }\n        int num_blocks = (n + block_size - 1) / block_size;\n        string letters = \"\";\n        for (int i = 0; i < k; ++i)\n            letters += 'a' + i;\n        for (int i = 0; i < num_blocks; ++i) {\n            char c = letters[i % k];\n            int len = min(block_size, n - (int)s.length());\n            s += string(len, c);\n        }\n    } else if (type == \"increase_diversity\") {\n        // String where new letters are introduced over time\n        if (k > n) {\n            cerr << \"Cannot have k > n in increase_diversity.\" << endl;\n            exit(1);\n        }\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int letters_to_use = min(k, i + 1);\n            s += 'a' + rnd.next(0, letters_to_use - 1);\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindromic string\n        string half;\n        string letters = \"\";\n        for (int i = 0; i < k; ++i)\n            letters += 'a' + i;\n        int half_len = n / 2;\n        for (int i = 0; i < half_len; ++i)\n            half += letters[rnd.next(0, k - 1)];\n        s = half;\n        if (n % 2 == 1)\n            s += letters[rnd.next(0, k - 1)];\n        s += string(half.rbegin(), half.rend());\n    } else if (type == \"alternating\") {\n        // Alternating characters\n        if (k < 2) {\n            cerr << \"k must be at least 2 for alternating\" << endl;\n            exit(1);\n        }\n        char c1 = 'a';\n        char c2 = 'b';\n        for (int i = 0; i < n; ++i)\n            s += (i % 2 == 0) ? c1 : c2;\n    } else if (type == \"max_diversity\") {\n        // Use all 26 letters as evenly as possible\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += 'a' + (i % 26);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k < 1 || k > 26) {\n        cerr << \"Parameter k must be between 1 and 26.\" << endl;\n        exit(1);\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        // Random string of length n, using k distinct letters\n        string letters = \"\";\n        for (int i = 0; i < k; ++i)\n            letters += 'a' + i;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(0, k - 1)];\n    } else if (type == \"repeating\") {\n        // String of length n, repeating a single character\n        char c = 'a';\n        s = string(n, c);\n    } else if (type == \"blocks\") {\n        // String of length n, blocks of same characters\n        s = \"\";\n        int block_size = opt<int>(\"block_size\", 1);\n        if (block_size <= 0) {\n            cerr << \"block_size must be positive.\" << endl;\n            exit(1);\n        }\n        int num_blocks = (n + block_size - 1) / block_size;\n        string letters = \"\";\n        for (int i = 0; i < k; ++i)\n            letters += 'a' + i;\n        for (int i = 0; i < num_blocks; ++i) {\n            char c = letters[i % k];\n            int len = min(block_size, n - (int)s.length());\n            s += string(len, c);\n        }\n    } else if (type == \"increase_diversity\") {\n        // String where new letters are introduced over time\n        if (k > n) {\n            cerr << \"Cannot have k > n in increase_diversity.\" << endl;\n            exit(1);\n        }\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int letters_to_use = min(k, i + 1);\n            s += 'a' + rnd.next(0, letters_to_use - 1);\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindromic string\n        string half;\n        string letters = \"\";\n        for (int i = 0; i < k; ++i)\n            letters += 'a' + i;\n        int half_len = n / 2;\n        for (int i = 0; i < half_len; ++i)\n            half += letters[rnd.next(0, k - 1)];\n        s = half;\n        if (n % 2 == 1)\n            s += letters[rnd.next(0, k - 1)];\n        s += string(half.rbegin(), half.rend());\n    } else if (type == \"alternating\") {\n        // Alternating characters\n        if (k < 2) {\n            cerr << \"k must be at least 2 for alternating\" << endl;\n            exit(1);\n        }\n        char c1 = 'a';\n        char c2 = 'b';\n        for (int i = 0; i < n; ++i)\n            s += (i % 2 == 0) ? c1 : c2;\n    } else if (type == \"max_diversity\") {\n        // Use all 26 letters as evenly as possible\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += 'a' + (i % 26);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal length strings\n./gen -n 1 -k 1 -type repeating\n./gen -n 1 -k 1 -type random\n\n# Small length strings\n./gen -n 5 -k 2 -type alternating\n./gen -n 10 -k 3 -type random\n./gen -n 15 -k 4 -type blocks -block_size 3\n\n# Medium length strings\n./gen -n 1000 -k 26 -type random\n./gen -n 1000 -k 5 -type increase_diversity\n./gen -n 5000 -k 2 -type alternating\n./gen -n 10000 -k 6 -type palindrome\n./gen -n 10000 -k 10 -type blocks -block_size 1000\n\n# Large length strings\n./gen -n 100000 -k 26 -type random\n./gen -n 200000 -k 1 -type repeating\n./gen -n 300000 -type max_diversity\n./gen -n 300000 -k 2 -type alternating\n./gen -n 300000 -k 15 -type increase_diversity\n./gen -n 300000 -k 10 -type blocks -block_size 10000\n./gen -n 300000 -k 13 -type palindrome\n\n# Edge cases\n./gen -n 300000 -k 1 -type repeating\n./gen -n 26 -k 26 -type random\n./gen -n 100000 -k 26 -type increase_diversity\n./gen -n 260000 -type max_diversity\n./gen -n 100000 -k 10 -type blocks -block_size 1\n./gen -n 100000 -k 10 -type blocks -block_size 10000\n./gen -n 99999 -k 5 -type palindrome\n./gen -n 300000 -k 2 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:25.981685",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "386/D",
      "title": "D. Игра с точками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (3 ≤ n ≤ 70) — количество точек. Во второй строке записаны три различных целых числа от 1 до n — номера точек, в которых изначально находятся фишки. Каждая из следующих строк содержит по n символов — это матрица, задающая цвета отрезков. Цвета задаются строчными буквами латинского алфавита. Символ с номером j в i-й строке матрицы обозначает цвет отрезка между точками i и j. Матрица симметрична, то есть j-й символ i-й строки совпадает с i-м символом j-й строки. На главной диагонали матрицы стоят символы '*', потому что не существует отрезка, соединяющего точку саму с собой.",
      "output_spec": "Выходные данныеЕсли не существует ни одной последовательности ходов, после которых фишки оказываются в точках с номерами 1, 2 и 3, выведите в единственной строке число -1. Если же решение существует, то в первой строке выведите наименьшее возможное количество ходов, а далее сами ходы. Для описания очередного хода в отдельной строке выведите два целых числа через пробел — номер точки, откуда следует взять фишку, и номер точки, куда ее следует передвинуть. Если оптимальных последовательностей ходов несколько, выведите любую из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 3 4*abaa*abba*babb*Выходные данныеСкопировать14 1Входные данныеСкопировать42 3 4*abca*abba*bcbb*Выходные данныеСкопировать-1",
      "description": "D. Игра с точками\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (3 ≤ n ≤ 70) — количество точек. Во второй строке записаны три различных целых числа от 1 до n — номера точек, в которых изначально находятся фишки. Каждая из следующих строк содержит по n символов — это матрица, задающая цвета отрезков. Цвета задаются строчными буквами латинского алфавита. Символ с номером j в i-й строке матрицы обозначает цвет отрезка между точками i и j. Матрица симметрична, то есть j-й символ i-й строки совпадает с i-м символом j-й строки. На главной диагонали матрицы стоят символы '*', потому что не существует отрезка, соединяющего точку саму с собой.\n\nВходные данные\n\nВыходные данныеЕсли не существует ни одной последовательности ходов, после которых фишки оказываются в точках с номерами 1, 2 и 3, выведите в единственной строке число -1. Если же решение существует, то в первой строке выведите наименьшее возможное количество ходов, а далее сами ходы. Для описания очередного хода в отдельной строке выведите два целых числа через пробел — номер точки, откуда следует взять фишку, и номер точки, куда ее следует передвинуть. Если оптимальных последовательностей ходов несколько, выведите любую из них.\n\nВыходные данные\n\nВходные данныеСкопировать42 3 4*abaa*abba*babb*Выходные данныеСкопировать14 1Входные данныеСкопировать42 3 4*abca*abba*bcbb*Выходные данныеСкопировать-1\n\nВходные данныеСкопировать42 3 4*abaa*abba*babb*\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать14 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать42 3 4*abca*abba*bcbb*\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере мы можем передвинуть фишку из точки 4 в точку 1, потому что они соединены отрезком цвета 'a', как и точки 2 и 3, в которых находятся две другие фишки. После этого хода фишки находятся в точках 1, 2 и 3.",
      "solutions": [
        {
          "title": "Testing Round #9 - Codeforces",
          "content": "Если вы не спите в час ночи и не знаете чем заняться, то у меня есть для вас хорошие новости. В час ночи 17-го января 2014 г. состоится Testing Round 9, цель которого протестировать хорошенько платформу перед завтрашним раундом. Мы порелизили большое количество внутренних изменений, которые не видны пользователям, но влияют на всевозможную функциональность системы.Раунд будет неофициальным, нерейтинговым. Мы постараемся дать вам новые задачи, уверен, многие из вас получат удовольствие от их решения.Если вы видите какие-то изменения в функциональности, то пишите о них в комментариях.Спасибо.UPD. Контест закончен. Спасибо всем, кто принял участие.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10422",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 653
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 70, \"n\");\n    inf.readEoln();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, n, \"c\");\n    inf.readEoln();\n    ensuref(a != b && b != c && a != c, \"The stones must be on three distinct points\");\n\n    vector<string> matrix(n);\n    for (int i = 0; i < n; i++) {\n        matrix[i] = inf.readLine();\n        ensuref((int)matrix[i].length() == n, \"Line %d should have length %d\", i+1, n);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                ensuref(matrix[i][j] == '*', \"Matrix[%d][%d] should be '*'\", i+1, j+1);\n            } else {\n                ensuref(matrix[i][j] >= 'a' && matrix[i][j] <= 'z', \"Matrix[%d][%d] should be a lowercase letter\", i+1, j+1);\n            }\n            ensuref(matrix[i][j] == matrix[j][i], \"Matrix not symmetric at positions (%d,%d) and (%d,%d)\", i+1, j+1, j+1, i+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 70, \"n\");\n    inf.readEoln();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, n, \"c\");\n    inf.readEoln();\n    ensuref(a != b && b != c && a != c, \"The stones must be on three distinct points\");\n\n    vector<string> matrix(n);\n    for (int i = 0; i < n; i++) {\n        matrix[i] = inf.readLine();\n        ensuref((int)matrix[i].length() == n, \"Line %d should have length %d\", i+1, n);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                ensuref(matrix[i][j] == '*', \"Matrix[%d][%d] should be '*'\", i+1, j+1);\n            } else {\n                ensuref(matrix[i][j] >= 'a' && matrix[i][j] <= 'z', \"Matrix[%d][%d] should be a lowercase letter\", i+1, j+1);\n            }\n            ensuref(matrix[i][j] == matrix[j][i], \"Matrix not symmetric at positions (%d,%d) and (%d,%d)\", i+1, j+1, j+1, i+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 70, \"n\");\n    inf.readEoln();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, n, \"c\");\n    inf.readEoln();\n    ensuref(a != b && b != c && a != c, \"The stones must be on three distinct points\");\n\n    vector<string> matrix(n);\n    for (int i = 0; i < n; i++) {\n        matrix[i] = inf.readLine();\n        ensuref((int)matrix[i].length() == n, \"Line %d should have length %d\", i+1, n);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                ensuref(matrix[i][j] == '*', \"Matrix[%d][%d] should be '*'\", i+1, j+1);\n            } else {\n                ensuref(matrix[i][j] >= 'a' && matrix[i][j] <= 'z', \"Matrix[%d][%d] should be a lowercase letter\", i+1, j+1);\n            }\n            ensuref(matrix[i][j] == matrix[j][i], \"Matrix not symmetric at positions (%d,%d) and (%d,%d)\", i+1, j+1, j+1, i+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<string> color; // 1-based indexing\nset<int> stones;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(3, 70, \"n\");\n\n    // Read initial positions\n    int s[3];\n    for (int i = 0; i < 3; ++i) {\n        s[i] = inf.readInt(1, n, format(\"initial stone %d\", i + 1).c_str());\n        stones.insert(s[i]);\n    }\n    // Check initial positions are distinct\n    if (stones.size() != 3) {\n        quitf(_fail, \"Initial stones are not at distinct positions\");\n    }\n\n    // Read color matrix\n    color.resize(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        color[i] = inf.readToken(format(\"[a-z*]{%d}\", n).c_str(), format(\"color matrix row %d\", i).c_str());\n        color[i] = \" \" + color[i]; // 1-based indexing\n    }\n\n    // Verify that color matrix is symmetric and main diagonal is '*'\n    for (int i = 1; i <= n; ++i) {\n        if (color[i][i] != '*') {\n            quitf(_fail, \"Color matrix main diagonal must be '*'\");\n        }\n        for (int j = 1; j <= n; ++j) {\n            if (color[i][j] != color[j][i]) {\n                quitf(_fail, \"Color matrix is not symmetric at positions (%d, %d)\", i, j);\n            }\n        }\n    }\n\n    // Read jury's answer\n    int jury_m = ans.readInt(-1, n * n, \"jury's minimal number of moves\");\n\n    // Read participant's answer\n    int participant_m = ouf.readInt(-1, n * n, \"participant's number of moves\");\n\n    if (participant_m == -1) {\n        if (jury_m == -1) {\n            // No solution exists\n            quitf(_ok, \"No solution exists\");\n        } else {\n            // Participant failed to find a solution\n            quitf(_wa, \"Participant failed to find a solution\");\n        }\n    } else {\n        if (jury_m == -1) {\n            quitf(_fail, \"Participant found a solution, but jury says impossible\");\n        }\n        if (participant_m > jury_m) {\n            quitf(_wa, \"Participant's answer is not optimal: m = %d, expected minimal moves = %d\", participant_m, jury_m);\n        } else if (participant_m == jury_m) {\n            // Validate participant's moves\n            for (int move_num = 1; move_num <= participant_m; ++move_num) {\n                int u = ouf.readInt(1, n, format(\"move %d: u\", move_num).c_str());\n                int v = ouf.readInt(1, n, format(\"move %d: v\", move_num).c_str());\n\n                if (u == v) {\n                    quitf(_wa, \"In move %d, u and v are the same: %d\", move_num, u);\n                }\n                if (stones.find(u) == stones.end()) {\n                    quitf(_wa, \"In move %d, u = %d, but u is not occupied by a stone\", move_num, u);\n                }\n                if (stones.find(v) != stones.end()) {\n                    quitf(_wa, \"In move %d, v = %d, but v is already occupied\", move_num, v);\n                }\n                if (color[u][v] == '*') {\n                    quitf(_wa, \"In move %d, no diagonal between %d and %d\", move_num, u, v);\n                }\n\n                // Get the other two stones\n                set<int> other_stones = stones;\n                other_stones.erase(u);\n                if (other_stones.size() != 2) {\n                    quitf(_fail, \"Unexpected error: other_stones.size() != 2\");\n                }\n                auto it = other_stones.begin();\n                int s = *it;\n                int t = *(++it);\n                if (color[s][t] == '*') {\n                    quitf(_wa, \"In move %d, other stones at %d and %d are not connected by a diagonal\", move_num, s, t);\n                }\n                if (color[u][v] != color[s][t]) {\n                    quitf(_wa, \"In move %d, color of diagonal %d-%d ('%c') does not match color of diagonal %d-%d ('%c')\", move_num, u, v, color[u][v], s, t, color[s][t]);\n                }\n                // Move the stone\n                stones.erase(u);\n                stones.insert(v);\n            }\n            // At the end, stones should be at positions 1,2,3\n            if (stones.count(1) && stones.count(2) && stones.count(3) && stones.size() == 3) {\n                quitf(_ok, \"Correct solution with minimal number of moves: %d\", participant_m);\n            } else {\n                quitf(_wa, \"At the end, stones are not at positions 1, 2, 3\");\n            }\n        } else {\n            // participant_m < jury_m\n            quitf(_fail, \"Participant's answer is better than jury's: m = %d, expected minimal moves = %d\", participant_m, jury_m);\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // n in [3, 70]\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> stones(3);\n    vector<string> matrix(n);\n\n    if (type == \"random\") {\n        // Generate random stones\n        set<int> stone_set;\n        while (stone_set.size() < 3) {\n            stone_set.insert(rnd.next(1, n));\n        }\n        int idx = 0;\n        for (int s : stone_set) {\n            stones[idx++] = s;\n        }\n        // Generate random symmetric matrix\n        for (int i = 0; i < n; ++i) {\n            matrix[i].resize(n, '*');\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                char c = 'a' + rnd.next(26);\n                matrix[i][j] = matrix[j][i] = c;\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Generate a test case where no solution exists\n        // Stones are at positions 1, 2, and n\n        stones[0] = 1;\n        stones[1] = 2;\n        stones[2] = n;\n\n        // Create colors that prevent valid moves\n        matrix.resize(n);\n        for (int i = 0; i < n; ++i) {\n            matrix[i].resize(n, '*');\n        }\n\n        // Set specific colors between stones\n        matrix[stones[0]-1][stones[1]-1] = matrix[stones[1]-1][stones[0]-1] = 'a';\n        matrix[stones[0]-1][stones[2]-1] = matrix[stones[2]-1][stones[0]-1] = 'b';\n        matrix[stones[1]-1][stones[2]-1] = matrix[stones[2]-1][stones[1]-1] = 'c';\n\n        // Fill the rest with random colors\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                if (matrix[i][j] == '*') {\n                    char c = 'd' + rnd.next(23); // from 'd' to 'z'\n                    matrix[i][j] = matrix[j][i] = c;\n                }\n            }\n        }\n    } else if (type == \"already_solved\") {\n        // Stones are already at positions 1, 2, 3\n        stones[0] = 1;\n        stones[1] = 2;\n        stones[2] = 3;\n\n        // Generate random symmetric matrix\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, '*');\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i +1; j < n; ++j) {\n                char c = 'a' + rnd.next(26);\n                matrix[i][j] = matrix[j][i] = c;\n            }\n        }\n    } else if (type == \"same_colors\") {\n        // All diagonals have the same color\n        set<int> stone_set;\n        while (stone_set.size() < 3) {\n            stone_set.insert(rnd.next(1, n));\n        }\n        int idx = 0;\n        for (int s : stone_set) {\n            stones[idx++] = s;\n        }\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'a');\n            matrix[i][i] = '*';\n        }\n    } else if (type == \"different_colors\") {\n        // Each diagonal has a unique color\n        set<int> stone_set;\n        while (stone_set.size() < 3) {\n            stone_set.insert(rnd.next(1, n));\n        }\n        int idx = 0;\n        for (int s : stone_set) {\n            stones[idx++] = s;\n        }\n        char current_color = 'a';\n        matrix.resize(n);\n        for (int i = 0; i < n; ++i) {\n            matrix[i].resize(n, '*');\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i +1; j < n; ++j) {\n                matrix[i][j] = matrix[j][i] = current_color;\n                current_color++;\n                if (current_color > 'z') current_color = 'a'; // Wrap around\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    printf(\"%d %d %d\\n\", stones[0], stones[1], stones[2]);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", matrix[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // n in [3, 70]\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> stones(3);\n    vector<string> matrix(n);\n\n    if (type == \"random\") {\n        // Generate random stones\n        set<int> stone_set;\n        while (stone_set.size() < 3) {\n            stone_set.insert(rnd.next(1, n));\n        }\n        int idx = 0;\n        for (int s : stone_set) {\n            stones[idx++] = s;\n        }\n        // Generate random symmetric matrix\n        for (int i = 0; i < n; ++i) {\n            matrix[i].resize(n, '*');\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                char c = 'a' + rnd.next(26);\n                matrix[i][j] = matrix[j][i] = c;\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Generate a test case where no solution exists\n        // Stones are at positions 1, 2, and n\n        stones[0] = 1;\n        stones[1] = 2;\n        stones[2] = n;\n\n        // Create colors that prevent valid moves\n        matrix.resize(n);\n        for (int i = 0; i < n; ++i) {\n            matrix[i].resize(n, '*');\n        }\n\n        // Set specific colors between stones\n        matrix[stones[0]-1][stones[1]-1] = matrix[stones[1]-1][stones[0]-1] = 'a';\n        matrix[stones[0]-1][stones[2]-1] = matrix[stones[2]-1][stones[0]-1] = 'b';\n        matrix[stones[1]-1][stones[2]-1] = matrix[stones[2]-1][stones[1]-1] = 'c';\n\n        // Fill the rest with random colors\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                if (matrix[i][j] == '*') {\n                    char c = 'd' + rnd.next(23); // from 'd' to 'z'\n                    matrix[i][j] = matrix[j][i] = c;\n                }\n            }\n        }\n    } else if (type == \"already_solved\") {\n        // Stones are already at positions 1, 2, 3\n        stones[0] = 1;\n        stones[1] = 2;\n        stones[2] = 3;\n\n        // Generate random symmetric matrix\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, '*');\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i +1; j < n; ++j) {\n                char c = 'a' + rnd.next(26);\n                matrix[i][j] = matrix[j][i] = c;\n            }\n        }\n    } else if (type == \"same_colors\") {\n        // All diagonals have the same color\n        set<int> stone_set;\n        while (stone_set.size() < 3) {\n            stone_set.insert(rnd.next(1, n));\n        }\n        int idx = 0;\n        for (int s : stone_set) {\n            stones[idx++] = s;\n        }\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'a');\n            matrix[i][i] = '*';\n        }\n    } else if (type == \"different_colors\") {\n        // Each diagonal has a unique color\n        set<int> stone_set;\n        while (stone_set.size() < 3) {\n            stone_set.insert(rnd.next(1, n));\n        }\n        int idx = 0;\n        for (int s : stone_set) {\n            stones[idx++] = s;\n        }\n        char current_color = 'a';\n        matrix.resize(n);\n        for (int i = 0; i < n; ++i) {\n            matrix[i].resize(n, '*');\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i +1; j < n; ++j) {\n                matrix[i][j] = matrix[j][i] = current_color;\n                current_color++;\n                if (current_color > 'z') current_color = 'a'; // Wrap around\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    printf(\"%d %d %d\\n\", stones[0], stones[1], stones[2]);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", matrix[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type already_solved\n./gen -n 3 -type no_solution\n\n./gen -n 4 -type random\n./gen -n 4 -type no_solution\n\n./gen -n 5 -type random\n./gen -n 5 -type same_colors\n./gen -n 5 -type different_colors\n./gen -n 5 -type already_solved\n\n./gen -n 10 -type random\n./gen -n 10 -type no_solution\n./gen -n 10 -type already_solved\n\n./gen -n 15 -type random\n./gen -n 15 -type same_colors\n./gen -n 15 -type different_colors\n./gen -n 15 -type already_solved\n\n./gen -n 20 -type random\n\n./gen -n 25 -type random\n./gen -n 25 -type same_colors\n./gen -n 25 -type different_colors\n./gen -n 25 -type no_solution\n\n./gen -n 30 -type random\n\n./gen -n 50 -type random\n./gen -n 50 -type same_colors\n./gen -n 50 -type different_colors\n./gen -n 50 -type no_solution\n\n./gen -n 70 -type random\n./gen -n 70 -type same_colors\n./gen -n 70 -type different_colors\n./gen -n 70 -type no_solution\n./gen -n 70 -type already_solved\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:28.099243",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "387/A",
      "title": "A. Георгий и сон",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано текущее время s в виде строки в формате «hh:mm». Во второй строке задано время t в формате «hh:mm» — продолжительность сна Георгия. Гарантируется, что входные данные содержат корректное время в 24-часовом формате, то есть 00 ≤ hh ≤ 23, 00 ≤ mm ≤ 59.",
      "output_spec": "Выходные данныеВ единственной строке выведите время p — время, когда Георгий лег спать, в формате аналогичном формату времени во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать05:5005:44Выходные данныеСкопировать00:06Входные данныеСкопировать00:0001:00Выходные данныеСкопировать23:00Входные данныеСкопировать00:0100:00Выходные данныеСкопировать00:01",
      "description": "A. Георгий и сон\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано текущее время s в виде строки в формате «hh:mm». Во второй строке задано время t в формате «hh:mm» — продолжительность сна Георгия. Гарантируется, что входные данные содержат корректное время в 24-часовом формате, то есть 00 ≤ hh ≤ 23, 00 ≤ mm ≤ 59.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите время p — время, когда Георгий лег спать, в формате аналогичном формату времени во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать05:5005:44Выходные данныеСкопировать00:06Входные данныеСкопировать00:0001:00Выходные данныеСкопировать23:00Входные данныеСкопировать00:0100:00Выходные данныеСкопировать00:01\n\nВходные данныеСкопировать05:5005:44\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00:06\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать00:0001:00\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать23:00\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать00:0100:00\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00:01\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Георгий лег спать в «00:06». Обратите внимание, что время нужно вывести именно в формате «00:06». Поэтому ответы «0:06», «00:6» и другие будут засчитаны как неверные. Во втором примере Георгий лег спать вчера.В третьем примере Георгий не спал совсем.",
      "solutions": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "Всем привет!Скоро, 30 января, 19:30 MSK, состоится очередной Codeforces Round #227 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса. Автором задач являюсь я. Большое спасибо Гере Агапову (Gerald) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. Главный герой задач этого раунда — кот Георгий.UPD1: Распределение баллов будет таким: 500, 1000, 1500, 2000, 2500.UPD2: Соревнование закончилось, поздравляем победителей! hmm_dream_big graphis InternationalGrandmaster Skedar mateusz UPD: Разбор на русскомUPD: Статистика",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10569",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 682
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "387A - Георгий и сонЯ опишу достаточно простое решение. Пусть Георгий проснулся в h0 часов и m0 минут, а спал ровно h1 часов и m1 минут. Получим числа hp = h0 - h1 и mp = m0 - m1. Если mp < 0, то прибавим к нему 60 минут, а из hp вычтем единицу. Потом, если окажется что hp < 0, то прибавим к нему 24 часа. Вывести ответ на C++ очень просто следующей строкой: Сложность решения: O(1) по времени / O(1) по памяти. printf(\"%02d:%02d\", h[p], m[p]).Авторское решение: 5850831387B - Георгий и раундПереберем количество требований на сложности, которые мы удовлетворим, остальные задачи мы придумаем и подготовим. Понятно, что если мы решили удовлетворить i требований, то выгодно взять те, что обладают минимальной сложностью. Упростим i самых сложных задач до самых легких требований. Если все прошло успешно, то обновим ответ величиной n - i.Сложность решения: O(n2) по времени / O(n) по памяти. Отмечу, существует решение и за линейную сложность O(n + m).Авторское решение: 5850888387C - Георгий и числоПолучим следующее неприводимое представление числа p = a1 + a2 + ... + ak, где  +  — конкатенация, а числа ai имеют вид x00..000 (некоторая ненулевая цифра, потом нули). Найдем самой большой индекс i, такой, что число a1 + a2 + ... + ai - 1 < ai. Если такого i нет, то i = 1. Тогда ответом на задачу будет число k - i + 1. Сравнения чисел можно производить, используя длину чисел и первые цифры. Попробуйте доказать это, используя единственность неприводимого разложения.Сложность решения: O(n) по времени / O(n) по памяти.Авторское решение: 5850919387D - Георгий и интересный графДля решения данной задачи нужно знать что такое максимальное паросочетание. Переберем центр графа i. Удалим все дуги вида (i, u) и (u, i). Пусть таких дуг cntWithI. Количество остальных дуг обозначим за Other. На остальных дугах и всех вершинах, кроме i, запустим алгоритм поиска максимального паросочетания, если полагать в качестве левой доли степень исхода, а в качестве правой степень захода. Дуга из нашего графа (i, j) будет равна дуге (i, j) — где i в левой доле, а j — в правой. Пусть его размер равен leng. Тогда ответ равен для текущей вершины равен 2n - 1 - cntWithI + Other - leng + (n - 1) - leng. Обновим глобальный ответ. Почему так можно делать? Понятно, что если мы найдем максимальное паросочетание в графе, мы удовлетворим максимально возможное количество требований на степени исхода и захода. Поэтому ребра из максимального паросочетания мы удалять не будем, удалим все кроме максимального паросочетания, и дополним его до полного паросочетания добавив (n - 1) - leng ребер. Следует добавить, что важно требование, что петли разрешены. Без этого разрешения так решать задачу нельзя. Сложность решения: O(n2m) по времени / O(n + m) по памяти.5850946387E - Георгий и карточкиПосчитаем массивы pos[i] — позиция числа i перестановке p, и need[i] — нужно ли удалить число i из перестановки p.Теперь рассмотрим числа a1, a2, ..., an - k — числа, которые нужно удалить. Понятно, что их выгодно удалять в порядке возрастания, это нетрудно доказать. Теперь будем иди по всем числам от 1 до n. Дополнительно будем поддерживать упорядоченное множество (set <> в с++, TreeSet в Java) — позиции не удаленных чисел, строго меньших текущего. Эти числа, как раз, могут создать <<препятствия>> для позиции текущего числа. Данное множество очень просто поддерживать. Для удобства, можно добавить в данное множество числа  - 1 и n. Теперь очень просто узнать размер максимального подотрезка, на котором число будет минимум. Это делается с помощью стандартных функций языка программирования (lower и higher в Java) Теперь осталось воспользоваться деревом Фенвика, чтобы узнать количество еще не удаленных чисел на данном отрезке.Сложность решения: по времени / O(n) по памяти.Очень короткая реализация решения на языке Java: 5850986",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10583",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 387\\s*A"
          },
          "content_length": 3815
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "Round duration increased for 10 minutes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 3",
          "code": "left/right(int i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 4",
          "code": "cout << setw(5) << setfill('0') << 42 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 5",
          "code": "cout << \"0\" << hour << \":\" <<\"0\" << min << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 6",
          "code": "00:00\n00:01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 7",
          "code": "00:00\n00:01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 8",
          "code": "if(hour<10 && min<10) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the first line: s in format \"hh:mm\"\n    string s = inf.readLine(\"[0-9]{2}:[0-9]{2}\", \"s\");\n    \n    // Extract hh and mm from s\n    string hh_str = s.substr(0,2);\n    string mm_str = s.substr(3,2);\n    int hh = stoi(hh_str);\n    int mm = stoi(mm_str);\n    // Check ranges\n    ensuref(0 <= hh && hh <= 23, \"Hour in s should be between 00 and 23, but it's %d\", hh);\n    ensuref(0 <= mm && mm <= 59, \"Minute in s should be between 00 and 59, but it's %d\", mm);\n\n    // Read the second line: t in format \"hh:mm\"\n    string t = inf.readLine(\"[0-9]{2}:[0-9]{2}\", \"t\");\n    \n    // Extract hh and mm from t\n    string hh_t_str = t.substr(0,2);\n    string mm_t_str = t.substr(3,2);\n    int hh_t = stoi(hh_t_str);\n    int mm_t = stoi(mm_t_str);\n    // Check ranges\n    ensuref(0 <= hh_t && hh_t <= 23, \"Hour in t should be between 00 and 23, but it's %d\", hh_t);\n    ensuref(0 <= mm_t && mm_t <= 59, \"Minute in t should be between 00 and 59, but it's %d\", mm_t);\n\n    // Ensure no more input\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the first line: s in format \"hh:mm\"\n    string s = inf.readLine(\"[0-9]{2}:[0-9]{2}\", \"s\");\n    \n    // Extract hh and mm from s\n    string hh_str = s.substr(0,2);\n    string mm_str = s.substr(3,2);\n    int hh = stoi(hh_str);\n    int mm = stoi(mm_str);\n    // Check ranges\n    ensuref(0 <= hh && hh <= 23, \"Hour in s should be between 00 and 23, but it's %d\", hh);\n    ensuref(0 <= mm && mm <= 59, \"Minute in s should be between 00 and 59, but it's %d\", mm);\n\n    // Read the second line: t in format \"hh:mm\"\n    string t = inf.readLine(\"[0-9]{2}:[0-9]{2}\", \"t\");\n    \n    // Extract hh and mm from t\n    string hh_t_str = t.substr(0,2);\n    string mm_t_str = t.substr(3,2);\n    int hh_t = stoi(hh_t_str);\n    int mm_t = stoi(mm_t_str);\n    // Check ranges\n    ensuref(0 <= hh_t && hh_t <= 23, \"Hour in t should be between 00 and 23, but it's %d\", hh_t);\n    ensuref(0 <= mm_t && mm_t <= 59, \"Minute in t should be between 00 and 59, but it's %d\", mm_t);\n\n    // Ensure no more input\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read the first line: s in format \"hh:mm\"\n    string s = inf.readLine(\"[0-9]{2}:[0-9]{2}\", \"s\");\n    \n    // Extract hh and mm from s\n    string hh_str = s.substr(0,2);\n    string mm_str = s.substr(3,2);\n    int hh = stoi(hh_str);\n    int mm = stoi(mm_str);\n    // Check ranges\n    ensuref(0 <= hh && hh <= 23, \"Hour in s should be between 00 and 23, but it's %d\", hh);\n    ensuref(0 <= mm && mm <= 59, \"Minute in s should be between 00 and 59, but it's %d\", mm);\n\n    // Read the second line: t in format \"hh:mm\"\n    string t = inf.readLine(\"[0-9]{2}:[0-9]{2}\", \"t\");\n    \n    // Extract hh and mm from t\n    string hh_t_str = t.substr(0,2);\n    string mm_t_str = t.substr(3,2);\n    int hh_t = stoi(hh_t_str);\n    int mm_t = stoi(mm_t_str);\n    // Check ranges\n    ensuref(0 <= hh_t && hh_t <= 23, \"Hour in t should be between 00 and 23, but it's %d\", hh_t);\n    ensuref(0 <= mm_t && mm_t <= 59, \"Minute in t should be between 00 and 59, but it's %d\", mm_t);\n\n    // Ensure no more input\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring format_time(int hour, int minute) {\n    char buffer[6];\n    sprintf(buffer, \"%02d:%02d\", hour, minute);\n    return string(buffer);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate random current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        // Generate random sleep duration t\n        int t_hour = rnd.next(0,23);\n        int t_minute = rnd.next(0,59);\n        t = format_time(t_hour, t_minute);\n    } else if (type == \"zero_sleep\") {\n        // Generate random current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        // Sleep duration t is \"00:00\"\n        t = \"00:00\";\n    } else if (type == \"max_sleep\") {\n        // Generate random current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        // Sleep duration t is \"23:59\"\n        t = \"23:59\";\n    } else if (type == \"over_midnight\") {\n        // Generate current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        int s_total = s_hour * 60 + s_minute;\n        // Generate t_total such that t_total > s_total\n        int t_total = (s_total + rnd.next(1, 24*60 - 1)) % (24*60);\n        int t_hour = t_total / 60;\n        int t_minute = t_total % 60;\n        t = format_time(t_hour, t_minute);\n    } else if (type == \"edge_times\") {\n        // s is \"00:00\" or \"23:59\"\n        int s_hour = rnd.next(0,1)*23;\n        int s_minute = rnd.next(0,1)*59;\n        s = format_time(s_hour, s_minute);\n        // Generate random sleep duration t\n        int t_hour = rnd.next(0,23);\n        int t_minute = rnd.next(0,59);\n        t = format_time(t_hour, t_minute);\n    } else if (type == \"specific\") {\n        // Use specified s and t\n        s = opt<string>(\"s\");\n        t = opt<string>(\"t\");\n    } else {\n        // Default to random\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        int t_hour = rnd.next(0,23);\n        int t_minute = rnd.next(0,59);\n        t = format_time(t_hour, t_minute);\n    }\n\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring format_time(int hour, int minute) {\n    char buffer[6];\n    sprintf(buffer, \"%02d:%02d\", hour, minute);\n    return string(buffer);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate random current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        // Generate random sleep duration t\n        int t_hour = rnd.next(0,23);\n        int t_minute = rnd.next(0,59);\n        t = format_time(t_hour, t_minute);\n    } else if (type == \"zero_sleep\") {\n        // Generate random current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        // Sleep duration t is \"00:00\"\n        t = \"00:00\";\n    } else if (type == \"max_sleep\") {\n        // Generate random current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        // Sleep duration t is \"23:59\"\n        t = \"23:59\";\n    } else if (type == \"over_midnight\") {\n        // Generate current time s\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        int s_total = s_hour * 60 + s_minute;\n        // Generate t_total such that t_total > s_total\n        int t_total = (s_total + rnd.next(1, 24*60 - 1)) % (24*60);\n        int t_hour = t_total / 60;\n        int t_minute = t_total % 60;\n        t = format_time(t_hour, t_minute);\n    } else if (type == \"edge_times\") {\n        // s is \"00:00\" or \"23:59\"\n        int s_hour = rnd.next(0,1)*23;\n        int s_minute = rnd.next(0,1)*59;\n        s = format_time(s_hour, s_minute);\n        // Generate random sleep duration t\n        int t_hour = rnd.next(0,23);\n        int t_minute = rnd.next(0,59);\n        t = format_time(t_hour, t_minute);\n    } else if (type == \"specific\") {\n        // Use specified s and t\n        s = opt<string>(\"s\");\n        t = opt<string>(\"t\");\n    } else {\n        // Default to random\n        int s_hour = rnd.next(0,23);\n        int s_minute = rnd.next(0,59);\n        s = format_time(s_hour, s_minute);\n        int t_hour = rnd.next(0,23);\n        int t_minute = rnd.next(0,59);\n        t = format_time(t_hour, t_minute);\n    }\n\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type zero_sleep\n./gen -type zero_sleep\n./gen -type zero_sleep\n\n./gen -type max_sleep\n./gen -type max_sleep\n./gen -type max_sleep\n\n./gen -type over_midnight\n./gen -type over_midnight\n./gen -type over_midnight\n./gen -type over_midnight\n./gen -type over_midnight\n\n./gen -type edge_times\n./gen -type edge_times\n./gen -type edge_times\n./gen -type edge_times\n./gen -type edge_times\n\n./gen -type specific -s 00:00 -t 00:00\n./gen -type specific -s 23:59 -t 23:59\n./gen -type specific -s 00:00 -t 23:59\n./gen -type specific -s 23:59 -t 00:01\n./gen -type specific -s 12:34 -t 12:34\n./gen -type specific -s 05:50 -t 05:44\n./gen -type specific -s 00:00 -t 01:00\n./gen -type specific -s 00:01 -t 00:00\n./gen -type specific -s 13:37 -t 00:00\n./gen -type specific -s 00:00 -t 13:37\n\n./gen -type specific -s 00:00 -t 00:01\n./gen -type specific -s 23:59 -t 00:01\n./gen -type specific -s 00:00 -t 23:59\n./gen -type specific -s 23:59 -t 23:59\n./gen -type specific -s 23:59 -t 23:58\n./gen -type specific -s 00:01 -t 00:01\n./gen -type specific -s 12:00 -t 12:00\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:30.291431",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "387/B",
      "title": "B. Георгий и раунд",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n и m (1 ≤ n, m ≤ 3000) — минимальное количество задач в хорошем раунде и количество подготовленных Георгием задач. Во второй строке заданы целые числа через пробел a1, a2, ..., an (1 ≤ a1 < a2 < ... < an ≤ 106) — требования на сложности задач в хорошем раунде. В третьей строке заданы целые числа через пробел b1, b2, ..., bm (1 ≤ b1 ≤ b2... ≤ bm ≤ 106) — сложности задач, подготовленных Георгием.",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 51 2 31 2 2 3 3Выходные данныеСкопировать0Входные данныеСкопировать3 51 2 31 1 1 1 1Выходные данныеСкопировать2Входные данныеСкопировать3 12 3 41Выходные данныеСкопировать3",
      "description": "B. Георгий и раунд\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа n и m (1 ≤ n, m ≤ 3000) — минимальное количество задач в хорошем раунде и количество подготовленных Георгием задач. Во второй строке заданы целые числа через пробел a1, a2, ..., an (1 ≤ a1 < a2 < ... < an ≤ 106) — требования на сложности задач в хорошем раунде. В третьей строке заданы целые числа через пробел b1, b2, ..., bm (1 ≤ b1 ≤ b2... ≤ bm ≤ 106) — сложности задач, подготовленных Георгием.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать3 51 2 31 2 2 3 3Выходные данныеСкопировать0Входные данныеСкопировать3 51 2 31 1 1 1 1Выходные данныеСкопировать2Входные данныеСкопировать3 12 3 41Выходные данныеСкопировать3\n\nВходные данныеСкопировать3 51 2 31 2 2 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 51 2 31 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 12 3 41\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере набор подготовленных задач удовлетворяет требованиям хорошего раунда.Во втором примере достаточно придумать и подготовить две задачи со сложностями 2 и 3, чтобы получить хороший раунд.В третьем примере очень просто получить хороший раунд, если дополнительно придумать и подготовить три задачи со сложностями 2, 3, 4.",
      "solutions": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "Всем привет!Скоро, 30 января, 19:30 MSK, состоится очередной Codeforces Round #227 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса. Автором задач являюсь я. Большое спасибо Гере Агапову (Gerald) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. Главный герой задач этого раунда — кот Георгий.UPD1: Распределение баллов будет таким: 500, 1000, 1500, 2000, 2500.UPD2: Соревнование закончилось, поздравляем победителей! hmm_dream_big graphis InternationalGrandmaster Skedar mateusz UPD: Разбор на русскомUPD: Статистика",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10569",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 682
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "387A - Георгий и сонЯ опишу достаточно простое решение. Пусть Георгий проснулся в h0 часов и m0 минут, а спал ровно h1 часов и m1 минут. Получим числа hp = h0 - h1 и mp = m0 - m1. Если mp < 0, то прибавим к нему 60 минут, а из hp вычтем единицу. Потом, если окажется что hp < 0, то прибавим к нему 24 часа. Вывести ответ на C++ очень просто следующей строкой: Сложность решения: O(1) по времени / O(1) по памяти. printf(\"%02d:%02d\", h[p], m[p]).Авторское решение: 5850831387B - Георгий и раундПереберем количество требований на сложности, которые мы удовлетворим, остальные задачи мы придумаем и подготовим. Понятно, что если мы решили удовлетворить i требований, то выгодно взять те, что обладают минимальной сложностью. Упростим i самых сложных задач до самых легких требований. Если все прошло успешно, то обновим ответ величиной n - i.Сложность решения: O(n2) по времени / O(n) по памяти. Отмечу, существует решение и за линейную сложность O(n + m).Авторское решение: 5850888387C - Георгий и числоПолучим следующее неприводимое представление числа p = a1 + a2 + ... + ak, где  +  — конкатенация, а числа ai имеют вид x00..000 (некоторая ненулевая цифра, потом нули). Найдем самой большой индекс i, такой, что число a1 + a2 + ... + ai - 1 < ai. Если такого i нет, то i = 1. Тогда ответом на задачу будет число k - i + 1. Сравнения чисел можно производить, используя длину чисел и первые цифры. Попробуйте доказать это, используя единственность неприводимого разложения.Сложность решения: O(n) по времени / O(n) по памяти.Авторское решение: 5850919387D - Георгий и интересный графДля решения данной задачи нужно знать что такое максимальное паросочетание. Переберем центр графа i. Удалим все дуги вида (i, u) и (u, i). Пусть таких дуг cntWithI. Количество остальных дуг обозначим за Other. На остальных дугах и всех вершинах, кроме i, запустим алгоритм поиска максимального паросочетания, если полагать в качестве левой доли степень исхода, а в качестве правой степень захода. Дуга из нашего графа (i, j) будет равна дуге (i, j) — где i в левой доле, а j — в правой. Пусть его размер равен leng. Тогда ответ равен для текущей вершины равен 2n - 1 - cntWithI + Other - leng + (n - 1) - leng. Обновим глобальный ответ. Почему так можно делать? Понятно, что если мы найдем максимальное паросочетание в графе, мы удовлетворим максимально возможное количество требований на степени исхода и захода. Поэтому ребра из максимального паросочетания мы удалять не будем, удалим все кроме максимального паросочетания, и дополним его до полного паросочетания добавив (n - 1) - leng ребер. Следует добавить, что важно требование, что петли разрешены. Без этого разрешения так решать задачу нельзя. Сложность решения: O(n2m) по времени / O(n + m) по памяти.5850946387E - Георгий и карточкиПосчитаем массивы pos[i] — позиция числа i перестановке p, и need[i] — нужно ли удалить число i из перестановки p.Теперь рассмотрим числа a1, a2, ..., an - k — числа, которые нужно удалить. Понятно, что их выгодно удалять в порядке возрастания, это нетрудно доказать. Теперь будем иди по всем числам от 1 до n. Дополнительно будем поддерживать упорядоченное множество (set <> в с++, TreeSet в Java) — позиции не удаленных чисел, строго меньших текущего. Эти числа, как раз, могут создать <<препятствия>> для позиции текущего числа. Данное множество очень просто поддерживать. Для удобства, можно добавить в данное множество числа  - 1 и n. Теперь очень просто узнать размер максимального подотрезка, на котором число будет минимум. Это делается с помощью стандартных функций языка программирования (lower и higher в Java) Теперь осталось воспользоваться деревом Фенвика, чтобы узнать количество еще не удаленных чисел на данном отрезке.Сложность решения: по времени / O(n) по памяти.Очень короткая реализация решения на языке Java: 5850986",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10583",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 387\\s*B"
          },
          "content_length": 3815
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "Round duration increased for 10 minutes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 3",
          "code": "left/right(int i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 4",
          "code": "cout << setw(5) << setfill('0') << 42 << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 5",
          "code": "cout << \"0\" << hour << \":\" <<\"0\" << min << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 6",
          "code": "00:00\n00:01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 7",
          "code": "00:00\n00:01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #227 (Div. 2) - Codeforces - Code 8",
          "code": "if(hour<10 && min<10) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a\");\n    inf.readEoln();\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a[%d] = %d is not less than a[%d] = %d\", i - 1, a[i - 1], i, a[i]);\n    }\n\n    vector<int> b = inf.readInts(m, 1, 1000000, \"b\");\n    inf.readEoln();\n    for (int i = 1; i < m; ++i) {\n        ensuref(b[i - 1] <= b[i], \"b[%d] = %d is greater than b[%d] = %d\", i - 1, b[i - 1], i, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a\");\n    inf.readEoln();\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a[%d] = %d is not less than a[%d] = %d\", i - 1, a[i - 1], i, a[i]);\n    }\n\n    vector<int> b = inf.readInts(m, 1, 1000000, \"b\");\n    inf.readEoln();\n    for (int i = 1; i < m; ++i) {\n        ensuref(b[i - 1] <= b[i], \"b[%d] = %d is greater than b[%d] = %d\", i - 1, b[i - 1], i, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a\");\n    inf.readEoln();\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a[%d] = %d is not less than a[%d] = %d\", i - 1, a[i - 1], i, a[i]);\n    }\n\n    vector<int> b = inf.readInts(m, 1, 1000000, \"b\");\n    inf.readEoln();\n    for (int i = 1; i < m; ++i) {\n        ensuref(b[i - 1] <= b[i], \"b[%d] = %d is greater than b[%d] = %d\", i - 1, b[i - 1], i, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    /*\n      The problem constraints:\n        1 <= n, m <= 3000\n        1 <= a1 < a2 < ... < aN <= 10^6\n        1 <= b1 <= b2 <= ... <= bM <= 10^6\n\n      We will read:\n        - \"n\": number of required complexities.\n        - \"m\": number of prepared problems.\n        - \"type\": a string to determine how we generate data.\n\n      Our generator outputs exactly ONE test case:\n      1) line: n, m\n      2) line: a1, a2, ..., aN  (strictly ascending)\n      3) line: b1, b2, ..., bM  (non-decreasing)\n    */\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll store the complexities in these arrays:\n    vector<int> A(n), B(m);\n\n    // A helper lambda to get random distinct integers in [low, high].\n    // We will generate \"count\" distinct integers within [low, high], then sort ascending.\n    auto generateDistinctSorted = [&](int count, int low, int high) {\n        // We'll pick distinct values by sampling from the range\n        // but be sure that high - low + 1 >= count\n        // (callers must ensure this).\n        // Then we sort them ascending.\n        // Use testlib's rnd to generate random values.\n\n        assert(high - low + 1 >= count);\n\n        unordered_set<int> used;\n        vector<int> result;\n        result.reserve(count);\n\n        while ((int)used.size() < count) {\n            int val = rnd.next(low, high);\n            if (!used.count(val)) {\n                used.insert(val);\n                result.push_back(val);\n            }\n        }\n        sort(result.begin(), result.end());\n        return result;\n    };\n\n    // We will fill A and B depending on \"type\".\n    // Some \"type\" will ignore user-provided n, m to produce special corner cases.\n    // Otherwise, we'll use n, m in a random or special pattern.\n\n    if (type == \"small-corner\") {\n        // Force n=1, m=1, and both complexities = 1\n        // This is a trivial case where no new problems are needed if a1=1\n        n = 1; \n        m = 1;\n        A[0] = 1;\n        B[0] = 1;\n    }\n    else if (type == \"all-larger\") {\n        // The array A is small or moderate in [1, 10].\n        // The array B is much larger, e.g. near 10^6,\n        // meaning we could simplify prepared problems to meet the A array if needed.\n        // We'll still generate them according to the user-supplied n, m,\n        // but we fix the range for A small [1..10], and B is in [500000..600000] for instance.\n\n        // Ensure the range can fit n distinct values from 1..10\n        int nn = min(n, 10);\n        // Generate A in [1..10]\n        auto tmpA = generateDistinctSorted(nn, 1, 10);\n        for (int i = 0; i < nn; i++) {\n            A[i] = tmpA[i];\n        }\n        // If user requested more than 10, we artificially clamp n=nn\n        n = nn;\n\n        // Now fill B with complexities in [500000, 600000].\n        int lowB = 500000, highB = 600000;\n        int mm = min(m, highB - lowB + 1);\n        auto tmpB = generateDistinctSorted(mm, lowB, highB);\n        for (int i = 0; i < mm; i++) {\n            B[i] = tmpB[i];\n        }\n        // If user requested more than mm, we just replicate some large values (to keep sorting).\n        for (int i = mm; i < m; i++) {\n            B[i] = B[mm - 1]; // replicate the largest value\n        }\n        m = max(m, mm); // keep m, though the extras are identical\n        sort(B.begin(), B.end());\n    }\n    else if (type == \"all-smaller\") {\n        // The array A could be in high range, e.g. [500000..500100].\n        // The array B is in a small range [1..100].\n        {\n            // We attempt to place A in [500000..500000 + n - 1]\n            int lowA = 500000;\n            int highA = lowA + 3 * n; // extra space\n            if (highA > 1000000) {\n                highA = 1000000; \n            }\n            int nn = min(n, highA - lowA + 1);\n            auto tmpA = generateDistinctSorted(nn, lowA, highA);\n            for (int i = 0; i < nn; i++) {\n                A[i] = tmpA[i];\n            }\n            n = nn; // clamp if needed\n        }\n        {\n            // B in [1..100]\n            int lowB = 1;\n            int highB = 100;\n            int mm = min(m, highB - lowB + 1);\n            auto tmpB = generateDistinctSorted(mm, lowB, highB);\n            for (int i = 0; i < mm; i++) {\n                B[i] = tmpB[i];\n            }\n            // If user wants more, replicate the largest\n            for (int i = mm; i < m; i++) {\n                B[i] = B[mm - 1];\n            }\n            sort(B.begin(), B.end());\n        }\n    }\n    else if (type == \"mixed\") {\n        // We generate half of the required complexities small, half large\n        // B can be random anywhere, but we ensure some duplicates in B to test sorting, etc.\n\n        // Half of A in [1..1000]\n        // half of A in [500000..501000]\n        // clamp with n\n        int half = n/2;\n        int halfRem = n - half;\n        auto smallPart = generateDistinctSorted(half, 1, 1000);\n        auto largePart = generateDistinctSorted(halfRem, 500000, 500000 + 2*n);\n        // put them together in ascending order\n        vector<int> aCombined;\n        aCombined.insert(aCombined.end(), smallPart.begin(), smallPart.end());\n        aCombined.insert(aCombined.end(), largePart.begin(), largePart.end());\n        sort(aCombined.begin(), aCombined.end());\n        for (int i = 0; i < n; i++) {\n            A[i] = aCombined[i];\n        }\n\n        // B is fully random in [1..10^6], but we allow duplicates\n        // We'll directly choose M values in [1..10^6], sorted non-decreasing.\n\n        vector<int> Btmp(m);\n        for (int i = 0; i < m; i++) {\n            Btmp[i] = rnd.next(1, 1000000);\n        }\n        sort(Btmp.begin(), Btmp.end());\n        for (int i = 0; i < m; i++) {\n            B[i] = Btmp[i];\n        }\n    }\n    else if (type == \"exact-match\") {\n        // We attempt to produce a scenario where we already have exactly\n        // one b_i for each a_i, and no extra. So no new problems needed,\n        // and n == m. We fill B with the identical set as A.\n        // But we also ensure A is strictly ascending, B is non-decreasing,\n        // so let's just replicate A into B.\n\n        // We'll generate random distinct A in [1..1000] if n <= 1000\n        // or clamp if needed to avoid overshoot\n        int lowA = 1;\n        int highA = min(1000000, lowA + 2*n); // some range\n        auto tmpA = generateDistinctSorted(n, lowA, highA);\n        // Now set B = A sorted (which is the same order because A is sorted).\n        // but we must also ensure m == n, so let's clamp m to n.\n        m = n;\n        for (int i = 0; i < n; i++) {\n            A[i] = tmpA[i];\n            B[i] = tmpA[i];\n        }\n    }\n    else if (type == \"random\") {\n        // Fully random scenario. Distinct A in [1..10^6].\n        // B in [1..10^6], sorted non-decreasing. Possibly with duplicates.\n\n        // Generate distinct A\n        {\n            // to be safe, we ensure there's enough room for n distinct values\n            // pick some range. We'll do [1..max(10^6, n)] but 10^6 is the max.\n            // n <= 3000 is definitely smaller than 10^6 range\n\n            auto tmpA = generateDistinctSorted(n, 1, 1000000);\n            for (int i = 0; i < n; i++) {\n                A[i] = tmpA[i];\n            }\n        }\n        {\n            // B can have duplicates. We'll choose values randomly in [1..10^6], sort them.\n            vector<int> tmpB(m);\n            for (int i = 0; i < m; i++) {\n                tmpB[i] = rnd.next(1, 1000000);\n            }\n            sort(tmpB.begin(), tmpB.end());\n            for (int i = 0; i < m; i++) {\n                B[i] = tmpB[i];\n            }\n        }\n    }\n    else {\n        // Fallback: same as \"random\"\n        // (In case the user passes an unrecognized type)\n        // We'll just do the same as above\n        auto tmpA = generateDistinctSorted(n, 1, 1000000);\n        for (int i = 0; i < n; i++) {\n            A[i] = tmpA[i];\n        }\n        vector<int> tmpB(m);\n        for (int i = 0; i < m; i++) {\n            tmpB[i] = rnd.next(1, 1000000);\n        }\n        sort(tmpB.begin(), tmpB.end());\n        for (int i = 0; i < m; i++) {\n            B[i] = tmpB[i];\n        }\n    }\n\n    // Now print the test case.\n    // 1) n, m\n    // 2) a1..aN (all distinct, strictly ascending)\n    // 3) b1..bM (non-decreasing)\n\n    cout << n << \" \" << m << \"\\n\";\n\n    // Print A\n    // We must ensure a1 < a2 < ... < aN strictly ascending:\n    // If any generation approach above made them ascend,\n    // we should keep them in ascending order.\n    // However, double-check if we need to forcibly sort again\n    // (some code already sorted them). Let's be safe:\n\n    sort(A.begin(), A.begin() + n);\n    for (int i = 0; i < n; i++) {\n        cout << A[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n\n    // Print B\n    // Non-decreasing order is required. We'll do a final sort:\n    sort(B.begin(), B.end());\n    for (int i = 0; i < m; i++) {\n        cout << B[i] << (i + 1 < m ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    /*\n      The problem constraints:\n        1 <= n, m <= 3000\n        1 <= a1 < a2 < ... < aN <= 10^6\n        1 <= b1 <= b2 <= ... <= bM <= 10^6\n\n      We will read:\n        - \"n\": number of required complexities.\n        - \"m\": number of prepared problems.\n        - \"type\": a string to determine how we generate data.\n\n      Our generator outputs exactly ONE test case:\n      1) line: n, m\n      2) line: a1, a2, ..., aN  (strictly ascending)\n      3) line: b1, b2, ..., bM  (non-decreasing)\n    */\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll store the complexities in these arrays:\n    vector<int> A(n), B(m);\n\n    // A helper lambda to get random distinct integers in [low, high].\n    // We will generate \"count\" distinct integers within [low, high], then sort ascending.\n    auto generateDistinctSorted = [&](int count, int low, int high) {\n        // We'll pick distinct values by sampling from the range\n        // but be sure that high - low + 1 >= count\n        // (callers must ensure this).\n        // Then we sort them ascending.\n        // Use testlib's rnd to generate random values.\n\n        assert(high - low + 1 >= count);\n\n        unordered_set<int> used;\n        vector<int> result;\n        result.reserve(count);\n\n        while ((int)used.size() < count) {\n            int val = rnd.next(low, high);\n            if (!used.count(val)) {\n                used.insert(val);\n                result.push_back(val);\n            }\n        }\n        sort(result.begin(), result.end());\n        return result;\n    };\n\n    // We will fill A and B depending on \"type\".\n    // Some \"type\" will ignore user-provided n, m to produce special corner cases.\n    // Otherwise, we'll use n, m in a random or special pattern.\n\n    if (type == \"small-corner\") {\n        // Force n=1, m=1, and both complexities = 1\n        // This is a trivial case where no new problems are needed if a1=1\n        n = 1; \n        m = 1;\n        A[0] = 1;\n        B[0] = 1;\n    }\n    else if (type == \"all-larger\") {\n        // The array A is small or moderate in [1, 10].\n        // The array B is much larger, e.g. near 10^6,\n        // meaning we could simplify prepared problems to meet the A array if needed.\n        // We'll still generate them according to the user-supplied n, m,\n        // but we fix the range for A small [1..10], and B is in [500000..600000] for instance.\n\n        // Ensure the range can fit n distinct values from 1..10\n        int nn = min(n, 10);\n        // Generate A in [1..10]\n        auto tmpA = generateDistinctSorted(nn, 1, 10);\n        for (int i = 0; i < nn; i++) {\n            A[i] = tmpA[i];\n        }\n        // If user requested more than 10, we artificially clamp n=nn\n        n = nn;\n\n        // Now fill B with complexities in [500000, 600000].\n        int lowB = 500000, highB = 600000;\n        int mm = min(m, highB - lowB + 1);\n        auto tmpB = generateDistinctSorted(mm, lowB, highB);\n        for (int i = 0; i < mm; i++) {\n            B[i] = tmpB[i];\n        }\n        // If user requested more than mm, we just replicate some large values (to keep sorting).\n        for (int i = mm; i < m; i++) {\n            B[i] = B[mm - 1]; // replicate the largest value\n        }\n        m = max(m, mm); // keep m, though the extras are identical\n        sort(B.begin(), B.end());\n    }\n    else if (type == \"all-smaller\") {\n        // The array A could be in high range, e.g. [500000..500100].\n        // The array B is in a small range [1..100].\n        {\n            // We attempt to place A in [500000..500000 + n - 1]\n            int lowA = 500000;\n            int highA = lowA + 3 * n; // extra space\n            if (highA > 1000000) {\n                highA = 1000000; \n            }\n            int nn = min(n, highA - lowA + 1);\n            auto tmpA = generateDistinctSorted(nn, lowA, highA);\n            for (int i = 0; i < nn; i++) {\n                A[i] = tmpA[i];\n            }\n            n = nn; // clamp if needed\n        }\n        {\n            // B in [1..100]\n            int lowB = 1;\n            int highB = 100;\n            int mm = min(m, highB - lowB + 1);\n            auto tmpB = generateDistinctSorted(mm, lowB, highB);\n            for (int i = 0; i < mm; i++) {\n                B[i] = tmpB[i];\n            }\n            // If user wants more, replicate the largest\n            for (int i = mm; i < m; i++) {\n                B[i] = B[mm - 1];\n            }\n            sort(B.begin(), B.end());\n        }\n    }\n    else if (type == \"mixed\") {\n        // We generate half of the required complexities small, half large\n        // B can be random anywhere, but we ensure some duplicates in B to test sorting, etc.\n\n        // Half of A in [1..1000]\n        // half of A in [500000..501000]\n        // clamp with n\n        int half = n/2;\n        int halfRem = n - half;\n        auto smallPart = generateDistinctSorted(half, 1, 1000);\n        auto largePart = generateDistinctSorted(halfRem, 500000, 500000 + 2*n);\n        // put them together in ascending order\n        vector<int> aCombined;\n        aCombined.insert(aCombined.end(), smallPart.begin(), smallPart.end());\n        aCombined.insert(aCombined.end(), largePart.begin(), largePart.end());\n        sort(aCombined.begin(), aCombined.end());\n        for (int i = 0; i < n; i++) {\n            A[i] = aCombined[i];\n        }\n\n        // B is fully random in [1..10^6], but we allow duplicates\n        // We'll directly choose M values in [1..10^6], sorted non-decreasing.\n\n        vector<int> Btmp(m);\n        for (int i = 0; i < m; i++) {\n            Btmp[i] = rnd.next(1, 1000000);\n        }\n        sort(Btmp.begin(), Btmp.end());\n        for (int i = 0; i < m; i++) {\n            B[i] = Btmp[i];\n        }\n    }\n    else if (type == \"exact-match\") {\n        // We attempt to produce a scenario where we already have exactly\n        // one b_i for each a_i, and no extra. So no new problems needed,\n        // and n == m. We fill B with the identical set as A.\n        // But we also ensure A is strictly ascending, B is non-decreasing,\n        // so let's just replicate A into B.\n\n        // We'll generate random distinct A in [1..1000] if n <= 1000\n        // or clamp if needed to avoid overshoot\n        int lowA = 1;\n        int highA = min(1000000, lowA + 2*n); // some range\n        auto tmpA = generateDistinctSorted(n, lowA, highA);\n        // Now set B = A sorted (which is the same order because A is sorted).\n        // but we must also ensure m == n, so let's clamp m to n.\n        m = n;\n        for (int i = 0; i < n; i++) {\n            A[i] = tmpA[i];\n            B[i] = tmpA[i];\n        }\n    }\n    else if (type == \"random\") {\n        // Fully random scenario. Distinct A in [1..10^6].\n        // B in [1..10^6], sorted non-decreasing. Possibly with duplicates.\n\n        // Generate distinct A\n        {\n            // to be safe, we ensure there's enough room for n distinct values\n            // pick some range. We'll do [1..max(10^6, n)] but 10^6 is the max.\n            // n <= 3000 is definitely smaller than 10^6 range\n\n            auto tmpA = generateDistinctSorted(n, 1, 1000000);\n            for (int i = 0; i < n; i++) {\n                A[i] = tmpA[i];\n            }\n        }\n        {\n            // B can have duplicates. We'll choose values randomly in [1..10^6], sort them.\n            vector<int> tmpB(m);\n            for (int i = 0; i < m; i++) {\n                tmpB[i] = rnd.next(1, 1000000);\n            }\n            sort(tmpB.begin(), tmpB.end());\n            for (int i = 0; i < m; i++) {\n                B[i] = tmpB[i];\n            }\n        }\n    }\n    else {\n        // Fallback: same as \"random\"\n        // (In case the user passes an unrecognized type)\n        // We'll just do the same as above\n        auto tmpA = generateDistinctSorted(n, 1, 1000000);\n        for (int i = 0; i < n; i++) {\n            A[i] = tmpA[i];\n        }\n        vector<int> tmpB(m);\n        for (int i = 0; i < m; i++) {\n            tmpB[i] = rnd.next(1, 1000000);\n        }\n        sort(tmpB.begin(), tmpB.end());\n        for (int i = 0; i < m; i++) {\n            B[i] = tmpB[i];\n        }\n    }\n\n    // Now print the test case.\n    // 1) n, m\n    // 2) a1..aN (all distinct, strictly ascending)\n    // 3) b1..bM (non-decreasing)\n\n    cout << n << \" \" << m << \"\\n\";\n\n    // Print A\n    // We must ensure a1 < a2 < ... < aN strictly ascending:\n    // If any generation approach above made them ascend,\n    // we should keep them in ascending order.\n    // However, double-check if we need to forcibly sort again\n    // (some code already sorted them). Let's be safe:\n\n    sort(A.begin(), A.begin() + n);\n    for (int i = 0; i < n; i++) {\n        cout << A[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n\n    // Print B\n    // Non-decreasing order is required. We'll do a final sort:\n    sort(B.begin(), B.end());\n    for (int i = 0; i < m; i++) {\n        cout << B[i] << (i + 1 < m ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are commands that each produce a single test case on stdout.\n# They demonstrate how to generate around 20~30 different test files.\n\n./gen -n 1 -m 1 -type small-corner\n./gen -n 2 -m 2 -type exact-match\n./gen -n 3 -m 5 -type random\n./gen -n 3 -m 1 -type random\n./gen -n 5 -m 5 -type all-smaller\n./gen -n 5 -m 5 -type all-larger\n./gen -n 5 -m 5 -type mixed\n./gen -n 8 -m 3 -type random\n./gen -n 8 -m 3 -type exact-match\n./gen -n 10 -m 10 -type all-smaller\n./gen -n 10 -m 10 -type all-larger\n./gen -n 10 -m 10 -type mixed\n./gen -n 12 -m 20 -type random\n./gen -n 15 -m 10 -type random\n./gen -n 15 -m 15 -type exact-match\n./gen -n 15 -m 15 -type mixed\n./gen -n 20 -m 5 -type all-smaller\n./gen -n 20 -m 5 -type all-larger\n./gen -n 30 -m 30 -type random\n./gen -n 30 -m 30 -type mixed\n./gen -n 50 -m 50 -type exact-match\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type mixed\n./gen -n 3000 -m 3000 -type random\n./gen -n 3000 -m 3000 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:31.992261",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "387/C",
      "title": "Problem 387/C",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string p = inf.readToken(\"[1-9][0-9]{0,999999}\", \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string p = inf.readToken(\"[1-9][0-9]{0,999999}\", \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string p = inf.readToken(\"[1-9][0-9]{0,999999}\", \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\"); // length of p\n    string type = opt<string>(\"type\", \"random\");\n\n    if (len <= 0 || len > 10000000) {\n        cerr << \"Invalid length. Must be between 1 and 10^7.\" << endl;\n        return 1;\n    }\n\n    string p;\n\n    if (type == \"random\") {\n        // Generate a random number of length 'len'\n        // Ensure no leading zeros\n        p += '1' + rnd.next(9); // Random digit from '1' to '9'\n\n        for (int i = 1; i < len; ++i) {\n            p += '0' + rnd.next(10); // Random digit from '0' to '9'\n        }\n    } else if (type == \"all_ones\") {\n        p = string(len, '1');\n    } else if (type == \"all_nines\") {\n        p = string(len, '9');\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome of length 'len'\n        string half;\n        int half_len = (len + 1) / 2;\n        half += '1' + rnd.next(9); // First digit\n\n        for (int i = 1; i < half_len; ++i) {\n            half += '0' + rnd.next(10);\n        }\n        p = half;\n        if (len % 2 == 1) {\n            p += string(half.rbegin() + 1, half.rend());\n        } else {\n            p += string(half.rbegin(), half.rend());\n        }\n    } else if (type == \"alternating\") {\n        char digits[2] = {'1' + rnd.next(9), '0' + rnd.next(10)};\n        for (int i = 0; i < len; ++i) {\n            p += digits[i % 2];\n        }\n    } else if (type == \"increasing\") {\n        char digit = '1';\n        for (int i = 0; i < len; ++i) {\n            p += digit;\n            digit++;\n            if (digit > '9') digit = '1'; // wrap around to '1'\n        }\n    } else if (type == \"decreasing\") {\n        char digit = '9';\n        for (int i = 0; i < len; ++i) {\n            p += digit;\n            digit--;\n            if (digit < '1') digit = '9'; // wrap around to '9'\n        }\n    } else if (type == \"repunit\") {\n        char digit = '1' + rnd.next(9); // Random digit from '1' to '9'\n        p = string(len, digit);\n    } else {\n        // Default to random\n        p += '1' + rnd.next(9); // Random digit from '1' to '9'\n\n        for (int i = 1; i < len; ++i) {\n            p += '0' + rnd.next(10); // Random digit from '0' to '9'\n        }\n    }\n\n    cout << p << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\"); // length of p\n    string type = opt<string>(\"type\", \"random\");\n\n    if (len <= 0 || len > 10000000) {\n        cerr << \"Invalid length. Must be between 1 and 10^7.\" << endl;\n        return 1;\n    }\n\n    string p;\n\n    if (type == \"random\") {\n        // Generate a random number of length 'len'\n        // Ensure no leading zeros\n        p += '1' + rnd.next(9); // Random digit from '1' to '9'\n\n        for (int i = 1; i < len; ++i) {\n            p += '0' + rnd.next(10); // Random digit from '0' to '9'\n        }\n    } else if (type == \"all_ones\") {\n        p = string(len, '1');\n    } else if (type == \"all_nines\") {\n        p = string(len, '9');\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome of length 'len'\n        string half;\n        int half_len = (len + 1) / 2;\n        half += '1' + rnd.next(9); // First digit\n\n        for (int i = 1; i < half_len; ++i) {\n            half += '0' + rnd.next(10);\n        }\n        p = half;\n        if (len % 2 == 1) {\n            p += string(half.rbegin() + 1, half.rend());\n        } else {\n            p += string(half.rbegin(), half.rend());\n        }\n    } else if (type == \"alternating\") {\n        char digits[2] = {'1' + rnd.next(9), '0' + rnd.next(10)};\n        for (int i = 0; i < len; ++i) {\n            p += digits[i % 2];\n        }\n    } else if (type == \"increasing\") {\n        char digit = '1';\n        for (int i = 0; i < len; ++i) {\n            p += digit;\n            digit++;\n            if (digit > '9') digit = '1'; // wrap around to '1'\n        }\n    } else if (type == \"decreasing\") {\n        char digit = '9';\n        for (int i = 0; i < len; ++i) {\n            p += digit;\n            digit--;\n            if (digit < '1') digit = '9'; // wrap around to '9'\n        }\n    } else if (type == \"repunit\") {\n        char digit = '1' + rnd.next(9); // Random digit from '1' to '9'\n        p = string(len, digit);\n    } else {\n        // Default to random\n        p += '1' + rnd.next(9); // Random digit from '1' to '9'\n\n        for (int i = 1; i < len; ++i) {\n            p += '0' + rnd.next(10); // Random digit from '0' to '9'\n        }\n    }\n\n    cout << p << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -type random\n./gen -len 1 -type all_ones\n./gen -len 1 -type all_nines\n./gen -len 1 -type palindrome\n./gen -len 1 -type alternating\n./gen -len 1 -type increasing\n./gen -len 1 -type decreasing\n./gen -len 1 -type repunit\n\n./gen -len 10 -type random\n./gen -len 10 -type all_ones\n./gen -len 10 -type all_nines\n./gen -len 10 -type palindrome\n./gen -len 10 -type alternating\n./gen -len 10 -type increasing\n./gen -len 10 -type decreasing\n./gen -len 10 -type repunit\n\n./gen -len 100 -type random\n./gen -len 100 -type all_ones\n./gen -len 100 -type all_nines\n./gen -len 100 -type palindrome\n./gen -len 100 -type alternating\n./gen -len 100 -type increasing\n./gen -len 100 -type decreasing\n./gen -len 100 -type repunit\n\n./gen -len 1000 -type random\n./gen -len 1000 -type all_ones\n./gen -len 1000 -type all_nines\n./gen -len 1000 -type palindrome\n./gen -len 1000 -type alternating\n./gen -len 1000 -type increasing\n./gen -len 1000 -type decreasing\n./gen -len 1000 -type repunit\n\n./gen -len 100000 -type random\n./gen -len 100000 -type all_ones\n./gen -len 100000 -type all_nines\n./gen -len 100000 -type palindrome\n./gen -len 100000 -type decreasing\n\n./gen -len 1000000 -type random\n./gen -len 1000000 -type all_ones\n./gen -len 1000000 -type all_nines\n\n./gen -len 10000000 -type random\n./gen -len 10000000 -type all_ones\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:34.631471",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "387/D",
      "title": "D. George and Interesting Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.Assume that the grah vertices are numbered 1 through n.",
      "output_spec": "OutputPrint a single integer — the answer to George's question.",
      "sample_tests": "ExamplesInputCopy3 71 12 23 11 33 22 33 3OutputCopy0InputCopy3 61 12 23 13 22 33 3OutputCopy1InputCopy3 12 2OutputCopy6",
      "description": "D. George and Interesting Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.Assume that the grah vertices are numbered 1 through n.\n\nOutputPrint a single integer — the answer to George's question.\n\nInputCopy3 71 12 23 11 33 22 33 3OutputCopy0InputCopy3 61 12 23 13 22 33 3OutputCopy1InputCopy3 12 2OutputCopy6\n\nInputCopy3 71 12 23 11 33 22 33 3\n\nOutputCopy0\n\nInputCopy3 61 12 23 13 22 33 3\n\nOutputCopy1\n\nInputCopy3 12 2\n\nOutputCopy6\n\nNoteFor more information about directed graphs, please visit: http://en.wikipedia.org/wiki/Directed_graphIn the first sample the graph already is interesting, its center is vertex 3.",
      "solutions": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on January 30 at 19:30 MSK) you are lucky to participate in Codeforces Round #227 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.The main character of the tasks is the cat George.UPD1: Scoring will be next: 500, 1000, 1500, 2000, 2500.UPD2: Contest finished, congratulations to winners! hmm_dream_big graphis InternationalGrandmaster Skedar mateusz UPD: EditorialUPD: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10569",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 688
        },
        {
          "title": "Editorial Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "387A - George and SleepI will describe the simple solution. Let George woke up in the h0 hours and m0 minutes, and he slept for h1 hours and m1 minutes. Let's get the number hp = h0 - h1 and mp = m0 - m1. If mp < 0, then you should add to mp 60 minutes and subtract from hp one hour. After that if hp < 0, then add to it 24 hours. You can print the answer in C++ by using the following line: printf(\"%02d:%02d\", h[p], m[p]).The complexity is O(1) time and O(1) memory.Author's solution: 5850831387B - George and RoundConsider the number of requirements of the difficulties, which we will cover, and we will come up with and prepare new problem to cover other requirements. It is clear that if we decided to meet the i out of n requirements, it would be better to take those with minimal complexity. Let's simplify i most difficult problems to lightest requirements. If all goes well, then we update the answer by value n - i.The complexity is: O(n2) time / O(n) memory. Note, that there is an solution with complexity O(n + m).Author's solution: 5850888387C - George and NumberLet's obtain the following irreducible representation of a number p = a1 + a2 + ... + ak, where  +  is a concatenation, and numbers ai have the form x00..000 (x — is non zero digit, and after that there are only zeroes). Let's determine largest index i, such that a1 + a2 + ... + ai - 1 < ai. If there are no such index i then i = 1. After that is k - i + 1. You can compare numbers by using length of number and first digit. You can prove these solution as home task : )The complexity is: O(n) time / O(n) memory.Author's solution: 5850919387D - George and Interesting GraphTo solve this problem you should know about bipartite matching.Let's consider the center of graph i. After that let's remove arcs that have form (i, u) or (u, i). Let's there are cntWithI arcs of such type. Let's Other = m - CntWithI — number of other arcs.After that we should found maximal bipartite matching on the bipartite graph. This graph has following idea: left part of this graph is indegrees of all vertexes except vertex i, right part of this graph is outdegrees of all vertexes except vertex i. Also if there an arc (i, j) in our graph then in our bipartite graph there an arc (i, j), where i — vertex from left part, j — vertex from the right part. Let's size of bipartite matching on the bipartite graph equals to leng. Then answer for the current vertex i equals to 2n - 1 - cntWithI + Other - leng + (n - 1) - leng. After that you should update global answer. Why it is correct? It is simple to understand that if we will found bipartite matching on the bipartite graph we will cover maximal number of requirements on in/out degrees. Because of that, we will remove all other arcs, except of maximal matching, and after that we will add this maximal matching to full matching by adding (n - 1) - leng arcs. Note, it is important, that self-loops are not forbidden. Withoud self-loops problem is very hard, I think. The complexity is: O(n2m) time / O(n + m) memory.5850946387E - George and CardsLet's calculate arrays pos[i] — position of number i in permutation p and need[i] — equals to one if we should remove number i from permutation p, and zero if we shouldn't remove i from permutation p. Let's a1, a2, ..., an - k — numvers, which we should remove. It is clear to understand that we should remove these number in increasing order. It is simple to proof this statement.Let's iterate i from to 1 to n. Also we the current number we will have special set (set <>in с++, TreeSet in Java) of positions of non-erased numbers (which are smaller then i) of permutation. These position can create an ``obstacle'' for current position of number i. It is simple to support this special set. Also we can add to this set numbers  - 1 and n. Now it is easy to find length og the maximal sub-array, where current number is a minimum. You can prosess such query by using standart functions of programming language (lower and higher in Java). After that we should use Fenwick tree to determine quantity of numbers which are not removed on the maximal sub-array.The complexity is: time / O(n) memory.Very simple implementation on Java: 5850986",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10583",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 387\\s*D"
          },
          "content_length": 4201
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "Round duration increased for 10 minutes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    \n    set<pair<int, int>> arcs;\n    \n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        \n        pair<int, int> arc = make_pair(a, b);\n        ensuref(arcs.count(arc) == 0, \"Multiple arcs detected between %d and %d\", a, b);\n        arcs.insert(arc);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    \n    set<pair<int, int>> arcs;\n    \n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        \n        pair<int, int> arc = make_pair(a, b);\n        ensuref(arcs.count(arc) == 0, \"Multiple arcs detected between %d and %d\", a, b);\n        arcs.insert(arc);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    \n    set<pair<int, int>> arcs;\n    \n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        \n        pair<int, int> arc = make_pair(a, b);\n        ensuref(arcs.count(arc) == 0, \"Multiple arcs detected between %d and %d\", a, b);\n        arcs.insert(arc);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring type;\nset<pair<int,int>> edges;\n\nvoid add_edge(int u, int v) {\n    if (edges.count({u, v}) == 0) {\n        edges.insert({u, v});\n    }\n}\n\nvoid generate_random() {\n    while ((int)edges.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        add_edge(u, v);\n    }\n}\n\nvoid generate_chain() {\n    for (int i = 1; i < n; ++i) {\n        add_edge(i, i + 1);\n    }\n    if ((int)edges.size() < m) {\n        // add more random edges if needed\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nvoid generate_star() {\n    int center = rnd.next(1, n);\n    for (int i = 1; i <= n; ++i) {\n        if (i != center) {\n            add_edge(center, i);\n            add_edge(i, center);\n        }\n    }\n    if ((int)edges.size() < m) {\n        // add more random edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nvoid generate_cycle() {\n    for (int i = 1; i <= n; ++i) {\n        int next = i % n + 1;\n        add_edge(i, next);\n    }\n    if ((int)edges.size() < m) {\n        // add more random edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nvoid generate_complete() {\n    for (int u = 1; u <= n; ++u) {\n        for (int v = 1; v <= n; ++v) {\n            add_edge(u, v);\n            if ((int)edges.size() >= m)\n                break;\n        }\n        if ((int)edges.size() >= m)\n            break;\n    }\n}\n\nvoid generate_selfloops() {\n    for (int i = 1; i <= n; ++i) {\n        add_edge(i, i); // add self-loop\n    }\n    if ((int)edges.size() < m) {\n        // add random edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\", -1); // if not provided, we will determine it based on 'n' and 'type'\n    type = opt<string>(\"type\", \"random\");\n\n    // Determine default 'm' if not provided\n    if (m == -1) {\n        if (type == \"complete\") {\n            m = n * n;\n        } else if (type == \"selfloops\") {\n            m = n; // only self-loops\n        } else {\n            m = min(1000, n * n);\n        }\n    }\n\n    // Ensure 'm' does not exceed constraints\n    m = min(m, n * n);\n    m = min(m, 1000);\n\n    // Generate graph based on 'type'\n    if (type == \"random\") {\n        generate_random();\n    } else if (type == \"chain\") {\n        generate_chain();\n    } else if (type == \"star\") {\n        generate_star();\n    } else if (type == \"cycle\") {\n        generate_cycle();\n    } else if (type == \"complete\") {\n        generate_complete();\n    } else if (type == \"selfloops\") {\n        generate_selfloops();\n    } else {\n        // Default to random if unknown type\n        generate_random();\n    }\n\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring type;\nset<pair<int,int>> edges;\n\nvoid add_edge(int u, int v) {\n    if (edges.count({u, v}) == 0) {\n        edges.insert({u, v});\n    }\n}\n\nvoid generate_random() {\n    while ((int)edges.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        add_edge(u, v);\n    }\n}\n\nvoid generate_chain() {\n    for (int i = 1; i < n; ++i) {\n        add_edge(i, i + 1);\n    }\n    if ((int)edges.size() < m) {\n        // add more random edges if needed\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nvoid generate_star() {\n    int center = rnd.next(1, n);\n    for (int i = 1; i <= n; ++i) {\n        if (i != center) {\n            add_edge(center, i);\n            add_edge(i, center);\n        }\n    }\n    if ((int)edges.size() < m) {\n        // add more random edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nvoid generate_cycle() {\n    for (int i = 1; i <= n; ++i) {\n        int next = i % n + 1;\n        add_edge(i, next);\n    }\n    if ((int)edges.size() < m) {\n        // add more random edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nvoid generate_complete() {\n    for (int u = 1; u <= n; ++u) {\n        for (int v = 1; v <= n; ++v) {\n            add_edge(u, v);\n            if ((int)edges.size() >= m)\n                break;\n        }\n        if ((int)edges.size() >= m)\n            break;\n    }\n}\n\nvoid generate_selfloops() {\n    for (int i = 1; i <= n; ++i) {\n        add_edge(i, i); // add self-loop\n    }\n    if ((int)edges.size() < m) {\n        // add random edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            add_edge(u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\", -1); // if not provided, we will determine it based on 'n' and 'type'\n    type = opt<string>(\"type\", \"random\");\n\n    // Determine default 'm' if not provided\n    if (m == -1) {\n        if (type == \"complete\") {\n            m = n * n;\n        } else if (type == \"selfloops\") {\n            m = n; // only self-loops\n        } else {\n            m = min(1000, n * n);\n        }\n    }\n\n    // Ensure 'm' does not exceed constraints\n    m = min(m, n * n);\n    m = min(m, 1000);\n\n    // Generate graph based on 'type'\n    if (type == \"random\") {\n        generate_random();\n    } else if (type == \"chain\") {\n        generate_chain();\n    } else if (type == \"star\") {\n        generate_star();\n    } else if (type == \"cycle\") {\n        generate_cycle();\n    } else if (type == \"complete\") {\n        generate_complete();\n    } else if (type == \"selfloops\") {\n        generate_selfloops();\n    } else {\n        // Default to random if unknown type\n        generate_random();\n    }\n\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type selfloops\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type complete\n\n./gen -n 3 -type random\n./gen -n 3 -type selfloops\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type cycle\n./gen -n 3 -type complete\n\n./gen -n 10 -type random\n./gen -n 10 -type random -m 20\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type cycle\n./gen -n 10 -type selfloops\n\n./gen -n 50 -type random\n./gen -n 50 -type random -m 100\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type cycle\n\n./gen -n 100 -type random\n./gen -n 100 -type random -m 500\n./gen -n 100 -type chain\n./gen -n 100 -type star\n\n./gen -n 250 -type random -m 1000\n./gen -n 500 -type random -m 1000\n\n./gen -n 500 -type chain\n./gen -n 500 -type star\n\n./gen -n 500 -type selfloops\n\n./gen -n 15 -type complete\n\n./gen -n 31 -type complete\n\n./gen -n 45 -type complete\n\n./gen -n 2 -type random\n\n./gen -n 500 -type random -m 1\n\n./gen -n 500 -type random -m 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:36.800604",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "387/E",
      "title": "E. George and Cards",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and k (1 ≤ k ≤ n ≤ 106) — the initial and the final number of cards.The second line contains n distinct space-separated integers p1, p2, ..., pn (1 ≤ pi ≤ n) — the initial row of cards. The third line contains k space-separated integers b1, b2, ..., bk — the row of cards that you need to get. It is guaranteed that it's possible to obtain the given row by using the remove operation for n - k times.",
      "output_spec": "OutputPrint a single integer — the maximum number of pieces of sausage that George can get if he acts optimally well.",
      "sample_tests": "ExamplesInputCopy3 22 1 31 3OutputCopy1InputCopy10 51 2 3 4 5 6 7 8 9 102 4 6 8 10OutputCopy30",
      "description": "E. George and Cards\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and k (1 ≤ k ≤ n ≤ 106) — the initial and the final number of cards.The second line contains n distinct space-separated integers p1, p2, ..., pn (1 ≤ pi ≤ n) — the initial row of cards. The third line contains k space-separated integers b1, b2, ..., bk — the row of cards that you need to get. It is guaranteed that it's possible to obtain the given row by using the remove operation for n - k times.\n\nOutputPrint a single integer — the maximum number of pieces of sausage that George can get if he acts optimally well.\n\nInputCopy3 22 1 31 3OutputCopy1InputCopy10 51 2 3 4 5 6 7 8 9 102 4 6 8 10OutputCopy30\n\nInputCopy3 22 1 31 3\n\nOutputCopy1\n\nInputCopy10 51 2 3 4 5 6 7 8 9 102 4 6 8 10\n\nOutputCopy30",
      "solutions": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "Hello!Soon (on January 30 at 19:30 MSK) you are lucky to participate in Codeforces Round #227 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition. Problems have been prepared by me. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Mary Belova (Delinur) for translation of statements, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.The main character of the tasks is the cat George.UPD1: Scoring will be next: 500, 1000, 1500, 2000, 2500.UPD2: Contest finished, congratulations to winners! hmm_dream_big graphis InternationalGrandmaster Skedar mateusz UPD: EditorialUPD: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10569",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 688
        },
        {
          "title": "Editorial Codeforces Round #227 (Div. 2) - Codeforces",
          "content": "387A - George and SleepI will describe the simple solution. Let George woke up in the h0 hours and m0 minutes, and he slept for h1 hours and m1 minutes. Let's get the number hp = h0 - h1 and mp = m0 - m1. If mp < 0, then you should add to mp 60 minutes and subtract from hp one hour. After that if hp < 0, then add to it 24 hours. You can print the answer in C++ by using the following line: printf(\"%02d:%02d\", h[p], m[p]).The complexity is O(1) time and O(1) memory.Author's solution: 5850831387B - George and RoundConsider the number of requirements of the difficulties, which we will cover, and we will come up with and prepare new problem to cover other requirements. It is clear that if we decided to meet the i out of n requirements, it would be better to take those with minimal complexity. Let's simplify i most difficult problems to lightest requirements. If all goes well, then we update the answer by value n - i.The complexity is: O(n2) time / O(n) memory. Note, that there is an solution with complexity O(n + m).Author's solution: 5850888387C - George and NumberLet's obtain the following irreducible representation of a number p = a1 + a2 + ... + ak, where  +  is a concatenation, and numbers ai have the form x00..000 (x — is non zero digit, and after that there are only zeroes). Let's determine largest index i, such that a1 + a2 + ... + ai - 1 < ai. If there are no such index i then i = 1. After that is k - i + 1. You can compare numbers by using length of number and first digit. You can prove these solution as home task : )The complexity is: O(n) time / O(n) memory.Author's solution: 5850919387D - George and Interesting GraphTo solve this problem you should know about bipartite matching.Let's consider the center of graph i. After that let's remove arcs that have form (i, u) or (u, i). Let's there are cntWithI arcs of such type. Let's Other = m - CntWithI — number of other arcs.After that we should found maximal bipartite matching on the bipartite graph. This graph has following idea: left part of this graph is indegrees of all vertexes except vertex i, right part of this graph is outdegrees of all vertexes except vertex i. Also if there an arc (i, j) in our graph then in our bipartite graph there an arc (i, j), where i — vertex from left part, j — vertex from the right part. Let's size of bipartite matching on the bipartite graph equals to leng. Then answer for the current vertex i equals to 2n - 1 - cntWithI + Other - leng + (n - 1) - leng. After that you should update global answer. Why it is correct? It is simple to understand that if we will found bipartite matching on the bipartite graph we will cover maximal number of requirements on in/out degrees. Because of that, we will remove all other arcs, except of maximal matching, and after that we will add this maximal matching to full matching by adding (n - 1) - leng arcs. Note, it is important, that self-loops are not forbidden. Withoud self-loops problem is very hard, I think. The complexity is: O(n2m) time / O(n + m) memory.5850946387E - George and CardsLet's calculate arrays pos[i] — position of number i in permutation p and need[i] — equals to one if we should remove number i from permutation p, and zero if we shouldn't remove i from permutation p. Let's a1, a2, ..., an - k — numvers, which we should remove. It is clear to understand that we should remove these number in increasing order. It is simple to proof this statement.Let's iterate i from to 1 to n. Also we the current number we will have special set (set <>in с++, TreeSet in Java) of positions of non-erased numbers (which are smaller then i) of permutation. These position can create an ``obstacle'' for current position of number i. It is simple to support this special set. Also we can add to this set numbers  - 1 and n. Now it is easy to find length og the maximal sub-array, where current number is a minimum. You can prosess such query by using standart functions of programming language (lower and higher in Java). After that we should use Fenwick tree to determine quantity of numbers which are not removed on the maximal sub-array.The complexity is: time / O(n) memory.Very simple implementation on Java: 5850986",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10583",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 387\\s*E"
          },
          "content_length": 4201
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "Round duration increased for 10 minutes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10569",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #227 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #227 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%02d:%02d\", h[p], m[p]).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10583",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All elements in p must be distinct\");\n\n    vector<int> b = inf.readInts(k, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All elements in p must be distinct\");\n\n    vector<int> b = inf.readInts(k, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All elements in p must be distinct\");\n\n    vector<int> b = inf.readInts(k, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n);\n    ensuref(1 <= k && k <= n, \"k must be in range [1, n]\");\n\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> p;\n    vector<int> b;\n\n    if (type == \"random\") {\n        // Generate p as a random permutation of 1..n\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n\n        // Generate b as random subsequence of p\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    } else if (type == \"ascending\") {\n        // p is ascending from 1 to n\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        // Generate b as random subsequence of p\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    } else if (type == \"descending\") {\n        // p is descending from n to 1\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n        // Generate b as random subsequence of p\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    } else if (type == \"same\") {\n        // p and b are the same\n        n = k;\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        b = p;\n    } else if (type == \"worst_case\") {\n        // Construct p and b to maximize the total number of pieces\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        // b consists of every second element starting from index 1\n        b.resize(k);\n        int interval = n / k;\n        for (int i = 0; i < k; ++i)\n            b[i] = p[i * interval];\n    } else if (type == \"minimal\") {\n        // Construct p and b to minimize the total number of pieces\n        // Interleave required elements with elements to be removed\n        p.clear();\n        b.clear();\n        int val = 1;\n        for (int i = 0; i < k; ++i) {\n            p.push_back(val); // required element\n            b.push_back(val);\n            val++;\n            if ((int)p.size() < n) {\n                p.push_back(val); // element to remove\n                val++;\n            }\n        }\n        while ((int)p.size() < n) {\n            p.push_back(val++);\n        }\n        n = p.size();\n    } else {\n        // Default to random\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output p\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    // Output b\n    for (int i = 0; i < k; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", n);\n    ensuref(1 <= k && k <= n, \"k must be in range [1, n]\");\n\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> p;\n    vector<int> b;\n\n    if (type == \"random\") {\n        // Generate p as a random permutation of 1..n\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n\n        // Generate b as random subsequence of p\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    } else if (type == \"ascending\") {\n        // p is ascending from 1 to n\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        // Generate b as random subsequence of p\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    } else if (type == \"descending\") {\n        // p is descending from n to 1\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n        // Generate b as random subsequence of p\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    } else if (type == \"same\") {\n        // p and b are the same\n        n = k;\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        b = p;\n    } else if (type == \"worst_case\") {\n        // Construct p and b to maximize the total number of pieces\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        // b consists of every second element starting from index 1\n        b.resize(k);\n        int interval = n / k;\n        for (int i = 0; i < k; ++i)\n            b[i] = p[i * interval];\n    } else if (type == \"minimal\") {\n        // Construct p and b to minimize the total number of pieces\n        // Interleave required elements with elements to be removed\n        p.clear();\n        b.clear();\n        int val = 1;\n        for (int i = 0; i < k; ++i) {\n            p.push_back(val); // required element\n            b.push_back(val);\n            val++;\n            if ((int)p.size() < n) {\n                p.push_back(val); // element to remove\n                val++;\n            }\n        }\n        while ((int)p.size() < n) {\n            p.push_back(val++);\n        }\n        n = p.size();\n    } else {\n        // Default to random\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        indices.resize(k);\n        sort(indices.begin(), indices.end());\n        b.resize(k);\n        for (int i = 0; i < k; ++i)\n            b[i] = p[indices[i]];\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output p\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    // Output b\n    for (int i = 0; i < k; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 5 -k 3 -type random\n./gen -n 10 -k 5 -type random\n\n# Random test cases with n up to 1e3\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 1000 -type random\n./gen -n 1000 -k 1 -type random\n\n# Random test cases with maximum n\n./gen -n 1000000 -k 500000 -type random\n./gen -n 1000000 -k 999999 -type random\n./gen -n 1000000 -k 1 -type random\n\n# Ascending sequence test cases\n./gen -n 1000 -k 500 -type ascending\n./gen -n 1000000 -k 500000 -type ascending\n\n# Descending sequence test cases\n./gen -n 1000 -k 500 -type descending\n./gen -n 1000000 -k 500000 -type descending\n\n# Test cases where p and b are the same\n./gen -n 10 -k 10 -type same\n./gen -n 1000 -k 1000 -type same\n./gen -n 1000000 -k 1000000 -type same\n\n# Test cases aiming for worst case (max total pieces of sausage)\n./gen -n 100 -k 10 -type worst_case\n./gen -n 1000 -k 50 -type worst_case\n./gen -n 1000000 -k 1000 -type worst_case\n\n# Test cases aiming for minimal total pieces of sausage\n./gen -n 100 -k 50 -type minimal\n./gen -n 1000 -k 500 -type minimal\n./gen -n 1000000 -k 500000 -type minimal\n\n# Edge case test cases\n./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type same\n\n# Test cases with k = 1\n./gen -n 10 -k 1 -type random\n./gen -n 1000 -k 1 -type random\n./gen -n 1000000 -k 1 -type random\n\n# Test cases with k = n - 1\n./gen -n 10 -k 9 -type random\n./gen -n 1000 -k 999 -type random\n./gen -n 1000000 -k 999999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:38.490918",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "388/A",
      "title": "A. Лиса и коробки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100). В следующей строке записано n целых чисел x1, x2, ..., xn (0 ≤ xi ≤ 100).",
      "output_spec": "Выходные данныеВыведите целое число — минимальное возможное количество стопок.",
      "sample_tests": "ПримерыВходные данныеСкопировать30 0 10Выходные данныеСкопировать2Входные данныеСкопировать50 1 2 3 4Выходные данныеСкопировать1Входные данныеСкопировать40 0 0 0Выходные данныеСкопировать4Входные данныеСкопировать90 1 0 2 0 1 1 2 10Выходные данныеСкопировать3",
      "description": "A. Лиса и коробки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100). В следующей строке записано n целых чисел x1, x2, ..., xn (0 ≤ xi ≤ 100).\n\nВходные данные\n\nВыходные данныеВыведите целое число — минимальное возможное количество стопок.\n\nВыходные данные\n\nВходные данныеСкопировать30 0 10Выходные данныеСкопировать2Входные данныеСкопировать50 1 2 3 4Выходные данныеСкопировать1Входные данныеСкопировать40 0 0 0Выходные данныеСкопировать4Входные данныеСкопировать90 1 0 2 0 1 1 2 10Выходные данныеСкопировать3\n\nВходные данныеСкопировать30 0 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать50 1 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать90 1 0 2 0 1 1 2 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оптимальный способ — соорудить 2 стопки: в первой стопке будут коробки номер 1 и 3 (сверху вниз), во второй стопке будет только коробка номер 2.Во втором примере можно построить одну стопку, содержащую коробки номер 1, 2, 3, 4, 5 (сверху вниз).",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Привет всем!В понедельник третьего февраля 2014 года в 19:30 по московскому времени состоится Codeforces Round #228 (Div1 + Div2).Этой мой второй раунд на Codeforces (кликните сюда, чтобы посмотреть предыдущий). Как обычно, в раунде будет семь задач: две — только для Div2, две — только для Div1 и три общие задачи. Точно так же, как и в прошлый раз, главным героем задач раунда будет лиса Ciel.Благодарю Gerald за тестирование задач и MikeMirzayanov за проект Codeforces и систему Polygon.Желаю удачи и фана от решения задач!Распределение баллов будет анонсировано позже. А разбор задач будет опубликован сразу после системного тестирования.Кроме всего прочего, вчера в Китае отмечали новый год. Поздравляю всех, кто отмечал этот праздник! И, конечно, я очень рад, что именно я автор первого контеста в новом году.Update1: Приятная новость для участников Петрозаводских сборов. Top 20 участников сборов по итогам этого раунда, которые придут на закрытие, получат футболки от Codeforces.Update 2: Распределение баллов по задачам стандартное. (500-1000-1500-2000-2500).Update 3: Приносим извинения, раунд перенесен на 10 минут по техническим причинам.Update 4: Продолжительность соревнования увеличена на 5 минут.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: разбор.Победители:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA К сожалению, никто не решил задачу Е. Решение Egor-a могло пройти тестирование, если бы TL был бы равен 7 секундам, вместо 6. Какая жалость!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel Только они решили все предложенные задачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1632
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 388\\s*A"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n from the first line, ensure it is between 1 and 100\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln(); // Ensure the line ends after n\n\n    // Read n integers xi, each between 0 and 100\n    inf.readInts(n, 0, 100, \"x\");\n    inf.readEoln(); // Ensure the line ends after the last xi\n\n    // Ensure that there is no extra data after the expected input\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n from the first line, ensure it is between 1 and 100\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln(); // Ensure the line ends after n\n\n    // Read n integers xi, each between 0 and 100\n    inf.readInts(n, 0, 100, \"x\");\n    inf.readEoln(); // Ensure the line ends after the last xi\n\n    // Ensure that there is no extra data after the expected input\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n from the first line, ensure it is between 1 and 100\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln(); // Ensure the line ends after n\n\n    // Read n integers xi, each between 0 and 100\n    inf.readInts(n, 0, 100, \"x\");\n    inf.readEoln(); // Ensure the line ends after the last xi\n\n    // Ensure that there is no extra data after the expected input\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int value = opt<int>(\"value\", -1); // Optional value parameter for 'constant' type\n\n    vector<int> xi(n);\n\n    if (type == \"zero\") {\n        // All xi are zero\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 0;\n        }\n    } else if (type == \"max\") {\n        // All xi are 100\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 100;\n        }\n    } else if (type == \"random\") {\n        // xi random between 0 and 100\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"random_low\") {\n        // xi random between 0 and 10\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"random_high\") {\n        // xi random between 90 and 100\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(90, 100);\n        }\n    } else if (type == \"increasing\") {\n        // xi increases from 0 to 100\n        if (n == 1) {\n            xi[0] = 100;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = (100 * i) / (n - 1); // Ensure xi[0]=0, xi[n-1]=100\n            }\n        }\n    } else if (type == \"decreasing\") {\n        // xi decreases from 100 to 0\n        if (n == 1) {\n            xi[0] = 100;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = (100 * (n - 1 - i)) / (n - 1); // Ensure xi[0]=100, xi[n-1]=0\n            }\n        }\n    } else if (type == \"alternating\") {\n        // xi alternates between low and high values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                xi[i] = rnd.next(0, 10);\n            else\n                xi[i] = rnd.next(90, 100);\n        }\n    } else if (type == \"constant\") {\n        // All xi are the same (value specified)\n        if (value == -1) {\n            xi.assign(n, rnd.next(0, 100));\n        } else {\n            xi.assign(n, value);\n        }\n    } else if (type == \"small_n\") {\n        // n is small, xi random\n        n = opt<int>(\"n\", rnd.next(1, 5));\n        xi.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"large_n\") {\n        // n is large (max), xi random\n        n = 100;\n        xi.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"one_zero_rest_max\") {\n        // One xi is zero, rest are max\n        xi.assign(n, 100);\n        xi[rnd.next(0, n-1)] = 0;\n    } else if (type == \"one_max_rest_zero\") {\n        // One xi is max, rest are zero\n        xi.assign(n, 0);\n        xi[rnd.next(0, n-1)] = 100;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int value = opt<int>(\"value\", -1); // Optional value parameter for 'constant' type\n\n    vector<int> xi(n);\n\n    if (type == \"zero\") {\n        // All xi are zero\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 0;\n        }\n    } else if (type == \"max\") {\n        // All xi are 100\n        for (int i = 0; i < n; ++i) {\n            xi[i] = 100;\n        }\n    } else if (type == \"random\") {\n        // xi random between 0 and 100\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"random_low\") {\n        // xi random between 0 and 10\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"random_high\") {\n        // xi random between 90 and 100\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(90, 100);\n        }\n    } else if (type == \"increasing\") {\n        // xi increases from 0 to 100\n        if (n == 1) {\n            xi[0] = 100;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = (100 * i) / (n - 1); // Ensure xi[0]=0, xi[n-1]=100\n            }\n        }\n    } else if (type == \"decreasing\") {\n        // xi decreases from 100 to 0\n        if (n == 1) {\n            xi[0] = 100;\n        } else {\n            for (int i = 0; i < n; ++i) {\n                xi[i] = (100 * (n - 1 - i)) / (n - 1); // Ensure xi[0]=100, xi[n-1]=0\n            }\n        }\n    } else if (type == \"alternating\") {\n        // xi alternates between low and high values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                xi[i] = rnd.next(0, 10);\n            else\n                xi[i] = rnd.next(90, 100);\n        }\n    } else if (type == \"constant\") {\n        // All xi are the same (value specified)\n        if (value == -1) {\n            xi.assign(n, rnd.next(0, 100));\n        } else {\n            xi.assign(n, value);\n        }\n    } else if (type == \"small_n\") {\n        // n is small, xi random\n        n = opt<int>(\"n\", rnd.next(1, 5));\n        xi.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"large_n\") {\n        // n is large (max), xi random\n        n = 100;\n        xi.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"one_zero_rest_max\") {\n        // One xi is zero, rest are max\n        xi.assign(n, 100);\n        xi[rnd.next(0, n-1)] = 0;\n    } else if (type == \"one_max_rest_zero\") {\n        // One xi is max, rest are zero\n        xi.assign(n, 0);\n        xi[rnd.next(0, n-1)] = 100;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type small_n\n./gen -n 2 -type small_n\n./gen -n 3 -type small_n\n\n./gen -n 10 -type zero\n./gen -n 100 -type zero\n\n./gen -n 10 -type max\n./gen -n 100 -type max\n\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 5 -type random\n./gen -n 1 -type random\n\n./gen -n 10 -type random_low\n./gen -n 50 -type random_low\n\n./gen -n 10 -type random_high\n./gen -n 50 -type random_high\n\n./gen -n 10 -type increasing\n./gen -n 100 -type increasing\n\n./gen -n 10 -type decreasing\n./gen -n 100 -type decreasing\n\n./gen -n 10 -type alternating\n./gen -n 50 -type alternating\n\n./gen -n 10 -type constant -value 50\n./gen -n 100 -type constant -value 0\n./gen -n 100 -type constant -value 100\n\n./gen -n 10 -type one_zero_rest_max\n./gen -n 100 -type one_zero_rest_max\n\n./gen -n 10 -type one_max_rest_zero\n./gen -n 100 -type one_max_rest_zero\n\n./gen -n 100 -type random\n./gen -n 5 -type random_low\n./gen -n 5 -type random_high\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:40.717288",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "388/B",
      "title": "B. Fox and Minimal path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer k (1 ≤ k ≤ 109).",
      "output_spec": "OutputYou should output a graph G with n vertexes (2 ≤ n ≤ 1000). There must be exactly k shortest paths between vertex 1 and vertex 2 of the graph.The first line must contain an integer n. Then adjacency matrix G with n rows and n columns must follow. Each element of the matrix must be 'N' or 'Y'. If Gij is 'Y', then graph G has a edge connecting vertex i and vertex j. Consider the graph vertexes are numbered from 1 to n.The graph must be undirected and simple: Gii = 'N' and Gij = Gji must hold. And there must be at least one path between vertex 1 and vertex 2. It's guaranteed that the answer exists. If there multiple correct answers, you can output any of them.",
      "sample_tests": "ExamplesInputCopy2OutputCopy4NNYYNNYYYYNNYYNNInputCopy9OutputCopy8NNYYYNNNNNNNNYYYYNNNNYYYYNNNNYYYYNNNNYYYNYYYYNNNNYYYYNNNNYYYYNNNInputCopy1OutputCopy2NYYN",
      "description": "B. Fox and Minimal path\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer k (1 ≤ k ≤ 109).\n\nOutputYou should output a graph G with n vertexes (2 ≤ n ≤ 1000). There must be exactly k shortest paths between vertex 1 and vertex 2 of the graph.The first line must contain an integer n. Then adjacency matrix G with n rows and n columns must follow. Each element of the matrix must be 'N' or 'Y'. If Gij is 'Y', then graph G has a edge connecting vertex i and vertex j. Consider the graph vertexes are numbered from 1 to n.The graph must be undirected and simple: Gii = 'N' and Gij = Gji must hold. And there must be at least one path between vertex 1 and vertex 2. It's guaranteed that the answer exists. If there multiple correct answers, you can output any of them.\n\nInputCopy2OutputCopy4NNYYNNYYYYNNYYNNInputCopy9OutputCopy8NNYYYNNNNNNNNYYYYNNNNYYYYNNNNYYYYNNNNYYYNYYYYNNNNYYYYNNNNYYYYNNNInputCopy1OutputCopy2NYYN\n\nOutputCopy4NNYYNNYYYYNNYYNN\n\nOutputCopy8NNYYYNNNNNNNNYYYYNNNNYYYYNNNNYYYYNNNNYYYNYYYYNNNNYYYYNNNNYYYYNNN\n\nOutputCopy2NYYN\n\nNoteIn first example, there are 2 shortest paths: 1-3-2 and 1-4-2.In second example, there are 9 shortest paths: 1-3-6-2, 1-3-7-2, 1-3-8-2, 1-4-6-2, 1-4-7-2, 1-4-8-2, 1-5-6-2, 1-5-7-2, 1-5-8-2.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Hello everyone!Codeforces Round #228 (Div. 1 and Div.2) will start at Monday, 3 February 2014, 19:30:00 MSK.This is my 2nd round on Codeforces. (Click here to see my last round) , As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. And same with the last round, the main character of all problem will be Fox Ciel.I would like to thank Gerald for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!The score distribution will be published later. And the editorial will be published right after the system test.By the way, yesterday is the Chinese new year. So I'd like to say Happy New Year to everyone who celebrate it! And I'm very glad to be the writer of the first round in the new year.Update1: Good news for participants of Petrozavodsk training camp. Top 20 participants of the camp by this round results will get t-shirts from Codeforces.Update 2: The score distribution for Both Division is regular (500-1000-1500-2000-2500).Update 3: We postpone the round 10 minutes by technical reasons (dinner on Petrozavodsk Training Camp), sorry for the inconvenience.Update 4: We've increased the contest time by 5 minutes.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: Editorial.Winners:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA Sadly no one solved E correctly. Egor's solution can pass if the TL is 7 seconds instead of 6, what a pity!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel They are the only people who solved all tasks!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1587
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 388\\s*B"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read k from the input file (the single integer).\n    long long k = inf.readLong(1, 1000000000, \"k\");\n\n    // From contestant's output, read n.\n    int n = ouf.readInt(2, 1000, \"n\");\n    \n    // Read adjacency matrix as n lines of length n, each containing 'Y' or 'N'.\n    vector<string> g(n);\n    for(int i=0; i<n; i++){\n        g[i] = ouf.readToken();\n        if((int) g[i].size() != n){\n            ouf.quitf(_wa, \"Each line of adjacency matrix must be length n = %d.\", n);\n        }\n    }\n\n    // Check the matrix is valid for a simple undirected graph:\n    // Gii = 'N' and Gij = Gji, Gij in {'Y','N'}.\n    for(int i = 0; i < n; i++){\n        if(g[i][i] != 'N'){\n            ouf.quitf(_wa, \"Graph must be simple: g[%d][%d] should be 'N'.\", i+1, i+1);\n        }\n        for(int j = i+1; j < n; j++){\n            if(g[i][j] != 'Y' && g[i][j] != 'N'){\n                ouf.quitf(_wa, \"Invalid character g[%d][%d] = '%c'. Must be 'Y' or 'N'.\",\n                          i+1, j+1, g[i][j]);\n            }\n            if(g[i][j] != g[j][i]){\n                ouf.quitf(_wa, \"Graph must be undirected: g[%d][%d] != g[%d][%d].\",\n                          i+1, j+1, j+1, i+1);\n            }\n        }\n    }\n\n    // Build adjacency list for BFS\n    vector<vector<int>> adj(n);\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(g[i][j] == 'Y'){\n                adj[i].push_back(j);\n            }\n        }\n    }\n\n    // We want to count the number of shortest paths from vertex 1 to vertex 2 (1-based).\n    // But our indices in code are 0-based. So we'll do BFS from node 0 to node 1.\n    const int start = 0, finish = 1;\n    // BFS to find shortest distance and number of shortest paths\n    vector<long long> dist(n, LLONG_MAX);\n    vector<long long> ways(n, 0LL);\n    queue<int> q;\n\n    dist[start] = 0;\n    ways[start] = 1;\n    q.push(start);\n\n    while(!q.empty()){\n        int u = q.front(); \n        q.pop();\n        for(int v : adj[u]){\n            if(dist[v] > dist[u] + 1){\n                dist[v] = dist[u] + 1;\n                ways[v] = ways[u];\n                q.push(v);\n            } else if(dist[v] == dist[u] + 1){\n                // Another way to reach v with the same shortest distance\n                ways[v] += ways[u];\n                // If ways[v] might get large, but this problem states k <= 1e9, \n                // so we stay within 64-bit long long safely.\n            }\n        }\n    }\n\n    // Check that there's at least one path\n    if(dist[finish] == LLONG_MAX || ways[finish] == 0LL){\n        ouf.quitf(_wa, \"No path from vertex 1 to vertex 2 in the submitted graph.\");\n    }\n\n    // Now ways[finish] is the number of shortest paths from 1->2\n    if(ways[finish] == k){\n        // Correct\n        ouf.quitf(_ok, \"Number of shortest paths = %lld, matches k.\", ways[finish]);\n    } else {\n        ouf.quitf(_wa, \"Number of shortest paths = %lld, expected = %lld.\", ways[finish], k);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read possible parameters:\n    //   \"k\": a fixed integer to output.\n    //   \"type\": a string indicating how to generate a random k.\n    // If neither is specified, we just pick a random k in [1..1e9].\n    \n    // 1. Parse \"k\" if provided:\n    //    If \"k\" exists, output that integer directly.\n    // 2. Otherwise, parse \"type\" if provided, and generate accordingly.\n    // 3. If neither \"k\" nor \"type\" is provided, just pick a random k in [1..1e9].\n    \n    // Constraint for k: 1 <= k <= 1e9.\n    \n    // Read optional parameters\n    long long paramK = opt<long long>(\"k\", -1LL);  // default is -1 meaning not provided\n    string type = opt<string>(\"type\", \"\");\n    \n    // If paramK is valid, just output that\n    if (paramK >= 1 && paramK <= 1000000000LL) {\n        cout << paramK << \"\\n\";\n        return 0;\n    }\n    \n    // Otherwise, determine k from \"type\"\n    long long k = -1;\n    \n    if (type == \"small\") {\n        // random k in [1..100]\n        k = rnd.next(1, 100);\n    } else if (type == \"medium\") {\n        // random k in [101..100000]\n        k = rnd.next(101, 100000);\n    } else if (type == \"large\") {\n        // random k in [100000001..1000000000]\n        k = rnd.next(100000001, 1000000000);\n    } else if (type == \"pow2\") {\n        // pick a random power of two within [1..1e9]\n        // the largest power of two below 1e9 is 2^30 = 1073741824, slightly above 1e9,\n        // so we only go up to 2^29 = 536870912\n        int p = rnd.next(0, 29); // power from 2^0..2^29\n        k = (1LL << p);\n    } else if (type == \"boundary\") {\n        // choose one of a few boundary values\n        // We'll pick from a small set at random\n        vector<long long> boundaries = {1LL, 2LL, 999999999LL, 1000000000LL};\n        k = boundaries[rnd.next(0, (int)boundaries.size() - 1)];\n    } else {\n        // No valid type or k: pick something totally random in [1..1e9]\n        k = rnd.next(1LL, 1000000000LL);\n    }\n    \n    // Output k\n    cout << k << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read possible parameters:\n    //   \"k\": a fixed integer to output.\n    //   \"type\": a string indicating how to generate a random k.\n    // If neither is specified, we just pick a random k in [1..1e9].\n    \n    // 1. Parse \"k\" if provided:\n    //    If \"k\" exists, output that integer directly.\n    // 2. Otherwise, parse \"type\" if provided, and generate accordingly.\n    // 3. If neither \"k\" nor \"type\" is provided, just pick a random k in [1..1e9].\n    \n    // Constraint for k: 1 <= k <= 1e9.\n    \n    // Read optional parameters\n    long long paramK = opt<long long>(\"k\", -1LL);  // default is -1 meaning not provided\n    string type = opt<string>(\"type\", \"\");\n    \n    // If paramK is valid, just output that\n    if (paramK >= 1 && paramK <= 1000000000LL) {\n        cout << paramK << \"\\n\";\n        return 0;\n    }\n    \n    // Otherwise, determine k from \"type\"\n    long long k = -1;\n    \n    if (type == \"small\") {\n        // random k in [1..100]\n        k = rnd.next(1, 100);\n    } else if (type == \"medium\") {\n        // random k in [101..100000]\n        k = rnd.next(101, 100000);\n    } else if (type == \"large\") {\n        // random k in [100000001..1000000000]\n        k = rnd.next(100000001, 1000000000);\n    } else if (type == \"pow2\") {\n        // pick a random power of two within [1..1e9]\n        // the largest power of two below 1e9 is 2^30 = 1073741824, slightly above 1e9,\n        // so we only go up to 2^29 = 536870912\n        int p = rnd.next(0, 29); // power from 2^0..2^29\n        k = (1LL << p);\n    } else if (type == \"boundary\") {\n        // choose one of a few boundary values\n        // We'll pick from a small set at random\n        vector<long long> boundaries = {1LL, 2LL, 999999999LL, 1000000000LL};\n        k = boundaries[rnd.next(0, (int)boundaries.size() - 1)];\n    } else {\n        // No valid type or k: pick something totally random in [1..1e9]\n        k = rnd.next(1LL, 1000000000LL);\n    }\n    \n    // Output k\n    cout << k << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1\n./gen -k 2\n./gen -k 9\n./gen -k 42\n./gen -k 999999999\n./gen -k 1000000000\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n./gen -type large\n./gen -type large\n./gen -type pow2\n./gen -type pow2\n./gen -type boundary\n./gen -type boundary\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen -k 314159265\n./gen -k 999999998\n./gen -k 100000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:42.757936",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "388/C",
      "title": "C. Лиса и игра в карты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100). В каждой из следующих n строк записано описание одной стопки: первым в строке идет целое число si (1 ≤ si ≤ 100); число si обозначает количество карт в i-ой стопке; затем следуют si положительных целых чисел c1, c2, ..., ck, ..., csi (1 ≤ ck ≤ 1000) — последовательность чисел на картах в текущей стопке, перечисленных сверху вниз.",
      "output_spec": "Выходные данныеВыведите два целых числа: сумму карт Сиель и сумму карт Джиро, если они играют оптимально.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 1002 1 10Выходные данныеСкопировать101 10Входные данныеСкопировать19 2 8 6 5 9 4 7 1 3Выходные данныеСкопировать30 15Входные данныеСкопировать33 1 3 23 5 4 62 8 7Выходные данныеСкопировать18 18Входные данныеСкопировать33 1000 1000 10006 1000 1000 1000 1000 1000 10005 1000 1000 1000 1000 1000Выходные данныеСкопировать7000 7000",
      "description": "C. Лиса и игра в карты\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100). В каждой из следующих n строк записано описание одной стопки: первым в строке идет целое число si (1 ≤ si ≤ 100); число si обозначает количество карт в i-ой стопке; затем следуют si положительных целых чисел c1, c2, ..., ck, ..., csi (1 ≤ ck ≤ 1000) — последовательность чисел на картах в текущей стопке, перечисленных сверху вниз.\n\nВходные данные\n\nВыходные данныеВыведите два целых числа: сумму карт Сиель и сумму карт Джиро, если они играют оптимально.\n\nВыходные данные\n\nВходные данныеСкопировать21 1002 1 10Выходные данныеСкопировать101 10Входные данныеСкопировать19 2 8 6 5 9 4 7 1 3Выходные данныеСкопировать30 15Входные данныеСкопировать33 1 3 23 5 4 62 8 7Выходные данныеСкопировать18 18Входные данныеСкопировать33 1000 1000 10006 1000 1000 1000 1000 1000 10005 1000 1000 1000 1000 1000Выходные данныеСкопировать7000 7000\n\nВходные данныеСкопировать21 1002 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать101 10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать19 2 8 6 5 9 4 7 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать30 15\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать33 1 3 23 5 4 62 8 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18 18\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать33 1000 1000 10006 1000 1000 1000 1000 1000 10005 1000 1000 1000 1000 1000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7000 7000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Сиель возьмет карты с числами 100 и 1, Джиро возьмет карту с числом 10.Во втором примере Сиель возьмет карты с числами 2, 8, 6, 5, 9, а Джиро возьмет карты с числами 4, 7, 1, 3.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Привет всем!В понедельник третьего февраля 2014 года в 19:30 по московскому времени состоится Codeforces Round #228 (Div1 + Div2).Этой мой второй раунд на Codeforces (кликните сюда, чтобы посмотреть предыдущий). Как обычно, в раунде будет семь задач: две — только для Div2, две — только для Div1 и три общие задачи. Точно так же, как и в прошлый раз, главным героем задач раунда будет лиса Ciel.Благодарю Gerald за тестирование задач и MikeMirzayanov за проект Codeforces и систему Polygon.Желаю удачи и фана от решения задач!Распределение баллов будет анонсировано позже. А разбор задач будет опубликован сразу после системного тестирования.Кроме всего прочего, вчера в Китае отмечали новый год. Поздравляю всех, кто отмечал этот праздник! И, конечно, я очень рад, что именно я автор первого контеста в новом году.Update1: Приятная новость для участников Петрозаводских сборов. Top 20 участников сборов по итогам этого раунда, которые придут на закрытие, получат футболки от Codeforces.Update 2: Распределение баллов по задачам стандартное. (500-1000-1500-2000-2500).Update 3: Приносим извинения, раунд перенесен на 10 минут по техническим причинам.Update 4: Продолжительность соревнования увеличена на 5 минут.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: разбор.Победители:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA К сожалению, никто не решил задачу Е. Решение Egor-a могло пройти тестирование, если бы TL был бы равен 7 секундам, вместо 6. Какая жалость!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel Только они решили все предложенные задачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1632
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 388\\s*C"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 100, \"si\");\n        for (int k = 0; k < si; k++) {\n            inf.readSpace();\n            int ck = inf.readInt(1, 1000, \"ck\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 100, \"si\");\n        for (int k = 0; k < si; k++) {\n            inf.readSpace();\n            int ck = inf.readInt(1, 1000, \"ck\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 100, \"si\");\n        for (int k = 0; k < si; k++) {\n            inf.readSpace();\n            int ck = inf.readInt(1, 1000, \"ck\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_s = opt<int>(\"max_s\", 100);\n    int max_c = opt<int>(\"max_c\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> piles(n);\n\n    if (type == \"random\") {\n        // Randomly generate piles\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = rnd.next(1, max_c);\n            }\n        }\n    } else if (type == \"max\") {\n        // Max size, max values\n        for (int i = 0; i < n; ++i) {\n            int s = max_s;\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = max_c;\n            }\n        }\n    } else if (type == \"min\") {\n        // Min size, min values\n        for (int i = 0; i < n; ++i) {\n            int s = 1;\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = 1;\n            }\n        }\n    } else if (type == \"ascending\") {\n        // Cards in ascending order in each pile\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            int c = rnd.next(1, max_c - s + 1);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = c + j;\n                if (piles[i][j] > max_c) piles[i][j] = max_c;\n            }\n        }\n    } else if (type == \"descending\") {\n        // Cards in descending order in each pile\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            int c = rnd.next(s, max_c);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = c - j;\n                if (piles[i][j] < 1) piles[i][j] = 1;\n            }\n        }\n    } else if (type == \"equal\") {\n        // All cards have the same value\n        int c = rnd.next(1, max_c);\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s, c);\n        }\n    } else if (type == \"tie\") {\n        // Generate a test case where total sums are equal\n        int total_cards = rnd.next(1, n * max_s / 2) * 2; // Ensure even number\n        vector<int> cards(total_cards);\n        for (int i = 0; i < total_cards / 2; ++i) {\n            int val = rnd.next(1, max_c);\n            cards[i] = val;\n            cards[total_cards - i - 1] = val;\n        }\n        // Shuffle the cards\n        shuffle(cards.begin(), cards.end());\n        // Now distribute cards into piles\n        int idx = 0;\n        for (int i = 0; i < n && idx < total_cards; ++i) {\n            int remaining_cards = total_cards - idx;\n            int s = rnd.next(1, min(max_s, remaining_cards));\n            piles[i].resize(s);\n            for (int j = 0; j < s && idx < total_cards; ++j) {\n                piles[i][j] = cards[idx++];\n            }\n        }\n    } else if (type == \"alternating\") {\n        // High and low values alternating in stacks\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(2, max_s); // At least 2 cards\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                if (j % 2 == 0) {\n                    piles[i][j] = rnd.next(max(1, max_c / 2), max_c);\n                } else {\n                    piles[i][j] = rnd.next(1, max_c / 2);\n                }\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = rnd.next(1, max_c);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int s = piles[i].size();\n        printf(\"%d\", s);\n        for (int j = 0; j < s; ++j) {\n            printf(\" %d\", piles[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_s = opt<int>(\"max_s\", 100);\n    int max_c = opt<int>(\"max_c\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> piles(n);\n\n    if (type == \"random\") {\n        // Randomly generate piles\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = rnd.next(1, max_c);\n            }\n        }\n    } else if (type == \"max\") {\n        // Max size, max values\n        for (int i = 0; i < n; ++i) {\n            int s = max_s;\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = max_c;\n            }\n        }\n    } else if (type == \"min\") {\n        // Min size, min values\n        for (int i = 0; i < n; ++i) {\n            int s = 1;\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = 1;\n            }\n        }\n    } else if (type == \"ascending\") {\n        // Cards in ascending order in each pile\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            int c = rnd.next(1, max_c - s + 1);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = c + j;\n                if (piles[i][j] > max_c) piles[i][j] = max_c;\n            }\n        }\n    } else if (type == \"descending\") {\n        // Cards in descending order in each pile\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            int c = rnd.next(s, max_c);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = c - j;\n                if (piles[i][j] < 1) piles[i][j] = 1;\n            }\n        }\n    } else if (type == \"equal\") {\n        // All cards have the same value\n        int c = rnd.next(1, max_c);\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s, c);\n        }\n    } else if (type == \"tie\") {\n        // Generate a test case where total sums are equal\n        int total_cards = rnd.next(1, n * max_s / 2) * 2; // Ensure even number\n        vector<int> cards(total_cards);\n        for (int i = 0; i < total_cards / 2; ++i) {\n            int val = rnd.next(1, max_c);\n            cards[i] = val;\n            cards[total_cards - i - 1] = val;\n        }\n        // Shuffle the cards\n        shuffle(cards.begin(), cards.end());\n        // Now distribute cards into piles\n        int idx = 0;\n        for (int i = 0; i < n && idx < total_cards; ++i) {\n            int remaining_cards = total_cards - idx;\n            int s = rnd.next(1, min(max_s, remaining_cards));\n            piles[i].resize(s);\n            for (int j = 0; j < s && idx < total_cards; ++j) {\n                piles[i][j] = cards[idx++];\n            }\n        }\n    } else if (type == \"alternating\") {\n        // High and low values alternating in stacks\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(2, max_s); // At least 2 cards\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                if (j % 2 == 0) {\n                    piles[i][j] = rnd.next(max(1, max_c / 2), max_c);\n                } else {\n                    piles[i][j] = rnd.next(1, max_c / 2);\n                }\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, max_s);\n            piles[i].resize(s);\n            for (int j = 0; j < s; ++j) {\n                piles[i][j] = rnd.next(1, max_c);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        int s = piles[i].size();\n        printf(\"%d\", s);\n        for (int j = 0; j < s; ++j) {\n            printf(\" %d\", piles[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 1 -max_s 1 -type random\n./gen -n 5 -max_s 5 -type random\n./gen -n 5 -max_s 10 -type random\n\n# Max size test cases\n./gen -n 100 -max_s 100 -type max\n\n# Min size test cases\n./gen -n 1 -max_s 1 -type min\n./gen -n 100 -max_s 1 -type min\n\n# Ascending piles\n./gen -n 10 -max_s 50 -type ascending\n./gen -n 50 -max_s 100 -type ascending\n\n# Descending piles\n./gen -n 10 -max_s 50 -type descending\n./gen -n 50 -max_s 100 -type descending\n\n# Equal value piles\n./gen -n 10 -max_s 50 -type equal\n./gen -n 50 -max_s 100 -type equal\n\n# Tie score test cases\n./gen -n 10 -max_s 50 -type tie\n./gen -n 50 -max_s 100 -type tie\n./gen -n 100 -max_s 100 -type tie\n\n# Alternating high and low values\n./gen -n 10 -max_s 50 -type alternating\n./gen -n 50 -max_s 100 -type alternating\n\n# Random test cases with varying max_c\n./gen -n 50 -max_s 100 -max_c 10 -type random\n./gen -n 50 -max_s 100 -max_c 1000 -type random\n\n# Edge cases\n./gen -n 1 -max_s 100 -type random\n./gen -n 100 -max_s 1 -type random\n./gen -n 100 -max_s 100 -type random\n\n# Random test cases\n./gen -n 50 -max_s 50 -type random\n./gen -n 70 -max_s 70 -type random\n./gen -n 100 -max_s 100 -type random\n\n# Equal piles with maximum card values\n./gen -n 100 -max_s 100 -type equal -max_c 1000\n\n# Piles designed to test greedy strategies\n./gen -n 10 -max_s 100 -type descending\n./gen -n 10 -max_s 100 -type ascending\n\n# Additional random test cases\n./gen -n 100 -max_s 100 -type random\n./gen -n 100 -max_s 100 -type random\n./gen -n 100 -max_s 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:44.572792",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "388/D",
      "title": "D. Лиса и идеальные наборы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число k (0 ≤ k ≤ 109).",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество искомых множеств по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать2Входные данныеСкопировать2Выходные данныеСкопировать3Входные данныеСкопировать3Выходные данныеСкопировать5Входные данныеСкопировать4Выходные данныеСкопировать6",
      "description": "D. Лиса и идеальные наборы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число k (0 ≤ k ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество искомых множеств по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать2Входные данныеСкопировать2Выходные данныеСкопировать3Входные данныеСкопировать3Выходные данныеСкопировать5Входные данныеСкопировать4Выходные данныеСкопировать6\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере существует 2 таких множества: {0} и {0, 1}. Обратите внимание, что {1} не является идеальным множеством, так как 1 xor 1 = 0 и {1} не содержит нулей.В четвертом примере существует 6 таких множеств: {0}, {0, 1}, {0, 2}, {0, 3}, {0, 4} и {0, 1, 2, 3}.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Привет всем!В понедельник третьего февраля 2014 года в 19:30 по московскому времени состоится Codeforces Round #228 (Div1 + Div2).Этой мой второй раунд на Codeforces (кликните сюда, чтобы посмотреть предыдущий). Как обычно, в раунде будет семь задач: две — только для Div2, две — только для Div1 и три общие задачи. Точно так же, как и в прошлый раз, главным героем задач раунда будет лиса Ciel.Благодарю Gerald за тестирование задач и MikeMirzayanov за проект Codeforces и систему Polygon.Желаю удачи и фана от решения задач!Распределение баллов будет анонсировано позже. А разбор задач будет опубликован сразу после системного тестирования.Кроме всего прочего, вчера в Китае отмечали новый год. Поздравляю всех, кто отмечал этот праздник! И, конечно, я очень рад, что именно я автор первого контеста в новом году.Update1: Приятная новость для участников Петрозаводских сборов. Top 20 участников сборов по итогам этого раунда, которые придут на закрытие, получат футболки от Codeforces.Update 2: Распределение баллов по задачам стандартное. (500-1000-1500-2000-2500).Update 3: Приносим извинения, раунд перенесен на 10 минут по техническим причинам.Update 4: Продолжительность соревнования увеличена на 5 минут.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: разбор.Победители:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA К сожалению, никто не решил задачу Е. Решение Egor-a могло пройти тестирование, если бы TL был бы равен 7 секундам, вместо 6. Какая жалость!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel Только они решили все предложенные задачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1632
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 388\\s*D"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long k = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        if (type == \"min\") {\n            k = 0;\n        } else if (type == \"max\") {\n            k = 1000000000LL;\n        } else if (type == \"small\") {\n            k = rnd.next(1LL, 10LL);\n        } else if (type == \"medium\") {\n            k = rnd.next(100000LL, 1000000LL);\n        } else if (type == \"large\") {\n            k = rnd.next(1000000000LL - 100000LL, 1000000000LL);\n        } else if (type == \"power2\") {\n            int n = rnd.next(0, 30); // since 2^30 ~ 1e9\n            k = 1LL << n;\n        } else if (type == \"random\") {\n            k = rnd.next(0LL, 1000000000LL);\n        } else {\n            // Invalid type\n            fprintf(stderr, \"Invalid type\\n\");\n            exit(1);\n        }\n    }\n    if (k < 0 || k > 1000000000LL) {\n        fprintf(stderr, \"k out of bounds\\n\");\n        exit(1);\n    }\n    // Output k\n    printf(\"%lld\\n\", k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long k = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        if (type == \"min\") {\n            k = 0;\n        } else if (type == \"max\") {\n            k = 1000000000LL;\n        } else if (type == \"small\") {\n            k = rnd.next(1LL, 10LL);\n        } else if (type == \"medium\") {\n            k = rnd.next(100000LL, 1000000LL);\n        } else if (type == \"large\") {\n            k = rnd.next(1000000000LL - 100000LL, 1000000000LL);\n        } else if (type == \"power2\") {\n            int n = rnd.next(0, 30); // since 2^30 ~ 1e9\n            k = 1LL << n;\n        } else if (type == \"random\") {\n            k = rnd.next(0LL, 1000000000LL);\n        } else {\n            // Invalid type\n            fprintf(stderr, \"Invalid type\\n\");\n            exit(1);\n        }\n    }\n    if (k < 0 || k > 1000000000LL) {\n        fprintf(stderr, \"k out of bounds\\n\");\n        exit(1);\n    }\n    // Output k\n    printf(\"%lld\\n\", k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n./gen -type large\n./gen -type large\n./gen -type power2\n./gen -type power2\n./gen -type power2\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -k 0\n./gen -k 1\n./gen -k 2\n./gen -k 1000000000\n./gen -k 999999999\n./gen -k 500000000\n./gen -k 1023\n./gen -k 1024\n./gen -k 1025\n./gen -k 1048575\n./gen -k 1048576\n./gen -k 1048577\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:46.827568",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "388/E",
      "title": "E. Fox and Meteor Shower",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1000). Each of the next n lines contains six integers: t1, x1, y1, t2, x2, y2 — the description of a meteor's orbit: at time t1, the current meteor is located at the point (x1, y1) and at time t2, the meteor is located at point (x2, y2) ( - 106 ≤ t1, x1, y1, t2, x2, y2 ≤ 106; t1 ≠ t2). There will be no two meteors are always in the same position for any time.",
      "output_spec": "OutputPrint a single integer — the maximum number of meteors such that any pair met at the same position at a certain time.",
      "sample_tests": "ExamplesInputCopy20 0 1 1 0 20 1 0 1 2 0OutputCopy2InputCopy3-1 -1 0 3 3 00 2 -1 -1 3 -2-2 0 -1 6 0 3OutputCopy3InputCopy40 0 0 1 0 10 0 1 1 1 10 1 1 1 1 00 1 0 1 0 0OutputCopy1InputCopy10 0 0 1 0 0OutputCopy1",
      "description": "E. Fox and Meteor Shower\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1000). Each of the next n lines contains six integers: t1, x1, y1, t2, x2, y2 — the description of a meteor's orbit: at time t1, the current meteor is located at the point (x1, y1) and at time t2, the meteor is located at point (x2, y2) ( - 106 ≤ t1, x1, y1, t2, x2, y2 ≤ 106; t1 ≠ t2). There will be no two meteors are always in the same position for any time.\n\nOutputPrint a single integer — the maximum number of meteors such that any pair met at the same position at a certain time.\n\nInputCopy20 0 1 1 0 20 1 0 1 2 0OutputCopy2InputCopy3-1 -1 0 3 3 00 2 -1 -1 3 -2-2 0 -1 6 0 3OutputCopy3InputCopy40 0 0 1 0 10 0 1 1 1 10 1 1 1 1 00 1 0 1 0 0OutputCopy1InputCopy10 0 0 1 0 0OutputCopy1\n\nInputCopy20 0 1 1 0 20 1 0 1 2 0\n\nOutputCopy2\n\nInputCopy3-1 -1 0 3 3 00 2 -1 -1 3 -2-2 0 -1 6 0 3\n\nOutputCopy3\n\nInputCopy40 0 0 1 0 10 0 1 1 1 10 1 1 1 1 00 1 0 1 0 0\n\nOutputCopy1\n\nInputCopy10 0 0 1 0 0\n\nOutputCopy1\n\nNoteIn example 1, meteor 1 and 2 meet in t=-1 at (0, 0).In example 2, meteor 1 and 2 meet in t=1 at (1, 0), meteor 1 and 3 meet in t=0 at (0, 0) and meteor 2 and 3 meet in t=2 at (0, 1).In example 3, no two meteor meet.In example 4, there is only 1 meteor, and its velocity is zero.If your browser doesn't support animation png, please see the gif version here: http://assets.codeforces.com/images/388e/example1.gifhttp://assets.codeforces.com/images/388e/example2.gifhttp://assets.codeforces.com/images/388e/example3.gifhttp://assets.codeforces.com/images/388e/example4.gif",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Hello everyone!Codeforces Round #228 (Div. 1 and Div.2) will start at Monday, 3 February 2014, 19:30:00 MSK.This is my 2nd round on Codeforces. (Click here to see my last round) , As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. And same with the last round, the main character of all problem will be Fox Ciel.I would like to thank Gerald for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!The score distribution will be published later. And the editorial will be published right after the system test.By the way, yesterday is the Chinese new year. So I'd like to say Happy New Year to everyone who celebrate it! And I'm very glad to be the writer of the first round in the new year.Update1: Good news for participants of Petrozavodsk training camp. Top 20 participants of the camp by this round results will get t-shirts from Codeforces.Update 2: The score distribution for Both Division is regular (500-1000-1500-2000-2500).Update 3: We postpone the round 10 minutes by technical reasons (dinner on Petrozavodsk Training Camp), sorry for the inconvenience.Update 4: We've increased the contest time by 5 minutes.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: Editorial.Winners:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA Sadly no one solved E correctly. Egor's solution can pass if the TL is 7 seconds instead of 6, what a pity!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel They are the only people who solved all tasks!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1587
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 388\\s*E"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Fraction {\n    long long num, den;\n    Fraction(long long n, long long d) {\n        // Normalize fraction to ensure den > 0\n        if (d < 0) {\n            n = -n;\n            d = -d;\n        }\n        long long g = gcd(abs(n), d);\n        num = n / g;\n        den = d / g;\n    }\n    bool operator<(const Fraction &other) const {\n        return num * other.den < other.num * den;\n    }\n    bool operator==(const Fraction &other) const {\n        return num == other.num && den == other.den;\n    }\n};\n\nlong long gcd(long long a, long long b) {\n    return b == 0 ? llabs(a) : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    const int MIN_N = 1, MAX_N = 1000;\n    const long long MIN_VAL = -1000000, MAX_VAL = 1000000;\n    \n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readEoln();\n    \n    // To store the unique trajectories\n    set<tuple<Fraction, Fraction, Fraction, Fraction>> meteorSet;\n    \n    for (int i = 0; i < n; i++) {\n        long long t1 = inf.readLong(MIN_VAL, MAX_VAL, \"t1\");\n        inf.readSpace();\n        long long x1 = inf.readLong(MIN_VAL, MAX_VAL, \"x1\");\n        inf.readSpace();\n        long long y1 = inf.readLong(MIN_VAL, MAX_VAL, \"y1\");\n        inf.readSpace();\n        long long t2 = inf.readLong(MIN_VAL, MAX_VAL, \"t2\");\n        inf.readSpace();\n        long long x2 = inf.readLong(MIN_VAL, MAX_VAL, \"x2\");\n        inf.readSpace();\n        long long y2 = inf.readLong(MIN_VAL, MAX_VAL, \"y2\");\n        inf.readEoln();\n        \n        ensuref(t1 != t2, \"t1 (%lld) should not be equal to t2 (%lld)\", t1, t2);\n        \n        // Compute velocities and constants\n        long long delta_t = t2 - t1;\n        long long delta_x = x2 - x1;\n        long long delta_y = y2 - y1;\n        \n        Fraction v_x(delta_x, delta_t);\n        Fraction v_y(delta_y, delta_t);\n        \n        // Compute c_x and c_y\n        long long c_x_num = x1 * v_x.den - v_x.num * t1;\n        long long c_x_den = v_x.den;\n        Fraction c_x(c_x_num, c_x_den);\n        \n        long long c_y_num = y1 * v_y.den - v_y.num * t1;\n        long long c_y_den = v_y.den;\n        Fraction c_y(c_y_num, c_y_den);\n        \n        auto key = make_tuple(v_x, c_x, v_y, c_y);\n        ensuref(meteorSet.find(key) == meteorSet.end(), \"Two meteors have identical paths\");\n        meteorSet.insert(key);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Fraction {\n    long long num, den;\n    Fraction(long long n, long long d) {\n        // Normalize fraction to ensure den > 0\n        if (d < 0) {\n            n = -n;\n            d = -d;\n        }\n        long long g = gcd(abs(n), d);\n        num = n / g;\n        den = d / g;\n    }\n    bool operator<(const Fraction &other) const {\n        return num * other.den < other.num * den;\n    }\n    bool operator==(const Fraction &other) const {\n        return num == other.num && den == other.den;\n    }\n};\n\nlong long gcd(long long a, long long b) {\n    return b == 0 ? llabs(a) : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    const int MIN_N = 1, MAX_N = 1000;\n    const long long MIN_VAL = -1000000, MAX_VAL = 1000000;\n    \n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readEoln();\n    \n    // To store the unique trajectories\n    set<tuple<Fraction, Fraction, Fraction, Fraction>> meteorSet;\n    \n    for (int i = 0; i < n; i++) {\n        long long t1 = inf.readLong(MIN_VAL, MAX_VAL, \"t1\");\n        inf.readSpace();\n        long long x1 = inf.readLong(MIN_VAL, MAX_VAL, \"x1\");\n        inf.readSpace();\n        long long y1 = inf.readLong(MIN_VAL, MAX_VAL, \"y1\");\n        inf.readSpace();\n        long long t2 = inf.readLong(MIN_VAL, MAX_VAL, \"t2\");\n        inf.readSpace();\n        long long x2 = inf.readLong(MIN_VAL, MAX_VAL, \"x2\");\n        inf.readSpace();\n        long long y2 = inf.readLong(MIN_VAL, MAX_VAL, \"y2\");\n        inf.readEoln();\n        \n        ensuref(t1 != t2, \"t1 (%lld) should not be equal to t2 (%lld)\", t1, t2);\n        \n        // Compute velocities and constants\n        long long delta_t = t2 - t1;\n        long long delta_x = x2 - x1;\n        long long delta_y = y2 - y1;\n        \n        Fraction v_x(delta_x, delta_t);\n        Fraction v_y(delta_y, delta_t);\n        \n        // Compute c_x and c_y\n        long long c_x_num = x1 * v_x.den - v_x.num * t1;\n        long long c_x_den = v_x.den;\n        Fraction c_x(c_x_num, c_x_den);\n        \n        long long c_y_num = y1 * v_y.den - v_y.num * t1;\n        long long c_y_den = v_y.den;\n        Fraction c_y(c_y_num, c_y_den);\n        \n        auto key = make_tuple(v_x, c_x, v_y, c_y);\n        ensuref(meteorSet.find(key) == meteorSet.end(), \"Two meteors have identical paths\");\n        meteorSet.insert(key);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Fraction {\n    long long num, den;\n    Fraction(long long n, long long d) {\n        // Normalize fraction to ensure den > 0\n        if (d < 0) {\n            n = -n;\n            d = -d;\n        }\n        long long g = gcd(abs(n), d);\n        num = n / g;\n        den = d / g;\n    }\n    bool operator<(const Fraction &other) const {\n        return num * other.den < other.num * den;\n    }\n    bool operator==(const Fraction &other) const {\n        return num == other.num && den == other.den;\n    }\n};\n\nlong long gcd(long long a, long long b) {\n    return b == 0 ? llabs(a) : gcd(b, a % b);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    const int MIN_N = 1, MAX_N = 1000;\n    const long long MIN_VAL = -1000000, MAX_VAL = 1000000;\n    \n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readEoln();\n    \n    // To store the unique trajectories\n    set<tuple<Fraction, Fraction, Fraction, Fraction>> meteorSet;\n    \n    for (int i = 0; i < n; i++) {\n        long long t1 = inf.readLong(MIN_VAL, MAX_VAL, \"t1\");\n        inf.readSpace();\n        long long x1 = inf.readLong(MIN_VAL, MAX_VAL, \"x1\");\n        inf.readSpace();\n        long long y1 = inf.readLong(MIN_VAL, MAX_VAL, \"y1\");\n        inf.readSpace();\n        long long t2 = inf.readLong(MIN_VAL, MAX_VAL, \"t2\");\n        inf.readSpace();\n        long long x2 = inf.readLong(MIN_VAL, MAX_VAL, \"x2\");\n        inf.readSpace();\n        long long y2 = inf.readLong(MIN_VAL, MAX_VAL, \"y2\");\n        inf.readEoln();\n        \n        ensuref(t1 != t2, \"t1 (%lld) should not be equal to t2 (%lld)\", t1, t2);\n        \n        // Compute velocities and constants\n        long long delta_t = t2 - t1;\n        long long delta_x = x2 - x1;\n        long long delta_y = y2 - y1;\n        \n        Fraction v_x(delta_x, delta_t);\n        Fraction v_y(delta_y, delta_t);\n        \n        // Compute c_x and c_y\n        long long c_x_num = x1 * v_x.den - v_x.num * t1;\n        long long c_x_den = v_x.den;\n        Fraction c_x(c_x_num, c_x_den);\n        \n        long long c_y_num = y1 * v_y.den - v_y.num * t1;\n        long long c_y_den = v_y.den;\n        Fraction c_y(c_y_num, c_y_den);\n        \n        auto key = make_tuple(v_x, c_x, v_y, c_y);\n        ensuref(meteorSet.find(key) == meteorSet.end(), \"Two meteors have identical paths\");\n        meteorSet.insert(key);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator produces test data for the \"meteor meeting\" problem.\n\n   We provide several \"type\" modes to generate various patterns of data:\n   1) random    -- Completely random (t1, x1, y1, t2, x2, y2) in [-1e6, 1e6].\n   2) small     -- Same as random, but in a smaller coordinate range [-10, 10].\n   3) zero_vel  -- All meteors have zero velocity (i.e., x1=x2, y1=y2), but\n                   distinct positions so that no two orbits are identical.\n\n   We must ensure:\n   - 1 <= n <= 1000\n   - t1 != t2\n   - -1e6 <= t1,x1,y1,t2,x2,y2 <= 1e6\n   - No two meteors have the exact same parametric line for all time\n     (i.e., \"no two meteors are always in the same position\").\n   - We do NOT set the random seed, and do not accept it as a parameter.\n   - We do not redirect output in this code; it just prints the test case.\n*/\n\nstatic long long gcd2(long long a, long long b) {\n    return b == 0 ? llabs(a) : gcd2(b, a % b);\n}\n\nstatic long long gcd3(long long a, long long b, long long c) {\n    return gcd2(gcd2(a, b), c);\n}\n\n// A structure to hold the meteor's parameters (t1, x1, y1, t2, x2, y2)\nstruct Meteor {\n    long long t1, x1, y1, t2, x2, y2;\n};\n\n// Convert a Meteor into its canonical form for checking\n// if two meteors are always at the same position (same orbit).\n// \n// The meteor satisfies:\n//    at time t1: position (x1, y1)\n//    at time t2: position (x2, y2)\n// velocity = ((x2 - x1)/(t2 - t1), (y2 - y1)/(t2 - t1))\n// offset   = ( x1 - velocity_x * t1 , y1 - velocity_y * t1 ) \n//\n// We store the velocity and offset as integer ratios in a canonical form.\nstatic tuple<long long, long long, long long, long long, long long>\ncanonicalForm(const Meteor &m) {\n    // velocity_x = (x2 - x1), velocity_y = (y2 - y1), velocity_t = (t2 - t1)\n    long long vx = m.x2 - m.x1;\n    long long vy = m.y2 - m.y1;\n    long long vt = m.t2 - m.t1; // guaranteed != 0\n\n    // offset_x = x1 * vt - vx * t1\n    // offset_y = y1 * vt - vy * t1\n    // The position at any real time t is:\n    //    x(t) = x1 + vx/(vt) * (t - t1)\n    // => x(t) = ( x1*vt - vx*t1 ) / vt + (vx / vt)* t\n    // So offset_x = (x1*vt - vx*t1)\n    // Similarly offset_y = (y1*vt - vy*t1)\n    long long ox = m.x1 * vt - vx * m.t1;\n    long long oy = m.y1 * vt - vy * m.t1;\n\n    // 1) Reduce (vx, vy, vt) by gcd\n    long long g1 = gcd3(vx, vy, vt);\n    if (g1 != 0) {\n        vx /= g1;\n        vy /= g1;\n        vt /= g1;\n    }\n    // Make vt positive if possible (to fix the sign in the canonical form)\n    // If vt is 0, we must have t1==t2 which is not allowed, so vt won't be zero.\n    if (vt < 0) {\n        vx = -vx;\n        vy = -vy;\n        vt = -vt;\n    }\n\n    // 2) Now reduce offset with vt:\n    // offset uses the same denominator vt, so we do gcd with vt as well\n    long long g2 = gcd3(ox, oy, vt);\n    if (g2 != 0) {\n        ox /= g2;\n        oy /= g2;\n        // no need to divide vt again, because vt is used for sign reference\n        // but we do keep the ratio consistent. However, to avoid double\n        // division of vt, standard approach is just to treat vt as part\n        // of velocity only. So let's keep vt as is after step 1. \n    }\n\n    // Finally, to unify sign, if vt < 0 we already flipped.\n    // We won't flip offset separately because that would\n    // break the velocity sign. It's consistent now.\n\n    // Return a 5-tuple: (vx, vy, vt, ox, oy)\n    // That is enough to check \"same orbit\".\n    return make_tuple(vx, vy, vt, ox, oy);\n}\n\n// Check if two meteors have the exact same orbit\nstatic bool sameOrbit(const Meteor &a, const Meteor &b) {\n    return canonicalForm(a) == canonicalForm(b);\n}\n\n// Generate a random in [L, R]\nstatic long long randInRange(long long L, long long R) {\n    return rnd.next((long long)R - L + 1) + L; \n}\n\n// Generate one random meteor in the range [-rangeVal, rangeVal], ensuring t1 != t2\nMeteor genRandomMeteor(long long rangeVal) {\n    Meteor m;\n    // Generate t1, t2 distinct\n    while (true) {\n        m.t1 = randInRange(-rangeVal, rangeVal);\n        m.t2 = randInRange(-rangeVal, rangeVal);\n        if (m.t1 != m.t2) break;\n    }\n    m.x1 = randInRange(-rangeVal, rangeVal);\n    m.y1 = randInRange(-rangeVal, rangeVal);\n    m.x2 = randInRange(-rangeVal, rangeVal);\n    m.y2 = randInRange(-rangeVal, rangeVal);\n    return m;\n}\n\n// Generate one zero-velocity meteor in the range [-rangeVal, rangeVal]\nMeteor genZeroVelMeteor(long long rangeVal) {\n    Meteor m;\n    // t1 != t2\n    while (true) {\n        m.t1 = randInRange(-rangeVal, rangeVal);\n        m.t2 = randInRange(-rangeVal, rangeVal);\n        if (m.t1 != m.t2) break;\n    }\n    // x1=x2, y1=y2\n    m.x1 = randInRange(-rangeVal, rangeVal);\n    m.y1 = randInRange(-rangeVal, rangeVal);\n    m.x2 = m.x1;\n    m.y2 = m.y1;\n    return m;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll store the meteors here\n    vector<Meteor> meteors;\n    meteors.reserve(n);\n\n    // Generate n distinct orbits\n    // We'll do a simple loop, re-generate if we find duplicates.\n    while ((int)meteors.size() < n) {\n        Meteor cand;\n        if (type == \"random\") {\n            cand = genRandomMeteor(1000000LL); // full range [-1e6, 1e6]\n        } \n        else if (type == \"small\") {\n            cand = genRandomMeteor(10LL);      // small range [-10, 10]\n        }\n        else if (type == \"zero_vel\") {\n            cand = genZeroVelMeteor(100LL);    // smaller range for zero velocity\n        }\n        else {\n            // default fallback: same as random\n            cand = genRandomMeteor(1000000LL);\n        }\n\n        // Check for duplicate orbit\n        bool duplicate = false;\n        for (auto &m : meteors) {\n            if (sameOrbit(m, cand)) {\n                duplicate = true;\n                break;\n            }\n        }\n        if (!duplicate) {\n            meteors.push_back(cand);\n        }\n        // else skip and regenerate\n    }\n\n    // Output\n    // First line: n\n    // Next n lines: t1, x1, y1, t2, x2, y2\n    cout << n << \"\\n\";\n    for (auto &m : meteors) {\n        cout << m.t1 << \" \" << m.x1 << \" \" << m.y1 << \" \"\n             << m.t2 << \" \" << m.x2 << \" \" << m.y2 << \"\\n\";\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator produces test data for the \"meteor meeting\" problem.\n\n   We provide several \"type\" modes to generate various patterns of data:\n   1) random    -- Completely random (t1, x1, y1, t2, x2, y2) in [-1e6, 1e6].\n   2) small     -- Same as random, but in a smaller coordinate range [-10, 10].\n   3) zero_vel  -- All meteors have zero velocity (i.e., x1=x2, y1=y2), but\n                   distinct positions so that no two orbits are identical.\n\n   We must ensure:\n   - 1 <= n <= 1000\n   - t1 != t2\n   - -1e6 <= t1,x1,y1,t2,x2,y2 <= 1e6\n   - No two meteors have the exact same parametric line for all time\n     (i.e., \"no two meteors are always in the same position\").\n   - We do NOT set the random seed, and do not accept it as a parameter.\n   - We do not redirect output in this code; it just prints the test case.\n*/\n\nstatic long long gcd2(long long a, long long b) {\n    return b == 0 ? llabs(a) : gcd2(b, a % b);\n}\n\nstatic long long gcd3(long long a, long long b, long long c) {\n    return gcd2(gcd2(a, b), c);\n}\n\n// A structure to hold the meteor's parameters (t1, x1, y1, t2, x2, y2)\nstruct Meteor {\n    long long t1, x1, y1, t2, x2, y2;\n};\n\n// Convert a Meteor into its canonical form for checking\n// if two meteors are always at the same position (same orbit).\n// \n// The meteor satisfies:\n//    at time t1: position (x1, y1)\n//    at time t2: position (x2, y2)\n// velocity = ((x2 - x1)/(t2 - t1), (y2 - y1)/(t2 - t1))\n// offset   = ( x1 - velocity_x * t1 , y1 - velocity_y * t1 ) \n//\n// We store the velocity and offset as integer ratios in a canonical form.\nstatic tuple<long long, long long, long long, long long, long long>\ncanonicalForm(const Meteor &m) {\n    // velocity_x = (x2 - x1), velocity_y = (y2 - y1), velocity_t = (t2 - t1)\n    long long vx = m.x2 - m.x1;\n    long long vy = m.y2 - m.y1;\n    long long vt = m.t2 - m.t1; // guaranteed != 0\n\n    // offset_x = x1 * vt - vx * t1\n    // offset_y = y1 * vt - vy * t1\n    // The position at any real time t is:\n    //    x(t) = x1 + vx/(vt) * (t - t1)\n    // => x(t) = ( x1*vt - vx*t1 ) / vt + (vx / vt)* t\n    // So offset_x = (x1*vt - vx*t1)\n    // Similarly offset_y = (y1*vt - vy*t1)\n    long long ox = m.x1 * vt - vx * m.t1;\n    long long oy = m.y1 * vt - vy * m.t1;\n\n    // 1) Reduce (vx, vy, vt) by gcd\n    long long g1 = gcd3(vx, vy, vt);\n    if (g1 != 0) {\n        vx /= g1;\n        vy /= g1;\n        vt /= g1;\n    }\n    // Make vt positive if possible (to fix the sign in the canonical form)\n    // If vt is 0, we must have t1==t2 which is not allowed, so vt won't be zero.\n    if (vt < 0) {\n        vx = -vx;\n        vy = -vy;\n        vt = -vt;\n    }\n\n    // 2) Now reduce offset with vt:\n    // offset uses the same denominator vt, so we do gcd with vt as well\n    long long g2 = gcd3(ox, oy, vt);\n    if (g2 != 0) {\n        ox /= g2;\n        oy /= g2;\n        // no need to divide vt again, because vt is used for sign reference\n        // but we do keep the ratio consistent. However, to avoid double\n        // division of vt, standard approach is just to treat vt as part\n        // of velocity only. So let's keep vt as is after step 1. \n    }\n\n    // Finally, to unify sign, if vt < 0 we already flipped.\n    // We won't flip offset separately because that would\n    // break the velocity sign. It's consistent now.\n\n    // Return a 5-tuple: (vx, vy, vt, ox, oy)\n    // That is enough to check \"same orbit\".\n    return make_tuple(vx, vy, vt, ox, oy);\n}\n\n// Check if two meteors have the exact same orbit\nstatic bool sameOrbit(const Meteor &a, const Meteor &b) {\n    return canonicalForm(a) == canonicalForm(b);\n}\n\n// Generate a random in [L, R]\nstatic long long randInRange(long long L, long long R) {\n    return rnd.next((long long)R - L + 1) + L; \n}\n\n// Generate one random meteor in the range [-rangeVal, rangeVal], ensuring t1 != t2\nMeteor genRandomMeteor(long long rangeVal) {\n    Meteor m;\n    // Generate t1, t2 distinct\n    while (true) {\n        m.t1 = randInRange(-rangeVal, rangeVal);\n        m.t2 = randInRange(-rangeVal, rangeVal);\n        if (m.t1 != m.t2) break;\n    }\n    m.x1 = randInRange(-rangeVal, rangeVal);\n    m.y1 = randInRange(-rangeVal, rangeVal);\n    m.x2 = randInRange(-rangeVal, rangeVal);\n    m.y2 = randInRange(-rangeVal, rangeVal);\n    return m;\n}\n\n// Generate one zero-velocity meteor in the range [-rangeVal, rangeVal]\nMeteor genZeroVelMeteor(long long rangeVal) {\n    Meteor m;\n    // t1 != t2\n    while (true) {\n        m.t1 = randInRange(-rangeVal, rangeVal);\n        m.t2 = randInRange(-rangeVal, rangeVal);\n        if (m.t1 != m.t2) break;\n    }\n    // x1=x2, y1=y2\n    m.x1 = randInRange(-rangeVal, rangeVal);\n    m.y1 = randInRange(-rangeVal, rangeVal);\n    m.x2 = m.x1;\n    m.y2 = m.y1;\n    return m;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll store the meteors here\n    vector<Meteor> meteors;\n    meteors.reserve(n);\n\n    // Generate n distinct orbits\n    // We'll do a simple loop, re-generate if we find duplicates.\n    while ((int)meteors.size() < n) {\n        Meteor cand;\n        if (type == \"random\") {\n            cand = genRandomMeteor(1000000LL); // full range [-1e6, 1e6]\n        } \n        else if (type == \"small\") {\n            cand = genRandomMeteor(10LL);      // small range [-10, 10]\n        }\n        else if (type == \"zero_vel\") {\n            cand = genZeroVelMeteor(100LL);    // smaller range for zero velocity\n        }\n        else {\n            // default fallback: same as random\n            cand = genRandomMeteor(1000000LL);\n        }\n\n        // Check for duplicate orbit\n        bool duplicate = false;\n        for (auto &m : meteors) {\n            if (sameOrbit(m, cand)) {\n                duplicate = true;\n                break;\n            }\n        }\n        if (!duplicate) {\n            meteors.push_back(cand);\n        }\n        // else skip and regenerate\n    }\n\n    // Output\n    // First line: n\n    // Next n lines: t1, x1, y1, t2, x2, y2\n    cout << n << \"\\n\";\n    for (auto &m : meteors) {\n        cout << m.t1 << \" \" << m.x1 << \" \" << m.y1 << \" \"\n             << m.t2 << \" \" << m.x2 << \" \" << m.y2 << \"\\n\";\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are 20 distinct example commands to run this generator.\n# Each command produces one test case on the standard output.\n\n# 1) Single meteor, random\n./gen -n 1 -type random\n\n# 2) Two meteors, random\n./gen -n 2 -type random\n\n# 3) Three meteors, random\n./gen -n 3 -type random\n\n# 4) Five meteors, random\n./gen -n 5 -type random\n\n# 5) Ten meteors, random\n./gen -n 10 -type random\n\n# 6) Ten meteors, small\n./gen -n 10 -type small\n\n# 7) Ten meteors, zero velocity\n./gen -n 10 -type zero_vel\n\n# 8) Fifty meteors, small\n./gen -n 50 -type small\n\n# 9) Fifty meteors, zero velocity\n./gen -n 50 -type zero_vel\n\n# 10) Fifty meteors, random\n./gen -n 50 -type random\n\n# 11) One hundred meteors, random\n./gen -n 100 -type random\n\n# 12) One hundred meteors, small\n./gen -n 100 -type small\n\n# 13) One hundred meteors, zero velocity\n./gen -n 100 -type zero_vel\n\n# 14) Two hundred meteors, random\n./gen -n 200 -type random\n\n# 15) Three hundred meteors, small\n./gen -n 300 -type small\n\n# 16) Three hundred meteors, zero velocity\n./gen -n 300 -type zero_vel\n\n# 17) Five hundred meteors, random\n./gen -n 500 -type random\n\n# 18) Seven hundred meteors, random\n./gen -n 700 -type random\n\n# 19) Nine hundred meteors, zero velocity\n./gen -n 900 -type zero_vel\n\n# 20) One thousand meteors, random\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:48.644150",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "389/A",
      "title": "A. Лиса и игра с числами",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 100). Затем во второй строке записано n целых чисел: x1, x2, ..., xn (1 ≤ xi ≤ 100).",
      "output_spec": "Выходные данныеВыведите единственное целое число — требуемую минимальную сумму.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопировать2Входные данныеСкопировать32 4 6Выходные данныеСкопировать6Входные данныеСкопировать212 18Выходные данныеСкопировать12Входные данныеСкопировать545 12 27 30 18Выходные данныеСкопировать15",
      "description": "A. Лиса и игра с числами\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 100). Затем во второй строке записано n целых чисел: x1, x2, ..., xn (1 ≤ xi ≤ 100).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — требуемую минимальную сумму.\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопировать2Входные данныеСкопировать32 4 6Выходные данныеСкопировать6Входные данныеСкопировать212 18Выходные данныеСкопировать12Входные данныеСкопировать545 12 27 30 18Выходные данныеСкопировать15\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать32 4 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать212 18\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать545 12 27 30 18\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать15\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оптимальный способ — выполнить присвоение: x2 = x2 - x1.Во втором примере оптимальная последовательность операций такая: x3 = x3 - x2, x2 = x2 - x1.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Привет всем!В понедельник третьего февраля 2014 года в 19:30 по московскому времени состоится Codeforces Round #228 (Div1 + Div2).Этой мой второй раунд на Codeforces (кликните сюда, чтобы посмотреть предыдущий). Как обычно, в раунде будет семь задач: две — только для Div2, две — только для Div1 и три общие задачи. Точно так же, как и в прошлый раз, главным героем задач раунда будет лиса Ciel.Благодарю Gerald за тестирование задач и MikeMirzayanov за проект Codeforces и систему Polygon.Желаю удачи и фана от решения задач!Распределение баллов будет анонсировано позже. А разбор задач будет опубликован сразу после системного тестирования.Кроме всего прочего, вчера в Китае отмечали новый год. Поздравляю всех, кто отмечал этот праздник! И, конечно, я очень рад, что именно я автор первого контеста в новом году.Update1: Приятная новость для участников Петрозаводских сборов. Top 20 участников сборов по итогам этого раунда, которые придут на закрытие, получат футболки от Codeforces.Update 2: Распределение баллов по задачам стандартное. (500-1000-1500-2000-2500).Update 3: Приносим извинения, раунд перенесен на 10 минут по техническим причинам.Update 4: Продолжительность соревнования увеличена на 5 минут.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: разбор.Победители:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA К сожалению, никто не решил задачу Е. Решение Egor-a могло пройти тестирование, если бы TL был бы равен 7 секундам, вместо 6. Какая жалость!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel Только они решили все предложенные задачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1632
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 389\\s*A"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 100, \"x_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 100, \"x_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 100, \"x_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"equal\") {\n        // All numbers are equal\n        int x = rnd.next(1, 100);\n        for (int i = 0; i < n; i++)\n            a[i] = x;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"gcd1\") {\n        // Generate numbers with GCD 1\n        a[0] = 1;\n        for (int i = 1; i < n; i++) {\n            a[i] = rnd.next(2, 100);\n        }\n    } else if (type == \"smallgcd\") {\n        // Generate numbers with GCD = 2 or 3\n        int gcd_options[] = {2, 3};\n        int gcd = gcd_options[rnd.next(0, 1)];\n        for (int i = 0; i < n; i++)\n            a[i] = gcd * rnd.next(1, 100 / gcd);\n    } else if (type == \"largegcd\") {\n        // Generate numbers with GCD between 50 and 100\n        int gcd = rnd.next(50, 100);\n        int max_k = 100 / gcd;\n        for (int i = 0; i < n; i++)\n            a[i] = gcd * rnd.next(1, max_k);\n    } else if (type == \"mixgcd\") {\n        // Generate numbers where GCD of n-1 numbers is gcd, but overall GCD is 1\n        int gcd = rnd.next(2, 10);\n        int co_prime = gcd + 1;\n        a[0] = co_prime;\n        for (int i = 1; i < n; i++) {\n            a[i] = gcd * rnd.next(1, 100 / gcd);\n        }\n    } else if (type == \"alternatenums\") {\n        int x = rnd.next(1, 100);\n        int y = rnd.next(1, 100);\n        while (y == x) {\n            y = rnd.next(1, 100);\n        }\n        for (int i = 0; i < n; i++)\n            a[i] = (i % 2 == 0) ? x : y;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 100);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the numbers\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i < n -1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"equal\") {\n        // All numbers are equal\n        int x = rnd.next(1, 100);\n        for (int i = 0; i < n; i++)\n            a[i] = x;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"gcd1\") {\n        // Generate numbers with GCD 1\n        a[0] = 1;\n        for (int i = 1; i < n; i++) {\n            a[i] = rnd.next(2, 100);\n        }\n    } else if (type == \"smallgcd\") {\n        // Generate numbers with GCD = 2 or 3\n        int gcd_options[] = {2, 3};\n        int gcd = gcd_options[rnd.next(0, 1)];\n        for (int i = 0; i < n; i++)\n            a[i] = gcd * rnd.next(1, 100 / gcd);\n    } else if (type == \"largegcd\") {\n        // Generate numbers with GCD between 50 and 100\n        int gcd = rnd.next(50, 100);\n        int max_k = 100 / gcd;\n        for (int i = 0; i < n; i++)\n            a[i] = gcd * rnd.next(1, max_k);\n    } else if (type == \"mixgcd\") {\n        // Generate numbers where GCD of n-1 numbers is gcd, but overall GCD is 1\n        int gcd = rnd.next(2, 10);\n        int co_prime = gcd + 1;\n        a[0] = co_prime;\n        for (int i = 1; i < n; i++) {\n            a[i] = gcd * rnd.next(1, 100 / gcd);\n        }\n    } else if (type == \"alternatenums\") {\n        int x = rnd.next(1, 100);\n        int y = rnd.next(1, 100);\n        while (y == x) {\n            y = rnd.next(1, 100);\n        }\n        for (int i = 0; i < n; i++)\n            a[i] = (i % 2 == 0) ? x : y;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 100);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the numbers\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i < n -1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type equal\n./gen -n 2 -type gcd1\n./gen -n 2 -type smallgcd\n./gen -n 2 -type largegcd\n./gen -n 2 -type mixgcd\n./gen -n 2 -type alternatenums\n\n./gen -n 10 -type random\n./gen -n 10 -type equal\n./gen -n 10 -type gcd1\n./gen -n 10 -type smallgcd\n./gen -n 10 -type largegcd\n./gen -n 10 -type mixgcd\n./gen -n 10 -type alternatenums\n\n./gen -n 20 -type random\n./gen -n 20 -type equal\n./gen -n 20 -type gcd1\n./gen -n 20 -type smallgcd\n./gen -n 20 -type largegcd\n./gen -n 20 -type mixgcd\n./gen -n 20 -type alternatenums\n\n./gen -n 50 -type random\n./gen -n 50 -type equal\n./gen -n 50 -type gcd1\n./gen -n 50 -type smallgcd\n./gen -n 50 -type largegcd\n./gen -n 50 -type mixgcd\n./gen -n 50 -type alternatenums\n\n./gen -n 75 -type random\n./gen -n 75 -type equal\n./gen -n 75 -type gcd1\n./gen -n 75 -type smallgcd\n./gen -n 75 -type largegcd\n./gen -n 75 -type mixgcd\n./gen -n 75 -type alternatenums\n\n./gen -n 100 -type random\n./gen -n 100 -type equal\n./gen -n 100 -type gcd1\n./gen -n 100 -type smallgcd\n./gen -n 100 -type largegcd\n./gen -n 100 -type mixgcd\n./gen -n 100 -type alternatenums\n\n# Edge cases with minimal n\n./gen -n 2 -type random\n./gen -n 2 -type equal\n./gen -n 2 -type gcd1\n\n# Edge cases with maximal n\n./gen -n 100 -type random\n./gen -n 100 -type equal\n./gen -n 100 -type gcd1\n./gen -n 100 -type smallgcd\n./gen -n 100 -type largegcd\n./gen -n 100 -type mixgcd\n./gen -n 100 -type alternatenums\n\n# Additional test cases with varying n\n./gen -n 15 -type smallgcd\n./gen -n 25 -type mixgcd\n./gen -n 35 -type gcd1\n./gen -n 45 -type alternatenums\n./gen -n 55 -type random\n./gen -n 65 -type equal\n./gen -n 85 -type largegcd\n./gen -n 95 -type smallgcd\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:50.874382",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "389/B",
      "title": "B. Fox and Cross",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (3 ≤ n ≤ 100) — the size of the board.Each of the next n lines describes one row of the board. The i-th line describes the i-th row of the board and consists of n characters. Each character is either a symbol '.', or a symbol '#'.",
      "output_spec": "OutputOutput a single line with \"YES\" if Ciel can draw the crosses in the described way. Otherwise output a single line with \"NO\".",
      "sample_tests": "ExamplesInputCopy5.#...####..####...#......OutputCopyYESInputCopy4################OutputCopyNOInputCopy6.#....####...####..#.##.######.#..#.OutputCopyYESInputCopy6.#..#.######.####..####.######.#..#.OutputCopyNOInputCopy3.........OutputCopyYES",
      "description": "B. Fox and Cross\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (3 ≤ n ≤ 100) — the size of the board.Each of the next n lines describes one row of the board. The i-th line describes the i-th row of the board and consists of n characters. Each character is either a symbol '.', or a symbol '#'.\n\nOutputOutput a single line with \"YES\" if Ciel can draw the crosses in the described way. Otherwise output a single line with \"NO\".\n\nInputCopy5.#...####..####...#......OutputCopyYESInputCopy4################OutputCopyNOInputCopy6.#....####...####..#.##.######.#..#.OutputCopyYESInputCopy6.#..#.######.####..####.######.#..#.OutputCopyNOInputCopy3.........OutputCopyYES\n\nInputCopy5.#...####..####...#......\n\nOutputCopyYES\n\nInputCopy4################\n\nOutputCopyNO\n\nInputCopy6.#....####...####..#.##.######.#..#.\n\nOutputCopyYES\n\nInputCopy6.#..#.######.####..####.######.#..#.\n\nOutputCopyNO\n\nInputCopy3.........\n\nOutputCopyYES\n\nNoteIn example 1, you can draw two crosses. The picture below shows what they look like.In example 2, the board contains 16 cells with '#', but each cross contains 5. Since 16 is not a multiple of 5, so it's impossible to cover all.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Hello everyone!Codeforces Round #228 (Div. 1 and Div.2) will start at Monday, 3 February 2014, 19:30:00 MSK.This is my 2nd round on Codeforces. (Click here to see my last round) , As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. And same with the last round, the main character of all problem will be Fox Ciel.I would like to thank Gerald for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!The score distribution will be published later. And the editorial will be published right after the system test.By the way, yesterday is the Chinese new year. So I'd like to say Happy New Year to everyone who celebrate it! And I'm very glad to be the writer of the first round in the new year.Update1: Good news for participants of Petrozavodsk training camp. Top 20 participants of the camp by this round results will get t-shirts from Codeforces.Update 2: The score distribution for Both Division is regular (500-1000-1500-2000-2500).Update 3: We postpone the round 10 minutes by technical reasons (dinner on Petrozavodsk Training Camp), sorry for the inconvenience.Update 4: We've increased the contest time by 5 minutes.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: Editorial.Winners:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA Sadly no one solved E correctly. Egor's solution can pass if the TL is 7 seconds instead of 6, what a pity!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel They are the only people who solved all tasks!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1587
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 389\\s*B"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[.#]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"grid_row\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[.#]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"grid_row\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[.#]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"grid_row\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"empty\") {\n        // The grid is already initialized to '.'\n    }\n    else if (type == \"full\") {\n        for(int i = 0; i < n; ++i)\n            grid[i] = string(n, '#');\n    }\n    else if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // Default density\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if (rnd.next(0.0, 1.0) < density)\n                    grid[i][j] = '#';\n            }\n        }\n    }\n    else if (type == \"possible\") {\n        // Place crosses without overlaps\n        for(int i = 1; i < n - 1; i += 3) {\n            for(int j = 1; j < n - 1; j +=3) {\n                grid[i][j] = '#';\n                grid[i-1][j] = '#';\n                grid[i+1][j] = '#';\n                grid[i][j-1] = '#';\n                grid[i][j+1] = '#';\n            }\n        }\n    }\n    else if (type == \"impossible\") {\n        // Total '#' cells is multiple of 5, but can't form crosses\n        int max_hashes = (n * n) / 5 * 5; // Largest multiple of 5 less than n*n\n        int total_hashes = rnd.next(1, max_hashes / 5) * 5;\n        int placed_hashes = 0;\n        while (placed_hashes < total_hashes) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, n-1);\n            if (grid[i][j] == '.') {\n                grid[i][j] = '#';\n                ++placed_hashes;\n            }\n        }\n    }\n    else if (type == \"no_of_hash_not_multiple_of_5\") {\n        // Total '#' cells is not a multiple of 5\n        int total_hashes = rnd.next(1, n*n);\n        while(total_hashes % 5 == 0)\n            total_hashes = rnd.next(1, n*n);\n        int placed_hashes = 0;\n        while (placed_hashes < total_hashes) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, n-1);\n            if (grid[i][j] == '.') {\n                grid[i][j] = '#';\n                ++placed_hashes;\n            }\n        }\n    }\n    else if (type == \"border\") {\n        // '#' cells only at the borders\n        for(int i = 0; i < n; ++i) {\n            grid[0][i] = '#';\n            grid[n-1][i] = '#';\n            grid[i][0] = '#';\n            grid[i][n-1] = '#';\n        }\n    }\n    else if (type == \"corner_cases\") {\n        // '#' cells only at the corners\n        grid[0][0] = '#';\n        grid[0][n-1] = '#';\n        grid[n-1][0] = '#';\n        grid[n-1][n-1] = '#';\n    }\n    else {\n        // Default to random\n        double density = opt<double>(\"density\", 0.5); // Default density\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if (rnd.next(0.0, 1.0) < density)\n                    grid[i][j] = '#';\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output grid\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"empty\") {\n        // The grid is already initialized to '.'\n    }\n    else if (type == \"full\") {\n        for(int i = 0; i < n; ++i)\n            grid[i] = string(n, '#');\n    }\n    else if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // Default density\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if (rnd.next(0.0, 1.0) < density)\n                    grid[i][j] = '#';\n            }\n        }\n    }\n    else if (type == \"possible\") {\n        // Place crosses without overlaps\n        for(int i = 1; i < n - 1; i += 3) {\n            for(int j = 1; j < n - 1; j +=3) {\n                grid[i][j] = '#';\n                grid[i-1][j] = '#';\n                grid[i+1][j] = '#';\n                grid[i][j-1] = '#';\n                grid[i][j+1] = '#';\n            }\n        }\n    }\n    else if (type == \"impossible\") {\n        // Total '#' cells is multiple of 5, but can't form crosses\n        int max_hashes = (n * n) / 5 * 5; // Largest multiple of 5 less than n*n\n        int total_hashes = rnd.next(1, max_hashes / 5) * 5;\n        int placed_hashes = 0;\n        while (placed_hashes < total_hashes) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, n-1);\n            if (grid[i][j] == '.') {\n                grid[i][j] = '#';\n                ++placed_hashes;\n            }\n        }\n    }\n    else if (type == \"no_of_hash_not_multiple_of_5\") {\n        // Total '#' cells is not a multiple of 5\n        int total_hashes = rnd.next(1, n*n);\n        while(total_hashes % 5 == 0)\n            total_hashes = rnd.next(1, n*n);\n        int placed_hashes = 0;\n        while (placed_hashes < total_hashes) {\n            int i = rnd.next(0, n-1);\n            int j = rnd.next(0, n-1);\n            if (grid[i][j] == '.') {\n                grid[i][j] = '#';\n                ++placed_hashes;\n            }\n        }\n    }\n    else if (type == \"border\") {\n        // '#' cells only at the borders\n        for(int i = 0; i < n; ++i) {\n            grid[0][i] = '#';\n            grid[n-1][i] = '#';\n            grid[i][0] = '#';\n            grid[i][n-1] = '#';\n        }\n    }\n    else if (type == \"corner_cases\") {\n        // '#' cells only at the corners\n        grid[0][0] = '#';\n        grid[0][n-1] = '#';\n        grid[n-1][0] = '#';\n        grid[n-1][n-1] = '#';\n    }\n    else {\n        // Default to random\n        double density = opt<double>(\"density\", 0.5); // Default density\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if (rnd.next(0.0, 1.0) < density)\n                    grid[i][j] = '#';\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output grid\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type empty\n./gen -n 3 -type full\n./gen -n 3 -type random -density 0.5\n./gen -n 3 -type possible\n./gen -n 3 -type impossible\n./gen -n 3 -type no_of_hash_not_multiple_of_5\n./gen -n 3 -type border\n./gen -n 3 -type corner_cases\n\n./gen -n 5 -type empty\n./gen -n 5 -type full\n./gen -n 5 -type random -density 0.7\n./gen -n 5 -type possible\n./gen -n 5 -type impossible\n./gen -n 5 -type no_of_hash_not_multiple_of_5\n./gen -n 5 -type border\n./gen -n 5 -type corner_cases\n\n./gen -n 10 -type empty\n./gen -n 10 -type full\n./gen -n 10 -type random -density 0.3\n./gen -n 10 -type possible\n./gen -n 10 -type impossible\n./gen -n 10 -type no_of_hash_not_multiple_of_5\n./gen -n 10 -type border\n./gen -n 10 -type corner_cases\n\n./gen -n 50 -type random -density 0.5\n./gen -n 50 -type possible\n./gen -n 50 -type impossible\n./gen -n 50 -type no_of_hash_not_multiple_of_5\n./gen -n 50 -type border\n\n./gen -n 75 -type random -density 0.4\n./gen -n 75 -type possible\n./gen -n 75 -type impossible\n\n./gen -n 100 -type random -density 0.6\n./gen -n 100 -type possible\n./gen -n 100 -type impossible\n./gen -n 100 -type no_of_hash_not_multiple_of_5\n./gen -n 100 -type border\n\n./gen -n 100 -type random -density 0.1\n./gen -n 100 -type random -density 0.9\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:52.785417",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "389/C",
      "title": "C. Fox and Box Accumulation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100). The next line contains n integers x1, x2, ..., xn (0 ≤ xi ≤ 100).",
      "output_spec": "OutputOutput a single integer — the minimal possible number of piles.",
      "sample_tests": "ExamplesInputCopy30 0 10OutputCopy2InputCopy50 1 2 3 4OutputCopy1InputCopy40 0 0 0OutputCopy4InputCopy90 1 0 2 0 1 1 2 10OutputCopy3",
      "description": "C. Fox and Box Accumulation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100). The next line contains n integers x1, x2, ..., xn (0 ≤ xi ≤ 100).\n\nOutputOutput a single integer — the minimal possible number of piles.\n\nInputCopy30 0 10OutputCopy2InputCopy50 1 2 3 4OutputCopy1InputCopy40 0 0 0OutputCopy4InputCopy90 1 0 2 0 1 1 2 10OutputCopy3\n\nInputCopy30 0 10\n\nOutputCopy2\n\nInputCopy50 1 2 3 4\n\nOutputCopy1\n\nInputCopy40 0 0 0\n\nOutputCopy4\n\nInputCopy90 1 0 2 0 1 1 2 10\n\nOutputCopy3\n\nNoteIn example 1, one optimal way is to build 2 piles: the first pile contains boxes 1 and 3 (from top to bottom), the second pile contains only box 2.In example 2, we can build only 1 pile that contains boxes 1, 2, 3, 4, 5 (from top to bottom).",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Hello everyone!Codeforces Round #228 (Div. 1 and Div.2) will start at Monday, 3 February 2014, 19:30:00 MSK.This is my 2nd round on Codeforces. (Click here to see my last round) , As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. And same with the last round, the main character of all problem will be Fox Ciel.I would like to thank Gerald for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!The score distribution will be published later. And the editorial will be published right after the system test.By the way, yesterday is the Chinese new year. So I'd like to say Happy New Year to everyone who celebrate it! And I'm very glad to be the writer of the first round in the new year.Update1: Good news for participants of Petrozavodsk training camp. Top 20 participants of the camp by this round results will get t-shirts from Codeforces.Update 2: The score distribution for Both Division is regular (500-1000-1500-2000-2500).Update 3: We postpone the round 10 minutes by technical reasons (dinner on Petrozavodsk Training Camp), sorry for the inconvenience.Update 4: We've increased the contest time by 5 minutes.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: Editorial.Winners:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA Sadly no one solved E correctly. Egor's solution can pass if the TL is 7 seconds instead of 6, what a pity!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel They are the only people who solved all tasks!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1587
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 389\\s*C"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> x = inf.readInts(n, 0, 100, \"xi\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> x = inf.readInts(n, 0, 100, \"xi\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> x = inf.readInts(n, 0, 100, \"xi\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt(\"type\", \"random\");\n    vector<int> xi(n);\n    if (type == \"all_zero\") {\n        /* All xi = 0 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = 0;\n    } else if (type == \"all_max\") {\n        /* All xi = 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = 100;\n    } else if (type == \"random\") {\n        /* Random xi between 0 and 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 100);\n    } else if (type == \"increasing\") {\n        /* xi sorted in increasing order */\n        for (int i = 0; i < n; ++i)\n            xi[i] = i % 101; // Since xi between 0 and 100\n        sort(xi.begin(), xi.end());\n    } else if (type == \"decreasing\") {\n        /* xi sorted in decreasing order */\n        for (int i = 0; i < n; ++i)\n            xi[i] = 100 - (i % 101); // xi between 0 and 100\n        sort(xi.rbegin(), xi.rend());\n    } else if (type == \"alternating\") {\n        /* Alternate between small and large xi values */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i % 2 == 0) ? rnd.next(0, 5) : rnd.next(95, 100);\n    } else if (type == \"large_small\") {\n        /* First half large xi, second half small xi */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i < n/2) ? rnd.next(50, 100) : rnd.next(0, 50);\n    } else if (type == \"small_large\") {\n        /* First half small xi, second half large xi */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i < n/2) ? rnd.next(0, 50) : rnd.next(50, 100);\n    } else if (type == \"max_min\") {\n        /* xi alternates between 0 and 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i % 2 == 0) ? 0 : 100;\n    } else if (type == \"special_zero_half_max_half\") {\n        /* First half xi = 0, second half xi = 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i < n/2) ? 0 : 100;\n    } else if (type == \"special_random_0_1\") {\n        /* xi values randomly 0 or 1 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 1);\n    } else if (type == \"special_random_99_100\") {\n        /* xi values randomly 99 or 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(99, 100);\n    } else {\n        /* Default: random xi */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 100);\n    }\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", xi[i], (i == n-1) ? '\\n' : ' ');\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt(\"type\", \"random\");\n    vector<int> xi(n);\n    if (type == \"all_zero\") {\n        /* All xi = 0 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = 0;\n    } else if (type == \"all_max\") {\n        /* All xi = 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = 100;\n    } else if (type == \"random\") {\n        /* Random xi between 0 and 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 100);\n    } else if (type == \"increasing\") {\n        /* xi sorted in increasing order */\n        for (int i = 0; i < n; ++i)\n            xi[i] = i % 101; // Since xi between 0 and 100\n        sort(xi.begin(), xi.end());\n    } else if (type == \"decreasing\") {\n        /* xi sorted in decreasing order */\n        for (int i = 0; i < n; ++i)\n            xi[i] = 100 - (i % 101); // xi between 0 and 100\n        sort(xi.rbegin(), xi.rend());\n    } else if (type == \"alternating\") {\n        /* Alternate between small and large xi values */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i % 2 == 0) ? rnd.next(0, 5) : rnd.next(95, 100);\n    } else if (type == \"large_small\") {\n        /* First half large xi, second half small xi */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i < n/2) ? rnd.next(50, 100) : rnd.next(0, 50);\n    } else if (type == \"small_large\") {\n        /* First half small xi, second half large xi */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i < n/2) ? rnd.next(0, 50) : rnd.next(50, 100);\n    } else if (type == \"max_min\") {\n        /* xi alternates between 0 and 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i % 2 == 0) ? 0 : 100;\n    } else if (type == \"special_zero_half_max_half\") {\n        /* First half xi = 0, second half xi = 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = (i < n/2) ? 0 : 100;\n    } else if (type == \"special_random_0_1\") {\n        /* xi values randomly 0 or 1 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 1);\n    } else if (type == \"special_random_99_100\") {\n        /* xi values randomly 99 or 100 */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(99, 100);\n    } else {\n        /* Default: random xi */\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 100);\n    }\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", xi[i], (i == n-1) ? '\\n' : ' ');\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_max\n./gen -n 1 -type random\n\n./gen -n 2 -type all_zero\n./gen -n 2 -type all_max\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n\n./gen -n 5 -type all_zero\n./gen -n 5 -type all_max\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type alternating\n./gen -n 5 -type large_small\n./gen -n 5 -type small_large\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_max\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n./gen -n 10 -type large_small\n./gen -n 10 -type small_large\n./gen -n 10 -type max_min\n\n./gen -n 50 -type random\n./gen -n 50 -type increasing\n./gen -n 50 -type decreasing\n./gen -n 50 -type alternating\n\n./gen -n 100 -type all_zero\n./gen -n 100 -type all_max\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n./gen -n 100 -type large_small\n./gen -n 100 -type small_large\n./gen -n 100 -type max_min\n./gen -n 100 -type special_zero_half_max_half\n./gen -n 100 -type special_random_0_1\n./gen -n 100 -type special_random_99_100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:54.926941",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "389/D",
      "title": "D. Fox and Minimal path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer k (1 ≤ k ≤ 109).",
      "output_spec": "OutputYou should output a graph G with n vertexes (2 ≤ n ≤ 1000). There must be exactly k shortest paths between vertex 1 and vertex 2 of the graph.The first line must contain an integer n. Then adjacency matrix G with n rows and n columns must follow. Each element of the matrix must be 'N' or 'Y'. If Gij is 'Y', then graph G has a edge connecting vertex i and vertex j. Consider the graph vertexes are numbered from 1 to n.The graph must be undirected and simple: Gii = 'N' and Gij = Gji must hold. And there must be at least one path between vertex 1 and vertex 2. It's guaranteed that the answer exists. If there multiple correct answers, you can output any of them.",
      "sample_tests": "ExamplesInputCopy2OutputCopy4NNYYNNYYYYNNYYNNInputCopy9OutputCopy8NNYYYNNNNNNNNYYYYNNNNYYYYNNNNYYYYNNNNYYYNYYYYNNNNYYYYNNNNYYYYNNNInputCopy1OutputCopy2NYYN",
      "description": "D. Fox and Minimal path\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer k (1 ≤ k ≤ 109).\n\nOutputYou should output a graph G with n vertexes (2 ≤ n ≤ 1000). There must be exactly k shortest paths between vertex 1 and vertex 2 of the graph.The first line must contain an integer n. Then adjacency matrix G with n rows and n columns must follow. Each element of the matrix must be 'N' or 'Y'. If Gij is 'Y', then graph G has a edge connecting vertex i and vertex j. Consider the graph vertexes are numbered from 1 to n.The graph must be undirected and simple: Gii = 'N' and Gij = Gji must hold. And there must be at least one path between vertex 1 and vertex 2. It's guaranteed that the answer exists. If there multiple correct answers, you can output any of them.\n\nInputCopy2OutputCopy4NNYYNNYYYYNNYYNNInputCopy9OutputCopy8NNYYYNNNNNNNNYYYYNNNNYYYYNNNNYYYYNNNNYYYNYYYYNNNNYYYYNNNNYYYYNNNInputCopy1OutputCopy2NYYN\n\nOutputCopy4NNYYNNYYYYNNYYNN\n\nOutputCopy8NNYYYNNNNNNNNYYYYNNNNYYYYNNNNYYYYNNNNYYYNYYYYNNNNYYYYNNNNYYYYNNN\n\nOutputCopy2NYYN\n\nNoteIn first example, there are 2 shortest paths: 1-3-2 and 1-4-2.In second example, there are 9 shortest paths: 1-3-6-2, 1-3-7-2, 1-3-8-2, 1-4-6-2, 1-4-7-2, 1-4-8-2, 1-5-6-2, 1-5-7-2, 1-5-8-2.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Hello everyone!Codeforces Round #228 (Div. 1 and Div.2) will start at Monday, 3 February 2014, 19:30:00 MSK.This is my 2nd round on Codeforces. (Click here to see my last round) , As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. And same with the last round, the main character of all problem will be Fox Ciel.I would like to thank Gerald for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!The score distribution will be published later. And the editorial will be published right after the system test.By the way, yesterday is the Chinese new year. So I'd like to say Happy New Year to everyone who celebrate it! And I'm very glad to be the writer of the first round in the new year.Update1: Good news for participants of Petrozavodsk training camp. Top 20 participants of the camp by this round results will get t-shirts from Codeforces.Update 2: The score distribution for Both Division is regular (500-1000-1500-2000-2500).Update 3: We postpone the round 10 minutes by technical reasons (dinner on Petrozavodsk Training Camp), sorry for the inconvenience.Update 4: We've increased the contest time by 5 minutes.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: Editorial.Winners:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA Sadly no one solved E correctly. Egor's solution can pass if the TL is 7 seconds instead of 6, what a pity!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel They are the only people who solved all tasks!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1587
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 389\\s*D"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read k from input file\n    int k = inf.readInt(1, 1000000000, \"k\");\n    \n    // Read n from contestant's output\n    int n = ouf.readInt(2, 1000, \"n\");\n    \n    // Read n lines, each containing n characters 'Y' or 'N'\n    vector<string> G(n);\n    for (int i = 0; i < n; ++i) {\n        G[i] = ouf.readToken();\n        if ((int)G[i].size() != n)\n            quitf(_wa, \"Line %d is of incorrect length %d, expected %d\", i+1, (int)G[i].size(), n);\n    }\n    \n    // Check that G_ii = 'N' and G is symmetric\n    for (int i = 0; i < n; ++i) {\n        if (G[i][i] != 'N')\n            quitf(_wa, \"G[%d][%d] is not 'N'\", i+1, i+1);\n        for (int j = 0; j < n; ++j) {\n            char c = G[i][j];\n            if (c != 'Y' && c != 'N')\n                quitf(_wa, \"Invalid character G[%d][%d] = '%c'\", i+1, j+1, c);\n            if (G[i][j] != G[j][i])\n                quitf(_wa, \"G is not symmetric at G[%d][%d] and G[%d][%d]\", i+1, j+1, j+1, i+1);\n        }\n    }\n    \n    // Build adjacency list\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            if (G[i][j] == 'Y')\n                adj[i].push_back(j);\n    \n    // BFS from vertex 1\n    vector<long long> cnt(n, 0);\n    vector<int> dist(n, -1);\n    queue<int> q;\n    dist[0] = 0;\n    cnt[0] = 1;\n    q.push(0);\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                cnt[v] = cnt[u];\n                q.push(v);\n            } else if (dist[v] == dist[u] + 1) {\n                cnt[v] += cnt[u];\n                if (cnt[v] > 1e18)\n                    cnt[v] = 1e18; // prevent overflow\n            }\n        }\n    }\n\n    if (dist[1] == -1)\n        quitf(_wa, \"There is no path between vertex 1 and 2\");\n\n    if (cnt[1] != k)\n        quitf(_wa, \"Number of shortest paths is %lld, expected %d\", cnt[1], k);\n    else\n        quitf(_ok, \"Correct answer, number of shortest paths is %lld\", cnt[1]);\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single integer k in the range [1..1e9].\n  The problem's input is exactly one integer k, so the generator outputs\n  exactly one line containing k.\n\n  Usage examples:\n    ./gen -type min         // Outputs k=1\n    ./gen -type max         // Outputs k=1000000000\n    ./gen -type small       // Outputs k in [1..100]\n    ./gen -type medium      // Outputs k in [1..100000]\n    ./gen -type power2      // Outputs a power of 2 in [1..1e9]\n    ./gen -type random -low 123 -high 999  // Outputs k in [123..999]\n    ./gen -type special     // Outputs a random value from some special set\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    string type       = opt<string>(\"type\", \"random\");\n    long long rangeLow  = opt<long long>(\"low\", 1LL);\n    long long rangeHigh = opt<long long>(\"high\", 1000000000LL);\n\n    long long k = 1LL;\n\n    if (type == \"min\") {\n        // Always output k = 1\n        k = 1LL;\n    } \n    else if (type == \"max\") {\n        // Always output k = 10^9\n        k = 1000000000LL;\n    } \n    else if (type == \"small\") {\n        // Random k in [1..100]\n        k = rnd.next(1LL, 100LL);\n    } \n    else if (type == \"medium\") {\n        // Random k in [1..100000]\n        k = rnd.next(1LL, 100000LL);\n    } \n    else if (type == \"power2\") {\n        // Random power of 2 in [1..10^9]\n        vector<long long> powers;\n        for (int i = 0; i < 31; i++) {\n            long long val = (1LL << i);\n            if (val > 1000000000LL) break;\n            powers.push_back(val);\n        }\n        k = powers[rnd.next((int)powers.size())];\n    } \n    else if (type == \"special\") {\n        // Pick from a set of special values\n        vector<long long> sp {1, 2, 3, 9, 10, 2197, 10000, 99999, 1000000000LL};\n        k = sp[rnd.next((int)sp.size())];\n    } \n    else {\n        // \"random\" or unrecognized type: pick k in [rangeLow..rangeHigh]\n        k = rnd.next(rangeLow, rangeHigh);\n    }\n\n    // Output the single integer k\n    cout << k << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single integer k in the range [1..1e9].\n  The problem's input is exactly one integer k, so the generator outputs\n  exactly one line containing k.\n\n  Usage examples:\n    ./gen -type min         // Outputs k=1\n    ./gen -type max         // Outputs k=1000000000\n    ./gen -type small       // Outputs k in [1..100]\n    ./gen -type medium      // Outputs k in [1..100000]\n    ./gen -type power2      // Outputs a power of 2 in [1..1e9]\n    ./gen -type random -low 123 -high 999  // Outputs k in [123..999]\n    ./gen -type special     // Outputs a random value from some special set\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    string type       = opt<string>(\"type\", \"random\");\n    long long rangeLow  = opt<long long>(\"low\", 1LL);\n    long long rangeHigh = opt<long long>(\"high\", 1000000000LL);\n\n    long long k = 1LL;\n\n    if (type == \"min\") {\n        // Always output k = 1\n        k = 1LL;\n    } \n    else if (type == \"max\") {\n        // Always output k = 10^9\n        k = 1000000000LL;\n    } \n    else if (type == \"small\") {\n        // Random k in [1..100]\n        k = rnd.next(1LL, 100LL);\n    } \n    else if (type == \"medium\") {\n        // Random k in [1..100000]\n        k = rnd.next(1LL, 100000LL);\n    } \n    else if (type == \"power2\") {\n        // Random power of 2 in [1..10^9]\n        vector<long long> powers;\n        for (int i = 0; i < 31; i++) {\n            long long val = (1LL << i);\n            if (val > 1000000000LL) break;\n            powers.push_back(val);\n        }\n        k = powers[rnd.next((int)powers.size())];\n    } \n    else if (type == \"special\") {\n        // Pick from a set of special values\n        vector<long long> sp {1, 2, 3, 9, 10, 2197, 10000, 99999, 1000000000LL};\n        k = sp[rnd.next((int)sp.size())];\n    } \n    else {\n        // \"random\" or unrecognized type: pick k in [rangeLow..rangeHigh]\n        k = rnd.next(rangeLow, rangeHigh);\n    }\n\n    // Output the single integer k\n    cout << k << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to run this generator, each producing\n# a single integer k (the test input). No redirections (>) are used.\n\n# 1. Minimum possible k\n./gen -type min\n\n# 2. Maximum possible k\n./gen -type max\n\n# 3. A small random k in the range [1..100]\n./gen -type small\n\n# 4. Another small random k\n./gen -type small\n\n# 5. Yet another small random k\n./gen -type small\n\n# 6. A medium random k in the range [1..100000]\n./gen -type medium\n\n# 7. Another medium random k\n./gen -type medium\n\n# 8. A power of 2 up to 1e9\n./gen -type power2\n\n# 9. Another power of 2\n./gen -type power2\n\n# 10. Special set choice (e.g., 1, 2, 3, 9, 10, 2197, 10000, 99999, 1e9)\n./gen -type special\n\n# 11. Another special set choice\n./gen -type special\n\n# 12. A fully random k in [1..1e9]\n./gen -type random\n\n# 13. A fully random k in [1..1e9]\n./gen -type random\n\n# 14. A random k in [1..50]\n./gen -type random -low 1 -high 50\n\n# 15. A random k in [1..500]\n./gen -type random -low 1 -high 500\n\n# 16. A random k in [1..999999999]\n./gen -type random -low 1 -high 999999999\n\n# 17. A random k in [500000000..1000000000]\n./gen -type random -low 500000000 -high 1000000000\n\n# 18. Another random k in [123..999]\n./gen -type random -low 123 -high 999\n\n# 19. Another random k in [999000000..1000000000]\n./gen -type random -low 999000000 -high 1000000000\n\n# 20. Large random k near the upper bound\n./gen -type random -low 900000000 -high 1000000000\n\n# 21. Another random k in [1..2]\n./gen -type random -low 1 -high 2\n\n# 22. Another random k in [2..10]\n./gen -type random -low 2 -high 10\n\n# 23. Another random k in [500..600]\n./gen -type random -low 500 -high 600\n\n# 24. Another random k in [99900..100000]\n./gen -type random -low 99900 -high 100000\n\n# 25. One more special set choice\n./gen -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:56.696227",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "389/E",
      "title": "E. Fox and Card Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contain an integer n (1 ≤ n ≤ 100). Each of the next n lines contains a description of the pile: the first integer in the line is si (1 ≤ si ≤ 100) — the number of cards in the i-th pile; then follow si positive integers c1, c2, ..., ck, ..., csi (1 ≤ ck ≤ 1000) — the sequence of the numbers on the cards listed from top of the current pile to bottom of the pile.",
      "output_spec": "OutputPrint two integers: the sum of Ciel's cards and the sum of Jiro's cards if they play optimally.",
      "sample_tests": "ExamplesInputCopy21 1002 1 10OutputCopy101 10InputCopy19 2 8 6 5 9 4 7 1 3OutputCopy30 15InputCopy33 1 3 23 5 4 62 8 7OutputCopy18 18InputCopy33 1000 1000 10006 1000 1000 1000 1000 1000 10005 1000 1000 1000 1000 1000OutputCopy7000 7000",
      "description": "E. Fox and Card Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contain an integer n (1 ≤ n ≤ 100). Each of the next n lines contains a description of the pile: the first integer in the line is si (1 ≤ si ≤ 100) — the number of cards in the i-th pile; then follow si positive integers c1, c2, ..., ck, ..., csi (1 ≤ ck ≤ 1000) — the sequence of the numbers on the cards listed from top of the current pile to bottom of the pile.\n\nOutputPrint two integers: the sum of Ciel's cards and the sum of Jiro's cards if they play optimally.\n\nInputCopy21 1002 1 10OutputCopy101 10InputCopy19 2 8 6 5 9 4 7 1 3OutputCopy30 15InputCopy33 1 3 23 5 4 62 8 7OutputCopy18 18InputCopy33 1000 1000 10006 1000 1000 1000 1000 1000 10005 1000 1000 1000 1000 1000OutputCopy7000 7000\n\nInputCopy21 1002 1 10\n\nOutputCopy101 10\n\nInputCopy19 2 8 6 5 9 4 7 1 3\n\nOutputCopy30 15\n\nInputCopy33 1 3 23 5 4 62 8 7\n\nOutputCopy18 18\n\nInputCopy33 1000 1000 10006 1000 1000 1000 1000 1000 10005 1000 1000 1000 1000 1000\n\nOutputCopy7000 7000\n\nNoteIn the first example, Ciel will take the cards with number 100 and 1, Jiro will take the card with number 10.In the second example, Ciel will take cards with numbers 2, 8, 6, 5, 9 and Jiro will take cards with numbers 4, 7, 1, 3.",
      "solutions": [
        {
          "title": "Codeforces Round #228 - Codeforces",
          "content": "Hello everyone!Codeforces Round #228 (Div. 1 and Div.2) will start at Monday, 3 February 2014, 19:30:00 MSK.This is my 2nd round on Codeforces. (Click here to see my last round) , As usual, there will be 7 problems: 2 for Div2, 2 for Div1 and 3 for both. And same with the last round, the main character of all problem will be Fox Ciel.I would like to thank Gerald for testing, and MikeMirzayanov for the Codeforces project including polygon system.Good luck and have fun!The score distribution will be published later. And the editorial will be published right after the system test.By the way, yesterday is the Chinese new year. So I'd like to say Happy New Year to everyone who celebrate it! And I'm very glad to be the writer of the first round in the new year.Update1: Good news for participants of Petrozavodsk training camp. Top 20 participants of the camp by this round results will get t-shirts from Codeforces.Update 2: The score distribution for Both Division is regular (500-1000-1500-2000-2500).Update 3: We postpone the round 10 minutes by technical reasons (dinner on Petrozavodsk Training Camp), sorry for the inconvenience.Update 4: We've increased the contest time by 5 minutes.Update 5: Contest ended, thanks for your participating! I'll post the editorial soon.Update 6: Editorial.Winners:DIV1: tourist PavelKunyavskiy Egor 2222 dreamoon_love_AA Sadly no one solved E correctly. Egor's solution can pass if the TL is 7 seconds instead of 6, what a pity!DIV2: I_love_Hoang_Yen iaacboy GoldExperience shivatejesh lordpawel They are the only people who solved all tasks!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1587
        },
        {
          "title": "Codeforces Round #228 — Editorial - Codeforces",
          "content": "You can find the editorial and my solutions here: https://github.com/cgy4ever/CF228389A - Fox and Number GameFirst we know that: in the optimal solution, all number will be equal: otherwise we can pick a and b (a < b) then do b = b — a, it will make the answer better.Then we need an observation: after each operation, the GCD (Greatest common divisor) of all number will remain same. It can be proved by this lemma: if g is a divisor of all number of x[], then after the operation, g is still the divisor of these numbers, and vice versa.So in the end, all number will become the GCD of x[].Another solution that can pass is: While there exist x[i] > x[j], then do x[i] -= x[j]. We can select arbitrary i and j if there exist more than 1 choice.389B - Fox and CrossLet's define the first # of a shape is the cell contain # that have the lexicographical smallest coordinate. Then the first # of a cross is the top one.Then let x be the first # of the given board. (If the board is empty, then we can draw it with zero crosses.) x must be covered by a cross, and x must be the first # of the cross. (You can try 4 other positions, it will cause a lexicographical smaller # in the board than x)So we try to cover this x use one cross, if it leads some part of the cross covers a '.', then there will be no solution. If not, we just reduce the number of # in the board by 4, we can do this again and again.389C - Fox and Box Accumulation / 388A - Fox and Box AccumulationWe need some observation: There exists an optimal solution such that: in any pile, the box on the higher position will have a smaller strength. Let k be the minimal number of piles, then there exists an optimal solution such that: The height of all piles is n/k or n/k+1 (if n%k=0, then all of them have the height n/k). We can prove them by exchange argument: from an optimal solution, swap the boxes in it to make above property holds, and we can ensure it will remain valid while swapping.Then for a given k, we can check whether there exist a solution: the i-th (indexed from 0) smallest strength needs to be at least i/k.So we can do binary search (or just enumerate, since n is only 100) on k.389D - Fox and Minimal path / 388B - Fox and Minimal pathFirst we need to know how to calculate the number of different shortest paths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v] = sum{dp[t] | dist(1,t) = dist(1,v) — 1}, then dp[2] is our answer.We need to do dp layer by layer. (first we consider vertexes have distance 1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we can construct the graph layer by layer, and link edges to control the dp value of it.My solution is construct the answer by binary express: If k is 19, then we need some vertexes in previous layer such that the dp value is 16, 2 and 1. So we just need a way to construct layer with dp value equals to 2^k.In the first layer, it contains one node: 1, it has the dp value 1. In the next layer, we can construct 2 nodes, with dp value equals to 1. (We use [1 1] to denote it). And the next layer is [1 1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers such that gets all 2^k where k < 30. It uses about 500 nodes.389E - Fox and Card Game / 388C - Fox and Card GameFirst let's consider the case which all piles have even size. In this case, we can prove: in the optimal play, Ciel will gets all top most half cards of each pile, and Jiro gets the remain cards.We can prove by these facts: Ciel have a strategy to ensure she can get this outcome and Jiro also have a strategy to ensure this outcome. (For Jiro this strategy is easy: just pick the card from pile that Ciel have just picked. For Ciel it's a little bit harder.)Why we can conclude they are both the optimal strategy? Ciel just can't win more, because if she played with Jiro with above strategy, Jiro will get the bottom half of each pile.Then we come back with cases that contain odd size piles. The result is: for odd size pile, Ciel will get the top (s-1)/2 cards and Jiro will get the bottom (s-1)/2 cards. Then what about the middle one? Let's denote S is all such middle cards. Then we define a reduced game: In each turn, they pick one card from S. The optimal play for this game is easy: Ciel gets the max one, and Jiro gets the 2nd largest one, and Ciel gets the 3rd largest one and so on.We can prove Ciel have a strategy to get: all top half parts + cards she will get in the optimal play in the reduced game. And Jiro also have a strategy to get: all bottom half parts + cards he will get in the optimal play in the reduced game. And these strategy are optimal.388D - Fox and Perfect SetsA perfect set correspond to a linear space, so we can use base to represent it. We do the Gauss–Jordan elimination of vectors in that set, and can get an unique base. (Note that we need to to the all process of Gauss–Jordan elimination, including the elimination after it reached upper triangular)And we can construct the bases bit by bit from higher bit to lower, for a bit: We can add a vector to the base such that the bit is the highest bit of that vector. And at this time, all other vector will have 0 in this bit. Otherwise we need to assign this bit of each vector already in the base. If now we have k vector, then we have 2^k choices. And when we do this, we need to know what's the maximal vector in this space. It's not hard: If we add a vector, then in the maximal vector, this bit will be 1. Otherwise, if we don't have any vector in base yet, then this bit will be 0. Otherwise there will be 2^(k-1) choices results in this bit of maximal vector will be 0, and 2^(k-1) choices results in 1. So we can solve this task by DP bit by bit.388E - Fox and Meteor ShowerAll tasks beside this are very easy to code. And this one focus on implementation.We can represent the orbit of each meteor by a line in 3D space. (we use an axis to represent the time, and two axis to represent the position on the plane.)Then the problem becomes: we have some lines in 3D space (they are not complete coincide), find a largest clique such that each pair of lines touch at some point.We need this observation: If there are 3 lines in the optimal clique, and these 3 lines are not share a common point, then all line in this clique will on a plane.By using this observation, we only need to consider 2 cases: All lines in the clique have a common point. All lines in the clique are on the same plane. Both are easy tasks in theory, but it needs some coding.There are two ways: Use integer anywhere. Note that the coordinates of intersection can be rational number, but can't be irrational, so we could do this. We can use some way to encode the plane, direction. Use floating number. To count same number of points, we can sort (x, y, z) by using the following compare function: if (abs(A.x — B.x) > eps){return A.x < B.x} otherwise { if(abs(A.y-B.y)>eps){return A.y < B.y} otherwise return A.z < B.z}.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10629",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 389\\s*E"
          },
          "content_length": 6957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #228 - Codeforces - Code 1",
          "code": "1-3 1-4 2-3 2-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 2",
          "code": "1-3 1-4 3-5 4-5 5-6 5-7 2-6 2-7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 3",
          "code": "2^i( 0<=i<=32)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 4",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 5",
          "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int k,len;\n    cin >> k;\n    k = 1000000;\n    len = (int)pow(1.*k,0.2);\n    k -= (int)pow(1.*len,5.);\n    cout << k;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 6",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 7",
          "code": "k -= (int)pow(1.*len,5.);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 8",
          "code": "len*len*len*len*len != pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 9",
          "code": "cout << ((1.*len*len*len*len*len)==pow(len,5.));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 10",
          "code": "//k = 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 11",
          "code": "pow(len, 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 12",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #228 - Codeforces - Code 13",
          "code": "2\n1 2\n3 1 100 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10605",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int total_cards = 0;\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 100, \"si\");\n        total_cards += si;\n        ensuref(total_cards <= 10000, \"Total number of cards exceeds 10000\");\n        inf.readSpace();\n        inf.readInts(si, 1, 1000, \"cards\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int total_cards = 0;\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 100, \"si\");\n        total_cards += si;\n        ensuref(total_cards <= 10000, \"Total number of cards exceeds 10000\");\n        inf.readSpace();\n        inf.readInts(si, 1, 1000, \"cards\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int total_cards = 0;\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 100, \"si\");\n        total_cards += si;\n        ensuref(total_cards <= 10000, \"Total number of cards exceeds 10000\");\n        inf.readSpace();\n        inf.readInts(si, 1, 1000, \"cards\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10); // default n=10 if not provided\n    int m = opt<int>(\"m\", 10); // default maximum pile size m=10 if not provided\n    int card = opt<int>(\"card\", 1000); // default maximum card value is 1000\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> piles(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            for(int j = 0; j < si; ++j) {\n                int ck = rnd.next(1, card);\n                piles[i].push_back(ck);\n            }\n        }\n    } else if (type == \"same_values\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            int value = rnd.next(1, card);\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(value);\n            }\n        }\n    } else if (type == \"asc\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            int start = rnd.next(1, max(1, card - si + 1));\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(start + j);\n            }\n        }\n    } else if (type == \"desc\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            int start = rnd.next(si, card);\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(start - j);\n            }\n        }\n    } else if (type == \"one_big_pile\") {\n        piles[0].resize(m);\n        for(int j = 0; j < m; ++j) {\n            piles[0][j] = rnd.next(1, card);\n        }\n        for(int i = 1; i < n; ++i) {\n            piles[i].push_back(rnd.next(1, card));\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            int si = m;\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(card);\n            }\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            int si = 1;\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(1);\n            }\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            for(int j = 0; j < si; ++j) {\n                int ck = rnd.next(1, card);\n                piles[i].push_back(ck);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        int si = piles[i].size();\n        printf(\"%d\", si);\n        for(int j = 0; j < si; ++j) {\n            printf(\" %d\", piles[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10); // default n=10 if not provided\n    int m = opt<int>(\"m\", 10); // default maximum pile size m=10 if not provided\n    int card = opt<int>(\"card\", 1000); // default maximum card value is 1000\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> piles(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            for(int j = 0; j < si; ++j) {\n                int ck = rnd.next(1, card);\n                piles[i].push_back(ck);\n            }\n        }\n    } else if (type == \"same_values\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            int value = rnd.next(1, card);\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(value);\n            }\n        }\n    } else if (type == \"asc\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            int start = rnd.next(1, max(1, card - si + 1));\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(start + j);\n            }\n        }\n    } else if (type == \"desc\") {\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            int start = rnd.next(si, card);\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(start - j);\n            }\n        }\n    } else if (type == \"one_big_pile\") {\n        piles[0].resize(m);\n        for(int j = 0; j < m; ++j) {\n            piles[0][j] = rnd.next(1, card);\n        }\n        for(int i = 1; i < n; ++i) {\n            piles[i].push_back(rnd.next(1, card));\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            int si = m;\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(card);\n            }\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            int si = 1;\n            for(int j = 0; j < si; ++j) {\n                piles[i].push_back(1);\n            }\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            int si = rnd.next(1, m);\n            for(int j = 0; j < si; ++j) {\n                int ck = rnd.next(1, card);\n                piles[i].push_back(ck);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        int si = piles[i].size();\n        printf(\"%d\", si);\n        for(int j = 0; j < si; ++j) {\n            printf(\" %d\", piles[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -card 1 -type min\n./gen -n 1 -m 1 -card 1 -type random\n\n./gen -n 100 -m 100 -card 1000 -type max\n./gen -n 100 -m 100 -card 1000 -type random\n\n./gen -n 50 -m 50 -card 500 -type random\n./gen -n 75 -m 75 -card 750 -type random\n./gen -n 90 -m 90 -card 900 -type random\n./gen -n 100 -m 100 -card 1000 -type random\n\n./gen -n 100 -m 100 -card 1000 -type same_values\n./gen -n 100 -m 100 -card 1000 -type asc\n./gen -n 100 -m 100 -card 1000 -type desc\n./gen -n 100 -m 100 -card 1000 -type one_big_pile\n\n./gen -n 50 -m 100 -card 1000 -type one_big_pile\n./gen -n 75 -m 100 -card 1000 -type one_big_pile\n\n./gen -n 100 -m 1 -card 1000 -type random\n./gen -n 100 -m 1 -card 1 -type random\n./gen -n 100 -m 1 -card 1 -type min\n\n./gen -n 1 -m 100 -card 1000 -type random\n./gen -n 1 -m 100 -card 1000 -type min\n\n./gen -n 100 -m 100 -card 1 -type random\n./gen -n 100 -m 100 -card 1 -type same_values\n\n./gen -n 10 -m 50 -card 100 -type asc\n./gen -n 10 -m 50 -card 100 -type desc\n\n./gen -n 25 -m 50 -card 500 -type random\n./gen -n 50 -m 25 -card 500 -type random\n\n./gen -n 100 -m 100 -card 1000 -type random\n./gen -n 100 -m 100 -card 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:19:58.761732",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/A",
      "title": "A. C*++ Calculations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first input line contains an integer a ( - 1000 ≤ a ≤ 1000) — the initial value of the variable \"a\". The next line contains an expression in C*++ language of the described type. The number of the summands in the expression does not exceed 1000. It is guaranteed that the line describing the expression contains no spaces and tabulation.",
      "output_spec": "OutputOutput a single number — the maximal possible value of the expression.",
      "sample_tests": "ExamplesInputCopy15*a++-3*++a+a++OutputCopy11InputCopy3a+++++aOutputCopy8",
      "description": "A. C*++ Calculations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains an integer a ( - 1000 ≤ a ≤ 1000) — the initial value of the variable \"a\". The next line contains an expression in C*++ language of the described type. The number of the summands in the expression does not exceed 1000. It is guaranteed that the line describing the expression contains no spaces and tabulation.\n\nOutputOutput a single number — the maximal possible value of the expression.\n\nInputCopy15*a++-3*++a+a++OutputCopy11InputCopy3a+++++aOutputCopy8\n\nInputCopy15*a++-3*++a+a++\n\nOutputCopy11\n\nInputCopy3a+++++a\n\nOutputCopy8\n\nNoteConsider the second example. Initially a = 3. Suppose that at first the first summand is calculated, and then the second one is. The first summand gets equal to 3, and the value of a is increased by 1. At the calculation of the second summand a is increased once more (gets equal to 5). The value of the second summand is 5, and together they give 8. If we calculate the second summand first and the first summand later, then the both summands equals to 4, and the result is 8, too.",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring expr;\nint pos = 0;\nint len = 0;\nint num_summands = 0;\n\nvoid parseExpression();\nvoid parseSummand();\nvoid parseCoefficient();\nvoid parseIncrement();\n\nvoid parseExpression() {\n    parseSummand();\n    num_summands++;\n    ensuref(num_summands <= 1000, \"Number of summands exceeds 1000\");\n    while (pos < len && (expr[pos] == '+' || expr[pos] == '-')) {\n        pos++;\n        parseSummand();\n        num_summands++;\n        ensuref(num_summands <= 1000, \"Number of summands exceeds 1000\");\n    }\n}\n\nvoid parseSummand() {\n    int start_pos = pos;\n    if (pos < len && isdigit(expr[pos])) {\n        parseCoefficient();\n        ensuref(pos < len && expr[pos] == '*', \"Expected '*' after coefficient at position %d\", pos);\n        pos++;\n        parseIncrement();\n    } else {\n        parseIncrement();\n    }\n}\n\nvoid parseCoefficient() {\n    int start_pos = pos;\n    while (pos < len && isdigit(expr[pos])) {\n        pos++;\n    }\n    ensuref(pos > start_pos, \"Expected coefficient at position %d\", start_pos);\n    string coeff_str = expr.substr(start_pos, pos - start_pos);\n    // Ensure that coefficient is an integer between 0 and 1000 inclusive\n    ensuref(coeff_str.size() <= 4, \"Coefficient too large at position %d\", start_pos);\n    int coeff = stoi(coeff_str);\n    ensuref(0 <= coeff && coeff <= 1000, \"Coefficient %d out of bounds at position %d\", coeff, start_pos);\n    // Ensure no leading zeros unless single '0'\n    if (coeff_str.size() > 1 && coeff_str[0] == '0') {\n        ensuref(false, \"Leading zero in coefficient at position %d\", start_pos);\n    }\n}\n\nvoid parseIncrement() {\n    if (pos + 3 <= len && expr.substr(pos, 3) == \"a++\") {\n        pos += 3;\n    } else if (pos + 3 <= len && expr.substr(pos, 3) == \"++a\") {\n        pos += 3;\n    } else {\n        ensuref(false, \"Expected 'a++' or '++a' at position %d\", pos);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000, 1000, \"a\");\n    inf.readEoln();\n\n    expr = inf.readLine();\n    len = expr.size();\n    pos = 0;\n    num_summands = 0;\n\n    // Check that expr does not contain spaces or tabs\n    for (int i = 0; i < len; i++) {\n        char c = expr[i];\n        ensuref(c != ' ' && c != '\\t', \"Expression should not contain spaces or tabs\");\n    }\n\n    parseExpression();\n\n    ensuref(pos == len, \"Extra characters at end of expression starting at position %d\", pos);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring expr;\nint pos = 0;\nint len = 0;\nint num_summands = 0;\n\nvoid parseExpression();\nvoid parseSummand();\nvoid parseCoefficient();\nvoid parseIncrement();\n\nvoid parseExpression() {\n    parseSummand();\n    num_summands++;\n    ensuref(num_summands <= 1000, \"Number of summands exceeds 1000\");\n    while (pos < len && (expr[pos] == '+' || expr[pos] == '-')) {\n        pos++;\n        parseSummand();\n        num_summands++;\n        ensuref(num_summands <= 1000, \"Number of summands exceeds 1000\");\n    }\n}\n\nvoid parseSummand() {\n    int start_pos = pos;\n    if (pos < len && isdigit(expr[pos])) {\n        parseCoefficient();\n        ensuref(pos < len && expr[pos] == '*', \"Expected '*' after coefficient at position %d\", pos);\n        pos++;\n        parseIncrement();\n    } else {\n        parseIncrement();\n    }\n}\n\nvoid parseCoefficient() {\n    int start_pos = pos;\n    while (pos < len && isdigit(expr[pos])) {\n        pos++;\n    }\n    ensuref(pos > start_pos, \"Expected coefficient at position %d\", start_pos);\n    string coeff_str = expr.substr(start_pos, pos - start_pos);\n    // Ensure that coefficient is an integer between 0 and 1000 inclusive\n    ensuref(coeff_str.size() <= 4, \"Coefficient too large at position %d\", start_pos);\n    int coeff = stoi(coeff_str);\n    ensuref(0 <= coeff && coeff <= 1000, \"Coefficient %d out of bounds at position %d\", coeff, start_pos);\n    // Ensure no leading zeros unless single '0'\n    if (coeff_str.size() > 1 && coeff_str[0] == '0') {\n        ensuref(false, \"Leading zero in coefficient at position %d\", start_pos);\n    }\n}\n\nvoid parseIncrement() {\n    if (pos + 3 <= len && expr.substr(pos, 3) == \"a++\") {\n        pos += 3;\n    } else if (pos + 3 <= len && expr.substr(pos, 3) == \"++a\") {\n        pos += 3;\n    } else {\n        ensuref(false, \"Expected 'a++' or '++a' at position %d\", pos);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000, 1000, \"a\");\n    inf.readEoln();\n\n    expr = inf.readLine();\n    len = expr.size();\n    pos = 0;\n    num_summands = 0;\n\n    // Check that expr does not contain spaces or tabs\n    for (int i = 0; i < len; i++) {\n        char c = expr[i];\n        ensuref(c != ' ' && c != '\\t', \"Expression should not contain spaces or tabs\");\n    }\n\n    parseExpression();\n\n    ensuref(pos == len, \"Extra characters at end of expression starting at position %d\", pos);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring expr;\nint pos = 0;\nint len = 0;\nint num_summands = 0;\n\nvoid parseExpression();\nvoid parseSummand();\nvoid parseCoefficient();\nvoid parseIncrement();\n\nvoid parseExpression() {\n    parseSummand();\n    num_summands++;\n    ensuref(num_summands <= 1000, \"Number of summands exceeds 1000\");\n    while (pos < len && (expr[pos] == '+' || expr[pos] == '-')) {\n        pos++;\n        parseSummand();\n        num_summands++;\n        ensuref(num_summands <= 1000, \"Number of summands exceeds 1000\");\n    }\n}\n\nvoid parseSummand() {\n    int start_pos = pos;\n    if (pos < len && isdigit(expr[pos])) {\n        parseCoefficient();\n        ensuref(pos < len && expr[pos] == '*', \"Expected '*' after coefficient at position %d\", pos);\n        pos++;\n        parseIncrement();\n    } else {\n        parseIncrement();\n    }\n}\n\nvoid parseCoefficient() {\n    int start_pos = pos;\n    while (pos < len && isdigit(expr[pos])) {\n        pos++;\n    }\n    ensuref(pos > start_pos, \"Expected coefficient at position %d\", start_pos);\n    string coeff_str = expr.substr(start_pos, pos - start_pos);\n    // Ensure that coefficient is an integer between 0 and 1000 inclusive\n    ensuref(coeff_str.size() <= 4, \"Coefficient too large at position %d\", start_pos);\n    int coeff = stoi(coeff_str);\n    ensuref(0 <= coeff && coeff <= 1000, \"Coefficient %d out of bounds at position %d\", coeff, start_pos);\n    // Ensure no leading zeros unless single '0'\n    if (coeff_str.size() > 1 && coeff_str[0] == '0') {\n        ensuref(false, \"Leading zero in coefficient at position %d\", start_pos);\n    }\n}\n\nvoid parseIncrement() {\n    if (pos + 3 <= len && expr.substr(pos, 3) == \"a++\") {\n        pos += 3;\n    } else if (pos + 3 <= len && expr.substr(pos, 3) == \"++a\") {\n        pos += 3;\n    } else {\n        ensuref(false, \"Expected 'a++' or '++a' at position %d\", pos);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000, 1000, \"a\");\n    inf.readEoln();\n\n    expr = inf.readLine();\n    len = expr.size();\n    pos = 0;\n    num_summands = 0;\n\n    // Check that expr does not contain spaces or tabs\n    for (int i = 0; i < len; i++) {\n        char c = expr[i];\n        ensuref(c != ' ' && c != '\\t', \"Expression should not contain spaces or tabs\");\n    }\n\n    parseExpression();\n\n    ensuref(pos == len, \"Extra characters at end of expression starting at position %d\", pos);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure 'n' and 'a' within constraints\n    n = max(1, min(1000, n));\n    a = max(-1000, min(1000, a));\n\n    cout << a << endl;\n\n    vector<string> summands;\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int include_coeff = rnd.next(2); // 0 or 1\n            int coeff = rnd.next(0, 1000); // Coefficient between 0 and 1000 inclusive\n            int incr_type = rnd.next(0, 1); // 0: 'a++', 1: '++a'\n            string incr = (incr_type == 0) ? \"a++\" : \"++a\";\n            string summand = (include_coeff) ? to_string(coeff) + \"*\" + incr : incr;\n            summands.push_back(summand);\n        }\n    } else if (type == \"max_value\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = 1000;\n            string summand = to_string(coeff) + \"*++a\";\n            summands.push_back(summand);\n        }\n    } else if (type == \"min_value\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = 1000;\n            string summand = to_string(coeff) + \"*a++\";\n            summands.push_back(summand);\n        }\n    } else if (type == \"order_matter\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(1, 1000);\n            string incr = (i % 2 == 0) ? \"++a\" : \"a++\";\n            string summand = to_string(coeff) + \"*\" + incr;\n            summands.push_back(summand);\n        }\n        shuffle(summands.begin(), summands.end());\n    } else if (type == \"all_a++\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(0, 1000);\n            if (coeff == 0)\n                summands.push_back(\"a++\");\n            else \n                summands.push_back(to_string(coeff) + \"*a++\");\n        }\n    } else if (type == \"all_++a\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(0, 1000);\n            if (coeff == 0)\n                summands.push_back(\"++a\");\n            else \n                summands.push_back(to_string(coeff) + \"*++a\");\n        }\n    } else if (type == \"zero_coefficients\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = 0;\n            string incr = rnd.next(0, 1) ? \"a++\" : \"++a\";\n            summands.push_back(to_string(coeff) + \"*\" + incr);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(0, 1000);\n            string incr = rnd.next(0, 1) ? \"a++\" : \"++a\";\n            string summand = (coeff == 0) ? incr : to_string(coeff) + \"*\" + incr;\n            summands.push_back(summand);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int include_coeff = rnd.next(2); // 0 or 1\n            int coeff = rnd.next(0, 1000); // Coefficient between 0 and 1000 inclusive\n            int incr_type = rnd.next(0, 1); // 0: 'a++', 1: '++a'\n            string incr = (incr_type == 0) ? \"a++\" : \"++a\";\n            string summand = (include_coeff) ? to_string(coeff) + \"*\" + incr : incr;\n            summands.push_back(summand);\n        }\n    }\n\n    string expr = summands[0];\n    for (int i = 1; i < n; ++i) {\n        char op;\n        if (type == \"min_value\" || type == \"all_a++\") {\n            op = '-';\n        } else if (type == \"max_value\" || type == \"all_++a\") {\n            op = '+';\n        } else {\n            op = rnd.next(0, 1) ? '+' : '-';\n        }\n        expr += op + summands[i];\n    }\n\n    cout << expr << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure 'n' and 'a' within constraints\n    n = max(1, min(1000, n));\n    a = max(-1000, min(1000, a));\n\n    cout << a << endl;\n\n    vector<string> summands;\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int include_coeff = rnd.next(2); // 0 or 1\n            int coeff = rnd.next(0, 1000); // Coefficient between 0 and 1000 inclusive\n            int incr_type = rnd.next(0, 1); // 0: 'a++', 1: '++a'\n            string incr = (incr_type == 0) ? \"a++\" : \"++a\";\n            string summand = (include_coeff) ? to_string(coeff) + \"*\" + incr : incr;\n            summands.push_back(summand);\n        }\n    } else if (type == \"max_value\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = 1000;\n            string summand = to_string(coeff) + \"*++a\";\n            summands.push_back(summand);\n        }\n    } else if (type == \"min_value\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = 1000;\n            string summand = to_string(coeff) + \"*a++\";\n            summands.push_back(summand);\n        }\n    } else if (type == \"order_matter\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(1, 1000);\n            string incr = (i % 2 == 0) ? \"++a\" : \"a++\";\n            string summand = to_string(coeff) + \"*\" + incr;\n            summands.push_back(summand);\n        }\n        shuffle(summands.begin(), summands.end());\n    } else if (type == \"all_a++\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(0, 1000);\n            if (coeff == 0)\n                summands.push_back(\"a++\");\n            else \n                summands.push_back(to_string(coeff) + \"*a++\");\n        }\n    } else if (type == \"all_++a\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(0, 1000);\n            if (coeff == 0)\n                summands.push_back(\"++a\");\n            else \n                summands.push_back(to_string(coeff) + \"*++a\");\n        }\n    } else if (type == \"zero_coefficients\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = 0;\n            string incr = rnd.next(0, 1) ? \"a++\" : \"++a\";\n            summands.push_back(to_string(coeff) + \"*\" + incr);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int coeff = rnd.next(0, 1000);\n            string incr = rnd.next(0, 1) ? \"a++\" : \"++a\";\n            string summand = (coeff == 0) ? incr : to_string(coeff) + \"*\" + incr;\n            summands.push_back(summand);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int include_coeff = rnd.next(2); // 0 or 1\n            int coeff = rnd.next(0, 1000); // Coefficient between 0 and 1000 inclusive\n            int incr_type = rnd.next(0, 1); // 0: 'a++', 1: '++a'\n            string incr = (incr_type == 0) ? \"a++\" : \"++a\";\n            string summand = (include_coeff) ? to_string(coeff) + \"*\" + incr : incr;\n            summands.push_back(summand);\n        }\n    }\n\n    string expr = summands[0];\n    for (int i = 1; i < n; ++i) {\n        char op;\n        if (type == \"min_value\" || type == \"all_a++\") {\n            op = '-';\n        } else if (type == \"max_value\" || type == \"all_++a\") {\n            op = '+';\n        } else {\n            op = rnd.next(0, 1) ? '+' : '-';\n        }\n        expr += op + summands[i];\n    }\n\n    cout << expr << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random expressions, small 'a'\n./gen -n 1 -a 0 -type random\n./gen -n 5 -a -1000 -type random\n./gen -n 5 -a 1000 -type random\n\n# Maximal value test cases\n./gen -n 1000 -a -1000 -type max_value\n./gen -n 1000 -a 0 -type max_value\n./gen -n 1000 -a 1000 -type max_value\n\n# Minimal value test cases\n./gen -n 1000 -a 1000 -type min_value\n./gen -n 1000 -a 0 -type min_value\n./gen -n 1000 -a -1000 -type min_value\n\n# Order matters test cases\n./gen -n 1000 -a 0 -type order_matter\n./gen -n 500 -a 1000 -type order_matter\n\n# All 'a++' summands\n./gen -n 1000 -a 0 -type all_a++\n./gen -n 1000 -a -500 -type all_a++\n\n# All '++a' summands\n./gen -n 1000 -a 0 -type all_++a\n./gen -n 1000 -a 500 -type all_++a\n\n# Zero coefficients\n./gen -n 1000 -a 0 -type zero_coefficients\n\n# Mixed expressions\n./gen -n 1000 -a 0 -type mixed\n./gen -n 999 -a -999 -type mixed\n\n# Edge cases with small 'n'\n./gen -n 1 -a 0 -type max_value\n./gen -n 1 -a 0 -type min_value\n./gen -n 1 -a 0 -type order_matter\n\n# Edge case with only 'a++' and zero coefficients\n./gen -n 1000 -a 1000 -type zero_coefficients\n\n# Edge case with initial 'a' at min value\n./gen -n 1000 -a -1000 -type mixed\n\n# Edge case with alternating operators\n./gen -n 1000 -a 0 -type mixed\n\n# Random tests with varying 'a's\n./gen -n 1000 -a -500 -type random\n./gen -n 1000 -a 500 -type random\n./gen -n 1000 -a -250 -type random\n\n# Very minimal 'n'\n./gen -n 1 -a 0 -type random\n\n# Test with 'n' close to maximum\n./gen -n 1000 -a 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:01.455238",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/B",
      "title": "B. Company Income Growth",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100). The next line contains n integers ai ( - 100 ≤ ai ≤ 100). The number ai determines the income of BerSoft company in the (2000 + i)-th year. The numbers in the line are separated by spaces.",
      "output_spec": "OutputOutput k — the maximum possible length of a perfect sequence. In the next line output the sequence of years y1, y2, ..., yk. Separate the numbers by spaces. If the answer is not unique, output any. If no solution exist, output one number 0.",
      "sample_tests": "ExamplesInputCopy10-2 1 1 3 2 3 4 -10 -2 5OutputCopy52002 2005 2006 2007 2010InputCopy3-1 -2 -3OutputCopy0",
      "description": "B. Company Income Growth\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100). The next line contains n integers ai ( - 100 ≤ ai ≤ 100). The number ai determines the income of BerSoft company in the (2000 + i)-th year. The numbers in the line are separated by spaces.\n\nOutputOutput k — the maximum possible length of a perfect sequence. In the next line output the sequence of years y1, y2, ..., yk. Separate the numbers by spaces. If the answer is not unique, output any. If no solution exist, output one number 0.\n\nInputCopy10-2 1 1 3 2 3 4 -10 -2 5OutputCopy52002 2005 2006 2007 2010InputCopy3-1 -2 -3OutputCopy0\n\nInputCopy10-2 1 1 3 2 3 4 -10 -2 5\n\nOutputCopy52002 2005 2006 2007 2010\n\nInputCopy3-1 -2 -3\n\nOutputCopy0",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    inf.readInts(n, -100, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    inf.readInts(n, -100, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    inf.readInts(n, -100, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100);\n\n    vector<int> income(n + 1); // income[1..n]\n\n    // Read ai\n    for (int i = 1; i <= n; i++) {\n        income[i] = inf.readInt(-100, 100);\n    }\n    \n    // Read jury's k\n    int jury_k = ans.readInt(0, n);\n    \n    // Read participant's k\n    int participant_k = ouf.readInt(0, n, \"k\");\n    \n    // Check if participant's k matches the maximal length\n    if (participant_k < jury_k) {\n        quitf(_wa, \"Participant's sequence is not maximum: k = %d, but maximum possible is %d\", participant_k, jury_k);\n    } else if (participant_k > jury_k) {\n        quitf(_fail, \"Participant's k = %d is longer than maximum possible %d\", participant_k, jury_k);\n    }\n    \n    if (participant_k == 0) {\n        if (jury_k == 0)\n            quitf(_ok, \"No solution exists (k = 0)\");\n        else\n            quitf(_wa, \"Participant says k=0, but maximum possible is %d\", jury_k);\n    }\n    \n    // Read participant's sequence of years\n    vector<int> years;\n    for (int i = 0; i < participant_k; i++) {\n        int y = ouf.readInt(2001, 2000 + n, format(\"years[%d]\", i + 1).c_str());\n        years.push_back(y);\n    }\n    \n    // Check that years are strictly increasing\n    for (int i = 1; i < participant_k; i++) {\n        if (years[i] <= years[i - 1]) {\n            quitf(_wa, \"Years are not strictly increasing at position %d\", i + 1);\n        }\n    }\n    \n    // Validate incomes at the given years\n    for (int i = 0; i < participant_k; i++) {\n        int index = years[i] - 2000;\n        if (index < 1 || index > n) {\n            quitf(_fail, \"Year %d corresponds to invalid index %d\", years[i], index);\n        }\n        if (income[index] != i + 1) {\n            quitf(_wa, \"Income at year %d is %d, but expected %d\", years[i], income[index], i + 1);\n        }\n    }\n    \n    quitf(_ok, \"k = %d\", participant_k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\") {\n        // Generate random integers between -100 and 100\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    } else if (type == \"all_negative\") {\n        // All elements are -100\n        for (int i = 0; i < n; ++i)\n            a[i] = -100;\n    } else if (type == \"all_positive\") {\n        // All elements are 100\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"perfect_sequence\") {\n        // Elements form a perfect sequence: 1, 2, 3, ..., n\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"reverse_sequence\") {\n        // Elements are in reverse order: n, n-1, ..., 1\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"repeated_numbers\") {\n        // All elements are the same random number\n        int num = rnd.next(-100, 100);\n        for (int i = 0; i < n; ++i)\n            a[i] = num;\n    } else if (type == \"zeros_and_ones\") {\n        // Elements are randomly 0 or 1\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    } else if (type == \"multiple_ones\") {\n        // Random elements, with multiple ones scattered\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n        int num_ones = rnd.next(1, n);\n        for (int i = 0; i < num_ones; ++i)\n            a[rnd.next(0, n - 1)] = 1;\n    } else if (type == \"off_by_one\") {\n        // Elements are 0, 1, 2, ..., n-1\n        for (int i = 0; i < n; ++i)\n            a[i] = i;\n    } else if (type == \"many_candidates\") {\n        // Multiple candidates for the perfect sequence\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                a[i] = rnd.next(1, n / 2 + 1);\n            else\n                a[i] = rnd.next(-100, 100);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    }\n\n    // Output n and the sequence a_i\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\") {\n        // Generate random integers between -100 and 100\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    } else if (type == \"all_negative\") {\n        // All elements are -100\n        for (int i = 0; i < n; ++i)\n            a[i] = -100;\n    } else if (type == \"all_positive\") {\n        // All elements are 100\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"perfect_sequence\") {\n        // Elements form a perfect sequence: 1, 2, 3, ..., n\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"reverse_sequence\") {\n        // Elements are in reverse order: n, n-1, ..., 1\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"repeated_numbers\") {\n        // All elements are the same random number\n        int num = rnd.next(-100, 100);\n        for (int i = 0; i < n; ++i)\n            a[i] = num;\n    } else if (type == \"zeros_and_ones\") {\n        // Elements are randomly 0 or 1\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    } else if (type == \"multiple_ones\") {\n        // Random elements, with multiple ones scattered\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n        int num_ones = rnd.next(1, n);\n        for (int i = 0; i < num_ones; ++i)\n            a[rnd.next(0, n - 1)] = 1;\n    } else if (type == \"off_by_one\") {\n        // Elements are 0, 1, 2, ..., n-1\n        for (int i = 0; i < n; ++i)\n            a[i] = i;\n    } else if (type == \"many_candidates\") {\n        // Multiple candidates for the perfect sequence\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                a[i] = rnd.next(1, n / 2 + 1);\n            else\n                a[i] = rnd.next(-100, 100);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    }\n\n    // Output n and the sequence a_i\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n test cases\n./gen -n 1 -type random\n./gen -n 1 -type all_negative\n./gen -n 1 -type all_positive\n./gen -n 2 -type perfect_sequence\n./gen -n 2 -type reverse_sequence\n./gen -n 5 -type off_by_one\n\n# Medium n test cases\n./gen -n 10 -type random\n./gen -n 10 -type zeros_and_ones\n./gen -n 10 -type multiple_ones\n./gen -n 20 -type random\n./gen -n 20 -type all_negative\n./gen -n 20 -type all_positive\n./gen -n 20 -type perfect_sequence\n./gen -n 20 -type reverse_sequence\n./gen -n 20 -type repeated_numbers\n./gen -n 20 -type many_candidates\n./gen -n 50 -type zeros_and_ones\n./gen -n 50 -type multiple_ones\n./gen -n 50 -type off_by_one\n./gen -n 50 -type many_candidates\n\n# Maximum n test cases\n./gen -n 100 -type random\n./gen -n 100 -type all_negative\n./gen -n 100 -type all_positive\n./gen -n 100 -type perfect_sequence\n./gen -n 100 -type reverse_sequence\n./gen -n 100 -type repeated_numbers\n./gen -n 100 -type zeros_and_ones\n./gen -n 100 -type multiple_ones\n./gen -n 100 -type off_by_one\n./gen -n 100 -type many_candidates\n\n# Edge cases\n./gen -n 99 -type random\n./gen -n 99 -type perfect_sequence\n./gen -n 99 -type reverse_sequence\n./gen -n 99 -type many_candidates\n./gen -n 99 -type zeros_and_ones\n./gen -n 99 -type multiple_ones\n\n# Additional small n\n./gen -n 3 -type zeros_and_ones\n./gen -n 3 -type off_by_one\n./gen -n 3 -type repeated_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:04.293785",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/C",
      "title": "C. Moon Craters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line has an integer n (1 ≤ n ≤ 2000) — the number of discovered craters. The next n lines contain crater descriptions in the \"ci ri\" format, where ci is the coordinate of the center of the crater on the moon robot’s path, ri is the radius of the crater. All the numbers ci and ri are positive integers not exceeding 109. No two craters coincide.",
      "output_spec": "OutputIn the first line output the number of craters in the required largest set. In the next line output space-separated numbers of craters that this set consists of. The craters are numbered from 1 to n in the order in which they were given in the input data. The numbers may be output in any order. If the result is not unique, output any.",
      "sample_tests": "ExamplesInputCopy41 12 24 15 1OutputCopy31 2 4",
      "description": "C. Moon Craters\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line has an integer n (1 ≤ n ≤ 2000) — the number of discovered craters. The next n lines contain crater descriptions in the \"ci ri\" format, where ci is the coordinate of the center of the crater on the moon robot’s path, ri is the radius of the crater. All the numbers ci and ri are positive integers not exceeding 109. No two craters coincide.\n\nOutputIn the first line output the number of craters in the required largest set. In the next line output space-separated numbers of craters that this set consists of. The craters are numbered from 1 to n in the order in which they were given in the input data. The numbers may be output in any order. If the result is not unique, output any.\n\nInputCopy41 12 24 15 1OutputCopy31 2 4\n\nInputCopy41 12 24 15 1\n\nOutputCopy31 2 4",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> craters;\n    for (int i = 0; i < n; i++) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(craters.count({ci, ri}) == 0, \"Two craters coincide at line %d\", i + 2);\n        craters.insert({ci, ri});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> craters;\n    for (int i = 0; i < n; i++) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(craters.count({ci, ri}) == 0, \"Two craters coincide at line %d\", i + 2);\n        craters.insert({ci, ri});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> craters;\n    for (int i = 0; i < n; i++) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(craters.count({ci, ri}) == 0, \"Two craters coincide at line %d\", i + 2);\n        craters.insert({ci, ri});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int n = inf.readInt();\n    vector<long long> c(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        c[i] = inf.readLong();\n        r[i] = inf.readLong();\n    }\n\n    // Read the maximum size from the judge's answer\n    int max_size = ans.readInt(1, n);\n\n    // Read participant's output\n    int participant_size = ouf.readInt(1, n, \"participant_size\");\n\n    if (participant_size != max_size) {\n        quitf(_wa, \"participant's set size (%d) is not equal to maximum possible size (%d)\", participant_size, max_size);\n    }\n\n    set<int> indices;\n    for (int i = 0; i < participant_size; ++i) {\n        int idx = ouf.readInt(1, n, format(\"crater index #%d\", i + 1).c_str());\n        if (indices.count(idx)) {\n            quitf(_wa, \"duplicate crater index %d\", idx);\n        }\n        indices.insert(idx);\n    }\n\n    vector<int> idx_list(indices.begin(), indices.end());\n\n    // Check the conditions for each pair of craters\n    for (size_t i = 0; i < idx_list.size(); ++i) {\n        for (size_t j = i + 1; j < idx_list.size(); ++j) {\n            int idx_i = idx_list[i] - 1; // 0-based index\n            int idx_j = idx_list[j] - 1;\n\n            long long ci = c[idx_i];\n            long long ri = r[idx_i];\n            long long cj = c[idx_j];\n            long long rj = r[idx_j];\n\n            long long dist = abs(ci - cj);\n\n            long long min_r = min(ri, rj);\n            long long max_r = max(ri, rj);\n\n            if (dist >= ri + rj || dist + min_r <= max_r) {\n                // Conditions are satisfied\n                continue;\n            } else {\n                // Craters intersect partially, which is not allowed\n                quitf(_wa, \"craters %d and %d intersect partially\", idx_i + 1, idx_j + 1);\n            }\n        }\n    }\n\n    // If all conditions are satisfied\n    quitf(_ok, \"participant's set is valid and has size %d\", participant_size);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<long long, long long>> craters; // Each crater is (ci, ri)\n\n    if (type == \"random\") {\n        // Generate n craters with random ci and ri\n        for (int i = 0; i < n; ++i) {\n            long long ci = rnd.next(1LL, 1000000000LL);\n            long long ri = rnd.next(1LL, 1000000000LL);\n            craters.push_back(make_pair(ci, ri));\n        }\n    } else if (type == \"nested\") {\n        // Generate craters nested within each other\n        long long c = 500000000LL; // Center position\n        long long max_radius = 1000000000LL;\n        long long min_radius = 1LL;\n        long long radius_step = max(1LL, (max_radius - min_radius) / n);\n        long long ri = max_radius;\n        for (int i = 0; i < n; ++i) {\n            craters.push_back(make_pair(c, ri));\n            ri = max(ri - radius_step, min_radius);\n        }\n    } else if (type == \"disjoint\") {\n        // Generate disjoint craters\n        long long ci = 1;\n        long long max_ci = 1000000000LL;\n        for (int i = 0; i < n; ++i) {\n            long long ri = rnd.next(1LL, 100000LL);\n            craters.push_back(make_pair(ci, ri));\n            ci += ri * 2 + rnd.next(1LL, 1000LL); // Ensure craters are disjoint\n            if (ci > max_ci - 1000000LL) {\n                ci = 1; // Wrap around if ci exceeds max\n            }\n        }\n    } else if (type == \"partial_overlap\") {\n        // Generate craters that partially overlap\n        long long ci = 1;\n        for (int i = 0; i < n; ++i) {\n            long long ri = 100000LL;\n            craters.push_back(make_pair(ci, ri));\n            ci += ri; // Set up partial overlaps\n        }\n    } else if (type == \"tangency\") {\n        // Generate craters that are tangent to each other\n        long long ci = 1;\n        for (int i = 0; i < n; ++i) {\n            long long ri = rnd.next(1LL, 100000LL);\n            craters.push_back(make_pair(ci, ri));\n            ci += ri + rnd.next(1LL, 1000LL); // Next crater starts where previous ends\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            long long ci = rnd.next(1LL, 1000000000LL);\n            long long ri = rnd.next(1LL, 1000000000LL);\n            craters.push_back(make_pair(ci, ri));\n        }\n    }\n\n    // Ensure there are no coinciding craters\n    set<pair<long long, long long>> unique_craters(craters.begin(), craters.end());\n    while (unique_craters.size() < craters.size()) {\n        // Regenerate duplicate craters\n        for (size_t i = 0; i < craters.size(); ++i) {\n            if (unique_craters.count(craters[i]) > 1) {\n                long long ci = rnd.next(1LL, 1000000000LL);\n                long long ri = rnd.next(1LL, 1000000000LL);\n                craters[i] = make_pair(ci, ri);\n            }\n        }\n        unique_craters.clear();\n        unique_craters.insert(craters.begin(), craters.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)craters.size());\n    // Output craters\n    for (int i = 0; i < craters.size(); ++i) {\n        printf(\"%lld %lld\\n\", craters[i].first, craters[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<long long, long long>> craters; // Each crater is (ci, ri)\n\n    if (type == \"random\") {\n        // Generate n craters with random ci and ri\n        for (int i = 0; i < n; ++i) {\n            long long ci = rnd.next(1LL, 1000000000LL);\n            long long ri = rnd.next(1LL, 1000000000LL);\n            craters.push_back(make_pair(ci, ri));\n        }\n    } else if (type == \"nested\") {\n        // Generate craters nested within each other\n        long long c = 500000000LL; // Center position\n        long long max_radius = 1000000000LL;\n        long long min_radius = 1LL;\n        long long radius_step = max(1LL, (max_radius - min_radius) / n);\n        long long ri = max_radius;\n        for (int i = 0; i < n; ++i) {\n            craters.push_back(make_pair(c, ri));\n            ri = max(ri - radius_step, min_radius);\n        }\n    } else if (type == \"disjoint\") {\n        // Generate disjoint craters\n        long long ci = 1;\n        long long max_ci = 1000000000LL;\n        for (int i = 0; i < n; ++i) {\n            long long ri = rnd.next(1LL, 100000LL);\n            craters.push_back(make_pair(ci, ri));\n            ci += ri * 2 + rnd.next(1LL, 1000LL); // Ensure craters are disjoint\n            if (ci > max_ci - 1000000LL) {\n                ci = 1; // Wrap around if ci exceeds max\n            }\n        }\n    } else if (type == \"partial_overlap\") {\n        // Generate craters that partially overlap\n        long long ci = 1;\n        for (int i = 0; i < n; ++i) {\n            long long ri = 100000LL;\n            craters.push_back(make_pair(ci, ri));\n            ci += ri; // Set up partial overlaps\n        }\n    } else if (type == \"tangency\") {\n        // Generate craters that are tangent to each other\n        long long ci = 1;\n        for (int i = 0; i < n; ++i) {\n            long long ri = rnd.next(1LL, 100000LL);\n            craters.push_back(make_pair(ci, ri));\n            ci += ri + rnd.next(1LL, 1000LL); // Next crater starts where previous ends\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            long long ci = rnd.next(1LL, 1000000000LL);\n            long long ri = rnd.next(1LL, 1000000000LL);\n            craters.push_back(make_pair(ci, ri));\n        }\n    }\n\n    // Ensure there are no coinciding craters\n    set<pair<long long, long long>> unique_craters(craters.begin(), craters.end());\n    while (unique_craters.size() < craters.size()) {\n        // Regenerate duplicate craters\n        for (size_t i = 0; i < craters.size(); ++i) {\n            if (unique_craters.count(craters[i]) > 1) {\n                long long ci = rnd.next(1LL, 1000000000LL);\n                long long ri = rnd.next(1LL, 1000000000LL);\n                craters[i] = make_pair(ci, ri);\n            }\n        }\n        unique_craters.clear();\n        unique_craters.insert(craters.begin(), craters.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)craters.size());\n    // Output craters\n    for (int i = 0; i < craters.size(); ++i) {\n        printf(\"%lld %lld\\n\", craters[i].first, craters[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type nested\n./gen -n 1 -type disjoint\n./gen -n 1 -type partial_overlap\n./gen -n 1 -type tangency\n\n./gen -n 2 -type random\n./gen -n 2 -type nested\n./gen -n 2 -type disjoint\n./gen -n 2 -type partial_overlap\n./gen -n 2 -type tangency\n\n./gen -n 10 -type random\n./gen -n 10 -type nested\n./gen -n 10 -type disjoint\n./gen -n 10 -type partial_overlap\n./gen -n 10 -type tangency\n\n./gen -n 100 -type random\n./gen -n 100 -type nested\n./gen -n 100 -type disjoint\n./gen -n 100 -type partial_overlap\n./gen -n 100 -type tangency\n\n./gen -n 500 -type random\n./gen -n 500 -type nested\n./gen -n 500 -type disjoint\n./gen -n 500 -type partial_overlap\n./gen -n 500 -type tangency\n\n./gen -n 1000 -type random\n./gen -n 1000 -type nested\n./gen -n 1000 -type disjoint\n./gen -n 1000 -type partial_overlap\n./gen -n 1000 -type tangency\n\n./gen -n 2000 -type random\n./gen -n 2000 -type nested\n./gen -n 2000 -type disjoint\n./gen -n 2000 -type partial_overlap\n./gen -n 2000 -type tangency\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:06.433154",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/D",
      "title": "D. Cubical Planet",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers (0 or 1) — the coordinates of the first fly, the second line analogously contains the coordinates of the second fly.",
      "output_spec": "OutputOutput \"YES\" (without quotes) if the flies see each other. Otherwise, output \"NO\".",
      "sample_tests": "ExamplesInputCopy0 0 00 1 0OutputCopyYESInputCopy1 1 00 1 0OutputCopyYESInputCopy0 0 01 1 1OutputCopyNO",
      "description": "D. Cubical Planet\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers (0 or 1) — the coordinates of the first fly, the second line analogously contains the coordinates of the second fly.\n\nOutputOutput \"YES\" (without quotes) if the flies see each other. Otherwise, output \"NO\".\n\nInputCopy0 0 00 1 0OutputCopyYESInputCopy1 1 00 1 0OutputCopyYESInputCopy0 0 01 1 1OutputCopyNO\n\nInputCopy0 0 00 1 0\n\nOutputCopyYES\n\nInputCopy1 1 00 1 0\n\nOutputCopyYES\n\nInputCopy0 0 01 1 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> a = inf.readInts(3, 0, 1, \"coordinates of first fly\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(3, 0, 1, \"coordinates of second fly\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    ensuref(a != b, \"The two flies cannot be at the same vertex\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> a = inf.readInts(3, 0, 1, \"coordinates of first fly\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(3, 0, 1, \"coordinates of second fly\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    ensuref(a != b, \"The two flies cannot be at the same vertex\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> a = inf.readInts(3, 0, 1, \"coordinates of first fly\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(3, 0, 1, \"coordinates of second fly\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    ensuref(a != b, \"The two flies cannot be at the same vertex\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int x1, y1, z1, x2, y2, z2;\n\n    if (type == \"yes\") {\n        // Flies see each other (on the same face).\n        // Randomly choose an axis: 0 for x, 1 for y, 2 for z\n        int axis = rnd.next(3);\n        int coord_equal = rnd.next(2); // 0 or 1\n\n        if (axis == 0) {\n            x1 = x2 = coord_equal;\n            y1 = rnd.next(2);\n            z1 = rnd.next(2);\n            do {\n                y2 = rnd.next(2);\n                z2 = rnd.next(2);\n            } while (y1 == y2 && z1 == z2); // Ensure different vertices\n        } else if (axis == 1) {\n            y1 = y2 = coord_equal;\n            x1 = rnd.next(2);\n            z1 = rnd.next(2);\n            do {\n                x2 = rnd.next(2);\n                z2 = rnd.next(2);\n            } while (x1 == x2 && z1 == z2);\n        } else {\n            z1 = z2 = coord_equal;\n            x1 = rnd.next(2);\n            y1 = rnd.next(2);\n            do {\n                x2 = rnd.next(2);\n                y2 = rnd.next(2);\n            } while (x1 == x2 && y1 == y2);\n        }\n    } else if (type == \"no\") {\n        // Flies do not see each other (on different faces)\n        // Ensure that x1 != x2, y1 != y2, and z1 != z2\n        do {\n            x1 = rnd.next(2);\n            x2 = rnd.next(2);\n        } while (x1 == x2);\n        do {\n            y1 = rnd.next(2);\n            y2 = rnd.next(2);\n        } while (y1 == y2);\n        do {\n            z1 = rnd.next(2);\n            z2 = rnd.next(2);\n        } while (z1 == z2);\n    } else if (type == \"random\") {\n        // Random positions for both flies, ensuring they are different\n        x1 = rnd.next(2);\n        y1 = rnd.next(2);\n        z1 = rnd.next(2);\n        do {\n            x2 = rnd.next(2);\n            y2 = rnd.next(2);\n            z2 = rnd.next(2);\n        } while (x1 == x2 && y1 == y2 && z1 == z2);\n    } else if (type == \"special1\") {\n        // Flies at opposite corners\n        x1 = 0; y1 = 0; z1 = 0;\n        x2 = 1; y2 = 1; z2 = 1;\n    } else if (type == \"special2\") {\n        // Flies on the same face x=0\n        x1 = 0; y1 = 0; z1 = 0;\n        x2 = 0; y2 = 1; z2 = 1;\n    } else if (type == \"special3\") {\n        // Flies on the same face y=0\n        x1 = 1; y1 = 0; z1 = 1;\n        x2 = 0; y2 = 0; z2 = 0;\n    } else if (type == \"special4\") {\n        // Flies on the same face z=0\n        x1 = 0; y1 = 0; z1 = 0;\n        x2 = 1; y2 = 1; z2 = 0;\n    } else if (type == \"special5\") {\n        // Flies not on the same face\n        x1 = 0; y1 = 1; z1 = 0;\n        x2 = 1; y2 = 0; z2 = 1;\n    } else if (type == \"special6\") {\n        // Flies on adjacent edges\n        x1 = 0; y1 = 0; z1 = 1;\n        x2 = 1; y2 = 0; z2 = 1;\n    } else if (type == \"special7\") {\n        // Flies on the same face z=1\n        x1 = 1; y1 = 0; z1 = 1;\n        x2 = 1; y2 = 1; z2 = 1;\n    } else if (type == \"special8\") {\n        // Flies not on the same face\n        x1 = 1; y1 = 0; z1 = 0;\n        x2 = 0; y2 = 1; z2 = 1;\n    } else {\n        // Default to random\n        x1 = rnd.next(2);\n        y1 = rnd.next(2);\n        z1 = rnd.next(2);\n        do {\n            x2 = rnd.next(2);\n            y2 = rnd.next(2);\n            z2 = rnd.next(2);\n        } while (x1 == x2 && y1 == y2 && z1 == z2);\n    }\n\n    printf(\"%d %d %d\\n\", x1, y1, z1);\n    printf(\"%d %d %d\\n\", x2, y2, z2);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int x1, y1, z1, x2, y2, z2;\n\n    if (type == \"yes\") {\n        // Flies see each other (on the same face).\n        // Randomly choose an axis: 0 for x, 1 for y, 2 for z\n        int axis = rnd.next(3);\n        int coord_equal = rnd.next(2); // 0 or 1\n\n        if (axis == 0) {\n            x1 = x2 = coord_equal;\n            y1 = rnd.next(2);\n            z1 = rnd.next(2);\n            do {\n                y2 = rnd.next(2);\n                z2 = rnd.next(2);\n            } while (y1 == y2 && z1 == z2); // Ensure different vertices\n        } else if (axis == 1) {\n            y1 = y2 = coord_equal;\n            x1 = rnd.next(2);\n            z1 = rnd.next(2);\n            do {\n                x2 = rnd.next(2);\n                z2 = rnd.next(2);\n            } while (x1 == x2 && z1 == z2);\n        } else {\n            z1 = z2 = coord_equal;\n            x1 = rnd.next(2);\n            y1 = rnd.next(2);\n            do {\n                x2 = rnd.next(2);\n                y2 = rnd.next(2);\n            } while (x1 == x2 && y1 == y2);\n        }\n    } else if (type == \"no\") {\n        // Flies do not see each other (on different faces)\n        // Ensure that x1 != x2, y1 != y2, and z1 != z2\n        do {\n            x1 = rnd.next(2);\n            x2 = rnd.next(2);\n        } while (x1 == x2);\n        do {\n            y1 = rnd.next(2);\n            y2 = rnd.next(2);\n        } while (y1 == y2);\n        do {\n            z1 = rnd.next(2);\n            z2 = rnd.next(2);\n        } while (z1 == z2);\n    } else if (type == \"random\") {\n        // Random positions for both flies, ensuring they are different\n        x1 = rnd.next(2);\n        y1 = rnd.next(2);\n        z1 = rnd.next(2);\n        do {\n            x2 = rnd.next(2);\n            y2 = rnd.next(2);\n            z2 = rnd.next(2);\n        } while (x1 == x2 && y1 == y2 && z1 == z2);\n    } else if (type == \"special1\") {\n        // Flies at opposite corners\n        x1 = 0; y1 = 0; z1 = 0;\n        x2 = 1; y2 = 1; z2 = 1;\n    } else if (type == \"special2\") {\n        // Flies on the same face x=0\n        x1 = 0; y1 = 0; z1 = 0;\n        x2 = 0; y2 = 1; z2 = 1;\n    } else if (type == \"special3\") {\n        // Flies on the same face y=0\n        x1 = 1; y1 = 0; z1 = 1;\n        x2 = 0; y2 = 0; z2 = 0;\n    } else if (type == \"special4\") {\n        // Flies on the same face z=0\n        x1 = 0; y1 = 0; z1 = 0;\n        x2 = 1; y2 = 1; z2 = 0;\n    } else if (type == \"special5\") {\n        // Flies not on the same face\n        x1 = 0; y1 = 1; z1 = 0;\n        x2 = 1; y2 = 0; z2 = 1;\n    } else if (type == \"special6\") {\n        // Flies on adjacent edges\n        x1 = 0; y1 = 0; z1 = 1;\n        x2 = 1; y2 = 0; z2 = 1;\n    } else if (type == \"special7\") {\n        // Flies on the same face z=1\n        x1 = 1; y1 = 0; z1 = 1;\n        x2 = 1; y2 = 1; z2 = 1;\n    } else if (type == \"special8\") {\n        // Flies not on the same face\n        x1 = 1; y1 = 0; z1 = 0;\n        x2 = 0; y2 = 1; z2 = 1;\n    } else {\n        // Default to random\n        x1 = rnd.next(2);\n        y1 = rnd.next(2);\n        z1 = rnd.next(2);\n        do {\n            x2 = rnd.next(2);\n            y2 = rnd.next(2);\n            z2 = rnd.next(2);\n        } while (x1 == x2 && y1 == y2 && z1 == z2);\n    }\n\n    printf(\"%d %d %d\\n\", x1, y1, z1);\n    printf(\"%d %d %d\\n\", x2, y2, z2);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type special1\n./gen -type special2\n./gen -type special3\n./gen -type special4\n./gen -type special5\n./gen -type special6\n./gen -type special7\n./gen -type special8\n./gen -type yes\n./gen -type yes\n./gen -type yes\n./gen -type yes\n./gen -type yes\n./gen -type no\n./gen -type no\n./gen -type no\n./gen -type no\n./gen -type no\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:08.881322",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/E",
      "title": "E. При чем тут Дирихле?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ единственной строке входного файла записано три целых числа a, b, n (1 ≤ a ≤ 10000, 1 ≤ b ≤ 30, 2 ≤ n ≤ 109) — начальное число коробок, предметов и число, ограничивающее количество способов, соответственно. Гарантируется, что изначальное количество способов строго меньше n.",
      "output_spec": "Выходные данныеВыведите «Stas», если победит Маша. Выведите «Masha», если победит Стас. Если будет ничья, то выведите «Missing».",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 10Выходные данныеСкопироватьMashaВходные данныеСкопировать5 5 16808Выходные данныеСкопироватьMashaВходные данныеСкопировать3 1 4Выходные данныеСкопироватьStasВходные данныеСкопировать1 4 10Выходные данныеСкопироватьMissing",
      "description": "E. При чем тут Дирихле?\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входного файла записано три целых числа a, b, n (1 ≤ a ≤ 10000, 1 ≤ b ≤ 30, 2 ≤ n ≤ 109) — начальное число коробок, предметов и число, ограничивающее количество способов, соответственно. Гарантируется, что изначальное количество способов строго меньше n.\n\nВходные данные\n\nВыходные данныеВыведите «Stas», если победит Маша. Выведите «Masha», если победит Стас. Если будет ничья, то выведите «Missing».\n\nВыходные данные\n\nВходные данныеСкопировать2 2 10Выходные данныеСкопироватьMashaВходные данныеСкопировать5 5 16808Выходные данныеСкопироватьMashaВходные данныеСкопировать3 1 4Выходные данныеСкопироватьStasВходные данныеСкопировать1 4 10Выходные данныеСкопироватьMissing\n\nВходные данныеСкопировать2 2 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьMasha\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 5 16808\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьMasha\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьStas\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 4 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьMissing\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере первоначальное количество способов равно 3125.   Если Стас увеличит число коробок, то проиграет, так как Маша следующим ходом может еще раз увеличить число коробок. После этого любой ход Стаса приведет к поражению.  Если же Стас увеличит число предметов, то любой машин ход будет проигрышным.",
      "solutions": [
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces",
          "content": "Добрый день всем!Приглашаем всех на Школьную командную олимпиаду #1, которая состоится 24 октября в 11:00 MSK. Соревнование будет официальным для команд школьников, как часть серии школьных заочных олимпиад ЗКШ (http://codeforces.com/blog/entry/753), и неофициальным (и не рейтинговым!) для всех остальных.Чтобы принять участие официально, каждый участник школьной команды должен сначала зарегистрироваться лично, затем из зарегистрированных участников нужно создать команду и, когда будет открыта регистрация на соревнование, зарегистрировать команду еще и там.Надеюсь, что задачи окажутся интересными для школьников с разным уровнем подготовки в программировании, и не только для школьников! Обратите внимание на некоторые отличия от обычных соревнований на Codeforces. Во-первых, продолжительность соревнования 5 часов, и будут стандартные правила ACM ICPC. Во-вторых, задачи не будут идти в порядке возрастания сложности, они будут перемешаны. Поэтому ваша первая задача - найти простую задачу :)Авторы задач - Михаил Мирзаянов и я. Спасибо Геральду Агапову, Полине Бондаренко  и Артему Рахову, которые помогали мне готовить раунд. Также спасибо Марии Беловой за перевод условий задач на английский язык. Мы все - сотрудники и студенты Саратовского Государственного Университета.Удачи!P.S. Будьте внимательны при регистрации на соревнование. Аккуратно читайте все всплывающие сообщения. Для участия в конкурсе должна быть зарегистрирована команда, все члены которой зарегистрировались для участия в серии. В команду должны быть приглашены (и подтвердить свое участие) все те, кто собирается писать соревнование.UPD: Как только начнется соревнование, то будут доступны задачи в PDF (для печати):Русская версияАнглийская версияUPD: Соревнование завешено. Доступны результаты.Победителем и в официальном, и в общем зачете стал Gennady Korotkevich, решивший все задачи. Поздравляем победителя! Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1916
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задач - Codeforces",
          "content": "Задача АДля получения максимального возможного результата нужно просто отсортировать слагаемые в порядке неубывания коэффициентов (коэффициенты учитываются со стоящими перед ними знаками + и -). Не нужно обращать внимание на a++ или ++a! Вопрос заключается в том, почему это правильно.Во-первых, рассмотрим выражение, содержащее только a++. Тогда наше утверждение очевидно: выгодно умножать 'a' на маленькие коэффициенты, пока значение 'a' маленькое, и на большие коэффициенты, когда оно становится больше. То же самое происходит в случае трицательных значений коэффициентов или 'a'. Конечно, это не строгое доказательство. Я надеюсь, что вы еще подумаете над ним, если пока не поняли.Во-вторых, рассмотрим выражение k*a+++k*++a, где k - некотрый коэффициент, одинаковый для обоих слагаемых. Пусть начальное значение 'a' равно a0. Вычисляя значение выражения обоими способами, получаем: k * a0 + k * (a0 + 2) =  k * (a0 + 1) + k * (a0 + 1). Поэтому в данном случае порядок неважен.В-третьих, пусть наше выражение k*a+++l*++a, где k и l - различные коэффициенты. Это выражение может принимать два разных значения k * a0 + l * (a0 + 2) и k * (a0 + 1) + l * (a0 + 1). Первое значение больше второго тогда и только тогда, когда k < l. Аналогично можно рассмотреть выражение k*a+++l*++a.Таким образом, если имеются два последовательных слагаемых с одним и тем же коэффициентом, мы можем переставлять или не переставлять их. Если имеются два последовательных слагаемых с различными коэффициентами, мы должны поставить раньше то слагаемое, у которого коэффициент меньше. Применяя эти рассуждения, пока необходимо, получаем последовательность слагаемых отсортированных по коэффициентам. Задача BЭта задача решается жадно. Будем перебирать заданные числа последовательно, пока не встретим 1. Затем продолжим перебирать числа в поиске числа 2, потом 3, и т.д.Задача САвторское решение работает за O(n2) по времени и требует O(n2) памяти. Также проходили решения за времени и с O(n) памяти.Переформулируем задачу. Дано множество отрезков на прямой, и нужно найти максимальное его подмножество, такое, что отрезки в нем не пересекаются 'частично'. Два отрезка [a, b] и [c, d] пересекаются частично, если, например, a < c < b < d.Возьмем все концы данных трезков, отсортируем их и посчитаем динамику: dl, r --- максимальный возможный размер подмножества, отрезки в котором не пересекаются частично и расположены между l-м и r-м концом (в отсортированном порядке) включительно. Мы хотим вычислять dl, r, имея уже посчитанные значения di, j для всех l ≤ i ≤ j ≤ r, но [i, j] ≠ [l, r]. Сначала положим dl, r = dl + 1, r, если мы не берем отрезки с левым концом в l. Если существует отрезок [l, r], мы обязательно включаем его в наше множество. Если мы берем другой отрезок, скажем, [l, i], где i < r, посмотрим на отрезки [l, i] и [i, r] (для них ответ уже посчитан) и попытаемся изменить значение dl, r. Асимптотика решения O(n2), потому что общее количество левых концов O(n). Затем необходимо вывести сертификат, т.е. само оптимальное множество. Это делается стандартным образом.Задача DМухи НЕ могут видеть друг друга тогда и только тогда, когда они в противоположных вершинах. Существует  несколько способов проверить это. Например, можно проверить манхеттенское расстояние |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 или евклидово расстояние . Можно проверить, что все три координаты различны (x1 != x2) && (y1 != y2) && (z1 != z2) или просто (x1^x2)+(y1^y2)+(z1^z2) == 3!Задача EКоличество способов разложить b предметов по a коробкам, конечно же, ab. У нас имеется ациклическая игра для двух игроков с состояниями (a, b), для  которых ab < n. К сожалению, существует бесконечное количество таких состояний: a = 1, b любое. Но в этом случае, если 2b ≥ n, позиция является ничейной, потому что единственный способ действия для обоих игроков (не приводящий к поражению) - увеличивать b бесконечно.Другой отдельный случай возникает для позиции с b = 1 и достаточно большого a. А именно, если , имеется также только один ход из этой позиции - увеличивать a. Если a = n - 1, то позиция проигрышная, если a = n - 2 - она выигрышная, при a = n - 3 снова проигрышная и т.д.Итак, имеется два вида состояний, которые нужно обрабатывать отдельно. Количество остальных состояний не очень большое, и для них можно вычислять стандартную динамику для игр на ациклических графах.Задача FПростое моделирование прыжков лягушек работает слишком долго, потому что n может быть 109. Правильное решение состоит в том, чтобы посчитать для каждой лягушки количество раздавленных комаров путем проверки делимости номеров кочек с комарами на di.Задача GЧто можно сказать про задачу G? Нужно провести разбор данной функции и вычислить ее значение при всех значениях n. Разумеется, это невозможно сделать путем простой реализации рекурсии, потому что она может работать слишком долго (см. пример с последовательностью Фибоначчи). Поэтому нужно использовать динамическое программирование.Задача HНужно вычислить все произведения i * j и вывести их в состеме счисления с основанием k.Задача IРассмотрим только ту часть графа, которая достижима из вершины 1. Задача состоит в том, чтобы найти наибольшее такое t, чо выбранное множество вершин достижимо только в моменты времени, кратные t. Предположим, мы построили искомое множество S0. Рассмотрим множества S1, S2 ..., St - 1 всех вершин, достижимых в моменты времени, имеющие остатки 1, 2, ..., t - 1 по модулю t, соответственно. Нетрудно проверить, что эти множества не пересекаются и их объединение совпадает со всем множеством достижимых вершин. Ясно, что ребро из u в v может существовать только в том случае, когда u и v принадлежат последовательным множествам, т.е. , , k + 1 берется по модулю t.Для каждой вершины v посчитаем расстояние dv от 1 до v (если существует несколько путей, выберите любой, например, с помощью обхода в глубину). Если из u в v существует ребро, должно выполняться . Анализируя все ребра, мы приходим к заключению, что оптимальное значение t равно наибольшему общему делителю чисел |du + 1 - dv|. Теперь нетрудно райти множетсво S0.Задача JСамое простое решение - найти два числа l и r - длину наибольшего общего префикса и длину наибольшего общего суффикса двух строк, соответственно. Если l + 1 < n - r, решения нет. Здесь n - длина первой строки. Иначе нужно выдать позиции с max(n - r, 1) до min(l + 1, n). Задача KЗадача К имеет огромное количество различных решений, поэтому мне удивительно, почему их было так мало во время соревнования. Проходили решения за O(k4) и даже некоторые решения за O(k5) с оптимизациями, но KADR предложил решение даже лучше, работающее за O(k3) (http://codeforces.com/blog/entry/793).Здесь я приведу некоторые идеи жюри по этой задаче. В первую очередь сожмем координаты. Отметим по одной точке внутри каждого объекта и стандартной динамикой посчитаем количество отмеченных точек внутри каждого прямоугольника. Обработка всех возможных прямоугольников занимает O(k4). Возникает проблема с тем, что прямоугольник может содержать правильное количество объектов, но содержать некоторые объекты не полностью. Чтобы это предотвратить, проверим границы. Они являются отрезками, параллельными осям координат, и их количество O(k3). Поэтому мы можем предподсчитать, корректны они или нет, сравнивая их с каждым объектом. Затем нужно вернуться к несжатым координатам.Следующее решение за O(k5), и оно использует ограничение на количество объектов (3) в прямоугольнике. Обработаем все тройки объектов (то же самое, разумеется, для пар и до объектов по одному). Фиксируем тройку и заменим ее одним большим объектом. Затем будем двигаться от получившегося объекта вверх (и вниз), проверяя, может ли строка вверху (внизу) быть включена в пораженный прямоугольник. Для каждой строки выберем наибольший отрезок [l, r], содержащий текущий большой объект и не содержащий ничего больше. Используя эту информацию, нетрудно посчитать общее количество прямоугольников, содержащих данную тройку.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 7948
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задачи К - Codeforces",
          "content": "Предположим, что верхняя и нижняя стороны прямоугольника фиксированы и нам осталось только выбрать левую и правую стороны. Тогда мы за О(К) можем найти список всех прямоугольников, которые попадают в нашу полосу, а так же список всех прямоугольников, у которых только часть попадает в полосу. Тогда мы можем представить это в виде отсортированного набора отрезков [l,r], где l и r - икс координаты левой и правой сторон прямоугольника.Если какие-то отрезки в нашем наборе имеют общую точку - склеим их в один большой отрезок и запомним что теперь в нем на самом деле два отрезка. Таким образом, после того как мы склеили все отрезки, у нас получится какой-то набор отрезков, для каждого из которых известно количество прямоугольников, которые им покрываются (если в нем есть прямоугольник, который не лежит полностью в нашей полосе, то будем считать что такой отрезок содержит бесконечное количество прямоугольников). Теперь мы можем пройти по всем свободным отрезкам (находящимся между соседними отрезками из нашего набора) и посчитать количество способов покрыть их отрезком в котором лежит не более трех объектов (для этого будем помнить только те свободные отрезки, которые отделены от текущего не более чем тремя объектами).Таким образом, мы уже имеем решение за O(N2K): перебрать все возможные горизонтальные полосы и в каждой за О(К) посчитать количество прямоугольников, которые покрывают от 1 до 3 объектов. Заметим, что если, например, верхняя сторона полосы не прилегает ни к какому из объектов, то мы можем ее сдвинуть вверх либо вниз и ответ для полосы не изменится. Следовательно, можно перебирать в качестве границ полосы только те строки, в которых есть хотя бы одна клетка, принадлежащая объекту, а затем домножать полученный ответ на расстояния до ближайших \"не пустых\" строк снизу и сверху.Таким образом, мы получили решение работающее за O(K3) и не зависящее ни от размеров поля, ни от ограничения на максимальное количество покрываемых объектов.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1966
        }
      ],
      "code_examples": [
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 1",
          "code": "5\n4 2\n6 2\n7 3\n3 3\n5 1\nG, 33:55\nint f(int n)\n{\nif (n < 2) return 0;if (f(n-1) == f(n-2)) return f(n-2)+1;return f(n-1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 2",
          "code": "5\n4 2\n6 2\n7 3\n3 3\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 3",
          "code": "55\nint f(int n)\n{\nif (n < 2) return 0;if (f(n-1) == f(n-2)) return f(n-2)+1;return f(n-1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 4",
          "code": "#include <cstdlib>\n#include <cstdio>\n\nint main() {\n  char *s = \"123+456\";\n  printf(\"%d + %d\\n\", atoi(s), atoi(s + 4));\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 5",
          "code": "17\nint f(int n){if (n > 1000) return n/n;if (n > 100) return n/2;if (n > 10) return n; return 7;}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 6",
          "code": "2 1 536870912",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 7",
          "code": "10 10 5\n..**......\n..**.....*\n..**..**.*\n......**.*\n......**.*\n***......*\n***......*\n..........\n..........\n...******.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задач - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLessThan(int a, int b, int n) {\n    long long c = 1;\n    for (int i = 0; i < b; ++i) {\n        c *= a;\n        if (c >= (long long)n) return false;\n    }\n    return true; // c < n\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 30, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readEoln();\n\n    ensuref(isLessThan(a, b, n), \"Initial number of ways a^b should be less than n\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLessThan(int a, int b, int n) {\n    long long c = 1;\n    for (int i = 0; i < b; ++i) {\n        c *= a;\n        if (c >= (long long)n) return false;\n    }\n    return true; // c < n\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 30, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readEoln();\n\n    ensuref(isLessThan(a, b, n), \"Initial number of ways a^b should be less than n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLessThan(int a, int b, int n) {\n    long long c = 1;\n    for (int i = 0; i < b; ++i) {\n        c *= a;\n        if (c >= (long long)n) return false;\n    }\n    return true; // c < n\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 30, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readEoln();\n\n    ensuref(isLessThan(a, b, n), \"Initial number of ways a^b should be less than n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerLT(int a, int b, int n) {\n    long long res = 1;\n    for(int i = 0; i < b; i++) {\n        if (res > n / a) return false; // res * a would exceed n\n        res *= a;\n    }\n    return res < n;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    // Optional parameters\n    int max_a = opt<int>(\"max_a\", 10000);\n    int max_b = opt<int>(\"max_b\", 30);\n    int n = opt<int>(\"n\", rnd.next(2, int(1e9)));\n    int a, b;\n\n    if (type == \"special\") {\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n    } else if (type == \"small\") {\n        a = rnd.next(1, min(max_a, 10));\n        b = rnd.next(1, min(max_b, 5));\n    } else if (type == \"min_a\") {\n        a = 1;\n        b = rnd.next(1, max_b);\n    } else if (type == \"min_b\") {\n        a = rnd.next(1, max_a);\n        b = 1;\n    } else if (type == \"max_a\") {\n        a = max_a;\n        b = rnd.next(1, max_b);\n    } else if (type == \"max_b\") {\n        a = rnd.next(1, max_a);\n        b = max_b;\n    } else if (type == \"near_threshold\") {\n        b = rnd.next(1, max_b);\n        double a_real = pow(n - 1, 1.0 / b);\n        a = int(floor(a_real));\n        if (a < 1) a = 1;\n        while (!isPowerLT(a, b, n)) {\n            a -= 1;\n            if (a == 0) break;\n        }\n        if (a < 1) {\n            a = 1;\n            b = rnd.next(1, b - 1);\n        }\n    } else { // random\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    }\n\n    // Ensure that a^b < n\n    while (!isPowerLT(a, b, n)) {\n        if (type == \"min_a\" || type == \"max_a\") {\n            b = max(1, b - 1);\n        } else if (type == \"min_b\" || type == \"max_b\") {\n            a = max(1, a - 1);\n        } else {\n            if (rnd.next(2)) {\n                if (a > 1) a--;\n            } else {\n                if (b > 1) b--;\n            }\n        }\n        if (a == 1 && b == 1) break;\n    }\n\n    printf(\"%d %d %d\\n\", a, b, n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerLT(int a, int b, int n) {\n    long long res = 1;\n    for(int i = 0; i < b; i++) {\n        if (res > n / a) return false; // res * a would exceed n\n        res *= a;\n    }\n    return res < n;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    // Optional parameters\n    int max_a = opt<int>(\"max_a\", 10000);\n    int max_b = opt<int>(\"max_b\", 30);\n    int n = opt<int>(\"n\", rnd.next(2, int(1e9)));\n    int a, b;\n\n    if (type == \"special\") {\n        a = opt<int>(\"a\");\n        b = opt<int>(\"b\");\n    } else if (type == \"small\") {\n        a = rnd.next(1, min(max_a, 10));\n        b = rnd.next(1, min(max_b, 5));\n    } else if (type == \"min_a\") {\n        a = 1;\n        b = rnd.next(1, max_b);\n    } else if (type == \"min_b\") {\n        a = rnd.next(1, max_a);\n        b = 1;\n    } else if (type == \"max_a\") {\n        a = max_a;\n        b = rnd.next(1, max_b);\n    } else if (type == \"max_b\") {\n        a = rnd.next(1, max_a);\n        b = max_b;\n    } else if (type == \"near_threshold\") {\n        b = rnd.next(1, max_b);\n        double a_real = pow(n - 1, 1.0 / b);\n        a = int(floor(a_real));\n        if (a < 1) a = 1;\n        while (!isPowerLT(a, b, n)) {\n            a -= 1;\n            if (a == 0) break;\n        }\n        if (a < 1) {\n            a = 1;\n            b = rnd.next(1, b - 1);\n        }\n    } else { // random\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    }\n\n    // Ensure that a^b < n\n    while (!isPowerLT(a, b, n)) {\n        if (type == \"min_a\" || type == \"max_a\") {\n            b = max(1, b - 1);\n        } else if (type == \"min_b\" || type == \"max_b\") {\n            a = max(1, a - 1);\n        } else {\n            if (rnd.next(2)) {\n                if (a > 1) a--;\n            } else {\n                if (b > 1) b--;\n            }\n        }\n        if (a == 1 && b == 1) break;\n    }\n\n    printf(\"%d %d %d\\n\", a, b, n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small -n 10\n./gen -type small -n 100\n./gen -type small -n 1000\n\n./gen -type min_a -n 1000000000\n./gen -type min_b -n 1000000000\n\n./gen -type max_a -n 1000000000\n./gen -type max_b -n 1000000000\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type near_threshold -n 1000000000\n./gen -type near_threshold -n 500000000\n./gen -type near_threshold -n 123456789\n./gen -type near_threshold -n 1000000\n\n./gen -type random -max_a 1 -max_b 30\n./gen -type random -max_a 10000 -max_b 1\n\n./gen -type random -max_a 2 -max_b 30\n./gen -type random -max_a 10000 -max_b 2\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max_a -n 1000000000\n./gen -type max_b -n 1000000000\n\n./gen -type min_a -n 2\n./gen -type min_b -n 2\n\n./gen -type special -a 2 -b 2 -n 10\n./gen -type special -a 5 -b 5 -n 16808\n./gen -type special -a 3 -b 1 -n 4\n./gen -type special -a 1 -b 4 -n 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:11.504177",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/F",
      "title": "F. Лягушки-пацифисты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке заданы три целых числа n, m и k (1 ≤ n ≤ 109, 1 ≤ m, k ≤ 100) — количество кочек, лягушек и комаров соответственно. Во второй строке содержатся m целых чисел di (1 ≤ di ≤ 109) — длины прыжков лягушек. В третьей строке записаны k целых чисел — номера кочек, на которых спит каждый комар. На одной кочке может спать не более одного комара. Числа в строках разделены одиночными пробелами.",
      "output_spec": "Выходные данныеВ первой строке выведите количество лягушек, которые задавят наименьшее число комаров, во второй — их номера в порядке возрастания, разделенные пробелами. Лягушки номеруются числами от 1 до m в порядке задания длин их прыжков во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 3 52 3 41 2 3 4 5Выходные данныеСкопировать22 3Входные данныеСкопировать1000000000 2 32 5999999995 999999998 999999996Выходные данныеСкопировать12",
      "description": "F. Лягушки-пацифисты\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы три целых числа n, m и k (1 ≤ n ≤ 109, 1 ≤ m, k ≤ 100) — количество кочек, лягушек и комаров соответственно. Во второй строке содержатся m целых чисел di (1 ≤ di ≤ 109) — длины прыжков лягушек. В третьей строке записаны k целых чисел — номера кочек, на которых спит каждый комар. На одной кочке может спать не более одного комара. Числа в строках разделены одиночными пробелами.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите количество лягушек, которые задавят наименьшее число комаров, во второй — их номера в порядке возрастания, разделенные пробелами. Лягушки номеруются числами от 1 до m в порядке задания длин их прыжков во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать5 3 52 3 41 2 3 4 5Выходные данныеСкопировать22 3Входные данныеСкопировать1000000000 2 32 5999999995 999999998 999999996Выходные данныеСкопировать12\n\nВходные данныеСкопировать5 3 52 3 41 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать22 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1000000000 2 32 5999999995 999999998 999999996\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces",
          "content": "Добрый день всем!Приглашаем всех на Школьную командную олимпиаду #1, которая состоится 24 октября в 11:00 MSK. Соревнование будет официальным для команд школьников, как часть серии школьных заочных олимпиад ЗКШ (http://codeforces.com/blog/entry/753), и неофициальным (и не рейтинговым!) для всех остальных.Чтобы принять участие официально, каждый участник школьной команды должен сначала зарегистрироваться лично, затем из зарегистрированных участников нужно создать команду и, когда будет открыта регистрация на соревнование, зарегистрировать команду еще и там.Надеюсь, что задачи окажутся интересными для школьников с разным уровнем подготовки в программировании, и не только для школьников! Обратите внимание на некоторые отличия от обычных соревнований на Codeforces. Во-первых, продолжительность соревнования 5 часов, и будут стандартные правила ACM ICPC. Во-вторых, задачи не будут идти в порядке возрастания сложности, они будут перемешаны. Поэтому ваша первая задача - найти простую задачу :)Авторы задач - Михаил Мирзаянов и я. Спасибо Геральду Агапову, Полине Бондаренко  и Артему Рахову, которые помогали мне готовить раунд. Также спасибо Марии Беловой за перевод условий задач на английский язык. Мы все - сотрудники и студенты Саратовского Государственного Университета.Удачи!P.S. Будьте внимательны при регистрации на соревнование. Аккуратно читайте все всплывающие сообщения. Для участия в конкурсе должна быть зарегистрирована команда, все члены которой зарегистрировались для участия в серии. В команду должны быть приглашены (и подтвердить свое участие) все те, кто собирается писать соревнование.UPD: Как только начнется соревнование, то будут доступны задачи в PDF (для печати):Русская версияАнглийская версияUPD: Соревнование завешено. Доступны результаты.Победителем и в официальном, и в общем зачете стал Gennady Korotkevich, решивший все задачи. Поздравляем победителя! Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1916
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задач - Codeforces",
          "content": "Задача АДля получения максимального возможного результата нужно просто отсортировать слагаемые в порядке неубывания коэффициентов (коэффициенты учитываются со стоящими перед ними знаками + и -). Не нужно обращать внимание на a++ или ++a! Вопрос заключается в том, почему это правильно.Во-первых, рассмотрим выражение, содержащее только a++. Тогда наше утверждение очевидно: выгодно умножать 'a' на маленькие коэффициенты, пока значение 'a' маленькое, и на большие коэффициенты, когда оно становится больше. То же самое происходит в случае трицательных значений коэффициентов или 'a'. Конечно, это не строгое доказательство. Я надеюсь, что вы еще подумаете над ним, если пока не поняли.Во-вторых, рассмотрим выражение k*a+++k*++a, где k - некотрый коэффициент, одинаковый для обоих слагаемых. Пусть начальное значение 'a' равно a0. Вычисляя значение выражения обоими способами, получаем: k * a0 + k * (a0 + 2) =  k * (a0 + 1) + k * (a0 + 1). Поэтому в данном случае порядок неважен.В-третьих, пусть наше выражение k*a+++l*++a, где k и l - различные коэффициенты. Это выражение может принимать два разных значения k * a0 + l * (a0 + 2) и k * (a0 + 1) + l * (a0 + 1). Первое значение больше второго тогда и только тогда, когда k < l. Аналогично можно рассмотреть выражение k*a+++l*++a.Таким образом, если имеются два последовательных слагаемых с одним и тем же коэффициентом, мы можем переставлять или не переставлять их. Если имеются два последовательных слагаемых с различными коэффициентами, мы должны поставить раньше то слагаемое, у которого коэффициент меньше. Применяя эти рассуждения, пока необходимо, получаем последовательность слагаемых отсортированных по коэффициентам. Задача BЭта задача решается жадно. Будем перебирать заданные числа последовательно, пока не встретим 1. Затем продолжим перебирать числа в поиске числа 2, потом 3, и т.д.Задача САвторское решение работает за O(n2) по времени и требует O(n2) памяти. Также проходили решения за времени и с O(n) памяти.Переформулируем задачу. Дано множество отрезков на прямой, и нужно найти максимальное его подмножество, такое, что отрезки в нем не пересекаются 'частично'. Два отрезка [a, b] и [c, d] пересекаются частично, если, например, a < c < b < d.Возьмем все концы данных трезков, отсортируем их и посчитаем динамику: dl, r --- максимальный возможный размер подмножества, отрезки в котором не пересекаются частично и расположены между l-м и r-м концом (в отсортированном порядке) включительно. Мы хотим вычислять dl, r, имея уже посчитанные значения di, j для всех l ≤ i ≤ j ≤ r, но [i, j] ≠ [l, r]. Сначала положим dl, r = dl + 1, r, если мы не берем отрезки с левым концом в l. Если существует отрезок [l, r], мы обязательно включаем его в наше множество. Если мы берем другой отрезок, скажем, [l, i], где i < r, посмотрим на отрезки [l, i] и [i, r] (для них ответ уже посчитан) и попытаемся изменить значение dl, r. Асимптотика решения O(n2), потому что общее количество левых концов O(n). Затем необходимо вывести сертификат, т.е. само оптимальное множество. Это делается стандартным образом.Задача DМухи НЕ могут видеть друг друга тогда и только тогда, когда они в противоположных вершинах. Существует  несколько способов проверить это. Например, можно проверить манхеттенское расстояние |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 или евклидово расстояние . Можно проверить, что все три координаты различны (x1 != x2) && (y1 != y2) && (z1 != z2) или просто (x1^x2)+(y1^y2)+(z1^z2) == 3!Задача EКоличество способов разложить b предметов по a коробкам, конечно же, ab. У нас имеется ациклическая игра для двух игроков с состояниями (a, b), для  которых ab < n. К сожалению, существует бесконечное количество таких состояний: a = 1, b любое. Но в этом случае, если 2b ≥ n, позиция является ничейной, потому что единственный способ действия для обоих игроков (не приводящий к поражению) - увеличивать b бесконечно.Другой отдельный случай возникает для позиции с b = 1 и достаточно большого a. А именно, если , имеется также только один ход из этой позиции - увеличивать a. Если a = n - 1, то позиция проигрышная, если a = n - 2 - она выигрышная, при a = n - 3 снова проигрышная и т.д.Итак, имеется два вида состояний, которые нужно обрабатывать отдельно. Количество остальных состояний не очень большое, и для них можно вычислять стандартную динамику для игр на ациклических графах.Задача FПростое моделирование прыжков лягушек работает слишком долго, потому что n может быть 109. Правильное решение состоит в том, чтобы посчитать для каждой лягушки количество раздавленных комаров путем проверки делимости номеров кочек с комарами на di.Задача GЧто можно сказать про задачу G? Нужно провести разбор данной функции и вычислить ее значение при всех значениях n. Разумеется, это невозможно сделать путем простой реализации рекурсии, потому что она может работать слишком долго (см. пример с последовательностью Фибоначчи). Поэтому нужно использовать динамическое программирование.Задача HНужно вычислить все произведения i * j и вывести их в состеме счисления с основанием k.Задача IРассмотрим только ту часть графа, которая достижима из вершины 1. Задача состоит в том, чтобы найти наибольшее такое t, чо выбранное множество вершин достижимо только в моменты времени, кратные t. Предположим, мы построили искомое множество S0. Рассмотрим множества S1, S2 ..., St - 1 всех вершин, достижимых в моменты времени, имеющие остатки 1, 2, ..., t - 1 по модулю t, соответственно. Нетрудно проверить, что эти множества не пересекаются и их объединение совпадает со всем множеством достижимых вершин. Ясно, что ребро из u в v может существовать только в том случае, когда u и v принадлежат последовательным множествам, т.е. , , k + 1 берется по модулю t.Для каждой вершины v посчитаем расстояние dv от 1 до v (если существует несколько путей, выберите любой, например, с помощью обхода в глубину). Если из u в v существует ребро, должно выполняться . Анализируя все ребра, мы приходим к заключению, что оптимальное значение t равно наибольшему общему делителю чисел |du + 1 - dv|. Теперь нетрудно райти множетсво S0.Задача JСамое простое решение - найти два числа l и r - длину наибольшего общего префикса и длину наибольшего общего суффикса двух строк, соответственно. Если l + 1 < n - r, решения нет. Здесь n - длина первой строки. Иначе нужно выдать позиции с max(n - r, 1) до min(l + 1, n). Задача KЗадача К имеет огромное количество различных решений, поэтому мне удивительно, почему их было так мало во время соревнования. Проходили решения за O(k4) и даже некоторые решения за O(k5) с оптимизациями, но KADR предложил решение даже лучше, работающее за O(k3) (http://codeforces.com/blog/entry/793).Здесь я приведу некоторые идеи жюри по этой задаче. В первую очередь сожмем координаты. Отметим по одной точке внутри каждого объекта и стандартной динамикой посчитаем количество отмеченных точек внутри каждого прямоугольника. Обработка всех возможных прямоугольников занимает O(k4). Возникает проблема с тем, что прямоугольник может содержать правильное количество объектов, но содержать некоторые объекты не полностью. Чтобы это предотвратить, проверим границы. Они являются отрезками, параллельными осям координат, и их количество O(k3). Поэтому мы можем предподсчитать, корректны они или нет, сравнивая их с каждым объектом. Затем нужно вернуться к несжатым координатам.Следующее решение за O(k5), и оно использует ограничение на количество объектов (3) в прямоугольнике. Обработаем все тройки объектов (то же самое, разумеется, для пар и до объектов по одному). Фиксируем тройку и заменим ее одним большим объектом. Затем будем двигаться от получившегося объекта вверх (и вниз), проверяя, может ли строка вверху (внизу) быть включена в пораженный прямоугольник. Для каждой строки выберем наибольший отрезок [l, r], содержащий текущий большой объект и не содержащий ничего больше. Используя эту информацию, нетрудно посчитать общее количество прямоугольников, содержащих данную тройку.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 7948
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задачи К - Codeforces",
          "content": "Предположим, что верхняя и нижняя стороны прямоугольника фиксированы и нам осталось только выбрать левую и правую стороны. Тогда мы за О(К) можем найти список всех прямоугольников, которые попадают в нашу полосу, а так же список всех прямоугольников, у которых только часть попадает в полосу. Тогда мы можем представить это в виде отсортированного набора отрезков [l,r], где l и r - икс координаты левой и правой сторон прямоугольника.Если какие-то отрезки в нашем наборе имеют общую точку - склеим их в один большой отрезок и запомним что теперь в нем на самом деле два отрезка. Таким образом, после того как мы склеили все отрезки, у нас получится какой-то набор отрезков, для каждого из которых известно количество прямоугольников, которые им покрываются (если в нем есть прямоугольник, который не лежит полностью в нашей полосе, то будем считать что такой отрезок содержит бесконечное количество прямоугольников). Теперь мы можем пройти по всем свободным отрезкам (находящимся между соседними отрезками из нашего набора) и посчитать количество способов покрыть их отрезком в котором лежит не более трех объектов (для этого будем помнить только те свободные отрезки, которые отделены от текущего не более чем тремя объектами).Таким образом, мы уже имеем решение за O(N2K): перебрать все возможные горизонтальные полосы и в каждой за О(К) посчитать количество прямоугольников, которые покрывают от 1 до 3 объектов. Заметим, что если, например, верхняя сторона полосы не прилегает ни к какому из объектов, то мы можем ее сдвинуть вверх либо вниз и ответ для полосы не изменится. Следовательно, можно перебирать в качестве границ полосы только те строки, в которых есть хотя бы одна клетка, принадлежащая объекту, а затем домножать полученный ответ на расстояния до ближайших \"не пустых\" строк снизу и сверху.Таким образом, мы получили решение работающее за O(K3) и не зависящее ни от размеров поля, ни от ограничения на максимальное количество покрываемых объектов.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1966
        }
      ],
      "code_examples": [
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 1",
          "code": "5\n4 2\n6 2\n7 3\n3 3\n5 1\nG, 33:55\nint f(int n)\n{\nif (n < 2) return 0;if (f(n-1) == f(n-2)) return f(n-2)+1;return f(n-1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 2",
          "code": "5\n4 2\n6 2\n7 3\n3 3\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 3",
          "code": "55\nint f(int n)\n{\nif (n < 2) return 0;if (f(n-1) == f(n-2)) return f(n-2)+1;return f(n-1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 4",
          "code": "#include <cstdlib>\n#include <cstdio>\n\nint main() {\n  char *s = \"123+456\";\n  printf(\"%d + %d\\n\", atoi(s), atoi(s + 4));\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 5",
          "code": "17\nint f(int n){if (n > 1000) return n/n;if (n > 100) return n/2;if (n > 10) return n; return 7;}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 6",
          "code": "2 1 536870912",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 7",
          "code": "10 10 5\n..**......\n..**.....*\n..**..**.*\n......**.*\n......**.*\n***......*\n***......*\n..........\n..........\n...******.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задач - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // First line: n m k\n    int n = inf.readInt(1, 1000000000, \"n\"); // 1 ≤ n ≤ 1e9\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\"); // 1 ≤ m ≤ 100\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\"); // 1 ≤ k ≤ 100\n    inf.readEoln(); // Ensure end of line\n\n    // Second line: m integers d_i (1 ≤ d_i ≤ 1e9), separated by single spaces\n    vector<int> d;\n    for (int i = 0; i < m; ++i) {\n        char varName[20];\n        sprintf(varName, \"d[%d]\", i+1);\n        int d_i = inf.readInt(1, 1000000000, varName);\n        if (i + 1 < m) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        d.push_back(d_i);\n    }\n\n    // Third line: k integers representing hills with mosquitoes (1 ≤ hill number ≤ n), separated by single spaces\n    vector<int> mosquito_hills;\n    for (int i = 0; i < k; ++i) {\n        char varName[30];\n        sprintf(varName, \"mosquito_hill[%d]\", i+1);\n        int hill_i = inf.readInt(1, n, varName);\n        if (i + 1 < k) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        mosquito_hills.push_back(hill_i);\n    }\n\n    // Check that no more than one mosquito on each hill\n    set<int> hills_set(mosquito_hills.begin(), mosquito_hills.end());\n    ensuref((int)hills_set.size() == k, \"Each hill can have at most one mosquito\");\n\n    // Must read EOF\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // First line: n m k\n    int n = inf.readInt(1, 1000000000, \"n\"); // 1 ≤ n ≤ 1e9\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\"); // 1 ≤ m ≤ 100\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\"); // 1 ≤ k ≤ 100\n    inf.readEoln(); // Ensure end of line\n\n    // Second line: m integers d_i (1 ≤ d_i ≤ 1e9), separated by single spaces\n    vector<int> d;\n    for (int i = 0; i < m; ++i) {\n        char varName[20];\n        sprintf(varName, \"d[%d]\", i+1);\n        int d_i = inf.readInt(1, 1000000000, varName);\n        if (i + 1 < m) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        d.push_back(d_i);\n    }\n\n    // Third line: k integers representing hills with mosquitoes (1 ≤ hill number ≤ n), separated by single spaces\n    vector<int> mosquito_hills;\n    for (int i = 0; i < k; ++i) {\n        char varName[30];\n        sprintf(varName, \"mosquito_hill[%d]\", i+1);\n        int hill_i = inf.readInt(1, n, varName);\n        if (i + 1 < k) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        mosquito_hills.push_back(hill_i);\n    }\n\n    // Check that no more than one mosquito on each hill\n    set<int> hills_set(mosquito_hills.begin(), mosquito_hills.end());\n    ensuref((int)hills_set.size() == k, \"Each hill can have at most one mosquito\");\n\n    // Must read EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // First line: n m k\n    int n = inf.readInt(1, 1000000000, \"n\"); // 1 ≤ n ≤ 1e9\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\"); // 1 ≤ m ≤ 100\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\"); // 1 ≤ k ≤ 100\n    inf.readEoln(); // Ensure end of line\n\n    // Second line: m integers d_i (1 ≤ d_i ≤ 1e9), separated by single spaces\n    vector<int> d;\n    for (int i = 0; i < m; ++i) {\n        char varName[20];\n        sprintf(varName, \"d[%d]\", i+1);\n        int d_i = inf.readInt(1, 1000000000, varName);\n        if (i + 1 < m) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        d.push_back(d_i);\n    }\n\n    // Third line: k integers representing hills with mosquitoes (1 ≤ hill number ≤ n), separated by single spaces\n    vector<int> mosquito_hills;\n    for (int i = 0; i < k; ++i) {\n        char varName[30];\n        sprintf(varName, \"mosquito_hill[%d]\", i+1);\n        int hill_i = inf.readInt(1, n, varName);\n        if (i + 1 < k) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        mosquito_hills.push_back(hill_i);\n    }\n\n    // Check that no more than one mosquito on each hill\n    set<int> hills_set(mosquito_hills.begin(), mosquito_hills.end());\n    ensuref((int)hills_set.size() == k, \"Each hill can have at most one mosquito\");\n\n    // Must read EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n, m, k within constraints\n    n = max(1, min(n, 1000000000));\n    m = max(1, min(m, 100));\n    k = max(0, min(k, 100));\n    if (k > n) k = n; // Can't have more mosquitoes than hills\n\n    vector<int> di(m);\n    vector<int> hi;\n    if (type == \"random\") {\n        // Generating random di in [1, n]\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        // Generating k unique random hi in [1, n]\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"max_n\") {\n        n = 1000000000;\n        // di in [1, n]\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        // hi random\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"max_m\") {\n        m = 100;\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"max_k\") {\n        k = min(n, 100);\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n        // di random\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n    } else if (type == \"no_mosquitoes\") {\n        k = 0;\n        // di random\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n    } else if (type == \"all_mosquitoes\") {\n        k = min(n, 100);\n        // Set hi from 1 to k\n        for (int i = 1; i <= k; ++i) {\n            hi.push_back(i);\n        }\n        // di random\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n    } else if (type == \"frogs_cannot_reach\") {\n        // Set di > n\n        for (int i = 0; i < m; ++i) {\n            di[i] = n + rnd.next(1, 1000);\n            if (di[i] > 1000000000) di[i] = 1000000000;\n        }\n        // hi random\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"one_good_frog\") {\n        // Only one frog can reach the shore without smashing mosquitoes\n        // Generate mosquitoes on positions that other frogs must land on\n        // Let's pick a special di[0], others will have different di\n        di[0] = n / 2 + 1;\n        for (int i = 1; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n            if (di[i] == di[0]) di[i] = (di[i] % n) + 1;\n        }\n        // Put mosquitoes on hills that frogs except di[0] must land on\n        set<int> positions;\n        for (int i = 1; i < m; ++i) {\n            int d = di[i];\n            for (int j = 1; j*d <= n && (int)positions.size() < k; ++j) {\n                positions.insert(j*d);\n            }\n        }\n        k = positions.size();\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"all_same_mosquitoes\") {\n        // All frogs smash the same minimal number of mosquitoes\n        // For simplicity, arrange mosquitoes to be on positions that frogs must land on equally\n        int d1 = 2, d2 = 3;\n        di[0] = d1;\n        for (int i = 1; i < m; ++i) {\n            di[i] = d2;\n        }\n        set<int> positions;\n        // Add mosquitoes on positions multiples of 6 (common multiples of 2 and 3)\n        for (int pos = 6; pos <= n && (int)positions.size() < k; pos += 6) {\n            positions.insert(pos);\n        }\n        k = positions.size();\n        hi.assign(positions.begin(), positions.end());\n    } else {\n        // Default to random\n        // Generating random di in [1, n]\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        // Generating k unique random hi in [1, n]\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", di[i], (i == m -1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d%c\", hi[i], (i == k -1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n, m, k within constraints\n    n = max(1, min(n, 1000000000));\n    m = max(1, min(m, 100));\n    k = max(0, min(k, 100));\n    if (k > n) k = n; // Can't have more mosquitoes than hills\n\n    vector<int> di(m);\n    vector<int> hi;\n    if (type == \"random\") {\n        // Generating random di in [1, n]\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        // Generating k unique random hi in [1, n]\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"max_n\") {\n        n = 1000000000;\n        // di in [1, n]\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        // hi random\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"max_m\") {\n        m = 100;\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"max_k\") {\n        k = min(n, 100);\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n        // di random\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n    } else if (type == \"no_mosquitoes\") {\n        k = 0;\n        // di random\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n    } else if (type == \"all_mosquitoes\") {\n        k = min(n, 100);\n        // Set hi from 1 to k\n        for (int i = 1; i <= k; ++i) {\n            hi.push_back(i);\n        }\n        // di random\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n    } else if (type == \"frogs_cannot_reach\") {\n        // Set di > n\n        for (int i = 0; i < m; ++i) {\n            di[i] = n + rnd.next(1, 1000);\n            if (di[i] > 1000000000) di[i] = 1000000000;\n        }\n        // hi random\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"one_good_frog\") {\n        // Only one frog can reach the shore without smashing mosquitoes\n        // Generate mosquitoes on positions that other frogs must land on\n        // Let's pick a special di[0], others will have different di\n        di[0] = n / 2 + 1;\n        for (int i = 1; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n            if (di[i] == di[0]) di[i] = (di[i] % n) + 1;\n        }\n        // Put mosquitoes on hills that frogs except di[0] must land on\n        set<int> positions;\n        for (int i = 1; i < m; ++i) {\n            int d = di[i];\n            for (int j = 1; j*d <= n && (int)positions.size() < k; ++j) {\n                positions.insert(j*d);\n            }\n        }\n        k = positions.size();\n        hi.assign(positions.begin(), positions.end());\n    } else if (type == \"all_same_mosquitoes\") {\n        // All frogs smash the same minimal number of mosquitoes\n        // For simplicity, arrange mosquitoes to be on positions that frogs must land on equally\n        int d1 = 2, d2 = 3;\n        di[0] = d1;\n        for (int i = 1; i < m; ++i) {\n            di[i] = d2;\n        }\n        set<int> positions;\n        // Add mosquitoes on positions multiples of 6 (common multiples of 2 and 3)\n        for (int pos = 6; pos <= n && (int)positions.size() < k; pos += 6) {\n            positions.insert(pos);\n        }\n        k = positions.size();\n        hi.assign(positions.begin(), positions.end());\n    } else {\n        // Default to random\n        // Generating random di in [1, n]\n        for (int i = 0; i < m; ++i) {\n            di[i] = rnd.next(1, n);\n        }\n        // Generating k unique random hi in [1, n]\n        set<int> positions;\n        while ((int)positions.size() < k) {\n            positions.insert(rnd.next(1, n));\n        }\n        hi.assign(positions.begin(), positions.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", di[i], (i == m -1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d%c\", hi[i], (i == k -1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -k 5 -type random\n./gen -n 1000000000 -m 100 -k 100 -type random\n./gen -n 1 -m 1 -k 1 -type random\n./gen -n 1000000000 -m 100 -k 100 -type max_n\n./gen -n 1000 -m 100 -k 100 -type max_m\n./gen -n 1000 -m 50 -k 100 -type max_k\n./gen -n 1000 -m 10 -k 0 -type no_mosquitoes\n./gen -n 100 -m 20 -k 100 -type all_mosquitoes\n./gen -n 1000000000 -m 50 -k 50 -type frogs_cannot_reach\n./gen -n 100000 -m 10 -k 100 -type one_good_frog\n./gen -n 1000000000 -m 30 -k 100 -type all_same_mosquitoes\n./gen -n 1 -m 1 -k 0 -type random\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 3 -m 3 -k 2 -type random\n./gen -n 1000000000 -m 1 -k 100 -type random\n./gen -n 999999937 -m 100 -k 100 -type max_n\n./gen -n 500000000 -m 100 -k 0 -type no_mosquitoes\n./gen -n 1000000 -m 1 -k 100 -type all_mosquitoes\n./gen -n 1000000 -m 100 -k 100 -type all_mosquitoes\n./gen -n 1000000000 -m 100 -k 100 -type frogs_cannot_reach\n./gen -n 897654321 -m 50 -k 50 -type one_good_frog\n./gen -n 1000000000 -m 100 -k 100 -type all_same_mosquitoes\n./gen -n 987654321 -m 75 -k 75 -type random\n./gen -n 500000000 -m 100 -k 100 -type random\n./gen -n 1 -m 1 -k 1 -type random\n./gen -n 1000000000 -m 100 -k 100 -type random\n./gen -n 1000000000 -m 100 -k 0 -type no_mosquitoes\n./gen -n 1000000000 -m 100 -k 100 -type frogs_cannot_reach\n./gen -n 1000000000 -m 100 -k 100 -type one_good_frog\n./gen -n 1000000000 -m 100 -k 100 -type all_same_mosquitoes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:14.157717",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/G",
      "title": "G. Inverse Function",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line has an integer f(n) from the interval [0..32767]. The next lines have the description of the function f. In the description can be found extra spaces and line breaks (see the examples) which, of course, can’t break key words int, if, return and numbers. The size of input data can’t exceed 100 bytes.",
      "output_spec": "OutputOutput a single number — the answer to the problem. If there’s no answer, output \"-1\" (without quotes).",
      "sample_tests": "ExamplesInputCopy17int f(int n){if (n < 100) return 17;if (n > 99) return 27;}OutputCopy99InputCopy13int f(int n){if (n == 0) return 0;return f(n - 1) + 1;}OutputCopy13InputCopy144int f(int n){if (n == 0) return 0;if (n == 1) return n;return f(n - 1) + f(n - 2);}OutputCopy24588",
      "description": "G. Inverse Function\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line has an integer f(n) from the interval [0..32767]. The next lines have the description of the function f. In the description can be found extra spaces and line breaks (see the examples) which, of course, can’t break key words int, if, return and numbers. The size of input data can’t exceed 100 bytes.\n\nOutputOutput a single number — the answer to the problem. If there’s no answer, output \"-1\" (without quotes).\n\nInputCopy17int f(int n){if (n < 100) return 17;if (n > 99) return 27;}OutputCopy99InputCopy13int f(int n){if (n == 0) return 0;return f(n - 1) + 1;}OutputCopy13InputCopy144int f(int n){if (n == 0) return 0;if (n == 1) return n;return f(n - 1) + f(n - 2);}OutputCopy24588\n\nInputCopy17int f(int n){if (n < 100) return 17;if (n > 99) return 27;}\n\nOutputCopy99\n\nInputCopy13int f(int n){if (n == 0) return 0;return f(n - 1) + 1;}\n\nOutputCopy13\n\nInputCopy144int f(int n){if (n == 0) return 0;if (n == 1) return n;return f(n - 1) + f(n - 2);}\n\nOutputCopy24588",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // 1) First line: an integer f(n) in [0..32767].\n    int fn = inf.readInt(0, 32767, \"f_n\");\n    inf.readEoln();\n\n    // We'll read the remainder of the input as text. The entire input size,\n    // including the first line, must not exceed 100 bytes.\n    // We'll accumulate the lines to check the total length and also to inspect them.\n\n    // Add length of the first line plus the newline we just read.\n    // The first line was read as an integer, but let's approximate it by converting\n    // to string for a length check. (This is enough for a strict upper bound.)\n    ostringstream oss;\n    oss << fn;\n    int totalBytes = (int)oss.str().size() + 1; // +1 for the newline\n\n    // Accumulate the rest of the program text.\n    // We'll store line-by-line, and also form one big string for validation.\n    string functionCode;\n    while (!inf.eof()) {\n        string line = inf.readLine();\n        // +1 for the newline after each line\n        totalBytes += (int)(line.size() + 1);\n        ensuref(totalBytes <= 100, \"Input size exceeds 100 bytes\");\n        functionCode += line + \"\\n\";\n    }\n\n    // 2) Basic structural checks:\n    // Remove newlines to simplify searches.\n    string codeNoNewline = functionCode;\n    codeNoNewline.erase(\n        remove(codeNoNewline.begin(), codeNoNewline.end(), '\\n'),\n        codeNoNewline.end()\n    );\n    codeNoNewline.erase(\n        remove(codeNoNewline.begin(), codeNoNewline.end(), '\\r'),\n        codeNoNewline.end()\n    );\n\n    // Must contain \"int f(int n)\" (unbroken) then '{' then '}' (in that order).\n    {\n        size_t pos = codeNoNewline.find(\"int f(int n)\");\n        ensuref(pos != string::npos, \"Function signature 'int f(int n)' not found\");\n        pos = codeNoNewline.find(\"{\", pos);\n        ensuref(pos != string::npos, \"Opening brace '{' not found after signature\");\n        pos = codeNoNewline.find(\"}\", pos);\n        ensuref(pos != string::npos, \"Closing brace '}' not found\");\n    }\n\n    // 3) All constants in [0..32767].\n    // Scan for digit sequences and check each value <= 32767.\n    // (We do not consider negative signs or other tokens as valid constants.)\n    static const regex numberRegex(\"\\\\b\\\\d+\\\\b\");\n    for (sregex_iterator it(codeNoNewline.begin(), codeNoNewline.end(), numberRegex), end; \n         it != end; ++it) \n    {\n        int val = stoi(it->str());\n        ensuref(val <= 32767, \"A constant in the code is out of range [0..32767]\");\n    }\n\n    // Ensure no leftover data\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // 1) First line: an integer f(n) in [0..32767].\n    int fn = inf.readInt(0, 32767, \"f_n\");\n    inf.readEoln();\n\n    // We'll read the remainder of the input as text. The entire input size,\n    // including the first line, must not exceed 100 bytes.\n    // We'll accumulate the lines to check the total length and also to inspect them.\n\n    // Add length of the first line plus the newline we just read.\n    // The first line was read as an integer, but let's approximate it by converting\n    // to string for a length check. (This is enough for a strict upper bound.)\n    ostringstream oss;\n    oss << fn;\n    int totalBytes = (int)oss.str().size() + 1; // +1 for the newline\n\n    // Accumulate the rest of the program text.\n    // We'll store line-by-line, and also form one big string for validation.\n    string functionCode;\n    while (!inf.eof()) {\n        string line = inf.readLine();\n        // +1 for the newline after each line\n        totalBytes += (int)(line.size() + 1);\n        ensuref(totalBytes <= 100, \"Input size exceeds 100 bytes\");\n        functionCode += line + \"\\n\";\n    }\n\n    // 2) Basic structural checks:\n    // Remove newlines to simplify searches.\n    string codeNoNewline = functionCode;\n    codeNoNewline.erase(\n        remove(codeNoNewline.begin(), codeNoNewline.end(), '\\n'),\n        codeNoNewline.end()\n    );\n    codeNoNewline.erase(\n        remove(codeNoNewline.begin(), codeNoNewline.end(), '\\r'),\n        codeNoNewline.end()\n    );\n\n    // Must contain \"int f(int n)\" (unbroken) then '{' then '}' (in that order).\n    {\n        size_t pos = codeNoNewline.find(\"int f(int n)\");\n        ensuref(pos != string::npos, \"Function signature 'int f(int n)' not found\");\n        pos = codeNoNewline.find(\"{\", pos);\n        ensuref(pos != string::npos, \"Opening brace '{' not found after signature\");\n        pos = codeNoNewline.find(\"}\", pos);\n        ensuref(pos != string::npos, \"Closing brace '}' not found\");\n    }\n\n    // 3) All constants in [0..32767].\n    // Scan for digit sequences and check each value <= 32767.\n    // (We do not consider negative signs or other tokens as valid constants.)\n    static const regex numberRegex(\"\\\\b\\\\d+\\\\b\");\n    for (sregex_iterator it(codeNoNewline.begin(), codeNoNewline.end(), numberRegex), end; \n         it != end; ++it) \n    {\n        int val = stoi(it->str());\n        ensuref(val <= 32767, \"A constant in the code is out of range [0..32767]\");\n    }\n\n    // Ensure no leftover data\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // 1) First line: an integer f(n) in [0..32767].\n    int fn = inf.readInt(0, 32767, \"f_n\");\n    inf.readEoln();\n\n    // We'll read the remainder of the input as text. The entire input size,\n    // including the first line, must not exceed 100 bytes.\n    // We'll accumulate the lines to check the total length and also to inspect them.\n\n    // Add length of the first line plus the newline we just read.\n    // The first line was read as an integer, but let's approximate it by converting\n    // to string for a length check. (This is enough for a strict upper bound.)\n    ostringstream oss;\n    oss << fn;\n    int totalBytes = (int)oss.str().size() + 1; // +1 for the newline\n\n    // Accumulate the rest of the program text.\n    // We'll store line-by-line, and also form one big string for validation.\n    string functionCode;\n    while (!inf.eof()) {\n        string line = inf.readLine();\n        // +1 for the newline after each line\n        totalBytes += (int)(line.size() + 1);\n        ensuref(totalBytes <= 100, \"Input size exceeds 100 bytes\");\n        functionCode += line + \"\\n\";\n    }\n\n    // 2) Basic structural checks:\n    // Remove newlines to simplify searches.\n    string codeNoNewline = functionCode;\n    codeNoNewline.erase(\n        remove(codeNoNewline.begin(), codeNoNewline.end(), '\\n'),\n        codeNoNewline.end()\n    );\n    codeNoNewline.erase(\n        remove(codeNoNewline.begin(), codeNoNewline.end(), '\\r'),\n        codeNoNewline.end()\n    );\n\n    // Must contain \"int f(int n)\" (unbroken) then '{' then '}' (in that order).\n    {\n        size_t pos = codeNoNewline.find(\"int f(int n)\");\n        ensuref(pos != string::npos, \"Function signature 'int f(int n)' not found\");\n        pos = codeNoNewline.find(\"{\", pos);\n        ensuref(pos != string::npos, \"Opening brace '{' not found after signature\");\n        pos = codeNoNewline.find(\"}\", pos);\n        ensuref(pos != string::npos, \"Closing brace '}' not found\");\n    }\n\n    // 3) All constants in [0..32767].\n    // Scan for digit sequences and check each value <= 32767.\n    // (We do not consider negative signs or other tokens as valid constants.)\n    static const regex numberRegex(\"\\\\b\\\\d+\\\\b\");\n    for (sregex_iterator it(codeNoNewline.begin(), codeNoNewline.end(), numberRegex), end; \n         it != end; ++it) \n    {\n        int val = stoi(it->str());\n        ensuref(val <= 32767, \"A constant in the code is out of range [0..32767]\");\n    }\n\n    // Ensure no leftover data\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // \"type\" will choose which pattern of function to generate.\n    // \"ret\" will be the desired f(n) in [0..32767], or if not specified, chosen randomly.\n    int type = opt<int>(\"type\", 1);\n    int ret = opt<int>(\"ret\", -1);\n\n    // If no ret is provided, pick a random value in [0..32767].\n    if(ret < 0) {\n        ret = rnd.next(32768);\n    }\n\n    // We'll output two things:\n    // 1) The integer f(n) on the first line.\n    // 2) The function definition on subsequent lines (within 100 bytes total).\n    // We use minimal formatting to stay within the size limit.\n\n    // Print f(n).\n    cout << ret << \"\\n\";\n\n    // Depending on \"type\", we generate a small function.\n    // We try to keep definitions under 100 bytes total.\n    switch(type) {\n\n        // 1) Constant function: int f(int n){return C;}\n        // If ret == C, the solution is \"any n\" => largest is 32767. Otherwise, no solution => -1.\n        case 1: {\n            // Choose a random C in [0..32767].\n            int C = rnd.next(32768);\n            // 50% chance to force C = ret (so there's a valid solution).\n            if(rnd.next(2) == 0) {\n                C = ret;\n            }\n            cout << \"int f(int n){return \" << C << \";}\\n\";\n            break;\n        }\n\n        // 2) Piecewise with a single if: if(n<x)return y;return z;\n        case 2: {\n            // We'll pick random x,y,z in [0..32767].\n            int x = rnd.next(32768);\n            int y = rnd.next(32768);\n            int z = rnd.next(32768);\n            // We'll ensure ret is either y or z (so there's a solution).\n            if(rnd.next(2) == 0) {\n                y = ret; // largest n < x is x-1, if x>0\n            } else {\n                z = ret; // largest n >= x is 32767 if x<=32767\n            }\n            cout << \"int f(int n){if(n<\" << x << \")return \" << y << \";return \" << z << \";}\\n\";\n            break;\n        }\n\n        // 3) Two ifs: if(n==a)return b;if(n>c)return d;return e;\n        case 3: {\n            int a = rnd.next(32768);\n            int b = rnd.next(32768);\n            int c = rnd.next(32768);\n            int d = rnd.next(32768);\n            int e = rnd.next(32768);\n\n            // We want to ensure ret is one of {b,d,e}.\n            // We'll randomly pick which branch yields ret.\n            int branch = rnd.next(3);\n            if(branch == 0) {\n                b = ret; // n==a\n            } else if(branch == 1) {\n                d = ret; // n>c\n            } else {\n                e = ret; // otherwise\n            }\n            cout << \"int f(int n){if(n==\" << a << \")return \" << b \n                 << \";if(n>\" << c << \")return \" << d \n                 << \";return \" << e << \";}\\n\";\n            break;\n        }\n\n        // 4) Simple recursion: if(n==0)return 0;return f(n-1)+1;\n        // f(n)=n(mod 32768). So if ret<=32767, solution n=ret. \n        case 4: {\n            cout << \"int f(int n){if(n==0)return 0;return f(n-1)+1;}\\n\";\n            break;\n        }\n\n        // 5) Fibonacci recursion: if(n==0)return 0;if(n==1)return 1;return f(n-1)+f(n-2);\n        // f(n) is fib(n) mod 32768. \n        case 5: {\n            cout << \"int f(int n){if(n==0)return 0;if(n==1)return 1;return f(n-1)+f(n-2);}\\n\";\n            break;\n        }\n\n        // 6) A small piecewise with multiplication & division:\n        // if(n>0)return(n*2)/3;return n;\n        case 6: {\n            cout << \"int f(int n){if(n>0)return(n*2)/3;return n;}\\n\";\n            break;\n        }\n\n        // 7) One extra variant: if(n<k)return n*k;return n/k;\n        // ensuring k>0 to avoid division by zero.\n        default: {\n            int k = rnd.next(1, 32767); // k in [1..32767]\n            cout << \"int f(int n){if(n<\" << k << \")return n*\" << k \n                 << \";return n/\" << k << \";}\\n\";\n            break;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // \"type\" will choose which pattern of function to generate.\n    // \"ret\" will be the desired f(n) in [0..32767], or if not specified, chosen randomly.\n    int type = opt<int>(\"type\", 1);\n    int ret = opt<int>(\"ret\", -1);\n\n    // If no ret is provided, pick a random value in [0..32767].\n    if(ret < 0) {\n        ret = rnd.next(32768);\n    }\n\n    // We'll output two things:\n    // 1) The integer f(n) on the first line.\n    // 2) The function definition on subsequent lines (within 100 bytes total).\n    // We use minimal formatting to stay within the size limit.\n\n    // Print f(n).\n    cout << ret << \"\\n\";\n\n    // Depending on \"type\", we generate a small function.\n    // We try to keep definitions under 100 bytes total.\n    switch(type) {\n\n        // 1) Constant function: int f(int n){return C;}\n        // If ret == C, the solution is \"any n\" => largest is 32767. Otherwise, no solution => -1.\n        case 1: {\n            // Choose a random C in [0..32767].\n            int C = rnd.next(32768);\n            // 50% chance to force C = ret (so there's a valid solution).\n            if(rnd.next(2) == 0) {\n                C = ret;\n            }\n            cout << \"int f(int n){return \" << C << \";}\\n\";\n            break;\n        }\n\n        // 2) Piecewise with a single if: if(n<x)return y;return z;\n        case 2: {\n            // We'll pick random x,y,z in [0..32767].\n            int x = rnd.next(32768);\n            int y = rnd.next(32768);\n            int z = rnd.next(32768);\n            // We'll ensure ret is either y or z (so there's a solution).\n            if(rnd.next(2) == 0) {\n                y = ret; // largest n < x is x-1, if x>0\n            } else {\n                z = ret; // largest n >= x is 32767 if x<=32767\n            }\n            cout << \"int f(int n){if(n<\" << x << \")return \" << y << \";return \" << z << \";}\\n\";\n            break;\n        }\n\n        // 3) Two ifs: if(n==a)return b;if(n>c)return d;return e;\n        case 3: {\n            int a = rnd.next(32768);\n            int b = rnd.next(32768);\n            int c = rnd.next(32768);\n            int d = rnd.next(32768);\n            int e = rnd.next(32768);\n\n            // We want to ensure ret is one of {b,d,e}.\n            // We'll randomly pick which branch yields ret.\n            int branch = rnd.next(3);\n            if(branch == 0) {\n                b = ret; // n==a\n            } else if(branch == 1) {\n                d = ret; // n>c\n            } else {\n                e = ret; // otherwise\n            }\n            cout << \"int f(int n){if(n==\" << a << \")return \" << b \n                 << \";if(n>\" << c << \")return \" << d \n                 << \";return \" << e << \";}\\n\";\n            break;\n        }\n\n        // 4) Simple recursion: if(n==0)return 0;return f(n-1)+1;\n        // f(n)=n(mod 32768). So if ret<=32767, solution n=ret. \n        case 4: {\n            cout << \"int f(int n){if(n==0)return 0;return f(n-1)+1;}\\n\";\n            break;\n        }\n\n        // 5) Fibonacci recursion: if(n==0)return 0;if(n==1)return 1;return f(n-1)+f(n-2);\n        // f(n) is fib(n) mod 32768. \n        case 5: {\n            cout << \"int f(int n){if(n==0)return 0;if(n==1)return 1;return f(n-1)+f(n-2);}\\n\";\n            break;\n        }\n\n        // 6) A small piecewise with multiplication & division:\n        // if(n>0)return(n*2)/3;return n;\n        case 6: {\n            cout << \"int f(int n){if(n>0)return(n*2)/3;return n;}\\n\";\n            break;\n        }\n\n        // 7) One extra variant: if(n<k)return n*k;return n/k;\n        // ensuring k>0 to avoid division by zero.\n        default: {\n            int k = rnd.next(1, 32767); // k in [1..32767]\n            cout << \"int f(int n){if(n<\" << k << \")return n*\" << k \n                 << \";return n/\" << k << \";}\\n\";\n            break;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are ~20 distinct commands to produce test cases.\n# Each invocation prints exactly one test in the format:\n#   <the integer f(n)>\n#   int f(int n){...}\n\n# 1) Constant function with random ret\n./gen -type 1\n# 2) Constant function forcing ret=100\n./gen -type 1 -ret 100\n# 3) Piecewise single if with random ret\n./gen -type 2\n# 4) Piecewise single if forcing ret=0\n./gen -type 2 -ret 0\n# 5) Two-ifs function with random ret\n./gen -type 3\n# 6) Two-ifs function forcing ret=32767\n./gen -type 3 -ret 32767\n# 7) Simple recursion function with random ret\n./gen -type 4\n# 8) Simple recursion function forcing ret=42\n./gen -type 4 -ret 42\n# 9) Fibonacci recursion with random ret\n./gen -type 5\n# 10) Fibonacci recursion forcing ret=1\n./gen -type 5 -ret 1\n# 11) Fibonacci recursion forcing ret=13\n./gen -type 5 -ret 13\n# 12) Multiplication/division piecewise with random ret\n./gen -type 6\n# 13) Multiplication/division piecewise forcing ret=9999\n./gen -type 6 -ret 9999\n# 14) Another random type (7) with random ret\n./gen -type 7\n# 15) Another random type (7) forcing ret=123\n./gen -type 7 -ret 123\n# 16) Yet another constant function forcibly no-solution if ret=100\n#    We'll pick a c != 100 internally (with some luck).\n./gen -type 1 -ret 100\n# 17) Another piecewise single if with random ret\n./gen -type 2\n# 18) Two-ifs function again with random ret\n./gen -type 3\n# 19) Random recursion type=4\n./gen -type 4\n# 20) Random recursion type=5\n./gen -type 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:16.869111",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/H",
      "title": "H. Multiplication Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains a single integer k (2 ≤ k ≤ 10) — the radix of the system.",
      "output_spec": "OutputOutput the multiplication table for the system of notations with the radix k. The table must contain k - 1 rows and k - 1 columns. The element on the crossing of the i-th row and the j-th column is equal to the product of i and j in the system of notations with the radix k. Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).",
      "sample_tests": "ExamplesInputCopy10OutputCopy1  2  3  4  5  6  7  8  92  4  6  8 10 12 14 16 183  6  9 12 15 18 21 24 274  8 12 16 20 24 28 32 365 10 15 20 25 30 35 40 456 12 18 24 30 36 42 48 547 14 21 28 35 42 49 56 638 16 24 32 40 48 56 64 729 18 27 36 45 54 63 72 81InputCopy3OutputCopy1  22 11",
      "description": "H. Multiplication Table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer k (2 ≤ k ≤ 10) — the radix of the system.\n\nOutputOutput the multiplication table for the system of notations with the radix k. The table must contain k - 1 rows and k - 1 columns. The element on the crossing of the i-th row and the j-th column is equal to the product of i and j in the system of notations with the radix k. Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).\n\nInputCopy10OutputCopy1  2  3  4  5  6  7  8  92  4  6  8 10 12 14 16 183  6  9 12 15 18 21 24 274  8 12 16 20 24 28 32 365 10 15 20 25 30 35 40 456 12 18 24 30 36 42 48 547 14 21 28 35 42 49 56 638 16 24 32 40 48 56 64 729 18 27 36 45 54 63 72 81InputCopy3OutputCopy1  22 11\n\nInputCopy10\n\nOutputCopy1  2  3  4  5  6  7  8  92  4  6  8 10 12 14 16 183  6  9 12 15 18 21 24 274  8 12 16 20 24 28 32 365 10 15 20 25 30 35 40 456 12 18 24 30 36 42 48 547 14 21 28 35 42 49 56 638 16 24 32 40 48 56 64 729 18 27 36 45 54 63 72 81\n\nOutputCopy1  22 11",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 10, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 10, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 10, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register generator\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    // \"k\" (2 <= k <= 10), defaults to 10 if not given\n    int k = opt<int>(\"k\", 10);\n\n    // A boolean parameter to decide whether to pick k randomly from [2..10]\n    bool isRand = opt<bool>(\"random\", false);\n\n    // If \"random\" is provided, choose a random k in [2..10]\n    if (isRand) {\n        k = rnd.next(2, 10);\n    }\n\n    // Ensure k is within [2..10], though ideally the user won't give invalid input.\n    k = max(2, min(k, 10));\n\n    // Output the single integer k\n    cout << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register generator\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    // \"k\" (2 <= k <= 10), defaults to 10 if not given\n    int k = opt<int>(\"k\", 10);\n\n    // A boolean parameter to decide whether to pick k randomly from [2..10]\n    bool isRand = opt<bool>(\"random\", false);\n\n    // If \"random\" is provided, choose a random k in [2..10]\n    if (isRand) {\n        k = rnd.next(2, 10);\n    }\n\n    // Ensure k is within [2..10], though ideally the user won't give invalid input.\n    k = max(2, min(k, 10));\n\n    // Output the single integer k\n    cout << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) Minimum k\n./gen -k 2\n\n# 2) Another small base\n./gen -k 3\n\n# 3) A middling base\n./gen -k 5\n\n# 4) Another middling base\n./gen -k 7\n\n# 5) Maximum base\n./gen -k 10\n\n# 6) Random choice of k in [2..10]\n./gen -random\n\n# 7) Another random choice\n./gen -random\n\n# 8) Another random choice\n./gen -random\n\n# 9) Another random choice\n./gen -random\n\n# 10) Another random choice\n./gen -random\n\n# 11) Fixed base again\n./gen -k 4\n\n# 12) Fixed base again\n./gen -k 6\n\n# 13) Fixed base again\n./gen -k 8\n\n# 14) Another random choice\n./gen -random\n\n# 15) Another random choice\n./gen -random\n\n# 16) Another random choice\n./gen -random\n\n# 17) Another random choice\n./gen -random\n\n# 18) Another random choice\n./gen -random\n\n# 19) Base 9\n./gen -k 9\n\n# 20) Another random choice\n./gen -random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:18.677092",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/I",
      "title": "I. Трамвай",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке содержатся целые числа n и m (2 ≤ n, m ≤ 105) — количество перекрестков и количество трамвайных путей в городе С*** соответственно. Следующие m строк содержат описания путей в формате «u v», где u — начальный перекресток пути, а v — его конечный перекресток. Перекрестки пронумерованы целыми числами от 1 до n, причем трамвайное депо находится на перекрестке с номером 1.",
      "output_spec": "Выходные данныеВ первой строке выведите значение t. В следующей строке выведите число k — необходимое количество камер наблюдения. В следующей строке через пробел выведите номера перекрестков, на которых следует установить камеры. Номера выводите в порядке возрастания.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 22 33 44 11 4Выходные данныеСкопировать221 3",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержатся целые числа n и m (2 ≤ n, m ≤ 105) — количество перекрестков и количество трамвайных путей в городе С*** соответственно. Следующие m строк содержат описания путей в формате «u v», где u — начальный перекресток пути, а v — его конечный перекресток. Перекрестки пронумерованы целыми числами от 1 до n, причем трамвайное депо находится на перекрестке с номером 1.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите значение t. В следующей строке выведите число k — необходимое количество камер наблюдения. В следующей строке через пробел выведите номера перекрестков, на которых следует установить камеры. Номера выводите в порядке возрастания.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 22 33 44 11 4Выходные данныеСкопировать221 3\n\nВходные данныеСкопировать4 51 22 33 44 11 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать221 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces",
          "content": "Добрый день всем!Приглашаем всех на Школьную командную олимпиаду #1, которая состоится 24 октября в 11:00 MSK. Соревнование будет официальным для команд школьников, как часть серии школьных заочных олимпиад ЗКШ (http://codeforces.com/blog/entry/753), и неофициальным (и не рейтинговым!) для всех остальных.Чтобы принять участие официально, каждый участник школьной команды должен сначала зарегистрироваться лично, затем из зарегистрированных участников нужно создать команду и, когда будет открыта регистрация на соревнование, зарегистрировать команду еще и там.Надеюсь, что задачи окажутся интересными для школьников с разным уровнем подготовки в программировании, и не только для школьников! Обратите внимание на некоторые отличия от обычных соревнований на Codeforces. Во-первых, продолжительность соревнования 5 часов, и будут стандартные правила ACM ICPC. Во-вторых, задачи не будут идти в порядке возрастания сложности, они будут перемешаны. Поэтому ваша первая задача - найти простую задачу :)Авторы задач - Михаил Мирзаянов и я. Спасибо Геральду Агапову, Полине Бондаренко  и Артему Рахову, которые помогали мне готовить раунд. Также спасибо Марии Беловой за перевод условий задач на английский язык. Мы все - сотрудники и студенты Саратовского Государственного Университета.Удачи!P.S. Будьте внимательны при регистрации на соревнование. Аккуратно читайте все всплывающие сообщения. Для участия в конкурсе должна быть зарегистрирована команда, все члены которой зарегистрировались для участия в серии. В команду должны быть приглашены (и подтвердить свое участие) все те, кто собирается писать соревнование.UPD: Как только начнется соревнование, то будут доступны задачи в PDF (для печати):Русская версияАнглийская версияUPD: Соревнование завешено. Доступны результаты.Победителем и в официальном, и в общем зачете стал Gennady Korotkevich, решивший все задачи. Поздравляем победителя! Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1916
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задач - Codeforces",
          "content": "Задача АДля получения максимального возможного результата нужно просто отсортировать слагаемые в порядке неубывания коэффициентов (коэффициенты учитываются со стоящими перед ними знаками + и -). Не нужно обращать внимание на a++ или ++a! Вопрос заключается в том, почему это правильно.Во-первых, рассмотрим выражение, содержащее только a++. Тогда наше утверждение очевидно: выгодно умножать 'a' на маленькие коэффициенты, пока значение 'a' маленькое, и на большие коэффициенты, когда оно становится больше. То же самое происходит в случае трицательных значений коэффициентов или 'a'. Конечно, это не строгое доказательство. Я надеюсь, что вы еще подумаете над ним, если пока не поняли.Во-вторых, рассмотрим выражение k*a+++k*++a, где k - некотрый коэффициент, одинаковый для обоих слагаемых. Пусть начальное значение 'a' равно a0. Вычисляя значение выражения обоими способами, получаем: k * a0 + k * (a0 + 2) =  k * (a0 + 1) + k * (a0 + 1). Поэтому в данном случае порядок неважен.В-третьих, пусть наше выражение k*a+++l*++a, где k и l - различные коэффициенты. Это выражение может принимать два разных значения k * a0 + l * (a0 + 2) и k * (a0 + 1) + l * (a0 + 1). Первое значение больше второго тогда и только тогда, когда k < l. Аналогично можно рассмотреть выражение k*a+++l*++a.Таким образом, если имеются два последовательных слагаемых с одним и тем же коэффициентом, мы можем переставлять или не переставлять их. Если имеются два последовательных слагаемых с различными коэффициентами, мы должны поставить раньше то слагаемое, у которого коэффициент меньше. Применяя эти рассуждения, пока необходимо, получаем последовательность слагаемых отсортированных по коэффициентам. Задача BЭта задача решается жадно. Будем перебирать заданные числа последовательно, пока не встретим 1. Затем продолжим перебирать числа в поиске числа 2, потом 3, и т.д.Задача САвторское решение работает за O(n2) по времени и требует O(n2) памяти. Также проходили решения за времени и с O(n) памяти.Переформулируем задачу. Дано множество отрезков на прямой, и нужно найти максимальное его подмножество, такое, что отрезки в нем не пересекаются 'частично'. Два отрезка [a, b] и [c, d] пересекаются частично, если, например, a < c < b < d.Возьмем все концы данных трезков, отсортируем их и посчитаем динамику: dl, r --- максимальный возможный размер подмножества, отрезки в котором не пересекаются частично и расположены между l-м и r-м концом (в отсортированном порядке) включительно. Мы хотим вычислять dl, r, имея уже посчитанные значения di, j для всех l ≤ i ≤ j ≤ r, но [i, j] ≠ [l, r]. Сначала положим dl, r = dl + 1, r, если мы не берем отрезки с левым концом в l. Если существует отрезок [l, r], мы обязательно включаем его в наше множество. Если мы берем другой отрезок, скажем, [l, i], где i < r, посмотрим на отрезки [l, i] и [i, r] (для них ответ уже посчитан) и попытаемся изменить значение dl, r. Асимптотика решения O(n2), потому что общее количество левых концов O(n). Затем необходимо вывести сертификат, т.е. само оптимальное множество. Это делается стандартным образом.Задача DМухи НЕ могут видеть друг друга тогда и только тогда, когда они в противоположных вершинах. Существует  несколько способов проверить это. Например, можно проверить манхеттенское расстояние |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 или евклидово расстояние . Можно проверить, что все три координаты различны (x1 != x2) && (y1 != y2) && (z1 != z2) или просто (x1^x2)+(y1^y2)+(z1^z2) == 3!Задача EКоличество способов разложить b предметов по a коробкам, конечно же, ab. У нас имеется ациклическая игра для двух игроков с состояниями (a, b), для  которых ab < n. К сожалению, существует бесконечное количество таких состояний: a = 1, b любое. Но в этом случае, если 2b ≥ n, позиция является ничейной, потому что единственный способ действия для обоих игроков (не приводящий к поражению) - увеличивать b бесконечно.Другой отдельный случай возникает для позиции с b = 1 и достаточно большого a. А именно, если , имеется также только один ход из этой позиции - увеличивать a. Если a = n - 1, то позиция проигрышная, если a = n - 2 - она выигрышная, при a = n - 3 снова проигрышная и т.д.Итак, имеется два вида состояний, которые нужно обрабатывать отдельно. Количество остальных состояний не очень большое, и для них можно вычислять стандартную динамику для игр на ациклических графах.Задача FПростое моделирование прыжков лягушек работает слишком долго, потому что n может быть 109. Правильное решение состоит в том, чтобы посчитать для каждой лягушки количество раздавленных комаров путем проверки делимости номеров кочек с комарами на di.Задача GЧто можно сказать про задачу G? Нужно провести разбор данной функции и вычислить ее значение при всех значениях n. Разумеется, это невозможно сделать путем простой реализации рекурсии, потому что она может работать слишком долго (см. пример с последовательностью Фибоначчи). Поэтому нужно использовать динамическое программирование.Задача HНужно вычислить все произведения i * j и вывести их в состеме счисления с основанием k.Задача IРассмотрим только ту часть графа, которая достижима из вершины 1. Задача состоит в том, чтобы найти наибольшее такое t, чо выбранное множество вершин достижимо только в моменты времени, кратные t. Предположим, мы построили искомое множество S0. Рассмотрим множества S1, S2 ..., St - 1 всех вершин, достижимых в моменты времени, имеющие остатки 1, 2, ..., t - 1 по модулю t, соответственно. Нетрудно проверить, что эти множества не пересекаются и их объединение совпадает со всем множеством достижимых вершин. Ясно, что ребро из u в v может существовать только в том случае, когда u и v принадлежат последовательным множествам, т.е. , , k + 1 берется по модулю t.Для каждой вершины v посчитаем расстояние dv от 1 до v (если существует несколько путей, выберите любой, например, с помощью обхода в глубину). Если из u в v существует ребро, должно выполняться . Анализируя все ребра, мы приходим к заключению, что оптимальное значение t равно наибольшему общему делителю чисел |du + 1 - dv|. Теперь нетрудно райти множетсво S0.Задача JСамое простое решение - найти два числа l и r - длину наибольшего общего префикса и длину наибольшего общего суффикса двух строк, соответственно. Если l + 1 < n - r, решения нет. Здесь n - длина первой строки. Иначе нужно выдать позиции с max(n - r, 1) до min(l + 1, n). Задача KЗадача К имеет огромное количество различных решений, поэтому мне удивительно, почему их было так мало во время соревнования. Проходили решения за O(k4) и даже некоторые решения за O(k5) с оптимизациями, но KADR предложил решение даже лучше, работающее за O(k3) (http://codeforces.com/blog/entry/793).Здесь я приведу некоторые идеи жюри по этой задаче. В первую очередь сожмем координаты. Отметим по одной точке внутри каждого объекта и стандартной динамикой посчитаем количество отмеченных точек внутри каждого прямоугольника. Обработка всех возможных прямоугольников занимает O(k4). Возникает проблема с тем, что прямоугольник может содержать правильное количество объектов, но содержать некоторые объекты не полностью. Чтобы это предотвратить, проверим границы. Они являются отрезками, параллельными осям координат, и их количество O(k3). Поэтому мы можем предподсчитать, корректны они или нет, сравнивая их с каждым объектом. Затем нужно вернуться к несжатым координатам.Следующее решение за O(k5), и оно использует ограничение на количество объектов (3) в прямоугольнике. Обработаем все тройки объектов (то же самое, разумеется, для пар и до объектов по одному). Фиксируем тройку и заменим ее одним большим объектом. Затем будем двигаться от получившегося объекта вверх (и вниз), проверяя, может ли строка вверху (внизу) быть включена в пораженный прямоугольник. Для каждой строки выберем наибольший отрезок [l, r], содержащий текущий большой объект и не содержащий ничего больше. Используя эту информацию, нетрудно посчитать общее количество прямоугольников, содержащих данную тройку.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 7948
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задачи К - Codeforces",
          "content": "Предположим, что верхняя и нижняя стороны прямоугольника фиксированы и нам осталось только выбрать левую и правую стороны. Тогда мы за О(К) можем найти список всех прямоугольников, которые попадают в нашу полосу, а так же список всех прямоугольников, у которых только часть попадает в полосу. Тогда мы можем представить это в виде отсортированного набора отрезков [l,r], где l и r - икс координаты левой и правой сторон прямоугольника.Если какие-то отрезки в нашем наборе имеют общую точку - склеим их в один большой отрезок и запомним что теперь в нем на самом деле два отрезка. Таким образом, после того как мы склеили все отрезки, у нас получится какой-то набор отрезков, для каждого из которых известно количество прямоугольников, которые им покрываются (если в нем есть прямоугольник, который не лежит полностью в нашей полосе, то будем считать что такой отрезок содержит бесконечное количество прямоугольников). Теперь мы можем пройти по всем свободным отрезкам (находящимся между соседними отрезками из нашего набора) и посчитать количество способов покрыть их отрезком в котором лежит не более трех объектов (для этого будем помнить только те свободные отрезки, которые отделены от текущего не более чем тремя объектами).Таким образом, мы уже имеем решение за O(N2K): перебрать все возможные горизонтальные полосы и в каждой за О(К) посчитать количество прямоугольников, которые покрывают от 1 до 3 объектов. Заметим, что если, например, верхняя сторона полосы не прилегает ни к какому из объектов, то мы можем ее сдвинуть вверх либо вниз и ответ для полосы не изменится. Следовательно, можно перебирать в качестве границ полосы только те строки, в которых есть хотя бы одна клетка, принадлежащая объекту, а затем домножать полученный ответ на расстояния до ближайших \"не пустых\" строк снизу и сверху.Таким образом, мы получили решение работающее за O(K3) и не зависящее ни от размеров поля, ни от ограничения на максимальное количество покрываемых объектов.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1966
        }
      ],
      "code_examples": [
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 1",
          "code": "5\n4 2\n6 2\n7 3\n3 3\n5 1\nG, 33:55\nint f(int n)\n{\nif (n < 2) return 0;if (f(n-1) == f(n-2)) return f(n-2)+1;return f(n-1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 2",
          "code": "5\n4 2\n6 2\n7 3\n3 3\n5 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 3",
          "code": "55\nint f(int n)\n{\nif (n < 2) return 0;if (f(n-1) == f(n-2)) return f(n-2)+1;return f(n-1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 4",
          "code": "#include <cstdlib>\n#include <cstdio>\n\nint main() {\n  char *s = \"123+456\";\n  printf(\"%d + %d\\n\", atoi(s), atoi(s + 4));\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 5",
          "code": "17\nint f(int n){if (n > 1000) return n/n;if (n > 100) return n/2;if (n > 10) return n; return 7;}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 6",
          "code": "2 1 536870912",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11) - Codeforces - Code 7",
          "code": "10 10 5\n..**......\n..**.....*\n..**..**.*\n......**.*\n......**.*\n***......*\n***......*\n..........\n..........\n...******.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/781",
          "author": "jiangly"
        },
        {
          "title": "Школьная командная олимпиада #1 (ЗКШ 2010/11): разбор задач - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\"); // n ∈ [2, 1e5]\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\"); // m ∈ [2, 1e5]\n    inf.readEoln();\n\n    vector<int> outdegree(n + 1, 0); // Indexes from 1 to n\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        ensuref(u != v, \"Each tramline must connect two different crossroads, but found tramline from %d to %d\", u, v);\n        inf.readEoln();\n        outdegree[u]++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(outdegree[i] >= 1, \"Crossroad %d does not have any outgoing tramline\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\"); // n ∈ [2, 1e5]\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\"); // m ∈ [2, 1e5]\n    inf.readEoln();\n\n    vector<int> outdegree(n + 1, 0); // Indexes from 1 to n\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        ensuref(u != v, \"Each tramline must connect two different crossroads, but found tramline from %d to %d\", u, v);\n        inf.readEoln();\n        outdegree[u]++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(outdegree[i] >= 1, \"Crossroad %d does not have any outgoing tramline\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\"); // n ∈ [2, 1e5]\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\"); // m ∈ [2, 1e5]\n    inf.readEoln();\n\n    vector<int> outdegree(n + 1, 0); // Indexes from 1 to n\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        ensuref(u != v, \"Each tramline must connect two different crossroads, but found tramline from %d to %d\", u, v);\n        inf.readEoln();\n        outdegree[u]++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(outdegree[i] >= 1, \"Crossroad %d does not have any outgoing tramline\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateRandomGraph(int n, int m) {\n    // Initialize edges\n    vector<pair<int,int>> edges;\n\n    // Ensure each node has at least one outgoing edge\n    for(int i = 1; i <= n; i++) {\n        int u = i;\n        int v = rnd.next(1, n);\n        while(v == u) v = rnd.next(1, n);\n        edges.push_back({u, v});\n    }\n\n    // Add remaining edges\n    int remaining = m - n;\n    for(int i = 0; i < remaining; i++) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while(v == u) v = rnd.next(1, n);\n        edges.push_back({u, v});\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nvoid generateGraphWithGCD(int n, int m, int gcd) {\n    // Partition nodes into cycles of lengths that have GCD gcd\n\n    vector<int> cycle_lengths;\n    int total = 0;\n\n    // Create cycles of lengths as multiples of gcd\n    while(total + gcd <= n) {\n        cycle_lengths.push_back(gcd);\n        total += gcd;\n    }\n    if(total < n) {\n        cycle_lengths.push_back(n - total);\n    }\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; i++)\n        nodes[i] = i + 1;\n    shuffle(nodes.begin(), nodes.end());\n\n    vector<pair<int,int>> edges;\n    int idx = 0;\n\n    for(int len : cycle_lengths) {\n        vector<int> nodes_in_cycle;\n        for(int i = 0; i < len; i++) {\n            nodes_in_cycle.push_back(nodes[idx++]);\n        }\n        // Create a cycle\n        for(int i = 0; i < len; i++) {\n            int u = nodes_in_cycle[i];\n            int v = nodes_in_cycle[(i+1)%len];\n            edges.push_back({u,v});\n        }\n    }\n\n    // Now ensure that each node has at least one outgoing edge\n    // (already ensured by cycles), and m - edges.size() more edges\n    \n    int extra_edges = m - edges.size();\n\n    for(int i = 0; i < extra_edges; i++) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while(v == u) v = rnd.next(1, n);\n        edges.push_back({u,v});\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"random\") {\n        generateRandomGraph(n, m);\n    } else if(type == \"gcd\") {\n        int gcd = opt<int>(\"gcd\", 1);\n        generateGraphWithGCD(n, m, gcd);\n    } else {\n        // Other types can be added here\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateRandomGraph(int n, int m) {\n    // Initialize edges\n    vector<pair<int,int>> edges;\n\n    // Ensure each node has at least one outgoing edge\n    for(int i = 1; i <= n; i++) {\n        int u = i;\n        int v = rnd.next(1, n);\n        while(v == u) v = rnd.next(1, n);\n        edges.push_back({u, v});\n    }\n\n    // Add remaining edges\n    int remaining = m - n;\n    for(int i = 0; i < remaining; i++) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while(v == u) v = rnd.next(1, n);\n        edges.push_back({u, v});\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nvoid generateGraphWithGCD(int n, int m, int gcd) {\n    // Partition nodes into cycles of lengths that have GCD gcd\n\n    vector<int> cycle_lengths;\n    int total = 0;\n\n    // Create cycles of lengths as multiples of gcd\n    while(total + gcd <= n) {\n        cycle_lengths.push_back(gcd);\n        total += gcd;\n    }\n    if(total < n) {\n        cycle_lengths.push_back(n - total);\n    }\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; i++)\n        nodes[i] = i + 1;\n    shuffle(nodes.begin(), nodes.end());\n\n    vector<pair<int,int>> edges;\n    int idx = 0;\n\n    for(int len : cycle_lengths) {\n        vector<int> nodes_in_cycle;\n        for(int i = 0; i < len; i++) {\n            nodes_in_cycle.push_back(nodes[idx++]);\n        }\n        // Create a cycle\n        for(int i = 0; i < len; i++) {\n            int u = nodes_in_cycle[i];\n            int v = nodes_in_cycle[(i+1)%len];\n            edges.push_back({u,v});\n        }\n    }\n\n    // Now ensure that each node has at least one outgoing edge\n    // (already ensured by cycles), and m - edges.size() more edges\n    \n    int extra_edges = m - edges.size();\n\n    for(int i = 0; i < extra_edges; i++) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while(v == u) v = rnd.next(1, n);\n        edges.push_back({u,v});\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"random\") {\n        generateRandomGraph(n, m);\n    } else if(type == \"gcd\") {\n        int gcd = opt<int>(\"gcd\", 1);\n        generateGraphWithGCD(n, m, gcd);\n    } else {\n        // Other types can be added here\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 20 -type random\n./gen -n 100 -m 200 -type random\n./gen -n 1000 -m 2000 -type random\n./gen -n 10000 -m 20000 -type random\n./gen -n 100000 -m 200000 -type random\n\n# Generate graphs with GCD of cycle lengths as 1\n./gen -n 10 -m 20 -type gcd -gcd 1\n./gen -n 100 -m 200 -type gcd -gcd 1\n./gen -n 1000 -m 2000 -type gcd -gcd 1\n./gen -n 10000 -m 20000 -type gcd -gcd 1\n./gen -n 100000 -m 200000 -type gcd -gcd 1\n\n# Generate graphs with GCD of cycle lengths as 2\n./gen -n 10 -m 20 -type gcd -gcd 2\n./gen -n 100 -m 200 -type gcd -gcd 2\n./gen -n 1000 -m 2000 -type gcd -gcd 2\n./gen -n 10000 -m 20000 -type gcd -gcd 2\n./gen -n 100000 -m 200000 -type gcd -gcd 2\n\n# Generate graphs with equal cycles of length 3 (GCD 3)\n./gen -n 9 -m 15 -type gcd -gcd 3\n./gen -n 99 -m 198 -type gcd -gcd 3\n./gen -n 999 -m 1998 -type gcd -gcd 3\n./gen -n 9999 -m 19998 -type gcd -gcd 3\n./gen -n 99999 -m 199998 -type gcd -gcd 3\n\n# Edge cases with minimum n and m\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type gcd -gcd 1\n\n# Maximum size test cases\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type gcd -gcd 1\n./gen -n 100000 -m 100000 -type gcd -gcd 2\n\n# Additional test cases\n./gen -n 50000 -m 100000 -type random\n./gen -n 50000 -m 100000 -type gcd -gcd 1\n./gen -n 50000 -m 100000 -type gcd -gcd 2\n\n# Test cases with GCD 5\n./gen -n 10 -m 20 -type gcd -gcd 5\n./gen -n 100 -m 250 -type gcd -gcd 5\n./gen -n 1000 -m 2500 -type gcd -gcd 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:21.288196",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/J",
      "title": "J. Spelling Check",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.",
      "output_spec": "OutputIn the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.",
      "sample_tests": "ExamplesInputCopyabdrakadabraabrakadabraOutputCopy13InputCopyaaaOutputCopy21 2InputCopycompetitioncodeforcesOutputCopy0",
      "description": "J. Spelling Check\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 106 symbols inclusive, the first string contains exactly 1 symbol more than the second one.\n\nOutputIn the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.\n\nInputCopyabdrakadabraabrakadabraOutputCopy13InputCopyaaaOutputCopy21 2InputCopycompetitioncodeforcesOutputCopy0\n\nInputCopyabdrakadabraabrakadabra\n\nOutputCopy13\n\nInputCopyaaa\n\nOutputCopy21 2\n\nInputCopycompetitioncodeforces\n\nOutputCopy0",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    std::string s1 = inf.readLine(\"[a-z]{1,1000000}\", \"s1\");\n    std::string s2 = inf.readLine(\"[a-z]{1,1000000}\", \"s2\");\n    ensuref(s1.length() == s2.length() + 1, \"Length of first string must be exactly one more than length of second string\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    std::string s1 = inf.readLine(\"[a-z]{1,1000000}\", \"s1\");\n    std::string s2 = inf.readLine(\"[a-z]{1,1000000}\", \"s2\");\n    ensuref(s1.length() == s2.length() + 1, \"Length of first string must be exactly one more than length of second string\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    std::string s1 = inf.readLine(\"[a-z]{1,1000000}\", \"s1\");\n    std::string s2 = inf.readLine(\"[a-z]{1,1000000}\", \"s2\");\n    ensuref(s1.length() == s2.length() + 1, \"Length of first string must be exactly one more than length of second string\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\");\n\n    string s1, s2;\n\n    if (type == \"random\") {\n        // Generate random s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        // Insert an extra character at a random position to form s1\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"nosolution\") {\n        // Generate random s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        // Generate s1 such that no deletion from s1 results in s2\n        s1 = \"\";\n        for (int i = 0; i < len + 1; ++i) {\n            char c;\n            do {\n                c = (char)('a' + rnd.next(26));\n            } while ((i < len && c == s2[i]) || (i > 0 && c == s1[i - 1]));\n            s1 += c;\n        }\n    }\n    else if (type == \"manydeletions\") {\n        // s2 consists of a single repeated character\n        char c = (char)('a' + rnd.next(26));\n        s2 = string(len, c);\n        s1 = string(len + 1, c);\n    }\n    else if (type == \"maxlen\") {\n        // Use maximum allowed length\n        len = 1000000; // Max len for s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"minlen\") {\n        // Use minimum allowed length\n        len = 1; // Min len for s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"endsame\") {\n        // s1 ends with an extra character\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2 + extraChar;\n    }\n    else if (type == \"startsame\") {\n        // s1 starts with an extra character\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = extraChar + s2;\n    }\n    else if (type == \"repeating\") {\n        // s2 has a repeating pattern\n        string pattern = \"abc\";\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += pattern[i % 3];\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = pattern[rnd.next(3)];\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"palindrome\") {\n        // s2 is a palindrome\n        string half = \"\";\n        for (int i = 0; i < len / 2; ++i) {\n            half += (char)('a' + rnd.next(26));\n        }\n        string rev_half = half;\n        reverse(rev_half.begin(), rev_half.end());\n        if (len % 2 == 1) {\n            char mid = (char)('a' + rnd.next(26));\n            s2 = half + mid + rev_half;\n        } else {\n            s2 = half + rev_half;\n        }\n        int pos = len / 2;\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else {\n        // Default to random\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n\n    // Output s1 and s2\n    cout << s1 << endl;\n    cout << s2 << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\");\n\n    string s1, s2;\n\n    if (type == \"random\") {\n        // Generate random s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        // Insert an extra character at a random position to form s1\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"nosolution\") {\n        // Generate random s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        // Generate s1 such that no deletion from s1 results in s2\n        s1 = \"\";\n        for (int i = 0; i < len + 1; ++i) {\n            char c;\n            do {\n                c = (char)('a' + rnd.next(26));\n            } while ((i < len && c == s2[i]) || (i > 0 && c == s1[i - 1]));\n            s1 += c;\n        }\n    }\n    else if (type == \"manydeletions\") {\n        // s2 consists of a single repeated character\n        char c = (char)('a' + rnd.next(26));\n        s2 = string(len, c);\n        s1 = string(len + 1, c);\n    }\n    else if (type == \"maxlen\") {\n        // Use maximum allowed length\n        len = 1000000; // Max len for s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"minlen\") {\n        // Use minimum allowed length\n        len = 1; // Min len for s2\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"endsame\") {\n        // s1 ends with an extra character\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2 + extraChar;\n    }\n    else if (type == \"startsame\") {\n        // s1 starts with an extra character\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = extraChar + s2;\n    }\n    else if (type == \"repeating\") {\n        // s2 has a repeating pattern\n        string pattern = \"abc\";\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += pattern[i % 3];\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = pattern[rnd.next(3)];\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else if (type == \"palindrome\") {\n        // s2 is a palindrome\n        string half = \"\";\n        for (int i = 0; i < len / 2; ++i) {\n            half += (char)('a' + rnd.next(26));\n        }\n        string rev_half = half;\n        reverse(rev_half.begin(), rev_half.end());\n        if (len % 2 == 1) {\n            char mid = (char)('a' + rnd.next(26));\n            s2 = half + mid + rev_half;\n        } else {\n            s2 = half + rev_half;\n        }\n        int pos = len / 2;\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n    else {\n        // Default to random\n        s2 = \"\";\n        for (int i = 0; i < len; ++i) {\n            s2 += (char)('a' + rnd.next(26));\n        }\n        int pos = rnd.next(len + 1);\n        char extraChar = (char)('a' + rnd.next(26));\n        s1 = s2.substr(0, pos) + extraChar + s2.substr(pos);\n    }\n\n    // Output s1 and s2\n    cout << s1 << endl;\n    cout << s2 << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -type minlen\n./gen -len 5 -type random\n./gen -len 10 -type random\n./gen -len 10 -type nosolution\n./gen -len 10 -type manydeletions\n./gen -len 10 -type palindrome\n./gen -len 10 -type repeating\n./gen -len 10 -type startsame\n./gen -len 10 -type endsame\n./gen -len 1000 -type random\n./gen -len 5000 -type manydeletions\n./gen -len 5000 -type nosolution\n./gen -len 10000 -type random\n./gen -len 10000 -type repeating\n./gen -len 10000 -type palindrome\n./gen -len 100000 -type random\n./gen -len 100000 -type startsame\n./gen -len 100000 -type endsame\n./gen -len 100000 -type nosolution\n./gen -len 200000 -type random\n./gen -len 300000 -type palindrome\n./gen -len 500000 -type manydeletions\n./gen -len 1000000 -type maxlen\n./gen -len 1000000 -type nosolution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:23.327074",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "39/K",
      "title": "K. Testing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line has three integers n, m и k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 90) — the sizes of the polygon and the number of objects on it respectively. Next n lines contain m symbols each and describe the polygon. The symbol \"*\" stands for a square occupied an object, whereas the symbol \".\" stands for an empty space. The symbols \"*\" form exactly k rectangular connected areas that meet the requirements of the task.",
      "output_spec": "OutputOutput a single number — the number of different ways to hit a target.",
      "sample_tests": "ExamplesInputCopy3 3 3*.*...*..OutputCopy21InputCopy4 5 4.*.**...****......**OutputCopy38InputCopy2 2 1.*..OutputCopy4",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line has three integers n, m и k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 90) — the sizes of the polygon and the number of objects on it respectively. Next n lines contain m symbols each and describe the polygon. The symbol \"*\" stands for a square occupied an object, whereas the symbol \".\" stands for an empty space. The symbols \"*\" form exactly k rectangular connected areas that meet the requirements of the task.\n\nOutputOutput a single number — the number of different ways to hit a target.\n\nInputCopy3 3 3*.*...*..OutputCopy21InputCopy4 5 4.*.**...****......**OutputCopy38InputCopy2 2 1.*..OutputCopy4\n\nInputCopy3 3 3*.*...*..\n\nOutputCopy21\n\nInputCopy4 5 4.*.**...****......**\n\nOutputCopy38\n\nInputCopy2 2 1.*..\n\nOutputCopy4",
      "solutions": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11) - Codeforces",
          "content": "Good day to everybody!Welcome to School Team Contest #1 that will be held on the 24th of October at 11:00 MSK. The contest will be official for school teams as a part of the series of winter programming school olympiads (http://codeforces.com/blog/entry/753), and it will be informal (and not rated!) contest for everyone else.To compete officially, each participant of a school team must at first register personally, then you must create a team of registered participants, and when registration to the contest opens, you must register your team there too.I hope that the problems will be interesting for school students with different level of programming skills, and not only for school students! Pay attention to some differences from usual Codeforces contests. First, the duration of the contest is 5 hours, and there will be standard ACM rules. Second, problems will not be sorted in increasing order by their complexity, they will be shuffled. So your first problem for you is to find an easy problem :)The authors of the problems are Mikhail Mirzayanov and me. Thanks to Gerald Agapov, Polina Bondarenko and Artem Rakhov, who helped me to prepare the round. Also thanks to Maria Belova for translating problem statements into English. We all are from Saratov State University.Good luck!  UPD: After the contest start, it will be available PDF-versions of the statements:RussianEnglishUPD: The contest is over. The results are available. The winner in both official and non-official standings is Gennady Korotkevich, who has solved all the problems. Congratulations to the winner! The problem analysis is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/781",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1622
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces",
          "content": "Problem ATo get the maximal possible result you have just to sort summands in non-decreasing order by coefficients (counting coefficients with preceeding signs + and -). You should not pay attention to 'a++' or '++a'! The question is: why is it true? First, consider an expression with only 'a++'. Then our assertion is obvious: it is better to multiply 'a' by small coefficients when it has small value, and by large coefficients, when it becomes larger. The same also takes place in case of negative coefficients or a-value. Of course, it is not a rigorous proof. I hope you will think on it if you haven't get it yet.Second, consider the expression k * a +  +  + k *  +  + a, where k is some coefficient equal for both summands. Let initial value of 'a' equals to a0. Calculating the value of the expression both ways, we obtain: k * a0 + k * (a0 + 2) = k * (a0 + 1) + k * (a0 + 1). So in this case the order is immaterial.Third, let us have the expression k * a +  +  + l *  +  + a, where k and l are two distinct coefficients. This expression can have two different values: k * a0 + l * (a0 + 2) and k * (a0 + 1) + l * (a0 + 1). The first value is greater than the second one if and only if k < l. We can deal with the expression k*++a+l*a++ analogously.Thus if we have two succesive summands with the same coefficient, we may swap or not to swap them. If we have two succesive summands with distinct coefficients, we must put the summand with a smaller coeficient first. Applying these considerations while it is necessary, we get a sequence of summands sorted by coefficients.  Porblem BFor this problem, the greedy solution is acceptable. Process given numbers consequently until 1 is found. Then continue to process searching for 2, then for 3, etc.Problem CThe authors solution takes O(n2) time and O(n2) memory. Solutions with time and O(n) memory are also acceptable.Let us reformulate the problem. Given a set of segments on a line, and the task is to find the largest subset such that segments in it don't intersect ``partially''. Two segments [a, b] and [c, d] intersect partially, if, for instance, a < c < b < d.Take all the ends of the given segments, sort them, and compute the dynamics: dl, r is the largest possible size of such subset that segments in don't intersect partially and located between the l-th end and the r end (in sorted order), inclusively. We want to compute dl, r having already computed di, j for all l ≤ i ≤ j ≤ r, but [i, j] ≠ [l, r]. First put dl, r = dl + 1, r if we don't take segments with the left end in l. Now process the segments with the left end in l. If the segment [l, r] exists, we undoubtedly take it to our set. If we take another segment, say, [l, i], where i < r, look at segments [l, i] and [i, r] (we have  answers for them already computed) and try to update dl, r. The asymptotics is O(n2), because  the total number of left ends is O(n). Then you have to output the certificate, i.e. the optimal set itself. It can be done in the standard way.Problem DThe flies can NOT see each other iff they are in opposite vertices. You may use multiple ways to check this. For instance, you can check the Manhattan distance |x1 - x2| + |y1 - y2| + |z1 - z2| = 3 or the Euclidian distance . You can check if all three coorditanes are distinct (x1 != x2) && (y1 != y2) && (z1 != z2), or just (x1^x2)+(y1^y2)+(z1^z2) == 3!Problem EThe number of ways to put b items into a boxes is, of course, ab. So we have an acyclic game for two players with positions (a, b) for which ab < n. Unfortunatly, there exists an infinite number of such positions: a = 1, b is any. But in this case, if 2b ≥ n, it is a draw position, because the only way for both players (not leading to lose) is to increase b infinitely. Another special case is a position with b = 1 and rather large a. Namely, if , there is also only one move from this position - to increase a. If a = n - 1 the position is losing, if a = n - 2 it is winning, for a = n - 3 it is losing again and so on.Thus we have two kinds of positions to deal with them specially. The number of other positions is not very large, and you can compute the standard dynamics for acyclic games for them.Problem FThe simple modelling of frog's jumps works too long, because n can be 109. The right solution is to count for each frog a number of smashed mosquitoes by checking divisibility of numbers of hills with mosquitoes by di.Problem GWhat can I say about problem G? You should parse a given function and calculate its value for all values of n. Of course, it is impossible to do it just implementing the recursion, because this can work too long (see example with Fibonacci sequence). So you should use dynamic programming.Problem HYou have to calculate all products i * j, and output them in the system of notations with radix k.Problem IConsider only the part of the graph reachable from 1. The task is to find the largest number t, such that a chosen set of vertices is reachable only at moments divisible by t. Suppose we have built  such a set S0. Look at sets S1, S2, ..., St - 1 of all vertices reachable at  moments having remainders 1, 2, ..., t - 1 modulo t, respectively. One can easily check that these sets are disjoint, and their union coinside with the set of all reacheble vertices. Clearly, that the edge from u to v can exist only when u and v belong to consequetive sets, i.e. , , k + 1 is taken modulo t.For each vertex v, find a distance dv from 1 to v (if there is multiple paths, choose any, for example, by dfs). If the edge exists from u to v, it must be . By analyzing all the edges, we come to the conclusion that the optimal value of t equals to the greatest common divisor of the numbers |du + 1 - dv|. To find the set S0 is not very difficult now.Problem JThe simplest solution is to find two numbers l and r - the length of the longest common prefix and the length of the longest common suffix of two strings, respectively. If l + 1 < n - r then there is no solution. Here n is the length of the first string. Otherwise we should output positions from max(n - r, 1) to min(l + 1, n).Problem KProblem K has a great number of different solutions, so I'm surprised that there was a lack of them during the contest. Solutions with time O(k4) and even some O(k5) solutions with optimization were acceptable, but KADR describes even better solution in O(k3) (http://codeforces.com/blog/entry/793).Here are some jury ideas of this problem. First, let us compress the coordinates. Choose a labeled point in each object and compute by the standard dynamics the number of such labels in each rectangle. It takes O(k4) to process all possible rectangles. The problem arises that a rectangle may contain a valid number of objects, but contain some objects not completely. To prevent this, we can check the borders. They are segments parallel to the coordinate axes, and their number is O(k3). So we can precalc for them if they are valid or not comparing them with each object. Then we have to come back to uncompressed coordinates.The following solution is O(k5), and it uses the limitation on the number of objects (3) inside the rectangle. Process all the triples of objects (the same, of course, with pairs and single objects). Fix a triple, and change it by a single big object. Then move from the resulting object up (and then down), and check if a row above (or below) can be included in a striked rectangle. For each row we find a longest segment [l, r], which contains the current big object and doesn't contain others. Using this information, one can easily calculate the total number of rectangles that contain the current triple.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7649
        },
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Problem K Tutorial - Codeforces",
          "content": "Suppose that the top and the bottom borders of the rectangle are fixed, and we are to choose only the left and the right borders. Then we can in O(K) find a list of all the rectangles which are contained in our band, and also a list of all the rectangles having a part in our fixed strip. We can represent it as a sorted collection of segments [l, r], where l and r are x-coordinates of left and right borders of a rectangle.                                                                                                                                          If multiple segments in the collection have a common point, glue them to make a one long segment, and memorize that now it really represents two segments. Thus, after such a gluing we obtain a collection of segments, and for each segment in the collection we know the number of rectangles covered by it (if there is a rectangle in it not lying in the band completely, we threat this segment as if it contains an infinity number of rectangles). Now we can process all the free segments (located between neirbouring segments in ur collection) and count the number of ways to cover them by a segment including no more than three objects (for this we will memorize only free segments separated from the current one by not more than three objects).  Thus, we already have the O(N^2 K) solution: to try all possible horisontal bands and to compute for each of them in O(K) the number of rectangles covering from 1 to 3 objects. Note that if, for instance, the top border of the band touch no object, then we can move it up or down, and the answer for the band wouldn't change. Hence we can take as a border of a band only those rows, which contain at least one square belonging to an object, and then multiply the obtained result by the distance to the closest \"non-empty\" strings from above and below.     Thus, we get the solution working O(K^3) and not depending on the field size or the limit on the number of covered objects.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/793",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1987
        }
      ],
      "code_examples": [
        {
          "title": "School Team Contest #1 (Winter Computer School 2010/11): Tutorial - Codeforces - Code 1",
          "code": "5\n2 1\n4 1\n6 1\n8 1\n5 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/786",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 90, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Line %d must contain exactly %d characters\", i + 1, m);\n\n        for (int j = 0; j < m; j++) {\n            ensuref(grid[i][j] == '.' || grid[i][j] == '*', \"Invalid character '%c' at position (%d, %d)\", grid[i][j], i + 1, j + 1);\n        }\n    }\n\n    vector<vector<int> > label(n, vector<int>(m, -1));\n    int label_count = 0;\n\n    int dx[4] = {0, 0, -1, 1}; // direction arrays for adjacency (up, down, left, right)\n    int dy[4] = {-1, 1, 0, 0};\n\n    // Label connected components of '*'\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '*' && label[i][j] == -1) {\n                queue<pair<int, int> > q;\n                q.push(make_pair(i, j));\n                label[i][j] = label_count;\n\n                while (!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n\n                    for (int dir = 0; dir < 4; dir++) {\n                        int nx = x + dx[dir];\n                        int ny = y + dy[dir];\n\n                        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                            if (grid[nx][ny] == '*' && label[nx][ny] == -1) {\n                                label[nx][ny] = label_count;\n                                q.push(make_pair(nx, ny));\n                            }\n                        }\n                    }\n                }\n\n                label_count++;\n            }\n        }\n    }\n\n    ensuref(label_count == k, \"Found %d rectangles, but k = %d\", label_count, k);\n\n    // For each rectangle, verify it forms a rectangle without holes and does not touch other rectangles\n    for (int l = 0; l < label_count; l++) {\n        int min_row = n, max_row = -1, min_col = m, max_col = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (label[i][j] == l) {\n                    if (i < min_row) min_row = i;\n                    if (i > max_row) max_row = i;\n                    if (j < min_col) min_col = j;\n                    if (j > max_col) max_col = j;\n                }\n            }\n        }\n\n        // Check that all cells within the bounding rectangle are '*'\n        for (int i = min_row; i <= max_row; i++) {\n            for (int j = min_col; j <= max_col; j++) {\n                ensuref(label[i][j] == l, \"Rectangle %d is not continuous at position (%d, %d)\", l + 1, i + 1, j + 1);\n            }\n        }\n\n        // Check that the rectangle does not touch other rectangles\n        for (int i = min_row; i <= max_row; i++) {\n            for (int j = min_col; j <= max_col; j++) {\n                for (int dir = 0; dir < 4; dir++) {\n                    int ni = i + dx[dir];\n                    int nj = j + dy[dir];\n                    if (0 <= ni && ni < n && 0 <= nj && nj < m) {\n                        if (grid[ni][nj] == '*') {\n                            if (label[ni][nj] != l) {\n                                ensuref(false, \"Rectangles %d and %d touch at (%d, %d)\", l + 1, label[ni][nj] + 1, ni + 1, nj + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 90, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Line %d must contain exactly %d characters\", i + 1, m);\n\n        for (int j = 0; j < m; j++) {\n            ensuref(grid[i][j] == '.' || grid[i][j] == '*', \"Invalid character '%c' at position (%d, %d)\", grid[i][j], i + 1, j + 1);\n        }\n    }\n\n    vector<vector<int> > label(n, vector<int>(m, -1));\n    int label_count = 0;\n\n    int dx[4] = {0, 0, -1, 1}; // direction arrays for adjacency (up, down, left, right)\n    int dy[4] = {-1, 1, 0, 0};\n\n    // Label connected components of '*'\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '*' && label[i][j] == -1) {\n                queue<pair<int, int> > q;\n                q.push(make_pair(i, j));\n                label[i][j] = label_count;\n\n                while (!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n\n                    for (int dir = 0; dir < 4; dir++) {\n                        int nx = x + dx[dir];\n                        int ny = y + dy[dir];\n\n                        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                            if (grid[nx][ny] == '*' && label[nx][ny] == -1) {\n                                label[nx][ny] = label_count;\n                                q.push(make_pair(nx, ny));\n                            }\n                        }\n                    }\n                }\n\n                label_count++;\n            }\n        }\n    }\n\n    ensuref(label_count == k, \"Found %d rectangles, but k = %d\", label_count, k);\n\n    // For each rectangle, verify it forms a rectangle without holes and does not touch other rectangles\n    for (int l = 0; l < label_count; l++) {\n        int min_row = n, max_row = -1, min_col = m, max_col = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (label[i][j] == l) {\n                    if (i < min_row) min_row = i;\n                    if (i > max_row) max_row = i;\n                    if (j < min_col) min_col = j;\n                    if (j > max_col) max_col = j;\n                }\n            }\n        }\n\n        // Check that all cells within the bounding rectangle are '*'\n        for (int i = min_row; i <= max_row; i++) {\n            for (int j = min_col; j <= max_col; j++) {\n                ensuref(label[i][j] == l, \"Rectangle %d is not continuous at position (%d, %d)\", l + 1, i + 1, j + 1);\n            }\n        }\n\n        // Check that the rectangle does not touch other rectangles\n        for (int i = min_row; i <= max_row; i++) {\n            for (int j = min_col; j <= max_col; j++) {\n                for (int dir = 0; dir < 4; dir++) {\n                    int ni = i + dx[dir];\n                    int nj = j + dy[dir];\n                    if (0 <= ni && ni < n && 0 <= nj && nj < m) {\n                        if (grid[ni][nj] == '*') {\n                            if (label[ni][nj] != l) {\n                                ensuref(false, \"Rectangles %d and %d touch at (%d, %d)\", l + 1, label[ni][nj] + 1, ni + 1, nj + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 90, \"k\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Line %d must contain exactly %d characters\", i + 1, m);\n\n        for (int j = 0; j < m; j++) {\n            ensuref(grid[i][j] == '.' || grid[i][j] == '*', \"Invalid character '%c' at position (%d, %d)\", grid[i][j], i + 1, j + 1);\n        }\n    }\n\n    vector<vector<int> > label(n, vector<int>(m, -1));\n    int label_count = 0;\n\n    int dx[4] = {0, 0, -1, 1}; // direction arrays for adjacency (up, down, left, right)\n    int dy[4] = {-1, 1, 0, 0};\n\n    // Label connected components of '*'\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '*' && label[i][j] == -1) {\n                queue<pair<int, int> > q;\n                q.push(make_pair(i, j));\n                label[i][j] = label_count;\n\n                while (!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n\n                    for (int dir = 0; dir < 4; dir++) {\n                        int nx = x + dx[dir];\n                        int ny = y + dy[dir];\n\n                        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                            if (grid[nx][ny] == '*' && label[nx][ny] == -1) {\n                                label[nx][ny] = label_count;\n                                q.push(make_pair(nx, ny));\n                            }\n                        }\n                    }\n                }\n\n                label_count++;\n            }\n        }\n    }\n\n    ensuref(label_count == k, \"Found %d rectangles, but k = %d\", label_count, k);\n\n    // For each rectangle, verify it forms a rectangle without holes and does not touch other rectangles\n    for (int l = 0; l < label_count; l++) {\n        int min_row = n, max_row = -1, min_col = m, max_col = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (label[i][j] == l) {\n                    if (i < min_row) min_row = i;\n                    if (i > max_row) max_row = i;\n                    if (j < min_col) min_col = j;\n                    if (j > max_col) max_col = j;\n                }\n            }\n        }\n\n        // Check that all cells within the bounding rectangle are '*'\n        for (int i = min_row; i <= max_row; i++) {\n            for (int j = min_col; j <= max_col; j++) {\n                ensuref(label[i][j] == l, \"Rectangle %d is not continuous at position (%d, %d)\", l + 1, i + 1, j + 1);\n            }\n        }\n\n        // Check that the rectangle does not touch other rectangles\n        for (int i = min_row; i <= max_row; i++) {\n            for (int j = min_col; j <= max_col; j++) {\n                for (int dir = 0; dir < 4; dir++) {\n                    int ni = i + dx[dir];\n                    int nj = j + dy[dir];\n                    if (0 <= ni && ni < n && 0 <= nj && nj < m) {\n                        if (grid[ni][nj] == '*') {\n                            if (label[ni][nj] != l) {\n                                ensuref(false, \"Rectangles %d and %d touch at (%d, %d)\", l + 1, label[ni][nj] + 1, ni + 1, nj + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command line options\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_attempts = 1000;\n    vector<string> grid(n, string(m, '.'));\n    vector<vector<int>> occupied(n, vector<int>(m, 0));\n\n    for (int rect = 0; rect < k; rect++) {\n        bool placed = false;\n        for (int attempt = 0; attempt < max_attempts; attempt++) {\n            int w, h;\n            if (type == \"random\") {\n                int min_w = 1, max_w = min(n, 20);\n                int min_h = 1, max_h = min(m, 20);\n                w = rnd.next(min_w, max_w);\n                h = rnd.next(min_h, max_h);\n            } else if (type == \"single_cell\") {\n                w = h = 1;\n            } else if (type == \"large_rectangles\") {\n                int min_w = max(n / (k * 2), 1), max_w = max(n / k, 1);\n                int min_h = max(m / (k * 2), 1), max_h = max(m / k, 1);\n                w = rnd.next(min_w, max_w);\n                h = rnd.next(min_h, max_h);\n            } else if (type == \"vertical_stripes\") {\n                w = 1;\n                int min_h = max(m / (k * 2), 1), max_h = max(m / k, 1);\n                h = rnd.next(min_h, max_h);\n            } else if (type == \"horizontal_stripes\") {\n                h = 1;\n                int min_w = max(n / (k * 2), 1), max_w = max(n / k, 1);\n                w = rnd.next(min_w, max_w);\n            } else {\n                // Default to random\n                int min_w = 1, max_w = min(n, 20);\n                int min_h = 1, max_h = min(m, 20);\n                w = rnd.next(min_w, max_w);\n                h = rnd.next(min_h, max_h);\n            }\n\n            if (w > n) w = n;\n            if (h > m) h = m;\n\n            if (w == 0 || h == 0)\n                continue;\n\n            int x0 = rnd.next(0, n - w);\n            int y0 = rnd.next(0, m - h);\n\n            // can_place function\n            bool can_place = true;\n            for (int x = x0 - 1; x <= x0 + w; ++x) {\n                for (int y = y0 - 1; y <= y0 + h; ++y) {\n                    if (x >= 0 && x < n && y >= 0 && y < m) {\n                        if (occupied[x][y]) { can_place = false; break; }\n                    }\n                }\n                if (!can_place) break;\n            }\n\n            if (can_place) {\n                // Place rectangle\n                for (int x = x0; x < x0 + w; ++x) {\n                    for (int y = y0; y < y0 + h; ++y) {\n                        grid[x][y] = '*';\n                        occupied[x][y] = 1;\n                    }\n                }\n                placed = true;\n                break;\n            }\n        }\n        if (!placed) {\n            fprintf(stderr, \"Failed to place rectangle #%d\\n\", rect + 1);\n            exit(1);\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command line options\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_attempts = 1000;\n    vector<string> grid(n, string(m, '.'));\n    vector<vector<int>> occupied(n, vector<int>(m, 0));\n\n    for (int rect = 0; rect < k; rect++) {\n        bool placed = false;\n        for (int attempt = 0; attempt < max_attempts; attempt++) {\n            int w, h;\n            if (type == \"random\") {\n                int min_w = 1, max_w = min(n, 20);\n                int min_h = 1, max_h = min(m, 20);\n                w = rnd.next(min_w, max_w);\n                h = rnd.next(min_h, max_h);\n            } else if (type == \"single_cell\") {\n                w = h = 1;\n            } else if (type == \"large_rectangles\") {\n                int min_w = max(n / (k * 2), 1), max_w = max(n / k, 1);\n                int min_h = max(m / (k * 2), 1), max_h = max(m / k, 1);\n                w = rnd.next(min_w, max_w);\n                h = rnd.next(min_h, max_h);\n            } else if (type == \"vertical_stripes\") {\n                w = 1;\n                int min_h = max(m / (k * 2), 1), max_h = max(m / k, 1);\n                h = rnd.next(min_h, max_h);\n            } else if (type == \"horizontal_stripes\") {\n                h = 1;\n                int min_w = max(n / (k * 2), 1), max_w = max(n / k, 1);\n                w = rnd.next(min_w, max_w);\n            } else {\n                // Default to random\n                int min_w = 1, max_w = min(n, 20);\n                int min_h = 1, max_h = min(m, 20);\n                w = rnd.next(min_w, max_w);\n                h = rnd.next(min_h, max_h);\n            }\n\n            if (w > n) w = n;\n            if (h > m) h = m;\n\n            if (w == 0 || h == 0)\n                continue;\n\n            int x0 = rnd.next(0, n - w);\n            int y0 = rnd.next(0, m - h);\n\n            // can_place function\n            bool can_place = true;\n            for (int x = x0 - 1; x <= x0 + w; ++x) {\n                for (int y = y0 - 1; y <= y0 + h; ++y) {\n                    if (x >= 0 && x < n && y >= 0 && y < m) {\n                        if (occupied[x][y]) { can_place = false; break; }\n                    }\n                }\n                if (!can_place) break;\n            }\n\n            if (can_place) {\n                // Place rectangle\n                for (int x = x0; x < x0 + w; ++x) {\n                    for (int y = y0; y < y0 + h; ++y) {\n                        grid[x][y] = '*';\n                        occupied[x][y] = 1;\n                    }\n                }\n                placed = true;\n                break;\n            }\n        }\n        if (!placed) {\n            fprintf(stderr, \"Failed to place rectangle #%d\\n\", rect + 1);\n            exit(1);\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -k 3 -type random\n./gen -n 10 -m 10 -k 5 -type single_cell\n./gen -n 10 -m 10 -k 2 -type large_rectangles\n./gen -n 100 -m 100 -k 10 -type random\n./gen -n 100 -m 100 -k 20 -type single_cell\n./gen -n 100 -m 100 -k 10 -type vertical_stripes\n./gen -n 100 -m 100 -k 10 -type horizontal_stripes\n./gen -n 100 -m 100 -k 5 -type large_rectangles\n./gen -n 1000 -m 1000 -k 50 -type random\n./gen -n 1000 -m 1000 -k 90 -type single_cell\n./gen -n 1000 -m 1000 -k 90 -type vertical_stripes\n./gen -n 1000 -m 1000 -k 90 -type horizontal_stripes\n./gen -n 1000 -m 1000 -k 30 -type large_rectangles\n./gen -n 500 -m 500 -k 50 -type random\n./gen -n 500 -m 500 -k 45 -type single_cell\n./gen -n 500 -m 500 -k 50 -type vertical_stripes\n./gen -n 500 -m 500 -k 50 -type horizontal_stripes\n./gen -n 500 -m 500 -k 20 -type large_rectangles\n./gen -n 100 -m 1000 -k 10 -type random\n./gen -n 1000 -m 100 -k 10 -type random\n./gen -n 1000 -m 1000 -k 1 -type large_rectangles\n./gen -n 1000 -m 1000 -k 1 -type single_cell\n./gen -n 1000 -m 1000 -k 90 -type random\n./gen -n 1 -m 1000 -k 1 -type horizontal_stripes\n./gen -n 1000 -m 1 -k 1 -type vertical_stripes\n./gen -n 1000 -m 1000 -k 90 -type large_rectangles\n./gen -n 1 -m 1 -k 1 -type single_cell\n./gen -n 1000 -m 1000 -k 90 -type single_cell\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:25.979786",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "390/A",
      "title": "A. Inna and Alarm Clock",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the number of the alarm clocks. The next n lines describe the clocks: the i-th line contains two integers xi, yi — the coordinates of the i-th alarm clock (0 ≤ xi, yi ≤ 100).Note that a single point in the room can contain any number of alarm clocks and the alarm clocks can lie on the sides of the square that represents the room.",
      "output_spec": "OutputIn a single line print a single integer — the minimum number of segments Inna will have to draw if she acts optimally.",
      "sample_tests": "ExamplesInputCopy40 00 10 21 0OutputCopy2InputCopy40 00 11 01 1OutputCopy2InputCopy41 11 22 33 3OutputCopy3",
      "description": "A. Inna and Alarm Clock\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the number of the alarm clocks. The next n lines describe the clocks: the i-th line contains two integers xi, yi — the coordinates of the i-th alarm clock (0 ≤ xi, yi ≤ 100).Note that a single point in the room can contain any number of alarm clocks and the alarm clocks can lie on the sides of the square that represents the room.\n\nOutputIn a single line print a single integer — the minimum number of segments Inna will have to draw if she acts optimally.\n\nInputCopy40 00 10 21 0OutputCopy2InputCopy40 00 11 01 1OutputCopy2InputCopy41 11 22 33 3OutputCopy3\n\nInputCopy40 00 10 21 0\n\nOutputCopy2\n\nInputCopy40 00 11 01 1\n\nOutputCopy2\n\nInputCopy41 11 22 33 3\n\nOutputCopy3\n\nNoteIn the first sample, Inna first chooses type \"vertical segments\", and then she makes segments with ends at : (0, 0), (0, 2); and, for example, (1, 0), (1, 1). If she paints horizontal segments, she will need at least 3 segments.In the third sample it is important to note that Inna doesn't have the right to change the type of the segments during the game. That's why she will need 3 horizontal or 3 vertical segments to end the game.",
      "solutions": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces",
          "content": "Since the original data has been lost during the dark days of Codeforces, no version of the editorial has been re-released, and I feel the round itself is quite educational, so I decided to give a try.390A - Inna and Alarm Clock ApproachThe criterion shows that we can only use either vertical segments or horizontal segments.Since there is no limit on the segments' length, we can see that it's always optimal to use a segment with infinite length (or may be known as a line).We can see that the vertical line x = a will span through every alarm clocks standing at positions with x-coordinate being equal to a. In a similar manner, the horizontal line y = b will span through every alarm clocks standing at positions with y-coordinate being equal to b.So, if we use vertical lines, the number of segments used will be the number of distinct values of x-coordinates found in the data. Similarly, the number of horizontal segments used will be the number of distinct values of y-coordinates found.The process can be implemented by a counting array, or a map.Time complexity: for regular arrays, or for maps. Solution 1 (Map)Submission link: 48214007 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tmap<int, int> cntx, cnty;\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\n\treturn 0;\n} Solution 2 (Array)Submission link: 48213984 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t distinctx += (cntx[i] > 0);\n\t distincty += (cnty[i] > 0);\n\t}\n\n\tcout << min(distinctx, distincty) << endl;\n\n\treturn 0;\n}390B - Inna, Dima and Song ApproachFrom the constraints given, for the i-th song, provided there exists corresponding xi and yi values, then the following inequality must hold: 2 ≤ xi + yi ≤ 2·ai.Thus, if any bi is either lower than 2 or higher than 2·ai, then no xi and yi can be found, thus, Sereja's joy will surely decrease by 1.Amongst all pairs of that xi + yi = bi, the pair with the highest value of xi·yi will be one with the equal value of xi = yi (this can be proven by the famous AM-GM inequality).Thus, if bi is divisible by 2, we can easily pick .Also, from this, we can see (either intuitively or with static proofs) that the lower the difference between xi and yi is, the higher the value xi·yi will be. Thus, in case bi being odd, the most optimal pair will be or (the order doesn't matter here).Time complexity: . SolutionSubmission link: 48212208 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\n\treturn 0;\n}390C - Inna and Candy Boxes ApproachThe query content looks pretty confusing at first, to be honest.Since k is static throughout a scenario, we can group the boxes into k groups, the z-th box (in this editorial let's assume that the indices of the boxes start from 0) falls into group number .Then, each query can be simplified as this: \"Is that true that among the boxes with numbers from li to ri, inclusive, the candies lie only in boxes of group ?To make sure the answer for a query being \"Yes\", Dima has to remove candies from all candied-box in all groups other than , while in that exact group, fill every empty box with a candy. Obviously, we'll consider boxes with indices between li and ri inclusively only.We can make k lists, the t-th (0-indexed) list stores the indices of candied boxes in group t.We'll process with each query as the following: Obviously, given from the criteria, each range will consist of exactly boxes per each group. Let's denote . Traverse all groups, for the t-th group (again, 0-indexed), let's denote xt as the number of candied boxes of group t in the given range. This value can be calculated quickly through binary searching the constructed lists above. If group t is not the group being demanded to have candies (group ), we'll need to perform xt actions (removing candies). Otherwise, we'll need to perform A - xt actions (adding candies to empty boxes). Time complexity: . SolutionSubmission link: 48213932 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\n\tvector< vector<int> > CandyGrp(k);\n\n\tfor (int i=0; i<n; i++) {\n\t if (s[i] == '0') continue;\n\t CandyGrp[i % k].push_back(i);\n\t}\n\n\twhile (w--) {\n\t int l, r;\n\t\tcin >> l >> r; l--; r--;\n\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\n\t\tfor (int id=0; id<k; id++) {\n\n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\n\t\t\tif (id == demandedGroup) {\n\t\t\t res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}390D - Inna and Sweet Matrix ApproachWe can see that the most optimal placement will be choosing k cells being nearest to cell (1, 1) (yup, including (1, 1) itself).To find these k points, we can simply do a BFS starting from (1, 1), with traceback feature to construct the paths to get to those cells.However, keep in mind that any cell being candied will later on become obstacles for the following paths. Thus, to avoid blocking yourself, you should transfer candies to the farthest cells first, then getting closer. Thus, cell (1, 1) will be the last one being filled with candy.Time complexity: or , based on implementation (I myself did , since the difference isn't too much). SolutionSubmission link: 48213856 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, k; cin >> n >> m >> k;\n\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n\n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\n\t\tcost += Dist[x][y];\n\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}390E - Inna and Large Sweet Matrix ApproachLet's denote A as the total number of candies on the board, Ri as the total number of candies on the i-th row (1 ≤ i ≤ n), Cj as the total number of candies on the j-th column (1 ≤ j ≤ m).Also, let's denote and .Let's considered the 2nd type of query first. Denoting the answer for the query as f(x1, y1, x2, y2), we can see that f(x1, y1, x2, y2) = R(x1, x2) + C(y1, y2) - A (you can draw a simple diagram and validate this function).Thus, the problem is now reduced to calculating R(x1, x2), C(y1, y2) and A: A can be easily calculated. After each query of the 1st type with parameters x1, y1, x2, y2, v; A will be increased by v·(x2 - x1 + 1)·(y2 - y1 + 1). The calculation of R(x1, x2) and C(y1, y2) makes us thinking about some kinds of data structures that support range sum update and range sum query. Segment trees and Fenwick trees can both work on that. Personally I used segment trees, they fit in just right for the memory limit (I implemented it by vectors, regular arrays will obviously be safer). Time complexity: . SolutionSubmission link: 48213830 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, w; cin >> n >> m >> w;\n\n\tlong long TotalCandies = 0;\n\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/64453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 390\\s*A"
          },
          "content_length": 12129
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 1",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 2",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 3",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 4",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 5",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 6",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 7",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 8",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 11",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 12",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 100);\n        inf.readSpace();\n        int y = inf.readInt(0, 100);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 100);\n        inf.readSpace();\n        int y = inf.readInt(0, 100);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 100);\n        inf.readSpace();\n        int y = inf.readInt(0, 100);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        // Generate random points in 0..100 x 0..100\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"same_x\") {\n        // All points have the same x-coordinate\n        int x = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"same_y\") {\n        // All points have the same y-coordinate\n        int y = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"few_x\") {\n        // Small number of distinct x-coordinates\n        int k = opt<int>(\"k\", 10); // Default to 10 distinct x-coordinates\n        vector<int> xs(k);\n        for (int i = 0; i < k; ++i) xs[i] = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int x = xs[rnd.next(0, k - 1)];\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"few_y\") {\n        // Small number of distinct y-coordinates\n        int k = opt<int>(\"k\", 10); // Default to 10 distinct y-coordinates\n        vector<int> ys(k);\n        for (int i = 0; i < k; ++i) ys[i] = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = ys[rnd.next(0, k - 1)];\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"diagonal\") {\n        // Points with x = y\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = x;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"multiple\") {\n        // All points at the same position\n        int x = rnd.next(0, 100);\n        int y = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"full\") {\n        // All possible points in 0..100 x 0..100\n        for (int x = 0; x <= 100; ++x) {\n            for (int y = 0; y <= 100; ++y) {\n                points.emplace_back(x, y);\n            }\n        }\n        // If n > 10201, add extra random points\n        while ((int)points.size() < n) {\n            int x = rnd.next(0, 100);\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n        // Shuffle and keep only n points\n        shuffle(points.begin(), points.end());\n        points.resize(n);\n    } else if (type == \"grid\") {\n        // Grid pattern\n        int k = opt<int>(\"k\", 10); // Grid size\n        for (int i = 0; i < n; ++i) {\n            int x = (i % k) * (100 / max(k - 1, 1));\n            int y = (i / k) * (100 / max(n / k - 1, 1));\n            x = min(x, 100);\n            y = min(y, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"line\") {\n        // Points on a line y = m * x + c\n        double m = opt<double>(\"m\", 1.0);\n        double c = opt<double>(\"c\", 0.0);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            double y_real = m * x + c;\n            int y = (int)(y_real + 0.5);\n            if (0 <= y && y <= 100) {\n                points.emplace_back(x, y);\n            } else {\n                i--; // Out of bounds, try again\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        // Generate random points in 0..100 x 0..100\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"same_x\") {\n        // All points have the same x-coordinate\n        int x = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"same_y\") {\n        // All points have the same y-coordinate\n        int y = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"few_x\") {\n        // Small number of distinct x-coordinates\n        int k = opt<int>(\"k\", 10); // Default to 10 distinct x-coordinates\n        vector<int> xs(k);\n        for (int i = 0; i < k; ++i) xs[i] = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int x = xs[rnd.next(0, k - 1)];\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"few_y\") {\n        // Small number of distinct y-coordinates\n        int k = opt<int>(\"k\", 10); // Default to 10 distinct y-coordinates\n        vector<int> ys(k);\n        for (int i = 0; i < k; ++i) ys[i] = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = ys[rnd.next(0, k - 1)];\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"diagonal\") {\n        // Points with x = y\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = x;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"multiple\") {\n        // All points at the same position\n        int x = rnd.next(0, 100);\n        int y = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"full\") {\n        // All possible points in 0..100 x 0..100\n        for (int x = 0; x <= 100; ++x) {\n            for (int y = 0; y <= 100; ++y) {\n                points.emplace_back(x, y);\n            }\n        }\n        // If n > 10201, add extra random points\n        while ((int)points.size() < n) {\n            int x = rnd.next(0, 100);\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n        // Shuffle and keep only n points\n        shuffle(points.begin(), points.end());\n        points.resize(n);\n    } else if (type == \"grid\") {\n        // Grid pattern\n        int k = opt<int>(\"k\", 10); // Grid size\n        for (int i = 0; i < n; ++i) {\n            int x = (i % k) * (100 / max(k - 1, 1));\n            int y = (i / k) * (100 / max(n / k - 1, 1));\n            x = min(x, 100);\n            y = min(y, 100);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"line\") {\n        // Points on a line y = m * x + c\n        double m = opt<double>(\"m\", 1.0);\n        double c = opt<double>(\"c\", 0.0);\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            double y_real = m * x + c;\n            int y = (int)(y_real + 0.5);\n            if (0 <= y && y <= 100) {\n                points.emplace_back(x, y);\n            } else {\n                i--; // Out of bounds, try again\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 100);\n            int y = rnd.next(0, 100);\n            points.emplace_back(x, y);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n\n./gen -n 100000 -type same_x\n./gen -n 100000 -type same_y\n\n./gen -n 100000 -type few_x -k 1\n./gen -n 100000 -type few_x -k 2\n./gen -n 100000 -type few_x -k 10\n./gen -n 100000 -type few_x -k 50\n./gen -n 100000 -type few_x -k 100\n\n./gen -n 100000 -type few_y -k 1\n./gen -n 100000 -type few_y -k 2\n./gen -n 100000 -type few_y -k 10\n./gen -n 100000 -type few_y -k 50\n./gen -n 100000 -type few_y -k 100\n\n./gen -n 100000 -type diagonal\n\n./gen -n 100000 -type multiple\n\n./gen -n 10201 -type full\n./gen -n 100000 -type full\n\n./gen -n 100000 -type grid -k 10\n./gen -n 100000 -type grid -k 50\n./gen -n 100000 -type grid -k 100\n\n./gen -n 100000 -type line -m 1 -c 0\n./gen -n 100000 -type line -m -1 -c 100\n\n./gen -n 100000 -type line -m 0 -c 50\n\n./gen -n 100000 -type random\n\n./gen -n 1 -type multiple\n\n./gen -n 100000 -type few_x -k 3\n\n./gen -n 100000 -type few_y -k 3\n\n./gen -n 100000 -type same_x\n./gen -n 100000 -type same_y\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:28.212333",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "390/B",
      "title": "B. Inna, Dima and Song",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the number of notes in the song. The second line contains n integers ai (1 ≤ ai ≤ 106). The third line contains n integers bi (1 ≤ bi ≤ 106).",
      "output_spec": "OutputIn a single line print an integer — the maximum possible joy Sereja feels after he listens to a song.",
      "sample_tests": "ExamplesInputCopy31 1 22 2 3OutputCopy4InputCopy125OutputCopy-1",
      "description": "B. Inna, Dima and Song\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 105) — the number of notes in the song. The second line contains n integers ai (1 ≤ ai ≤ 106). The third line contains n integers bi (1 ≤ bi ≤ 106).\n\nOutputIn a single line print an integer — the maximum possible joy Sereja feels after he listens to a song.\n\nInputCopy31 1 22 2 3OutputCopy4InputCopy125OutputCopy-1\n\nInputCopy31 1 22 2 3\n\nOutputCopy4\n\nInputCopy125\n\nOutputCopy-1\n\nNoteIn the first sample, Dima and Inna play the first two notes at volume 1 (1 + 1 = 2, the condition holds), they should play the last note at volumes 1 and 2. Sereja's total joy equals: 1·1 + 1·1 + 1·2 = 4.In the second sample, there is no such pair (x, y), that 1 ≤ x, y ≤ 2, x + y = 5, so Dima and Inna skip a note. Sereja's total joy equals -1.",
      "solutions": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces",
          "content": "Since the original data has been lost during the dark days of Codeforces, no version of the editorial has been re-released, and I feel the round itself is quite educational, so I decided to give a try.390A - Inna and Alarm Clock ApproachThe criterion shows that we can only use either vertical segments or horizontal segments.Since there is no limit on the segments' length, we can see that it's always optimal to use a segment with infinite length (or may be known as a line).We can see that the vertical line x = a will span through every alarm clocks standing at positions with x-coordinate being equal to a. In a similar manner, the horizontal line y = b will span through every alarm clocks standing at positions with y-coordinate being equal to b.So, if we use vertical lines, the number of segments used will be the number of distinct values of x-coordinates found in the data. Similarly, the number of horizontal segments used will be the number of distinct values of y-coordinates found.The process can be implemented by a counting array, or a map.Time complexity: for regular arrays, or for maps. Solution 1 (Map)Submission link: 48214007 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tmap<int, int> cntx, cnty;\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\n\treturn 0;\n} Solution 2 (Array)Submission link: 48213984 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t distinctx += (cntx[i] > 0);\n\t distincty += (cnty[i] > 0);\n\t}\n\n\tcout << min(distinctx, distincty) << endl;\n\n\treturn 0;\n}390B - Inna, Dima and Song ApproachFrom the constraints given, for the i-th song, provided there exists corresponding xi and yi values, then the following inequality must hold: 2 ≤ xi + yi ≤ 2·ai.Thus, if any bi is either lower than 2 or higher than 2·ai, then no xi and yi can be found, thus, Sereja's joy will surely decrease by 1.Amongst all pairs of that xi + yi = bi, the pair with the highest value of xi·yi will be one with the equal value of xi = yi (this can be proven by the famous AM-GM inequality).Thus, if bi is divisible by 2, we can easily pick .Also, from this, we can see (either intuitively or with static proofs) that the lower the difference between xi and yi is, the higher the value xi·yi will be. Thus, in case bi being odd, the most optimal pair will be or (the order doesn't matter here).Time complexity: . SolutionSubmission link: 48212208 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\n\treturn 0;\n}390C - Inna and Candy Boxes ApproachThe query content looks pretty confusing at first, to be honest.Since k is static throughout a scenario, we can group the boxes into k groups, the z-th box (in this editorial let's assume that the indices of the boxes start from 0) falls into group number .Then, each query can be simplified as this: \"Is that true that among the boxes with numbers from li to ri, inclusive, the candies lie only in boxes of group ?To make sure the answer for a query being \"Yes\", Dima has to remove candies from all candied-box in all groups other than , while in that exact group, fill every empty box with a candy. Obviously, we'll consider boxes with indices between li and ri inclusively only.We can make k lists, the t-th (0-indexed) list stores the indices of candied boxes in group t.We'll process with each query as the following: Obviously, given from the criteria, each range will consist of exactly boxes per each group. Let's denote . Traverse all groups, for the t-th group (again, 0-indexed), let's denote xt as the number of candied boxes of group t in the given range. This value can be calculated quickly through binary searching the constructed lists above. If group t is not the group being demanded to have candies (group ), we'll need to perform xt actions (removing candies). Otherwise, we'll need to perform A - xt actions (adding candies to empty boxes). Time complexity: . SolutionSubmission link: 48213932 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\n\tvector< vector<int> > CandyGrp(k);\n\n\tfor (int i=0; i<n; i++) {\n\t if (s[i] == '0') continue;\n\t CandyGrp[i % k].push_back(i);\n\t}\n\n\twhile (w--) {\n\t int l, r;\n\t\tcin >> l >> r; l--; r--;\n\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\n\t\tfor (int id=0; id<k; id++) {\n\n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\n\t\t\tif (id == demandedGroup) {\n\t\t\t res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}390D - Inna and Sweet Matrix ApproachWe can see that the most optimal placement will be choosing k cells being nearest to cell (1, 1) (yup, including (1, 1) itself).To find these k points, we can simply do a BFS starting from (1, 1), with traceback feature to construct the paths to get to those cells.However, keep in mind that any cell being candied will later on become obstacles for the following paths. Thus, to avoid blocking yourself, you should transfer candies to the farthest cells first, then getting closer. Thus, cell (1, 1) will be the last one being filled with candy.Time complexity: or , based on implementation (I myself did , since the difference isn't too much). SolutionSubmission link: 48213856 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, k; cin >> n >> m >> k;\n\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n\n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\n\t\tcost += Dist[x][y];\n\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}390E - Inna and Large Sweet Matrix ApproachLet's denote A as the total number of candies on the board, Ri as the total number of candies on the i-th row (1 ≤ i ≤ n), Cj as the total number of candies on the j-th column (1 ≤ j ≤ m).Also, let's denote and .Let's considered the 2nd type of query first. Denoting the answer for the query as f(x1, y1, x2, y2), we can see that f(x1, y1, x2, y2) = R(x1, x2) + C(y1, y2) - A (you can draw a simple diagram and validate this function).Thus, the problem is now reduced to calculating R(x1, x2), C(y1, y2) and A: A can be easily calculated. After each query of the 1st type with parameters x1, y1, x2, y2, v; A will be increased by v·(x2 - x1 + 1)·(y2 - y1 + 1). The calculation of R(x1, x2) and C(y1, y2) makes us thinking about some kinds of data structures that support range sum update and range sum query. Segment trees and Fenwick trees can both work on that. Personally I used segment trees, they fit in just right for the memory limit (I implemented it by vectors, regular arrays will obviously be safer). Time complexity: . SolutionSubmission link: 48213830 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, w; cin >> n >> m >> w;\n\n\tlong long TotalCandies = 0;\n\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/64453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 390\\s*B"
          },
          "content_length": 12129
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 1",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 2",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 3",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 4",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 5",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 6",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 7",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 8",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 11",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 12",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 1000000, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 1000000, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 1000000, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"all_possible\") {\n        /* All notes can be played */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            int max_b = min(2 * a[i], (int)1e6);\n            b[i] = rnd.next(2, max_b);\n        }\n    } else if (type == \"all_impossible\") {\n        /* No notes can be played */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            if (rnd.next(2)) {\n                b[i] = rnd.next(1, 1);\n            } else {\n                int min_b = 2 * a[i] + 1;\n                int max_b = (int)1e6;\n                if (min_b > max_b) min_b = max_b;\n                b[i] = rnd.next(min_b, max_b);\n            }\n        }\n    } else if (type == \"mixed\") {\n        /* Mix of playable and unplayable notes */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            if (rnd.next(2)) {\n                int max_b = min(2 * a[i], (int)1e6);\n                b[i] = rnd.next(2, max_b);\n            } else {\n                if (rnd.next(2)) {\n                    b[i] = rnd.next(1, 1);\n                } else {\n                    int min_b = 2 * a[i] + 1;\n                    int max_b = (int)1e6;\n                    if (min_b > max_b) min_b = max_b;\n                    b[i] = rnd.next(min_b, max_b);\n                }\n            }\n        }\n    } else if (type == \"max_a_min_b\") {\n        /* Maximum a_i, minimum b_i */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)1e6;\n            b[i] = 2;\n        }\n    } else if (type == \"min_a_max_b\") {\n        /* Minimum a_i, maximum possible b_i */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = min(2 * 1, (int)1e6);\n        }\n    } else if (type == \"edge_cases\") {\n        /* Edge cases with b_i = 2 or b_i = 2 * a_i */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            if (rnd.next(2)) {\n                b[i] = 2;\n            } else {\n                b[i] = min(2 * a[i], (int)1e6);\n            }\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            b[i] = rnd.next(1, (int)1e6);\n        }\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"all_possible\") {\n        /* All notes can be played */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            int max_b = min(2 * a[i], (int)1e6);\n            b[i] = rnd.next(2, max_b);\n        }\n    } else if (type == \"all_impossible\") {\n        /* No notes can be played */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            if (rnd.next(2)) {\n                b[i] = rnd.next(1, 1);\n            } else {\n                int min_b = 2 * a[i] + 1;\n                int max_b = (int)1e6;\n                if (min_b > max_b) min_b = max_b;\n                b[i] = rnd.next(min_b, max_b);\n            }\n        }\n    } else if (type == \"mixed\") {\n        /* Mix of playable and unplayable notes */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            if (rnd.next(2)) {\n                int max_b = min(2 * a[i], (int)1e6);\n                b[i] = rnd.next(2, max_b);\n            } else {\n                if (rnd.next(2)) {\n                    b[i] = rnd.next(1, 1);\n                } else {\n                    int min_b = 2 * a[i] + 1;\n                    int max_b = (int)1e6;\n                    if (min_b > max_b) min_b = max_b;\n                    b[i] = rnd.next(min_b, max_b);\n                }\n            }\n        }\n    } else if (type == \"max_a_min_b\") {\n        /* Maximum a_i, minimum b_i */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)1e6;\n            b[i] = 2;\n        }\n    } else if (type == \"min_a_max_b\") {\n        /* Minimum a_i, maximum possible b_i */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = min(2 * 1, (int)1e6);\n        }\n    } else if (type == \"edge_cases\") {\n        /* Edge cases with b_i = 2 or b_i = 2 * a_i */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            if (rnd.next(2)) {\n                b[i] = 2;\n            } else {\n                b[i] = min(2 * a[i], (int)1e6);\n            }\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e6);\n            b[i] = rnd.next(1, (int)1e6);\n        }\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_possible\n./gen -n 1 -type all_impossible\n./gen -n 1 -type mixed\n./gen -n 1 -type max_a_min_b\n./gen -n 1 -type min_a_max_b\n./gen -n 1 -type edge_cases\n./gen -n 1 -type random\n\n./gen -n 10 -type all_possible\n./gen -n 10 -type all_impossible\n./gen -n 10 -type mixed\n./gen -n 10 -type max_a_min_b\n./gen -n 10 -type min_a_max_b\n./gen -n 10 -type edge_cases\n./gen -n 10 -type random\n\n./gen -n 100 -type all_possible\n./gen -n 100 -type all_impossible\n./gen -n 100 -type mixed\n./gen -n 100 -type max_a_min_b\n./gen -n 100 -type min_a_max_b\n./gen -n 100 -type edge_cases\n./gen -n 100 -type random\n\n./gen -n 1000 -type all_possible\n./gen -n 1000 -type all_impossible\n./gen -n 1000 -type mixed\n./gen -n 1000 -type max_a_min_b\n./gen -n 1000 -type min_a_max_b\n./gen -n 1000 -type edge_cases\n./gen -n 1000 -type random\n\n./gen -n 10000 -type all_possible\n./gen -n 10000 -type all_impossible\n./gen -n 10000 -type mixed\n./gen -n 10000 -type max_a_min_b\n./gen -n 10000 -type min_a_max_b\n./gen -n 10000 -type edge_cases\n./gen -n 10000 -type random\n\n./gen -n 100000 -type all_possible\n./gen -n 100000 -type all_impossible\n./gen -n 100000 -type mixed\n./gen -n 100000 -type max_a_min_b\n./gen -n 100000 -type min_a_max_b\n./gen -n 100000 -type edge_cases\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:29.856272",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "390/C",
      "title": "C. Inna and Candy Boxes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, k and w (1 ≤ k ≤ min(n, 10), 1 ≤ n, w ≤ 105). The second line contains n characters. If the i-th box contains a candy, the i-th character of the line equals 1, otherwise it equals 0.Each of the following w lines contains two integers li and ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th question. It is guaranteed that ri - li + 1 is divisible by k.",
      "output_spec": "OutputFor each question, print a single number on a single line — the minimum number of operations Dima needs to make the answer to the question positive.",
      "sample_tests": "ExamplesInputCopy10 3 310101000111 31 64 9OutputCopy132",
      "description": "C. Inna and Candy Boxes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, k and w (1 ≤ k ≤ min(n, 10), 1 ≤ n, w ≤ 105). The second line contains n characters. If the i-th box contains a candy, the i-th character of the line equals 1, otherwise it equals 0.Each of the following w lines contains two integers li and ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th question. It is guaranteed that ri - li + 1 is divisible by k.\n\nOutputFor each question, print a single number on a single line — the minimum number of operations Dima needs to make the answer to the question positive.\n\nInputCopy10 3 310101000111 31 64 9OutputCopy132\n\nInputCopy10 3 310101000111 31 64 9\n\nOutputCopy132\n\nNoteFor the first question, you need to take a candy from the first box to make the answer positive. So the answer is 1.For the second question, you need to take a candy from the first box, take a candy from the fifth box and put a candy to the sixth box. The answer is 3.For the third question, you need to take a candy from the fifth box and put it to the sixth box. The answer is 2.",
      "solutions": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces",
          "content": "Since the original data has been lost during the dark days of Codeforces, no version of the editorial has been re-released, and I feel the round itself is quite educational, so I decided to give a try.390A - Inna and Alarm Clock ApproachThe criterion shows that we can only use either vertical segments or horizontal segments.Since there is no limit on the segments' length, we can see that it's always optimal to use a segment with infinite length (or may be known as a line).We can see that the vertical line x = a will span through every alarm clocks standing at positions with x-coordinate being equal to a. In a similar manner, the horizontal line y = b will span through every alarm clocks standing at positions with y-coordinate being equal to b.So, if we use vertical lines, the number of segments used will be the number of distinct values of x-coordinates found in the data. Similarly, the number of horizontal segments used will be the number of distinct values of y-coordinates found.The process can be implemented by a counting array, or a map.Time complexity: for regular arrays, or for maps. Solution 1 (Map)Submission link: 48214007 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tmap<int, int> cntx, cnty;\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\n\treturn 0;\n} Solution 2 (Array)Submission link: 48213984 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t distinctx += (cntx[i] > 0);\n\t distincty += (cnty[i] > 0);\n\t}\n\n\tcout << min(distinctx, distincty) << endl;\n\n\treturn 0;\n}390B - Inna, Dima and Song ApproachFrom the constraints given, for the i-th song, provided there exists corresponding xi and yi values, then the following inequality must hold: 2 ≤ xi + yi ≤ 2·ai.Thus, if any bi is either lower than 2 or higher than 2·ai, then no xi and yi can be found, thus, Sereja's joy will surely decrease by 1.Amongst all pairs of that xi + yi = bi, the pair with the highest value of xi·yi will be one with the equal value of xi = yi (this can be proven by the famous AM-GM inequality).Thus, if bi is divisible by 2, we can easily pick .Also, from this, we can see (either intuitively or with static proofs) that the lower the difference between xi and yi is, the higher the value xi·yi will be. Thus, in case bi being odd, the most optimal pair will be or (the order doesn't matter here).Time complexity: . SolutionSubmission link: 48212208 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\n\treturn 0;\n}390C - Inna and Candy Boxes ApproachThe query content looks pretty confusing at first, to be honest.Since k is static throughout a scenario, we can group the boxes into k groups, the z-th box (in this editorial let's assume that the indices of the boxes start from 0) falls into group number .Then, each query can be simplified as this: \"Is that true that among the boxes with numbers from li to ri, inclusive, the candies lie only in boxes of group ?To make sure the answer for a query being \"Yes\", Dima has to remove candies from all candied-box in all groups other than , while in that exact group, fill every empty box with a candy. Obviously, we'll consider boxes with indices between li and ri inclusively only.We can make k lists, the t-th (0-indexed) list stores the indices of candied boxes in group t.We'll process with each query as the following: Obviously, given from the criteria, each range will consist of exactly boxes per each group. Let's denote . Traverse all groups, for the t-th group (again, 0-indexed), let's denote xt as the number of candied boxes of group t in the given range. This value can be calculated quickly through binary searching the constructed lists above. If group t is not the group being demanded to have candies (group ), we'll need to perform xt actions (removing candies). Otherwise, we'll need to perform A - xt actions (adding candies to empty boxes). Time complexity: . SolutionSubmission link: 48213932 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\n\tvector< vector<int> > CandyGrp(k);\n\n\tfor (int i=0; i<n; i++) {\n\t if (s[i] == '0') continue;\n\t CandyGrp[i % k].push_back(i);\n\t}\n\n\twhile (w--) {\n\t int l, r;\n\t\tcin >> l >> r; l--; r--;\n\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\n\t\tfor (int id=0; id<k; id++) {\n\n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\n\t\t\tif (id == demandedGroup) {\n\t\t\t res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}390D - Inna and Sweet Matrix ApproachWe can see that the most optimal placement will be choosing k cells being nearest to cell (1, 1) (yup, including (1, 1) itself).To find these k points, we can simply do a BFS starting from (1, 1), with traceback feature to construct the paths to get to those cells.However, keep in mind that any cell being candied will later on become obstacles for the following paths. Thus, to avoid blocking yourself, you should transfer candies to the farthest cells first, then getting closer. Thus, cell (1, 1) will be the last one being filled with candy.Time complexity: or , based on implementation (I myself did , since the difference isn't too much). SolutionSubmission link: 48213856 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, k; cin >> n >> m >> k;\n\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n\n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\n\t\tcost += Dist[x][y];\n\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}390E - Inna and Large Sweet Matrix ApproachLet's denote A as the total number of candies on the board, Ri as the total number of candies on the i-th row (1 ≤ i ≤ n), Cj as the total number of candies on the j-th column (1 ≤ j ≤ m).Also, let's denote and .Let's considered the 2nd type of query first. Denoting the answer for the query as f(x1, y1, x2, y2), we can see that f(x1, y1, x2, y2) = R(x1, x2) + C(y1, y2) - A (you can draw a simple diagram and validate this function).Thus, the problem is now reduced to calculating R(x1, x2), C(y1, y2) and A: A can be easily calculated. After each query of the 1st type with parameters x1, y1, x2, y2, v; A will be increased by v·(x2 - x1 + 1)·(y2 - y1 + 1). The calculation of R(x1, x2) and C(y1, y2) makes us thinking about some kinds of data structures that support range sum update and range sum query. Segment trees and Fenwick trees can both work on that. Personally I used segment trees, they fit in just right for the memory limit (I implemented it by vectors, regular arrays will obviously be safer). Time complexity: . SolutionSubmission link: 48213830 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, w; cin >> n >> m >> w;\n\n\tlong long TotalCandies = 0;\n\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/64453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 390\\s*C"
          },
          "content_length": 12129
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 1",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 2",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 3",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 4",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 5",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 6",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 7",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 8",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 11",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 12",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, k, w\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 10), \"k\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    // Read the string s\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of string s should be n=%d, but s.length()=%d\", n, int(s.length()));\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '0' || s[i] == '1', \"s[%d]=%c should be '0' or '1'\", i+1, s[i]);\n    }\n\n    // Read w queries\n    for (int i = 0; i < w; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n        ensuref((ri - li + 1) % k == 0, \"In query %d: (ri - li + 1) %% k == 0 violated; li=%d, ri=%d, k=%d\", i+1, li, ri, k);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, k, w\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 10), \"k\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    // Read the string s\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of string s should be n=%d, but s.length()=%d\", n, int(s.length()));\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '0' || s[i] == '1', \"s[%d]=%c should be '0' or '1'\", i+1, s[i]);\n    }\n\n    // Read w queries\n    for (int i = 0; i < w; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n        ensuref((ri - li + 1) % k == 0, \"In query %d: (ri - li + 1) %% k == 0 violated; li=%d, ri=%d, k=%d\", i+1, li, ri, k);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, k, w\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 10), \"k\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    // Read the string s\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of string s should be n=%d, but s.length()=%d\", n, int(s.length()));\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '0' || s[i] == '1', \"s[%d]=%c should be '0' or '1'\", i+1, s[i]);\n    }\n\n    // Read w queries\n    for (int i = 0; i < w; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n        ensuref((ri - li + 1) % k == 0, \"In query %d: (ri - li + 1) %% k == 0 violated; li=%d, ri=%d, k=%d\", i+1, li, ri, k);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int w = opt<int>(\"w\");\n    string pattern = opt<string>(\"pattern\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // Ensure k is within constraints\n    ensure(1 <= k && k <= min(n, 10));\n\n    // Generate the boxes\n    vector<int> boxes(n);\n\n    if (pattern == \"all_ones\") {\n        fill(boxes.begin(), boxes.end(), 1);\n    }\n    else if (pattern == \"all_zeroes\") {\n        fill(boxes.begin(), boxes.end(), 0);\n    }\n    else if (pattern == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            boxes[i] = i % 2;\n    }\n    else {\n        // Random pattern\n        for (int i = 0; i < n; ++i)\n            boxes[i] = rnd.next(0, 1);\n    }\n\n    // Output n, k, w\n    printf(\"%d %d %d\\n\", n, k, w);\n\n    // Output the boxes\n    for (int i = 0; i < n; ++i)\n        printf(\"%d\", boxes[i]);\n    printf(\"\\n\");\n\n    // Generate the queries\n    for (int i = 0; i < w; ++i)\n    {\n        int length;\n        if (qtype == \"max_length\")\n            length = n - (n % k); // Maximum length divisible by k\n        else if (qtype == \"min_length\")\n            length = k; // Minimum length\n        else // Random length\n        {\n            int maxSegments = n / k;\n            int segments = rnd.next(1, maxSegments);\n            length = segments * k;\n        }\n        int maxL = n - length + 1;\n        int l = rnd.next(1, maxL);\n        int r = l + length - 1;\n        printf(\"%d %d\\n\", l, r);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int w = opt<int>(\"w\");\n    string pattern = opt<string>(\"pattern\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // Ensure k is within constraints\n    ensure(1 <= k && k <= min(n, 10));\n\n    // Generate the boxes\n    vector<int> boxes(n);\n\n    if (pattern == \"all_ones\") {\n        fill(boxes.begin(), boxes.end(), 1);\n    }\n    else if (pattern == \"all_zeroes\") {\n        fill(boxes.begin(), boxes.end(), 0);\n    }\n    else if (pattern == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            boxes[i] = i % 2;\n    }\n    else {\n        // Random pattern\n        for (int i = 0; i < n; ++i)\n            boxes[i] = rnd.next(0, 1);\n    }\n\n    // Output n, k, w\n    printf(\"%d %d %d\\n\", n, k, w);\n\n    // Output the boxes\n    for (int i = 0; i < n; ++i)\n        printf(\"%d\", boxes[i]);\n    printf(\"\\n\");\n\n    // Generate the queries\n    for (int i = 0; i < w; ++i)\n    {\n        int length;\n        if (qtype == \"max_length\")\n            length = n - (n % k); // Maximum length divisible by k\n        else if (qtype == \"min_length\")\n            length = k; // Minimum length\n        else // Random length\n        {\n            int maxSegments = n / k;\n            int segments = rnd.next(1, maxSegments);\n            length = segments * k;\n        }\n        int maxL = n - length + 1;\n        int l = rnd.next(1, maxL);\n        int r = l + length - 1;\n        printf(\"%d %d\\n\", l, r);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small tests with different patterns\n./gen -n 10 -k 1 -w 5 -pattern all_ones -qtype random\n./gen -n 10 -k 1 -w 5 -pattern all_zeroes -qtype random\n./gen -n 10 -k 1 -w 5 -pattern alternating -qtype random\n./gen -n 10 -k 2 -w 5 -pattern random -qtype random\n\n# Moderate tests with specific query lengths\n./gen -n 100 -k 5 -w 50 -pattern all_ones -qtype min_length\n./gen -n 100 -k 5 -w 50 -pattern all_zeroes -qtype max_length\n./gen -n 1000 -k 10 -w 100 -pattern random -qtype random\n\n# Large tests with maximum constraints\n./gen -n 100000 -k 1 -w 100000 -pattern random -qtype random\n./gen -n 100000 -k 10 -w 100000 -pattern all_ones -qtype min_length\n./gen -n 100000 -k 7 -w 100000 -pattern all_zeroes -qtype max_length\n./gen -n 100000 -k 3 -w 100000 -pattern alternating -qtype random\n\n# Edge cases with minimum n and k\n./gen -n 1 -k 1 -w 1 -pattern all_ones -qtype random\n./gen -n 1 -k 1 -w 1 -pattern all_zeroes -qtype random\n\n# Tests with k values from 1 to 10\n./gen -n 1000 -k 1 -w 1000 -pattern random -qtype random\n./gen -n 1000 -k 5 -w 1000 -pattern random -qtype random\n./gen -n 1000 -k 10 -w 1000 -pattern random -qtype random\n\n# Maximum constraints with varying query types\n./gen -n 100000 -k 1 -w 100000 -pattern random -qtype min_length\n./gen -n 100000 -k 10 -w 100000 -pattern random -qtype max_length\n\n# Tests with all ones pattern\n./gen -n 100000 -k 5 -w 100000 -pattern all_ones -qtype random\n\n# Tests with all zeroes pattern\n./gen -n 100000 -k 5 -w 100000 -pattern all_zeroes -qtype random\n\n# Tests with alternating pattern\n./gen -n 100000 -k 5 -w 100000 -pattern alternating -qtype random\n\n# Full range queries\n./gen -n 100000 -k 10 -w 1 -pattern random -qtype max_length\n\n# Minimal length queries\n./gen -n 100000 -k 10 -w 100000 -pattern random -qtype min_length\n\n# Random queries with maximum n and w\n./gen -n 99999 -k 9 -w 99999 -pattern random -qtype random\n\n# Tests where n is not divisible by k\n./gen -n 99999 -k 10 -w 99999 -pattern random -qtype random\n\n# Tests with randomly generated patterns and queries\n./gen -n 100000 -k 3 -w 50000 -pattern random -qtype random\n./gen -n 80000 -k 6 -w 80000 -pattern random -qtype random\n\n# Tests focusing on the maximum value of k\n./gen -n 100000 -k 10 -w 100000 -pattern random -qtype random\n\n# Tests focusing on the minimum value of k\n./gen -n 100000 -k 1 -w 100000 -pattern random -qtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:31.538584",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "390/D",
      "title": "D. Inna and Sweet Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, m and k (1 ≤ n, m ≤ 50, 1 ≤ k ≤ n·m).",
      "output_spec": "OutputIn the first line print an integer — Inna's minimum penalty in the game.In the next k lines print the description of the path for each candy. The description of the path of the candy that is placed i-th should follow on the i-th line. The description of a path is a sequence of cells. Each cell must be written in the format (i, j), where i is the number of the row and j is the number of the column. You are allowed to print extra whitespaces in the line. If there are multiple optimal solutions, print any of them.Please follow the output format strictly! If your program passes the first pretest, then the output format is correct.",
      "sample_tests": "ExamplesInputCopy4 4 4OutputCopy8(1,1) (2,1) (2,2)(1,1) (1,2)(1,1) (2,1)(1,1)",
      "description": "D. Inna and Sweet Matrix\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, m and k (1 ≤ n, m ≤ 50, 1 ≤ k ≤ n·m).\n\nOutputIn the first line print an integer — Inna's minimum penalty in the game.In the next k lines print the description of the path for each candy. The description of the path of the candy that is placed i-th should follow on the i-th line. The description of a path is a sequence of cells. Each cell must be written in the format (i, j), where i is the number of the row and j is the number of the column. You are allowed to print extra whitespaces in the line. If there are multiple optimal solutions, print any of them.Please follow the output format strictly! If your program passes the first pretest, then the output format is correct.\n\nInputCopy4 4 4OutputCopy8(1,1) (2,1) (2,2)(1,1) (1,2)(1,1) (2,1)(1,1)\n\nInputCopy4 4 4\n\nOutputCopy8(1,1) (2,1) (2,2)(1,1) (1,2)(1,1) (2,1)(1,1)\n\nNoteNote to the sample. Initially the matrix is empty. Then Inna follows her first path, the path penalty equals the number of cells in it — 3. Note that now no path can go through cell (2, 2), as it now contains a candy. The next two candies go to cells (1, 2) and (2, 1). Inna simply leaves the last candy at cell (1, 1), the path contains only this cell. The total penalty is: 3 + 2 + 2 + 1 = 8.Note that Inna couldn't use cell (1, 1) to place, for instance, the third candy as in this case she couldn't have made the path for the fourth candy.",
      "solutions": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces",
          "content": "Since the original data has been lost during the dark days of Codeforces, no version of the editorial has been re-released, and I feel the round itself is quite educational, so I decided to give a try.390A - Inna and Alarm Clock ApproachThe criterion shows that we can only use either vertical segments or horizontal segments.Since there is no limit on the segments' length, we can see that it's always optimal to use a segment with infinite length (or may be known as a line).We can see that the vertical line x = a will span through every alarm clocks standing at positions with x-coordinate being equal to a. In a similar manner, the horizontal line y = b will span through every alarm clocks standing at positions with y-coordinate being equal to b.So, if we use vertical lines, the number of segments used will be the number of distinct values of x-coordinates found in the data. Similarly, the number of horizontal segments used will be the number of distinct values of y-coordinates found.The process can be implemented by a counting array, or a map.Time complexity: for regular arrays, or for maps. Solution 1 (Map)Submission link: 48214007 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tmap<int, int> cntx, cnty;\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\n\treturn 0;\n} Solution 2 (Array)Submission link: 48213984 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t distinctx += (cntx[i] > 0);\n\t distincty += (cnty[i] > 0);\n\t}\n\n\tcout << min(distinctx, distincty) << endl;\n\n\treturn 0;\n}390B - Inna, Dima and Song ApproachFrom the constraints given, for the i-th song, provided there exists corresponding xi and yi values, then the following inequality must hold: 2 ≤ xi + yi ≤ 2·ai.Thus, if any bi is either lower than 2 or higher than 2·ai, then no xi and yi can be found, thus, Sereja's joy will surely decrease by 1.Amongst all pairs of that xi + yi = bi, the pair with the highest value of xi·yi will be one with the equal value of xi = yi (this can be proven by the famous AM-GM inequality).Thus, if bi is divisible by 2, we can easily pick .Also, from this, we can see (either intuitively or with static proofs) that the lower the difference between xi and yi is, the higher the value xi·yi will be. Thus, in case bi being odd, the most optimal pair will be or (the order doesn't matter here).Time complexity: . SolutionSubmission link: 48212208 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\n\treturn 0;\n}390C - Inna and Candy Boxes ApproachThe query content looks pretty confusing at first, to be honest.Since k is static throughout a scenario, we can group the boxes into k groups, the z-th box (in this editorial let's assume that the indices of the boxes start from 0) falls into group number .Then, each query can be simplified as this: \"Is that true that among the boxes with numbers from li to ri, inclusive, the candies lie only in boxes of group ?To make sure the answer for a query being \"Yes\", Dima has to remove candies from all candied-box in all groups other than , while in that exact group, fill every empty box with a candy. Obviously, we'll consider boxes with indices between li and ri inclusively only.We can make k lists, the t-th (0-indexed) list stores the indices of candied boxes in group t.We'll process with each query as the following: Obviously, given from the criteria, each range will consist of exactly boxes per each group. Let's denote . Traverse all groups, for the t-th group (again, 0-indexed), let's denote xt as the number of candied boxes of group t in the given range. This value can be calculated quickly through binary searching the constructed lists above. If group t is not the group being demanded to have candies (group ), we'll need to perform xt actions (removing candies). Otherwise, we'll need to perform A - xt actions (adding candies to empty boxes). Time complexity: . SolutionSubmission link: 48213932 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\n\tvector< vector<int> > CandyGrp(k);\n\n\tfor (int i=0; i<n; i++) {\n\t if (s[i] == '0') continue;\n\t CandyGrp[i % k].push_back(i);\n\t}\n\n\twhile (w--) {\n\t int l, r;\n\t\tcin >> l >> r; l--; r--;\n\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\n\t\tfor (int id=0; id<k; id++) {\n\n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\n\t\t\tif (id == demandedGroup) {\n\t\t\t res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}390D - Inna and Sweet Matrix ApproachWe can see that the most optimal placement will be choosing k cells being nearest to cell (1, 1) (yup, including (1, 1) itself).To find these k points, we can simply do a BFS starting from (1, 1), with traceback feature to construct the paths to get to those cells.However, keep in mind that any cell being candied will later on become obstacles for the following paths. Thus, to avoid blocking yourself, you should transfer candies to the farthest cells first, then getting closer. Thus, cell (1, 1) will be the last one being filled with candy.Time complexity: or , based on implementation (I myself did , since the difference isn't too much). SolutionSubmission link: 48213856 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, k; cin >> n >> m >> k;\n\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n\n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\n\t\tcost += Dist[x][y];\n\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}390E - Inna and Large Sweet Matrix ApproachLet's denote A as the total number of candies on the board, Ri as the total number of candies on the i-th row (1 ≤ i ≤ n), Cj as the total number of candies on the j-th column (1 ≤ j ≤ m).Also, let's denote and .Let's considered the 2nd type of query first. Denoting the answer for the query as f(x1, y1, x2, y2), we can see that f(x1, y1, x2, y2) = R(x1, x2) + C(y1, y2) - A (you can draw a simple diagram and validate this function).Thus, the problem is now reduced to calculating R(x1, x2), C(y1, y2) and A: A can be easily calculated. After each query of the 1st type with parameters x1, y1, x2, y2, v; A will be increased by v·(x2 - x1 + 1)·(y2 - y1 + 1). The calculation of R(x1, x2) and C(y1, y2) makes us thinking about some kinds of data structures that support range sum update and range sum query. Segment trees and Fenwick trees can both work on that. Personally I used segment trees, they fit in just right for the memory limit (I implemented it by vectors, regular arrays will obviously be safer). Time complexity: . SolutionSubmission link: 48213830 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, w; cin >> n >> m >> w;\n\n\tlong long TotalCandies = 0;\n\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/64453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 390\\s*D"
          },
          "content_length": 12129
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 1",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 2",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 3",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 4",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 5",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 6",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 7",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 8",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 11",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 12",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n * m, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n * m, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n * m, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nint min_penalty; // minimal penalty from the judge's answer\nvector<vector<bool>> grid; // to record occupied cells\n\n// Function to parse the path line into cells\nvector<pair<int, int>> parse_path(string line, InStream& stream, int idx) {\n    vector<pair<int, int>> path;\n    // Remove all whitespaces\n    line.erase(remove(line.begin(), line.end(), ' '), line.end());\n    line.erase(remove(line.begin(), line.end(), '\\t'), line.end());\n\n    int pos = 0;\n    while (pos < line.size()) {\n        if (line[pos] != '(')\n            stream.quitf(_wa, \"Expected '(' at position %d in path %d\", pos + 1, idx + 1);\n        pos++; // skip '('\n        // Parse number for i\n        int i = 0, j = 0;\n        int start_pos = pos;\n        if (pos >= line.size() || !isdigit(line[pos]))\n            stream.quitf(_wa, \"Expected digit for row number at position %d in path %d\", pos + 1, idx + 1);\n        while (pos < line.size() && isdigit(line[pos]))\n            pos++;\n        string i_str = line.substr(start_pos, pos - start_pos);\n        i = atoi(i_str.c_str());\n\n        if (pos >= line.size() || line[pos] != ',')\n            stream.quitf(_wa, \"Expected ',' after row number at position %d in path %d\", pos + 1, idx + 1);\n        pos++; // skip ','\n\n        // Parse number for j\n        start_pos = pos;\n        if (pos >= line.size() || !isdigit(line[pos]))\n            stream.quitf(_wa, \"Expected digit for column number at position %d in path %d\", pos + 1, idx + 1);\n        while (pos < line.size() && isdigit(line[pos]))\n            pos++;\n        string j_str = line.substr(start_pos, pos - start_pos);\n        j = atoi(j_str.c_str());\n\n        if (pos >= line.size() || line[pos] != ')')\n            stream.quitf(_wa, \"Expected ')' after column number at position %d in path %d\", pos + 1, idx + 1);\n        pos++; // skip ')'\n\n        // Add cell to path\n        path.push_back({i, j});\n    }\n    return path;\n}\n\n// Function to read and validate the contestant's output\nint read_and_validate_output(InStream& stream) {\n    int penalty = stream.readInt(1, n * m * (n + m), \"penalty\"); // upper bound on penalty\n    stream.readEoln(); // Read end of line\n\n    // Initialize the grid\n    grid = vector<vector<bool>>(n + 1, vector<bool>(m + 1, false));\n\n    int total_penalty = 0;\n    for (int idx = 0; idx < k; idx++) {\n        string line = stream.readLine();\n        // Parse the line into cells\n        vector<pair<int, int>> path = parse_path(line, stream, idx);\n        if (path.empty())\n            stream.quitf(_wa, \"Empty path for candy %d\", idx + 1);\n\n        // Validate the path\n        // Check that path starts at (1,1)\n        if (path.front().first != 1 || path.front().second != 1)\n            stream.quitf(_wa, \"Path %d does not start at (1,1)\", idx + 1);\n\n        // Check that path is connected via adjacent cells and moves through empty cells\n        for (size_t i = 0; i < path.size(); i++) {\n            int x = path[i].first;\n            int y = path[i].second;\n\n            if (x < 1 || x > n || y < 1 || y > m)\n                stream.quitf(_wa, \"Cell (%d,%d) out of bounds in path %d\", x, y, idx + 1);\n\n            // Check that cell is not occupied unless it's the first cell\n            if (grid[x][y] && !(i == 0 && x == 1 && y == 1))\n                stream.quitf(_wa, \"Path %d passes through occupied cell (%d,%d)\", idx + 1, x, y);\n\n            // For steps after the first, check that they are adjacent\n            if (i > 0) {\n                int px = path[i - 1].first;\n                int py = path[i - 1].second;\n                if (abs(x - px) + abs(y - py) != 1)\n                    stream.quitf(_wa, \"Path %d has non-adjacent move from (%d,%d) to (%d,%d)\", idx + 1, px, py, x, y);\n            }\n        }\n\n        // Mark the destination cell as occupied\n        int dest_x = path.back().first;\n        int dest_y = path.back().second;\n        if (grid[dest_x][dest_y])\n            stream.quitf(_wa, \"Destination cell (%d,%d) for candy %d is already occupied\", dest_x, dest_y, idx + 1);\n        grid[dest_x][dest_y] = true;\n\n        total_penalty += path.size();\n    }\n\n    if (total_penalty != penalty)\n        stream.quitf(_wa, \"Total penalty mismatch: claimed %d, computed %d\", penalty, total_penalty);\n\n    return penalty;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(); // Read n from input file\n    m = inf.readInt(); // Read m from input file\n    k = inf.readInt(); // Read k from input file\n\n    min_penalty = ans.readInt(); // Read minimal penalty from judge's answer\n    ans.readEoln(); // Skip to next line\n\n    int penalty = read_and_validate_output(ouf); // Read and validate contestant's output\n\n    if (penalty != min_penalty)\n        quitf(_wa, \"Total penalty is not minimal: participant's penalty %d, minimal penalty %d\", penalty, min_penalty);\n\n    // All good\n    quitf(_ok, \"Correct output with minimal total penalty %d\", penalty);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    int m = opt<int>(\"m\", 0);\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        k = 1;\n    } else if (type == \"maximal\") {\n        n = 50;\n        m = 50;\n        k = n * m;\n    } else if (type == \"single_row\") {\n        n = 1;\n        m = rnd.next(1, 50);\n        k = rnd.next(1, n * m);\n    } else if (type == \"single_column\") {\n        n = rnd.next(1, 50);\n        m = 1;\n        k = rnd.next(1, n * m);\n    } else if (type == \"max_k\") {\n        n = opt<int>(\"n\", 50);\n        m = opt<int>(\"m\", 50);\n        k = n * m;\n    } else if (type == \"min_k\") {\n        n = opt<int>(\"n\", 1);\n        m = opt<int>(\"m\", 1);\n        k = 1;\n    } else if (type == \"random_small\") {\n        n = rnd.next(2, 10);\n        m = rnd.next(2, 10);\n        k = rnd.next(1, n * m);\n    } else if (type == \"random_large\") {\n        n = rnd.next(40, 50);\n        m = rnd.next(40, 50);\n        k = rnd.next(1, n * m);\n    } else if (type == \"max_penalty\") {\n        n = rnd.next(2, 50);\n        m = rnd.next(2, 50);\n        k = rnd.next(max(1, n * m - rnd.next(0, 10)), n * m);\n    } else {\n        // default to random values\n        n = rnd.next(1, 50);\n        m = rnd.next(1, 50);\n        k = rnd.next(1, n * m);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    int m = opt<int>(\"m\", 0);\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        k = 1;\n    } else if (type == \"maximal\") {\n        n = 50;\n        m = 50;\n        k = n * m;\n    } else if (type == \"single_row\") {\n        n = 1;\n        m = rnd.next(1, 50);\n        k = rnd.next(1, n * m);\n    } else if (type == \"single_column\") {\n        n = rnd.next(1, 50);\n        m = 1;\n        k = rnd.next(1, n * m);\n    } else if (type == \"max_k\") {\n        n = opt<int>(\"n\", 50);\n        m = opt<int>(\"m\", 50);\n        k = n * m;\n    } else if (type == \"min_k\") {\n        n = opt<int>(\"n\", 1);\n        m = opt<int>(\"m\", 1);\n        k = 1;\n    } else if (type == \"random_small\") {\n        n = rnd.next(2, 10);\n        m = rnd.next(2, 10);\n        k = rnd.next(1, n * m);\n    } else if (type == \"random_large\") {\n        n = rnd.next(40, 50);\n        m = rnd.next(40, 50);\n        k = rnd.next(1, n * m);\n    } else if (type == \"max_penalty\") {\n        n = rnd.next(2, 50);\n        m = rnd.next(2, 50);\n        k = rnd.next(max(1, n * m - rnd.next(0, 10)), n * m);\n    } else {\n        // default to random values\n        n = rnd.next(1, 50);\n        m = rnd.next(1, 50);\n        k = rnd.next(1, n * m);\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -type maximal\n\n./gen -type single_row\n\n./gen -type single_column\n\n./gen -type random_small\n\n./gen -type random_small\n\n./gen -type random_small\n\n./gen -type random_large\n\n./gen -type random_large\n\n./gen -type random_large\n\n./gen -type max_k -n 50 -m 50\n\n./gen -type max_k -n 30 -m 20\n\n./gen -type min_k -n 50 -m 50\n\n./gen -type min_k -n 20 -m 30\n\n./gen -type max_penalty\n\n./gen -type max_penalty\n\n./gen -type max_penalty\n\n./gen -type single_row\n\n./gen -type single_column\n\n./gen -type random_small\n\n./gen -type random_large\n\n./gen\n\n./gen\n\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:33.885866",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "390/E",
      "title": "E. Inna and Large Sweet Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, m and w (3 ≤ n, m ≤ 4·106; 1 ≤ w ≤ 105).The next w lines describe the moves that were made in the game.   A line that describes an event of the first type contains 6 integers: 0, x1, y1, x2, y2 and v (1 ≤ x1 ≤ x2 ≤ n; 1 ≤ y1 ≤ y2 ≤ m; 1 ≤ v ≤ 109).  A line that describes an event of the second type contains 5 integers: 1, x1, y1, x2, y2 (2 ≤ x1 ≤ x2 ≤ n - 1; 2 ≤ y1 ≤ y2 ≤ m - 1). It is guaranteed that the second type move occurs at least once. It is guaranteed that a single operation will not add more than 109 candies.Be careful, the constraints are very large, so please use optimal data structures. Max-tests will be in pretests.",
      "output_spec": "OutputFor each second type move print a single integer on a single line — the difference between Dima and Inna's numbers.",
      "sample_tests": "ExamplesInputCopy4 5 50 1 1 2 3 20 2 2 3 3 30 1 5 4 5 11 2 3 3 41 3 4 3 4OutputCopy2-21",
      "description": "E. Inna and Large Sweet Matrix\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, m and w (3 ≤ n, m ≤ 4·106; 1 ≤ w ≤ 105).The next w lines describe the moves that were made in the game.   A line that describes an event of the first type contains 6 integers: 0, x1, y1, x2, y2 and v (1 ≤ x1 ≤ x2 ≤ n; 1 ≤ y1 ≤ y2 ≤ m; 1 ≤ v ≤ 109).  A line that describes an event of the second type contains 5 integers: 1, x1, y1, x2, y2 (2 ≤ x1 ≤ x2 ≤ n - 1; 2 ≤ y1 ≤ y2 ≤ m - 1). It is guaranteed that the second type move occurs at least once. It is guaranteed that a single operation will not add more than 109 candies.Be careful, the constraints are very large, so please use optimal data structures. Max-tests will be in pretests.\n\nOutputFor each second type move print a single integer on a single line — the difference between Dima and Inna's numbers.\n\nInputCopy4 5 50 1 1 2 3 20 2 2 3 3 30 1 5 4 5 11 2 3 3 41 3 4 3 4OutputCopy2-21\n\nInputCopy4 5 50 1 1 2 3 20 2 2 3 3 30 1 5 4 5 11 2 3 3 41 3 4 3 4\n\nOutputCopy2-21\n\nNoteNote to the sample. After the first query the matrix looks as: 2220022200 0000000000After the second one it is: 222002550003300 00000After the third one it is: 22201255010330100001For the fourth query, Dima's sum equals 5 + 0 + 3 + 0 = 8 and Inna's sum equals 4 + 1 + 0 + 1 = 6. The answer to the query equals 8 - 6 = 2. For the fifth query, Dima's sum equals 0 and Inna's sum equals 18 + 2 + 0 + 1 = 21. The answer to the query is 0 - 21 = -21.",
      "solutions": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces",
          "content": "Since the original data has been lost during the dark days of Codeforces, no version of the editorial has been re-released, and I feel the round itself is quite educational, so I decided to give a try.390A - Inna and Alarm Clock ApproachThe criterion shows that we can only use either vertical segments or horizontal segments.Since there is no limit on the segments' length, we can see that it's always optimal to use a segment with infinite length (or may be known as a line).We can see that the vertical line x = a will span through every alarm clocks standing at positions with x-coordinate being equal to a. In a similar manner, the horizontal line y = b will span through every alarm clocks standing at positions with y-coordinate being equal to b.So, if we use vertical lines, the number of segments used will be the number of distinct values of x-coordinates found in the data. Similarly, the number of horizontal segments used will be the number of distinct values of y-coordinates found.The process can be implemented by a counting array, or a map.Time complexity: for regular arrays, or for maps. Solution 1 (Map)Submission link: 48214007 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tmap<int, int> cntx, cnty;\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\n\treturn 0;\n} Solution 2 (Array)Submission link: 48213984 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t distinctx += (cntx[i] > 0);\n\t distincty += (cnty[i] > 0);\n\t}\n\n\tcout << min(distinctx, distincty) << endl;\n\n\treturn 0;\n}390B - Inna, Dima and Song ApproachFrom the constraints given, for the i-th song, provided there exists corresponding xi and yi values, then the following inequality must hold: 2 ≤ xi + yi ≤ 2·ai.Thus, if any bi is either lower than 2 or higher than 2·ai, then no xi and yi can be found, thus, Sereja's joy will surely decrease by 1.Amongst all pairs of that xi + yi = bi, the pair with the highest value of xi·yi will be one with the equal value of xi = yi (this can be proven by the famous AM-GM inequality).Thus, if bi is divisible by 2, we can easily pick .Also, from this, we can see (either intuitively or with static proofs) that the lower the difference between xi and yi is, the higher the value xi·yi will be. Thus, in case bi being odd, the most optimal pair will be or (the order doesn't matter here).Time complexity: . SolutionSubmission link: 48212208 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n; cin >> n;\n\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\n\treturn 0;\n}390C - Inna and Candy Boxes ApproachThe query content looks pretty confusing at first, to be honest.Since k is static throughout a scenario, we can group the boxes into k groups, the z-th box (in this editorial let's assume that the indices of the boxes start from 0) falls into group number .Then, each query can be simplified as this: \"Is that true that among the boxes with numbers from li to ri, inclusive, the candies lie only in boxes of group ?To make sure the answer for a query being \"Yes\", Dima has to remove candies from all candied-box in all groups other than , while in that exact group, fill every empty box with a candy. Obviously, we'll consider boxes with indices between li and ri inclusively only.We can make k lists, the t-th (0-indexed) list stores the indices of candied boxes in group t.We'll process with each query as the following: Obviously, given from the criteria, each range will consist of exactly boxes per each group. Let's denote . Traverse all groups, for the t-th group (again, 0-indexed), let's denote xt as the number of candied boxes of group t in the given range. This value can be calculated quickly through binary searching the constructed lists above. If group t is not the group being demanded to have candies (group ), we'll need to perform xt actions (removing candies). Otherwise, we'll need to perform A - xt actions (adding candies to empty boxes). Time complexity: . SolutionSubmission link: 48213932 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\n\tvector< vector<int> > CandyGrp(k);\n\n\tfor (int i=0; i<n; i++) {\n\t if (s[i] == '0') continue;\n\t CandyGrp[i % k].push_back(i);\n\t}\n\n\twhile (w--) {\n\t int l, r;\n\t\tcin >> l >> r; l--; r--;\n\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\n\t\tfor (int id=0; id<k; id++) {\n\n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\n\t\t\tif (id == demandedGroup) {\n\t\t\t res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}390D - Inna and Sweet Matrix ApproachWe can see that the most optimal placement will be choosing k cells being nearest to cell (1, 1) (yup, including (1, 1) itself).To find these k points, we can simply do a BFS starting from (1, 1), with traceback feature to construct the paths to get to those cells.However, keep in mind that any cell being candied will later on become obstacles for the following paths. Thus, to avoid blocking yourself, you should transfer candies to the farthest cells first, then getting closer. Thus, cell (1, 1) will be the last one being filled with candy.Time complexity: or , based on implementation (I myself did , since the difference isn't too much). SolutionSubmission link: 48213856 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, k; cin >> n >> m >> k;\n\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n\n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\n\t\tcost += Dist[x][y];\n\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}390E - Inna and Large Sweet Matrix ApproachLet's denote A as the total number of candies on the board, Ri as the total number of candies on the i-th row (1 ≤ i ≤ n), Cj as the total number of candies on the j-th column (1 ≤ j ≤ m).Also, let's denote and .Let's considered the 2nd type of query first. Denoting the answer for the query as f(x1, y1, x2, y2), we can see that f(x1, y1, x2, y2) = R(x1, x2) + C(y1, y2) - A (you can draw a simple diagram and validate this function).Thus, the problem is now reduced to calculating R(x1, x2), C(y1, y2) and A: A can be easily calculated. After each query of the 1st type with parameters x1, y1, x2, y2, v; A will be increased by v·(x2 - x1 + 1)·(y2 - y1 + 1). The calculation of R(x1, x2) and C(y1, y2) makes us thinking about some kinds of data structures that support range sum update and range sum query. Segment trees and Fenwick trees can both work on that. Personally I used segment trees, they fit in just right for the memory limit (I implemented it by vectors, regular arrays will obviously be safer). Time complexity: . SolutionSubmission link: 48213830 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\n\tint n, m, w; cin >> n >> m >> w;\n\n\tlong long TotalCandies = 0;\n\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/64453",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 390\\s*E"
          },
          "content_length": 12129
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 1",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 2",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tmap<int, int> cntx, cnty;\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tcout << min(cntx.size(), cnty.size()) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 3",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 4",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> cntx(101, 0);\n\tvector<int> cnty(101, 0);\n\t\n\twhile (n--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcntx[x]++; cnty[y]++;\n\t}\n\t\n\tint distinctx = 0, distincty = 0;\n\tfor (int i=0; i<101; i++) {\n\t    distinctx += (cntx[i] > 0);\n\t    distincty += (cnty[i] > 0);\n\t}\n\t\n\tcout << min(distinctx, distincty) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 5",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 6",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n; cin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor (auto &z: a) cin >> z;\n\tfor (auto &z: b) cin >> z;\n\t\n\tlong long Joy = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (b[i] < 2 || b[i] > a[i] * 2) {Joy--; continue;}\n\t\tint x = b[i] / 2, y = b[i] - x;\n\t\tJoy += 1LL * x * y;\n\t}\n\tcout << Joy << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 7",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 8",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, k, w; string s;\n\tcin >> n >> k >> w >> s;\n\t\n\tvector< vector<int> > CandyGrp(k);\n\t\n\tfor (int i=0; i<n; i++) {\n\t    if (s[i] == '0') continue;\n\t    CandyGrp[i % k].push_back(i);\n\t}\n\t\n\twhile (w--) {\n\t    int l, r;\n\t\tcin >> l >> r; l--; r--;\n\t\t\n\t\tint res = 0;\n\t\tint demandedGroup = (l + k - 1) % k;\n\t\tint BoxesPerGroup = (r - l + 1) / k;\n\t\t\n\t\tfor (int id=0; id<k; id++) {\n\t\t    \n\t\t\tint x = lower_bound(CandyGrp[id].begin(), CandyGrp[id].end(), l) - CandyGrp[id].begin();\n\t\t\tint y = upper_bound(CandyGrp[id].begin(), CandyGrp[id].end(), r) - CandyGrp[id].begin();\n\t\t\t\n\t\t\tif (id == demandedGroup) {\n\t\t\t    res += (BoxesPerGroup - (y - x));\n\t\t\t}\n\t\t\telse res += (y - x);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint dx[] = {-1, +0, +0, +1};\nint dy[] = {+0, -1, +1, +0};\npair<int, int> Default = {-1, -1};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, k; cin >> n >> m >> k;\n\t\n\tvector<vector<int>> Dist(n+2, vector<int>(m+2, 4444));\n\tvector<vector<pair<int, int>>> Last(n+2, vector<pair<int, int>>(m+2, Default));\n    \n\tstack<pair<int, int>> Cells;\n\tint cost = 0;\n\t\n\tqueue<pair<int, int>> Q;\n\tQ.push({1, 1}); Dist[1][1] = 1;\n\t\n\twhile (!Q.empty() && Cells.size() < k) {\n\t\tpair<int, int> C = Q.front(); Q.pop();\n\t\tCells.push(C); int x = C.first, y = C.second;\n\t\t\n\t\tcost += Dist[x][y];\n\t\t\n\t\tfor (int dir=0; dir<4; dir++) {\n\t\t\tif (x + dx[dir] < 1 || x + dx[dir] > n) continue;\n\t\t\tif (y + dy[dir] < 1 || y + dy[dir] > m) continue;\n\t\t\t\n\t\t\tif (Dist[x+dx[dir]][y+dy[dir]] != 4444) continue;\n\t\t\t\n\t\t\tDist[x+dx[dir]][y+dy[dir]] = Dist[x][y] + 1;\n\t\t\tQ.push({x + dx[dir], y + dy[dir]});\n\t\t\tLast[x+dx[dir]][y+dy[dir]] = C;\n\t\t}\n\t}\n\t\n\tcout << cost << endl;\n\t\n\twhile (!Cells.empty()) {\n\t\tint x = Cells.top().first, y = Cells.top().second; Cells.pop();\n\t\tstack<pair<int, int>> Traceback;\n\t\t\n\t\twhile (x != -1 && y != -1) {\n\t\t\tTraceback.push({x, y});\n\t\t\tpair<int, int> NextCell = Last[x][y];\n\t\t\tx = NextCell.first; y = NextCell.second;\n\t\t}\n\t\t\n\t\twhile (!Traceback.empty()) {\n\t\t\tpair<int, int> CurCell = Traceback.top();\n\t\t\tTraceback.pop();\n\t\t\tcout << \"(\" << CurCell.first << \", \" << CurCell.second << \") \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 11",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #229 (Div. 2) Editorial [Unofficial] - Codeforces - Code 12",
          "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct SegTree_Sum {\n\tint n; vector<long long> Tree, Lazy;\n\tSegTree_Sum() {}\n\tSegTree_Sum(int _n) {\n\t\tn = _n;\n\t\tTree.resize(n*4);\n\t\tLazy.resize(n*4);\n\t}\n\t\n\tvoid Propagate(int node, int st, int en) {\n\t\tif (Lazy[node] == 0) return;\n\t\tTree[node] += Lazy[node] * (en - st + 1);\n\t\tif (st != en) {\n\t\t\tLazy[node*2+1] += Lazy[node];\n\t\t\tLazy[node*2+2] += Lazy[node];\n\t\t}\n\t\tLazy[node] = 0;\n\t}\n\t\n\tvoid Update(int node, int st, int en, int L, int R, long long val) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return;\n\t\tif (L <= st && en <= R) {\n\t\t\tLazy[node] += val;\n\t\t\tPropagate(node, st, en); return;\n\t\t}\n\t\tUpdate(node*2+1, st, (st+en)/2+0, L, R, val);\n\t\tUpdate(node*2+2, (st+en)/2+1, en, L, R, val);\n\t\tTree[node] = Tree[node*2+1] + Tree[node*2+2];\n\t}\n\t\n\tlong long Sum(int node, int st, int en, int L, int R) {\n\t\tPropagate(node, st, en);\n\t\tif (en < st || R < st || en < L) return 0LL;\n\t\tif (L <= st && en <= R) return Tree[node];\n\t\tlong long p1 = Sum(node*2+1, st, (st+en)/2+0, L, R);\n\t\tlong long p2 = Sum(node*2+2, (st+en)/2+1, en, L, R);\n\t\treturn (p1 + p2);\n\t}\n\t\n\tvoid RangeUpdate(int L, int R, long long val) {\n\t\tUpdate(0, 0, n-1, L, R, val);\n\t}\n\t\n\tlong long RangeSum(int L, int R) {\n\t\treturn Sum(0, 0, n-1, L, R);\n\t}\n};\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\t\n\tint n, m, w; cin >> n >> m >> w;\n\t\n\tlong long TotalCandies = 0;\n\t\n\tSegTree_Sum TreeRow = SegTree_Sum(n);\n\tSegTree_Sum TreeCol = SegTree_Sum(m);\n\t\n\twhile (w--) {\n\t\tint t, x1, y1, x2, y2;\n\t\tcin >> t >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tif (t == 0) {\n\t\t\tint v; cin >> v;\n\t\t\t\n\t\t\tTotalCandies += 1LL * (x2 - x1 + 1) * (y2 - y1 + 1) * v;\n\t\t\t\n\t\t\tTreeRow.RangeUpdate(x1, x2, 1LL * v * (y2 - y1 + 1));\n\t\t\tTreeCol.RangeUpdate(y1, y2, 1LL * v * (x2 - x1 + 1));\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tlong long res = 0;\n\t\t\t\n\t\t\tres += TreeRow.RangeSum(x1, x2);\n\t\t\tres += TreeCol.RangeSum(y1, y2);\n\t\t\tres -= TotalCandies;\n\t\t\t\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/64453",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 4000000, \"m\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    bool hasType1 = false;\n    for (int i = 0; i < w; ++i) {\n        int t = inf.readInt(0, 1, \"t\");\n        inf.readSpace();\n        if (t == 0) {\n            int x1 = inf.readInt(1, n, \"x1\");\n            inf.readSpace();\n            int y1 = inf.readInt(1, m, \"y1\");\n            inf.readSpace();\n            int x2 = inf.readInt(x1, n, \"x2\");\n            inf.readSpace();\n            int y2 = inf.readInt(y1, m, \"y2\");\n            inf.readSpace();\n            int v = inf.readInt(1, 1000000000, \"v\");\n            inf.readEoln();\n        } else {\n            int x1 = inf.readInt(2, n - 1, \"x1\");\n            inf.readSpace();\n            int y1 = inf.readInt(2, m - 1, \"y1\");\n            inf.readSpace();\n            int x2 = inf.readInt(x1, n - 1, \"x2\");\n            inf.readSpace();\n            int y2 = inf.readInt(y1, m - 1, \"y2\");\n            inf.readEoln();\n            hasType1 = true;\n        }\n    }\n    ensuref(hasType1, \"At least one event of type 1 must occur.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 4000000, \"m\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    bool hasType1 = false;\n    for (int i = 0; i < w; ++i) {\n        int t = inf.readInt(0, 1, \"t\");\n        inf.readSpace();\n        if (t == 0) {\n            int x1 = inf.readInt(1, n, \"x1\");\n            inf.readSpace();\n            int y1 = inf.readInt(1, m, \"y1\");\n            inf.readSpace();\n            int x2 = inf.readInt(x1, n, \"x2\");\n            inf.readSpace();\n            int y2 = inf.readInt(y1, m, \"y2\");\n            inf.readSpace();\n            int v = inf.readInt(1, 1000000000, \"v\");\n            inf.readEoln();\n        } else {\n            int x1 = inf.readInt(2, n - 1, \"x1\");\n            inf.readSpace();\n            int y1 = inf.readInt(2, m - 1, \"y1\");\n            inf.readSpace();\n            int x2 = inf.readInt(x1, n - 1, \"x2\");\n            inf.readSpace();\n            int y2 = inf.readInt(y1, m - 1, \"y2\");\n            inf.readEoln();\n            hasType1 = true;\n        }\n    }\n    ensuref(hasType1, \"At least one event of type 1 must occur.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 4000000, \"m\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    bool hasType1 = false;\n    for (int i = 0; i < w; ++i) {\n        int t = inf.readInt(0, 1, \"t\");\n        inf.readSpace();\n        if (t == 0) {\n            int x1 = inf.readInt(1, n, \"x1\");\n            inf.readSpace();\n            int y1 = inf.readInt(1, m, \"y1\");\n            inf.readSpace();\n            int x2 = inf.readInt(x1, n, \"x2\");\n            inf.readSpace();\n            int y2 = inf.readInt(y1, m, \"y2\");\n            inf.readSpace();\n            int v = inf.readInt(1, 1000000000, \"v\");\n            inf.readEoln();\n        } else {\n            int x1 = inf.readInt(2, n - 1, \"x1\");\n            inf.readSpace();\n            int y1 = inf.readInt(2, m - 1, \"y1\");\n            inf.readSpace();\n            int x2 = inf.readInt(x1, n - 1, \"x2\");\n            inf.readSpace();\n            int y2 = inf.readInt(y1, m - 1, \"y2\");\n            inf.readEoln();\n            hasType1 = true;\n        }\n    }\n    ensuref(hasType1, \"At least one event of type 1 must occur.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Move {\n    int type; // 0 or 1\n    vector<int> params; // parameters\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int w = opt<int>(\"w\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Move> moves;\n\n    if (type == \"random\") {\n        for (int i = 0; i < w; ++i) {\n            int move_type = rnd.next(0,1); // 0 or 1\n            if (i == w-1 && moves.empty()) {\n                // Ensure at least one move is of type 2\n                move_type = 1;\n            }\n            if (move_type == 0) {\n                // Type 1 move\n                int x1 = rnd.next(1, n);\n                int x2 = rnd.next(x1, n);\n                int y1 = rnd.next(1, m);\n                int y2 = rnd.next(y1, m);\n                int v = rnd.next(1, 1000000000);\n                moves.push_back({0, {x1, y1, x2, y2, v}});\n            } else {\n                // Type 2 move\n                int x1 = rnd.next(2, n - 1);\n                int x2 = rnd.next(x1, n - 1);\n                int y1 = rnd.next(2, m - 1);\n                int y2 = rnd.next(y1, m - 1);\n                moves.push_back({1, {x1, y1, x2, y2}});\n            }\n        }\n    } else if (type == \"full\") {\n        int v = 1000000000;\n        for (int i = 0; i < w-1; ++i) {\n            moves.push_back({0, {1,1,n,m,v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"corner\") {\n        int v = 1000000000;\n        vector<pair<int, int>> corners = {{1,1}, {1,m}, {n,1}, {n,m}};\n        for (int i = 0; i < w-1; ++i) {\n            int ci = i % 4;\n            int x = corners[ci].first;\n            int y = corners[ci].second;\n            moves.push_back({0, {x, y, x, y, v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"single_cell\") {\n        int v = 1000000000;\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n        for (int i = 0; i < w-1; ++i) {\n            moves.push_back({0, {x, y, x, y, v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"edge\") {\n        int v = 1000000000;\n        for (int i = 0; i < w-1; ++i) {\n            int move = rnd.next(0, 3);\n            int x1, x2, y1, y2;\n            if (move == 0) { // First row\n                x1 = 1; x2 = 1; y1 = 1; y2 = m;\n            } else if (move == 1) { // Last row\n                x1 = n; x2 = n; y1 = 1; y2 = m;\n            } else if (move == 2) { // First column\n                x1 = 1; x2 = n; y1 = 1; y2 = 1;\n            } else { // Last column\n                x1 = 1; x2 = n; y1 = m; y2 = m;\n            }\n            moves.push_back({0, {x1,y1,x2,y2,v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"max_v\") {\n        int v = 1000000000;\n        for (int i = 0; i < w-1; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            moves.push_back({0, {x1,y1,x2,y2,v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else {\n        // Default to random\n        for (int i = 0; i < w; ++i) {\n            int move_type = rnd.next(0,1); // 0 or 1\n            if (i == w-1 && moves.empty()) {\n                move_type = 1;\n            }\n            if (move_type == 0) {\n                int x1 = rnd.next(1, n);\n                int x2 = rnd.next(x1, n);\n                int y1 = rnd.next(1, m);\n                int y2 = rnd.next(y1, m);\n                int v = rnd.next(1, 1000000000);\n                moves.push_back({0, {x1, y1, x2, y2, v}});\n            } else {\n                int x1 = rnd.next(2, n - 1);\n                int x2 = rnd.next(x1, n - 1);\n                int y1 = rnd.next(2, m - 1);\n                int y2 = rnd.next(y1, m - 1);\n                moves.push_back({1, {x1, y1, x2, y2}});\n            }\n        }\n    }\n\n    // Now, output n, m, w\n    printf(\"%d %d %d\\n\", n, m, w);\n    for (const auto& move : moves) {\n        if (move.type == 0) {\n            // Type 1 move\n            printf(\"0 %d %d %d %d %d\\n\", move.params[0], move.params[1],\n                move.params[2], move.params[3], move.params[4]);\n        } else if (move.type == 1) {\n            // Type 2 move\n            printf(\"1 %d %d %d %d\\n\", move.params[0], move.params[1],\n                move.params[2], move.params[3]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Move {\n    int type; // 0 or 1\n    vector<int> params; // parameters\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int w = opt<int>(\"w\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Move> moves;\n\n    if (type == \"random\") {\n        for (int i = 0; i < w; ++i) {\n            int move_type = rnd.next(0,1); // 0 or 1\n            if (i == w-1 && moves.empty()) {\n                // Ensure at least one move is of type 2\n                move_type = 1;\n            }\n            if (move_type == 0) {\n                // Type 1 move\n                int x1 = rnd.next(1, n);\n                int x2 = rnd.next(x1, n);\n                int y1 = rnd.next(1, m);\n                int y2 = rnd.next(y1, m);\n                int v = rnd.next(1, 1000000000);\n                moves.push_back({0, {x1, y1, x2, y2, v}});\n            } else {\n                // Type 2 move\n                int x1 = rnd.next(2, n - 1);\n                int x2 = rnd.next(x1, n - 1);\n                int y1 = rnd.next(2, m - 1);\n                int y2 = rnd.next(y1, m - 1);\n                moves.push_back({1, {x1, y1, x2, y2}});\n            }\n        }\n    } else if (type == \"full\") {\n        int v = 1000000000;\n        for (int i = 0; i < w-1; ++i) {\n            moves.push_back({0, {1,1,n,m,v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"corner\") {\n        int v = 1000000000;\n        vector<pair<int, int>> corners = {{1,1}, {1,m}, {n,1}, {n,m}};\n        for (int i = 0; i < w-1; ++i) {\n            int ci = i % 4;\n            int x = corners[ci].first;\n            int y = corners[ci].second;\n            moves.push_back({0, {x, y, x, y, v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"single_cell\") {\n        int v = 1000000000;\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n        for (int i = 0; i < w-1; ++i) {\n            moves.push_back({0, {x, y, x, y, v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"edge\") {\n        int v = 1000000000;\n        for (int i = 0; i < w-1; ++i) {\n            int move = rnd.next(0, 3);\n            int x1, x2, y1, y2;\n            if (move == 0) { // First row\n                x1 = 1; x2 = 1; y1 = 1; y2 = m;\n            } else if (move == 1) { // Last row\n                x1 = n; x2 = n; y1 = 1; y2 = m;\n            } else if (move == 2) { // First column\n                x1 = 1; x2 = n; y1 = 1; y2 = 1;\n            } else { // Last column\n                x1 = 1; x2 = n; y1 = m; y2 = m;\n            }\n            moves.push_back({0, {x1,y1,x2,y2,v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else if (type == \"max_v\") {\n        int v = 1000000000;\n        for (int i = 0; i < w-1; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            moves.push_back({0, {x1,y1,x2,y2,v}});\n        }\n        moves.push_back({1, {2,2,n-1,m-1}});\n    } else {\n        // Default to random\n        for (int i = 0; i < w; ++i) {\n            int move_type = rnd.next(0,1); // 0 or 1\n            if (i == w-1 && moves.empty()) {\n                move_type = 1;\n            }\n            if (move_type == 0) {\n                int x1 = rnd.next(1, n);\n                int x2 = rnd.next(x1, n);\n                int y1 = rnd.next(1, m);\n                int y2 = rnd.next(y1, m);\n                int v = rnd.next(1, 1000000000);\n                moves.push_back({0, {x1, y1, x2, y2, v}});\n            } else {\n                int x1 = rnd.next(2, n - 1);\n                int x2 = rnd.next(x1, n - 1);\n                int y1 = rnd.next(2, m - 1);\n                int y2 = rnd.next(y1, m - 1);\n                moves.push_back({1, {x1, y1, x2, y2}});\n            }\n        }\n    }\n\n    // Now, output n, m, w\n    printf(\"%d %d %d\\n\", n, m, w);\n    for (const auto& move : moves) {\n        if (move.type == 0) {\n            // Type 1 move\n            printf(\"0 %d %d %d %d %d\\n\", move.params[0], move.params[1],\n                move.params[2], move.params[3], move.params[4]);\n        } else if (move.type == 1) {\n            // Type 2 move\n            printf(\"1 %d %d %d %d\\n\", move.params[0], move.params[1],\n                move.params[2], move.params[3]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -w 1 -type random\n./gen -n 3 -m 3 -w 5 -type random\n./gen -n 3 -m 3 -w 100000 -type random\n\n./gen -n 10 -m 10 -w 10 -type random\n./gen -n 10 -m 10 -w 10 -type full\n./gen -n 10 -m 10 -w 10 -type corner\n./gen -n 10 -m 10 -w 10 -type edge\n./gen -n 10 -m 10 -w 10 -type single_cell\n./gen -n 10 -m 10 -w 10 -type max_v\n\n./gen -n 1000 -m 1000 -w 10000 -type random\n./gen -n 1000 -m 1000 -w 10000 -type full\n./gen -n 1000 -m 1000 -w 10000 -type corner\n./gen -n 1000 -m 1000 -w 10000 -type edge\n./gen -n 1000 -m 1000 -w 10000 -type single_cell\n./gen -n 1000 -m 1000 -w 10000 -type max_v\n\n./gen -n 4000000 -m 4000000 -w 100000 -type random\n./gen -n 4000000 -m 4000000 -w 100000 -type full\n./gen -n 4000000 -m 4000000 -w 100000 -type corner\n./gen -n 4000000 -m 4000000 -w 100000 -type edge\n./gen -n 4000000 -m 4000000 -w 100000 -type single_cell\n./gen -n 4000000 -m 4000000 -w 100000 -type max_v\n\n./gen -n 4000000 -m 4000000 -w 1 -type random\n./gen -n 4000000 -m 4000000 -w 1 -type full\n./gen -n 4000000 -m 4000000 -w 1 -type corner\n./gen -n 4000000 -m 4000000 -w 1 -type edge\n./gen -n 4000000 -m 4000000 -w 1 -type single_cell\n./gen -n 4000000 -m 4000000 -w 1 -type max_v\n\n./gen -n 3 -m 4000000 -w 100000 -type random\n./gen -n 4000000 -m 3 -w 100000 -type random\n./gen -n 10 -m 4000000 -w 100000 -type single_cell\n./gen -n 4000000 -m 10 -w 100000 -type single_cell\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:36.261168",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "391/A",
      "title": "A. Genetic Engineering",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of a single line, containing a string s of length n (1 ≤ n ≤ 100). Each character of s will be from the set {'A', 'T', 'G', 'C'}.This problem doesn't have subproblems. You will get 3 points for the correct submission.",
      "output_spec": "OutputThe program should print on one line a single integer representing the minimum number of 'A', 'T', 'G', 'C' characters that are required to be inserted into the input string in order to make all runs of identical characters have odd length.",
      "sample_tests": "ExamplesInputCopyGTTAAAGOutputCopy1InputCopyAACCAACCAAAACOutputCopy5",
      "description": "A. Genetic Engineering\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of a single line, containing a string s of length n (1 ≤ n ≤ 100). Each character of s will be from the set {'A', 'T', 'G', 'C'}.This problem doesn't have subproblems. You will get 3 points for the correct submission.\n\nOutputThe program should print on one line a single integer representing the minimum number of 'A', 'T', 'G', 'C' characters that are required to be inserted into the input string in order to make all runs of identical characters have odd length.\n\nInputCopyGTTAAAGOutputCopy1InputCopyAACCAACCAAAACOutputCopy5\n\nInputCopyGTTAAAG\n\nOutputCopy1\n\nInputCopyAACCAACCAAAAC\n\nOutputCopy5\n\nNoteIn the first example, it is sufficient to insert a single nucleotide of any type between the two 'T's in the sequence to restore the functionality of the protein.",
      "solutions": [
        {
          "title": "Rockethon 2014 Overview - Codeforces",
          "content": "Hello Codeforces community,I am happy to announce that Rocket Fuel Inc. will soon be hosting a contest called Rockethon on Codeforces. The contest is prepared by Rocket Fuel employees Jon Derryberry, Alexander Ruff and me, Eldar Bogdanov. We hope you will have as much fun solving the problems as we had crafting them. The contest will feature prizes and T-shirts for top performers. Also, Rocket Fuel is interested in hiring the best of you after this event, so let me tell you about the company and why you would want to join us.About Rocket FuelRocket Fuel is building technology platform to do automatic targeting and optimization of ads across all channels — display, video, mobile and social. Our pitch to advertisers is very simple \"If you can measure metrics of success of your campaign, we can optimize\". We have run campaigns for many large advertisers. Examples include BMW, Pizza Hut, Brooks Running Shoes and many more!We buy all our inventory through real time bidding on ad exchanges like Google and Yahoo. Ad exchanges are similar to stock exchanges except the commodity being traded is ad slots on web pages. Our serving systems currently process 40B requests/ day (~6X Google search volume), 600K requests/ second at peak with response time requirement of 100ms. Our data platform has several PBs data that is used for analytics as well as modeling.Our engineering team is still small (~100) enough for any one person like yourself to make a huge impact. The team represents many top schools in US and outside — Stanford, CMU, MIT, Wisconsin-Madison, IIT (India), Tsinghua (China).Rocket Fuel has been named #4 on Forbes Most Promising Companies in America List in 2013 and #1 Fastest Growing Company in North America on Deloitte’s 2013 Tech Fast 500. -My Personal StoryI joined Rocket Fuel after competing in a previous Rocket Fuel programming contest that was similar to Rockethon. Since I joined, I’ve had the opportunity to learn a lot about the industry technologies we use, such as Hive, Hadoop, Hbase, Storm, and Redis, as well as work on production software that processes tens of billions of requests per day.Another thing I like about working here is the fast development cycle. We can see the immediate impact of our code by testing in production the same day the code is written. For example, I recently profiled our code, identified a suboptimal use of a trie data structure, tested improvements in production, and then was able to see the site-wide benefit of the optimizations within days, since we push new code to production daily.It has been a great opportunity to learn from experts across a variety of fields, such as distributed systems, software architecture, databases, machine learning, and optimization. The atmosphere within Engineering team is very friendly, and everyone is willing to answer your questions and discuss problems you may have or discuss their work with you. In addition, we take some time to unwind at work. There are always intellectually curious people around to chat about algorithmic puzzles. We play ping pong, soccer and cricket. Also, I think it’s cool that Rocket Fuel values the problem solving and coding skills of programming contest enthusiasts, and invite you to consider joining Rocket Fuel if the above sounds interesting.Contest OverviewThe contest will begin on February 16, 10AM PST.The contest length is 3 hours.The testing of each submission will be performed as soon as the submission is received and the verdict will be delivered to the submission author right away.The problemset will consist of 6 problems, each of them possibly featuring one or two subproblems. Each subproblem will be worth a fixed amount of points. The ties between contestants with the same score will be broken by penalty time which is computed similar to ACM scoring system.PrizesEach of top three contestants will be awarded an iPad Air 16GB.The top 150 performers will receive a Rockethon T-shirt designed specially for this contest.ResultsCongratulations to the top three contestants: tourist — Gennady Korotkevich, Belarus scott_wu — Scott Wu, USA uwi — Uwi Tenpen, Japan You can find the list of the top-150 here.Note. This is a combined reconstruction of Rockethon 2014 announcement and result posts which were lost due to March 2 technical failure.",
          "author": "gojira",
          "url": "https://codeforces.com/blog/entry/10731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4313
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces",
          "content": "In this post you will find the authors' solutions for the problems and subproblems featured in the competition, as well as some bonus questions related to these tasks.391A - Genetic EngineeringNote that we can consider each maximal sequence of identical characters independently, since there is no way to insert a character and affect more than one such sequence. Also, note that there are multiple ways to correct a single maximal sequence by inserting one character into it: we can either insert a different character somewhere in this sequence and divide it into two sequences of odd length (this is always possible for a sequence of even length), or even just add the same character in any point of this sequence, thus increasing its length by 1 and changing its parity.Therefore, the answer to the problem is the number of maximal sequences of even length. One can find all such sequences in linear time. A pseudocode of the solution follows: i = 1\nans = 0\nwhile i <= length(s) do\n end = length(s) + 1 // we will use this value if current sequence is the last in this string\n for j = i + 1 .. length(s)\n if s[j] <> s[i] then\n end = j\n break\n // at this point, we have the next maximal sequence of identical characters between i and j-1, inclusive\n if (j - i) mod 2 = 0 then\n ans = ans + 1\n i = jBonus: Alex decided to submit an almost one-line solution for this problem, which reminded me of shortest code competitions. I thought you might be interested in something similar, so here is Alex's solution to kick off (111 non-space chars): #include<stdio.h>\nmain(){int x=-1,y=1,c,d=0;for(;10!=(c=getchar());d=c,y^=1)if(c-d)x+=y,y=1;printf(\"%d\\n\",x+y);}391B - Word FoldingLet us describe the crucial observation necessary to solve this problem. Suppose that you have a character at some position i in the string and you want to fold the string in such a way that another character at position j > i is placed directly above the i-th character in the resulting structure. This is only possible if there is an even number of characters between i and j, and this is always possible in such case. In order to put the j-th character upon the i-th character, you would need to perform the fold exactly after position (i + j + 1) / 2. Thus, what the problem really asks for is \"What is the longest sequence of indices you can choose such that they all contain the same letter and there is an even number of characters between each pair of consecutive indices in the sequence?\". Note that \"even number of characters between each consecutive pair\" means that each index has different parity from the one before it.Armed with the observation above, we can devise a simple greedy algorithm. First, let us choose the letter which the highest pile will consist of. That is, let's iterate from 'A' to 'Z'. For a fixed letter, there are two possibly optimal choices: either we begin with the leftmost even index which contains the corresponding letter, or we begin with the leftmost odd such index. Once we make this choice, the maximum sequence of indices becomes fixed; the next index in the optimal sequence is always the leftmost index to the right of the current one that contains the same letter and has different parity. Thus, there are at most 26 * 2 cases to consider and the answer for each case can be found in O(n) time. If the alphabet size A was an input parameter, the total algorithm complexity would be O(A * n).Bonus: The initial version of the problem was slightly different, though we have abandoned it due to complicated problem statement. In that version, a pile could contain gaps or begin above the first level. Can you see why the solution to this problem is exactly the same?391C3 - The TournamentSince it was a question of multiple clarification requests, I will explain the third example here. The input is as follows: 5 2\n2 10\n2 10\n1 1\n3 1\n3 1The common misconception was that winning against three last opponents is sufficient to get in top 2. Note that winning only against the last three implies that Manao lost against the first two, so they'll have as many points as Manao and rank better than him. The optimal strategy is to win against one of the first two fighters, and win another two matches against fighters costing 1 unit of effort.Subproblem C1.As the constraints suggest, the intended solution here is brute force. Note that there are only 2n different possible scenarios, depending on which fight Manao wins and which he loses. Thus, we can generate all of these scenarios, compute the score that Manao will obtain as a result of it and what will the other contestants' new scores be, and determine what is the minimum total effort Manao needs for a scenario which gets him in top k.How can we generate all scenarios? A natural way to do this is recursion: for each fight, we choose the outcome (win or loss) and recurse one level deeper, stopping when all match outcomes have been chosen and performing the evaluation. However, there is another way which is usually less time-consuming: bitmasks. If you are not familiar with using bitmasks, I recommend reading the old-but-never-outdated tutorial by bmerry and dimkadimon's Topcoder Cookbook recipe on iterating over subsets. This is a pseudocode showing how short a bitmask solution for this problem is: ans = INFINITY\n for(bitmask = 0; bitmask < 2**n; bitmask++)\n int score = 0;\n int effort = 0;\n for(i = 0; i < n; i++)\n if (bitTurnedOnIn(mask, i))\n score = score + 1;\n effort = effort + fighter[i].effort;\n rank = n + 1;\n for(int i = 0; i < n; i++)\n if (fighter[i].score < score - 1 || fighter[i].score <= score && (bitTurnedOnIn(mask, i))\n rank = rank - 1\n if (rank <= k)\n ans = min(ans, effort);Subproblem C2.This subtask could be solved with any reasonable polynomial algorithm. My solution was the following: iterate over the number of points P that Manao will have in the end. For each P, let us check whether it is possible to finish in top k having P points and what is the minimum effort required. This can be computed using dynamic programming: let F(i, j, k) be the minimum effort required to win k of the fights against the first i fighters and be ranked worse than j of them. I will not go into details of this solution, since there are many alternatives, and it is suboptimal anyway.Subproblem C3.Let us look deeper into what amount of points Manao might have if he finishes in top k. Since finishing in top k is the same as ranking better than at least n - k + 1 opponent, I will just assume from now on that he has to beat Q = n - k + 1 opponents. Let S(i) be the number of fighters that have i points before Manao joins the tournament. Then, if S(0) + S(1) + … + S(P) is less than Q, there is no way Manao can possibly rank better than Q opponents if he has score P in the end. So we have a lower bound on the score Manao will have in the end. On the other hand, note that if S(0) + S(1) + … + S(P - 2) is more than or equal to Q, then after scoring P points Manao will surely rank better than at least Q rivals. Thus, if P' is the minimum amount of points such that S(0) + S(1) + … + S(P' - 2) >  = Q, there is no need to go for more points. Manao can just win the P' matches which require the least amount of effort from him. These observations leave us with only two interesting values of P — the first value when S(0) + S(1) + … + S(P) >  = Q and that value plus 1.What makes these cases more complicated is the fact that now it matters which matches does Manao win or lose. Suppose Manao wants to score P points. Let S' = S(0) + S(1) + … + S(P - 2). This is the count of opponents that are definitely ranked lower than Manao if he gets P points. Each of the fighters that has P - 1 or P points will rank better than Manao if Manao loses the corresponding fight and worse otherwise. Thus, Manao needs to win at least Q - S' of the fights against those opponents. Let's collect the efforts required to beat each of the opponents with score P - 1 or P into a list and collect the efforts required to beat each of the other opponents in another list. After we sort both lists, all we need to do is find the minimum sum of Q numbers such that at least Q - S' of them are from the first list and the rest are from the second.The complexity of this algorithm is O(NlogN).Bonus: Can you solve the problem in linear time?391D2 - SupercolliderThe goal in this problem was to find a pair of horizontal and vertical segments that forms the largest plus shape, truncating the ends of the segments so the plus is completely symmetric. A naive brute force O(n2) algorithm that simply tries all such pairs, computes the size of the plus for that pair, and prints the maximum is sufficient to solve the first subtask. For the second subtask, a faster algorithm is required. As with many problems related to computational geometry it is usually easiest to think of a sweepline algorithm to process a linear number of events, with each event requiring at most logarithmic time to process.It turns out that one key insight suffices to pave the way for a relatively simple approach. If you transform the problem from a maximization problem “what is the largest plus?” into the decision problem “does there exist a plus of size k?” then your task is somewhat simplified at the cost of a O(lgW) factor to perform binary search to find the maximum valid k, where W is the bound on the coordinate values.To answer the decision problem there is another trick that helps simplify your task. If you are interested in determining whether there exists a plus of size k, it suffices to simply truncate each segment by k on each end point and check whether any pair of segments intersects -- there is no need to check how long the arms of the plus are. For example, for each horizontal segment from (x, y) to (x + l, y), then you create a new segment from (x + k, y) to (x + l - k, y) if the segment still has non-negative length, and make a similar transformation for vertical segments. After transforming the segments, you can use a sweepline algorithm that keeps track of all vertical segments that intersect with a horizontal sweepline and use a binary indexed tree or binary search tree to determine whether the end points of each horizontal line the sweepline encounters straddles an active vertical line. Either of these data structures will suffice to clear the test cases for the second subproblem. Note that the full running time for this algorithm is where n is the number of segments and W is the size of the largest segment.For the interested algorithms enthusiast, there exists a trickier algorithm that runs in time and does not require binary searching for the largest plus size, though unfortunately it is difficult to distinguish this algorithm from the above one with the input constraints of a contest due to a higher constant factor overhead for this approach. The idea may be difficult to understand if you are not familiar with sweepline algorithms and augmented binary search trees, but I will sketch it here.The idea is to make four separate sweepline passes over the input, with each pass looking for plusses in which the shortest arm of the plus is in a different direction, north, south, east, or west. For example, if we assume that the shortest arm of the plus is pointing north, we can use a diagonal sweepline that starts in the northwest corner and sweeps in the southeast direction (note that the line itself is drawn from the southwest to the northeast, but moves from the northwest to the southeast).Each time this sweepline encounters the westmost endpoint of a horizontal line, it adds the segment into a binary search tree that is ordered from north to south. Each node in the search tree is further annotated with the sum of the x and y coordinates of the eastmost end point of the horizontal segment (i.e., if the eastmost point has coordinates (x, y), we store x + y) and stores the minimum such value in the subtree rooted at that node.Now, when the northmost endpoint of a vertical segment is encountered by the sweepline, we search for the southmost horizontal segment whose y value is north of the midpoint of the vertical segment and whose (x + y)-coordinate sum is greater than the (x + y)-coordinate sum of the northmost point of the vertical segment.Note that when the sweepline hits the northmost point of a vertical segment, it will only have added horizontal segments whose “west arm” is longer than the “north arm” and the condition on the (x + y)-coordinate of the eastmost endpoint of the horizontal line ensures that the “east arm” is longer than the north arm. The additional constraint that the searched y value in the tree is north of the midpoint adds the final constraint that the north arm is shorter than the south arm. Finding the southmost horizontal segment that satisfies these constraints is equivalent to finding the largest plus that uses this vertical segment and has the north arm as the shortest of the four arms. There are still some details to work out to get the binary search to operate correctly in O(lgn) time, but we leave these as an exercise.391E2 - Three TreesSubproblem 1.Let us start with choosing a tree that will be the \"middle tree\", i.e., have connections to two other trees. Let n2 be the number of vertices in this tree and yi be its i-th vertex. Let n1 be the number of vertices and xi be the vertices of one of the other trees, and n2 be the number of vertices and zi be the vertices of another tree. Let d(i, j) be the distance between nodes i and j of the same some tree. Suppose we insert the edges (X, Y1) and (Z, Y2), where , , . The sum of distances between all pairs of points in the united tree can be divided into four components: Distances between {xi} and {yi} Distances between {yi} and {zi} Distances between pairs of vertices that were connected before we inserted the additional edges Distances between {xi} and {zi} The first component is equal to sum(d(X, xi) + d(Y1, yi) + 1, xi = 1..n1, yi = 1..n2). Note that the summands are independent, so it can be broken into sum(d(X, xi), xi = 1..n1) * n2 + sum(d(Y1, yi), yi = 1..n2) * n1 + n1 * n2.Similarly, the second component is equal to sum(d(Z, zi), zi = 1..n3) * n2 + sum(d(Y2, yi), yi = 1..n2) * n3 + n2 * n2.The third component is simply a sum of pairwise distances in each of the trees and is a constant.The fourth component is equal to sum(d(X, xi) + d(Y1, Y2) + d(Z, zi) + 2, xi = 1..n1, zi = 1..n3) = sum(d(X, xi), xi = 1..n1) * n3  + sum(d(Z, zi), zi = 1..n3) + d(Y1, Y2) * n1 * n3 + 2 * n1 * n3.Let us compute the pairwise distances within each tree. This can be done with straightforward DFS/BFS and thus takes O(n12 + n22 + n32) time. Also, let's put D(v) = sum(d(v, i)) over all i from v's tree.If we write together all the sums mentioned above, we will see that is always optimal to choose X such that it has the maximum D(X) over all vertices in its tree. The same argument holds for Z. Y1 and Y2 are both a part of two sums, so they cannot be chosen independently. Thus, let's iterate over all possible values of Y1 and Y2 and choose the pair that maximizes sum(d(Y2, yi), yi = 1..n2) * n3 + sum(d(Y1, yi), yi = 1..n2) * n1  + d(Y1, Y2) * n1 * n3 = D(Y2) * n3 + D(Y1) * n1 + d(Y1, Y2) * n1 * n3.Since precalculation of distances takes square time, and choosing the optimal pair of (Y1, Y2) also takes square time, the resulting algorithm complexity is square.Subproblem 2.Please read the explanation for the previous problem if you have not done so yet.I will assume that the reader is familiar with some tricks on trees, because it does not seem plausible to explain every step of the algorithm.The core idea of the problem is the same as for the previous subproblem: we are maximizing a sum composed of several components, the only \"hard\" part of which is D(Y2) * n3 + D(Y1) * n1 + d(Y1, Y2) * n1 * n3. As we already know, the rest can be computed independently, which involves finding the sum of distances over all nodes in a tree and finding a node with maximum possible sum of distances to all other nodes, all in linear time.To maximize D(Y2) * n3 + D(Y1) * n1 + d(Y1, Y2) * n1 * n3, let's perform some additional precalculation first. Let us root the middle tree (doesn't matter at which node). For each of the vertices, we need to assume that it is Y1 and find the two best candidates of being a Y2 from its subtree. This is easy if we know the Y2-candidates for each of the current vertex's children.Having precalculated the Y2-candidates for each subtree, let us perform another traversal of the tree. This time, we will assume for each vertex that it is Y1, but will compute the optimal Y2 along the whole tree, not just current vertex's subtree. Obviously, for the root of the tree the optimal Y2 is the best Y2-candidate in the subtree of the root. When we start moving into the depth of the tree, we need to remember the current best Y2-candidate which is \"left behind\", i.e., is not within the subtree we just entered. This way, we will choose between the Y2-candidate left behind and the Y2-candidate within the current subtree and pick the best. Note that when we pass from a vertex P to a vertex V, the Y2-candidate left behind can only change to some vertex which is within P's subtree. We need to be careful and check that the Y2-candidate within P's subtree was not actually in V's subtree also, in which case the second-best Y2-candidate of P's subtree should be used for comparison against the one left behind.391F3 - Stock TradingThis problem is a generalization of a common interview problem: given a time series of prices, find the single trade that results in the maximum gain. The best solution, in O(n) time, is an example of a very simple DP that simply scans the prices, keeps track of both the minimum price seen so far and the best gain so far, and computes the best gain achievable by selling on the current day by subtracting the running minimum from the current price. In this contest’s problem, the task is generalized to handling the case of k trades. Perhaps surprisingly, the optimal running time is still O(n) even when k is allowed to be chosen arbitrarily. To get to this optimal solution, let’s consider a series of increasingly fast algorithms for solving the problem.Subproblem 1.First, there is a very straightforward O(n2k) time DP solution in which, for each i and j we compute OPT(i, j), the optimal gain achievable by making j trades, with the sell order of the j-th trade occurring on day i or earlier. A natural recurrence relation is OPT(i, j) = max(OPT(i - 1, j), OPT(i’, j - 1) + p[i] - p[i’]foralli’ < i). Here, we are computing O(nk) optimal values, and each requires O(n) work to scan over all previous days to find the best solution for which the j-th trade ends exactly on day i. This solution is not fast enough to clear any of the three subproblems for this contest.With a bit more work, we can speed up the O(n2k) DP to run in O(nk) time, which suffices to clear the first subproblem. It is important to realize that we do not need to consider all previous days when computing OPT(i, j) so that we can compute each such value in constant time. One way to achieve this is to create a slightly different optimization problem OPT2(i, j) that represents the maximum gain achievable with j trades during the first i - 1 days, minus the minimum price seen since the sell order for the j-th trade in OPT2(i, j). We also define MIN(i, j) to be the minimum price seen after the date of the last trade made in the solution for OPT2(i, j). With these definitions, we have the following recurrence: OPT2(i, j) = max(OPT2(i - 1, j), OPT2(i - 1, j) - p[i] + MIN(i - 1, j),  OPT2(i - 1, j - 1) + p[i - 1] - p[i]). Case 1 represents using the same trades and minimum as OPT2(i - 1, j); case 2 represents using the same trades as OPT2(i - 1, j) but using p[i] as the new minimum; and case 3 represents using the optimal solution from OPT2(i - 1, j - 1) and selling for the j-th trade on day i - 1 for a gain of p[i - 1] with the new min of p[i] subtracted from the objective value. To compute MIN(i, j), we simply consider which case we fell into and set MIN(i, j) accordingly. In case 1, we set MIN(i, j) to MIN(i - 1, j); in case 2 we set MIN(i, j) = p[i]; and in case 3, we set MIN(i, j) = p[i]. The final solution, ignoring boundary cases, for OPT(n, k) is the max over all i of OPT2(i, k) + MIN(i, k).Subproblem 2.To clear the second subtask, we need additional insight about the problem so that we can achieve a sub-quadratic solution. The most important insight is that there is a way of solving this problem using a greedy algorithm if we make a transformation to the original problem. We begin by identifying the optimal solution that uses an unlimited number of trades. This produces a series of gains g1, …, gt where t is the number of trades in the optimal solution with an unbounded number of trades (this solution is easily found by identifying all possible shortest trades that produce a gain in linear time).We interleave with these gains a series of “phantom-losses” l1, ..., lt - 1. The loss li represents the absolute value of the price difference between the price on the “sell day” for gi and the “buy day” for gi + 1. We let zt represent the value of the optimal solution for t trades (i.e., sum(gi) initially). Now, we look at the sequence St = s1, ..., s2t - 1 = g1, l1, g2, l2, ..., lt - 1, gt. We can compute zt - 1 from zt by finding the lowest value in St and eliminating this gain or loss by merging it with its neighbors (to handle s1 and s2t - 1, we can pad the ends with large values s0 and s2t so we can merge all candidates with two neighbors). This leads naturally to a greedy algorithm in which we continually merge the lowest si (found using either a heap or a BST in time for each iteration) with its neighbors until t = k. This merge consists of combining si - 1, si, andsi + 1 into one new value in the sequence that has value si - 1 - si + s{i + 1}, and zt - 1 = zt - si. Eliminating an si corresponding to a gain means skipping the trade and merging the neighboring losses into a new “phantom loss”. Eliminating an si corresponding to a loss means skipping a loss to merge two gains together into one trade of longer duration.For example, if the sequence of stock prices is 4, 2, 3, 5, 4, 3, 7, 2, 6, 5, the optimal strategy with unlimited trades the following gains: 2 -  > 5, 3 -  > 7, 2 -  > 6, so that g1 = 3, g2 = 4, and g3 = 4. We also have phantom losses of l1 = 2, l2 = 5. Thus, S3 = 3, 2, 4, 5, 4 and z3 = 11 is the profit from the optimal unlimited strategy. If k = 2, we need to execute one step in the greedy algorithm, and this corresponds to removing l1, which has value 2. This removal corresponds to lengthening the duration of the first trade to include the entire time interval from when the price first reaches 2 to when the price reaches 7. The resulting sequence S2 has the intervals 5, 5, 4, representing a gain, a phantom loss, and another gain. Thus, z2 = 9 is the optimal profit achievable with two trades. If we were to greedily iterate once more to find the optimal solution with k = 1, we would delete the last gain of 4, merging it with the preceding phantom loss of 5 and the following dummy phantom loss at the end of S_2 (i.e., S2t as described above). Merging such a gain with two phantom loss neighbors represents simply skipping a trade of low profit. From this, we see that that optimum profit from one trade is 5.In the heat of a competition with open testing such as this one, one might simply guess that this works and hope that the tests pass, risking penalty time if the submission fails, but it turns out that this solution is indeed correct (proof TBD).Subproblem 3.An algorithm suffices to clear the second subproblem, and an extremely fast implementation may pass the tests for the third subproblem (for example, tourist had the only successful submission during the contest for F3 and used an algorithm that squeaked by the tests for F3, avoiding a timeout by 52 milliseconds -- many others timed out with solutions). However, to pass the tests by a more comfortable margin, one can implement an O(n) time algorithm.The idea is as follows. Rather than greedily performing one merge in each iteration, we can perform many merges during each iteration. Note that whenever we perform a merge of 3 intervals into one, the resulting interval has a larger value than the central si interval that was targeted for removal if we take care only to merge local minima. Thus, suppose we need to perform m merges. We can find the m-th smallest value si *  among the segments using linear time select, and then eliminate all segments whose value is less than si * . This can be accomplished by a linear scan across the segments, though we must be careful only to merge local minima so as to guarantee the same final result as using the greedy algorithm. This constraint of only removing local minima still allows us to remove all segments less than si *  if we are careful with how we perform our scan. The result of such a scan is that the number of merges we need to perform falls by at least one third, from m to 2m / 3 (note that after m / 3 merges have been performed, it is possible that no segments remain whose value is less than si * ). Because the number of remaining merges falls by a constant factor in each iteration, we have only iterations to reach our target value. Unfortunately, each pass requires O(n) time so this is still an algorithm. However, we can remedy this by deleting some trades that have large gains (or deleting some large phantom losses). Note that if there are two consecutive segments that have very large values, we will never perform a merge with one of the two of them as a central segment, so we can eliminate any streak of consecutive large segments and replace them with a single segment. How large is large enough that we can forget about the segments? We know that if we have m merges left to perform, we will never perform a merge on a segment whose value is greater than the 3m-th smallest segment. Further, when m is small relative to the remaining number of segments, we know that a constant fraction of segments will be involved in a streak of large values, so we can remove a constant fraction of the total number of segments from consideration. Thus, the total work required for each scan is geometrically decreasing so the total running time is O(n)!After the contest, it has been brought to our attention that this problem has been studied academically. Here is the paper describing a linear-time algorithm.",
          "author": "gojira",
          "url": "https://codeforces.com/blog/entry/10727",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 391\\s*A"
          },
          "content_length": 26632
        }
      ],
      "code_examples": [
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 1",
          "code": "i = 1\nans = 0\nwhile i <= length(s) do\n  end = length(s) + 1  // we will use this value if current sequence is the last in this string\n  for j = i + 1 .. length(s)\n    if s[j] <> s[i] then\n      end = j\n      break\n  // at this point, we have the next maximal sequence of identical characters between i and j-1, inclusive\n  if (j - i) mod 2 = 0 then\n    ans = ans + 1\n  i = j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 2",
          "code": "i = 1\nans = 0\nwhile i <= length(s) do\n  end = length(s) + 1  // we will use this value if current sequence is the last in this string\n  for j = i + 1 .. length(s)\n    if s[j] <> s[i] then\n      end = j\n      break\n  // at this point, we have the next maximal sequence of identical characters between i and j-1, inclusive\n  if (j - i) mod 2 = 0 then\n    ans = ans + 1\n  i = j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 3",
          "code": "#include<stdio.h>\nmain(){int x=-1,y=1,c,d=0;for(;10!=(c=getchar());d=c,y^=1)if(c-d)x+=y,y=1;printf(\"%d\\n\",x+y);}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 4",
          "code": "#include<stdio.h>\nmain(){int x=-1,y=1,c,d=0;for(;10!=(c=getchar());d=c,y^=1)if(c-d)x+=y,y=1;printf(\"%d\\n\",x+y);}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 5",
          "code": "5 2\n2 10\n2 10\n1 1\n3 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 6",
          "code": "5 2\n2 10\n2 10\n1 1\n3 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 7",
          "code": "ans = INFINITY\n    for(bitmask = 0; bitmask < 2**n; bitmask++)\n        int score = 0;\n        int effort = 0;\n        for(i = 0; i < n; i++)\n            if (bitTurnedOnIn(mask, i))\n                score = score + 1;\n                effort = effort + fighter[i].effort;\n        rank = n + 1;\n        for(int i = 0; i < n; i++)\n            if (fighter[i].score < score - 1 || fighter[i].score <= score && (bitTurnedOnIn(mask, i))\n                rank = rank - 1\n        if (rank <= k)\n            ans = min(ans, effort);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 8",
          "code": "ans = INFINITY\n    for(bitmask = 0; bitmask < 2**n; bitmask++)\n        int score = 0;\n        int effort = 0;\n        for(i = 0; i < n; i++)\n            if (bitTurnedOnIn(mask, i))\n                score = score + 1;\n                effort = effort + fighter[i].effort;\n        rank = n + 1;\n        for(int i = 0; i < n; i++)\n            if (fighter[i].score < score - 1 || fighter[i].score <= score && (bitTurnedOnIn(mask, i))\n                rank = rank - 1\n        if (rank <= k)\n            ans = min(ans, effort);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ATGC]{1,100}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ATGC]{1,100}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ATGC]{1,100}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n\n    if (type == \"random\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += \"ATGC\"[rnd.next(0,3)];\n        }\n    } else if (type == \"same_char\") {\n        char c = \"ATGC\"[rnd.next(0,3)];\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        char c1 = \"ATGC\"[rnd.next(0,3)];\n        char c2;\n        do {\n            c2 = \"ATGC\"[rnd.next(0,3)];\n        } while (c2 == c1);\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"all_even_runs\") {\n        s = \"\";\n        int i = 0;\n        while (i < n) {\n            int remaining = n - i;\n            int run_length = min(2, remaining);\n            char c = \"ATGC\"[rnd.next(0,3)];\n            for(int j = 0; j < run_length; ++j) {\n                s += c;\n            }\n            i += run_length;\n        }\n    } else if (type == \"all_odd_runs\") {\n        s = \"\";\n        int i = 0;\n        while (i < n) {\n            int remaining = n - i;\n            int max_run = remaining / 2 * 2 + 1; // Max odd number <= remaining\n            int run_length = min(max_run, 2 * rnd.next(0, (max_run - 1)/2) + 1);\n            char c = \"ATGC\"[rnd.next(0,3)];\n            for(int j = 0; j < run_length; ++j) {\n                s += c;\n            }\n            i += run_length;\n        }\n    } else if (type == \"mixture\") {\n        s = \"\";\n        int i = 0;\n        while (i < n) {\n            int remaining = n - i;\n            int run_length = rnd.next(1, remaining);\n            char c = \"ATGC\"[rnd.next(0,3)];\n            for(int j = 0; j < run_length; ++j) {\n                s += c;\n            }\n            i += run_length;\n        }\n    } else if (type == \"worst_case\") {\n        // Generates runs of length 2\n        s = \"\";\n        if (n % 2 != 0) {\n            printf(\"Error: For worst_case type, n should be even.\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n / 2; ++i) {\n            char c = \"ATGC\"[rnd.next(0,3)];\n            s += c;\n            s += c;\n        }\n    } else {\n        printf(\"Error: Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n\n    if (type == \"random\") {\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += \"ATGC\"[rnd.next(0,3)];\n        }\n    } else if (type == \"same_char\") {\n        char c = \"ATGC\"[rnd.next(0,3)];\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        char c1 = \"ATGC\"[rnd.next(0,3)];\n        char c2;\n        do {\n            c2 = \"ATGC\"[rnd.next(0,3)];\n        } while (c2 == c1);\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"all_even_runs\") {\n        s = \"\";\n        int i = 0;\n        while (i < n) {\n            int remaining = n - i;\n            int run_length = min(2, remaining);\n            char c = \"ATGC\"[rnd.next(0,3)];\n            for(int j = 0; j < run_length; ++j) {\n                s += c;\n            }\n            i += run_length;\n        }\n    } else if (type == \"all_odd_runs\") {\n        s = \"\";\n        int i = 0;\n        while (i < n) {\n            int remaining = n - i;\n            int max_run = remaining / 2 * 2 + 1; // Max odd number <= remaining\n            int run_length = min(max_run, 2 * rnd.next(0, (max_run - 1)/2) + 1);\n            char c = \"ATGC\"[rnd.next(0,3)];\n            for(int j = 0; j < run_length; ++j) {\n                s += c;\n            }\n            i += run_length;\n        }\n    } else if (type == \"mixture\") {\n        s = \"\";\n        int i = 0;\n        while (i < n) {\n            int remaining = n - i;\n            int run_length = rnd.next(1, remaining);\n            char c = \"ATGC\"[rnd.next(0,3)];\n            for(int j = 0; j < run_length; ++j) {\n                s += c;\n            }\n            i += run_length;\n        }\n    } else if (type == \"worst_case\") {\n        // Generates runs of length 2\n        s = \"\";\n        if (n % 2 != 0) {\n            printf(\"Error: For worst_case type, n should be even.\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n / 2; ++i) {\n            char c = \"ATGC\"[rnd.next(0,3)];\n            s += c;\n            s += c;\n        }\n    } else {\n        printf(\"Error: Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_char\n./gen -n 2 -type alternating\n./gen -n 3 -type mixture\n./gen -n 4 -type all_even_runs\n./gen -n 5 -type all_odd_runs\n./gen -n 10 -type random\n./gen -n 10 -type same_char\n./gen -n 10 -type alternating\n./gen -n 10 -type all_even_runs\n./gen -n 10 -type all_odd_runs\n./gen -n 10 -type mixture\n./gen -n 20 -type random\n./gen -n 20 -type same_char\n./gen -n 20 -type alternating\n./gen -n 20 -type all_even_runs\n./gen -n 20 -type all_odd_runs\n./gen -n 20 -type mixture\n./gen -n 50 -type random\n./gen -n 50 -type same_char\n./gen -n 50 -type alternating\n./gen -n 50 -type all_even_runs\n./gen -n 50 -type all_odd_runs\n./gen -n 50 -type mixture\n./gen -n 99 -type random\n./gen -n 100 -type random\n./gen -n 99 -type mixture\n./gen -n 100 -type mixture\n./gen -n 100 -type same_char\n./gen -n 100 -type alternating\n./gen -n 100 -type all_even_runs\n./gen -n 100 -type all_odd_runs\n./gen -n 100 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:38.544778",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "391/B",
      "title": "B. Word Folding",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input will consist of one line containing a single string of n characters with 1 ≤ n ≤ 1000 and no spaces. All characters of the string will be uppercase letters.This problem doesn't have subproblems. You will get 5 points for the correct submission.",
      "output_spec": "OutputPrint a single integer — the size of the largest pile composed of identical characters that can be seen in a valid result of folding operations on the given string.",
      "sample_tests": "ExamplesInputCopyABRACADABRAOutputCopy3InputCopyABBBCBDBOutputCopy3InputCopyABOutputCopy1",
      "description": "B. Word Folding\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input will consist of one line containing a single string of n characters with 1 ≤ n ≤ 1000 and no spaces. All characters of the string will be uppercase letters.This problem doesn't have subproblems. You will get 5 points for the correct submission.\n\nOutputPrint a single integer — the size of the largest pile composed of identical characters that can be seen in a valid result of folding operations on the given string.\n\nInputCopyABRACADABRAOutputCopy3InputCopyABBBCBDBOutputCopy3InputCopyABOutputCopy1\n\nInputCopyABRACADABRA\n\nOutputCopy3\n\nInputCopyABBBCBDB\n\nOutputCopy3\n\nInputCopyAB\n\nOutputCopy1\n\nNoteConsider the first example. Manao can create a pile of three 'A's using the folding \"AB|RACAD|ABRA\", which results in the following structure: ABRADACAR   ABIn the second example, Manao can create a pile of three 'B's using the following folding: \"AB|BB|CBDB\". CBDBBBABAnother way for Manao to create a pile of three 'B's with \"ABBBCBDB\" is the following folding: \"AB|B|BCBDB\".  BCBDB BABIn the third example, there are no folds performed and the string is just written in one line.",
      "solutions": [
        {
          "title": "Rockethon 2014 Overview - Codeforces",
          "content": "Hello Codeforces community,I am happy to announce that Rocket Fuel Inc. will soon be hosting a contest called Rockethon on Codeforces. The contest is prepared by Rocket Fuel employees Jon Derryberry, Alexander Ruff and me, Eldar Bogdanov. We hope you will have as much fun solving the problems as we had crafting them. The contest will feature prizes and T-shirts for top performers. Also, Rocket Fuel is interested in hiring the best of you after this event, so let me tell you about the company and why you would want to join us.About Rocket FuelRocket Fuel is building technology platform to do automatic targeting and optimization of ads across all channels — display, video, mobile and social. Our pitch to advertisers is very simple \"If you can measure metrics of success of your campaign, we can optimize\". We have run campaigns for many large advertisers. Examples include BMW, Pizza Hut, Brooks Running Shoes and many more!We buy all our inventory through real time bidding on ad exchanges like Google and Yahoo. Ad exchanges are similar to stock exchanges except the commodity being traded is ad slots on web pages. Our serving systems currently process 40B requests/ day (~6X Google search volume), 600K requests/ second at peak with response time requirement of 100ms. Our data platform has several PBs data that is used for analytics as well as modeling.Our engineering team is still small (~100) enough for any one person like yourself to make a huge impact. The team represents many top schools in US and outside — Stanford, CMU, MIT, Wisconsin-Madison, IIT (India), Tsinghua (China).Rocket Fuel has been named #4 on Forbes Most Promising Companies in America List in 2013 and #1 Fastest Growing Company in North America on Deloitte’s 2013 Tech Fast 500. -My Personal StoryI joined Rocket Fuel after competing in a previous Rocket Fuel programming contest that was similar to Rockethon. Since I joined, I’ve had the opportunity to learn a lot about the industry technologies we use, such as Hive, Hadoop, Hbase, Storm, and Redis, as well as work on production software that processes tens of billions of requests per day.Another thing I like about working here is the fast development cycle. We can see the immediate impact of our code by testing in production the same day the code is written. For example, I recently profiled our code, identified a suboptimal use of a trie data structure, tested improvements in production, and then was able to see the site-wide benefit of the optimizations within days, since we push new code to production daily.It has been a great opportunity to learn from experts across a variety of fields, such as distributed systems, software architecture, databases, machine learning, and optimization. The atmosphere within Engineering team is very friendly, and everyone is willing to answer your questions and discuss problems you may have or discuss their work with you. In addition, we take some time to unwind at work. There are always intellectually curious people around to chat about algorithmic puzzles. We play ping pong, soccer and cricket. Also, I think it’s cool that Rocket Fuel values the problem solving and coding skills of programming contest enthusiasts, and invite you to consider joining Rocket Fuel if the above sounds interesting.Contest OverviewThe contest will begin on February 16, 10AM PST.The contest length is 3 hours.The testing of each submission will be performed as soon as the submission is received and the verdict will be delivered to the submission author right away.The problemset will consist of 6 problems, each of them possibly featuring one or two subproblems. Each subproblem will be worth a fixed amount of points. The ties between contestants with the same score will be broken by penalty time which is computed similar to ACM scoring system.PrizesEach of top three contestants will be awarded an iPad Air 16GB.The top 150 performers will receive a Rockethon T-shirt designed specially for this contest.ResultsCongratulations to the top three contestants: tourist — Gennady Korotkevich, Belarus scott_wu — Scott Wu, USA uwi — Uwi Tenpen, Japan You can find the list of the top-150 here.Note. This is a combined reconstruction of Rockethon 2014 announcement and result posts which were lost due to March 2 technical failure.",
          "author": "gojira",
          "url": "https://codeforces.com/blog/entry/10731",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4313
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces",
          "content": "In this post you will find the authors' solutions for the problems and subproblems featured in the competition, as well as some bonus questions related to these tasks.391A - Genetic EngineeringNote that we can consider each maximal sequence of identical characters independently, since there is no way to insert a character and affect more than one such sequence. Also, note that there are multiple ways to correct a single maximal sequence by inserting one character into it: we can either insert a different character somewhere in this sequence and divide it into two sequences of odd length (this is always possible for a sequence of even length), or even just add the same character in any point of this sequence, thus increasing its length by 1 and changing its parity.Therefore, the answer to the problem is the number of maximal sequences of even length. One can find all such sequences in linear time. A pseudocode of the solution follows: i = 1\nans = 0\nwhile i <= length(s) do\n end = length(s) + 1 // we will use this value if current sequence is the last in this string\n for j = i + 1 .. length(s)\n if s[j] <> s[i] then\n end = j\n break\n // at this point, we have the next maximal sequence of identical characters between i and j-1, inclusive\n if (j - i) mod 2 = 0 then\n ans = ans + 1\n i = jBonus: Alex decided to submit an almost one-line solution for this problem, which reminded me of shortest code competitions. I thought you might be interested in something similar, so here is Alex's solution to kick off (111 non-space chars): #include<stdio.h>\nmain(){int x=-1,y=1,c,d=0;for(;10!=(c=getchar());d=c,y^=1)if(c-d)x+=y,y=1;printf(\"%d\\n\",x+y);}391B - Word FoldingLet us describe the crucial observation necessary to solve this problem. Suppose that you have a character at some position i in the string and you want to fold the string in such a way that another character at position j > i is placed directly above the i-th character in the resulting structure. This is only possible if there is an even number of characters between i and j, and this is always possible in such case. In order to put the j-th character upon the i-th character, you would need to perform the fold exactly after position (i + j + 1) / 2. Thus, what the problem really asks for is \"What is the longest sequence of indices you can choose such that they all contain the same letter and there is an even number of characters between each pair of consecutive indices in the sequence?\". Note that \"even number of characters between each consecutive pair\" means that each index has different parity from the one before it.Armed with the observation above, we can devise a simple greedy algorithm. First, let us choose the letter which the highest pile will consist of. That is, let's iterate from 'A' to 'Z'. For a fixed letter, there are two possibly optimal choices: either we begin with the leftmost even index which contains the corresponding letter, or we begin with the leftmost odd such index. Once we make this choice, the maximum sequence of indices becomes fixed; the next index in the optimal sequence is always the leftmost index to the right of the current one that contains the same letter and has different parity. Thus, there are at most 26 * 2 cases to consider and the answer for each case can be found in O(n) time. If the alphabet size A was an input parameter, the total algorithm complexity would be O(A * n).Bonus: The initial version of the problem was slightly different, though we have abandoned it due to complicated problem statement. In that version, a pile could contain gaps or begin above the first level. Can you see why the solution to this problem is exactly the same?391C3 - The TournamentSince it was a question of multiple clarification requests, I will explain the third example here. The input is as follows: 5 2\n2 10\n2 10\n1 1\n3 1\n3 1The common misconception was that winning against three last opponents is sufficient to get in top 2. Note that winning only against the last three implies that Manao lost against the first two, so they'll have as many points as Manao and rank better than him. The optimal strategy is to win against one of the first two fighters, and win another two matches against fighters costing 1 unit of effort.Subproblem C1.As the constraints suggest, the intended solution here is brute force. Note that there are only 2n different possible scenarios, depending on which fight Manao wins and which he loses. Thus, we can generate all of these scenarios, compute the score that Manao will obtain as a result of it and what will the other contestants' new scores be, and determine what is the minimum total effort Manao needs for a scenario which gets him in top k.How can we generate all scenarios? A natural way to do this is recursion: for each fight, we choose the outcome (win or loss) and recurse one level deeper, stopping when all match outcomes have been chosen and performing the evaluation. However, there is another way which is usually less time-consuming: bitmasks. If you are not familiar with using bitmasks, I recommend reading the old-but-never-outdated tutorial by bmerry and dimkadimon's Topcoder Cookbook recipe on iterating over subsets. This is a pseudocode showing how short a bitmask solution for this problem is: ans = INFINITY\n for(bitmask = 0; bitmask < 2**n; bitmask++)\n int score = 0;\n int effort = 0;\n for(i = 0; i < n; i++)\n if (bitTurnedOnIn(mask, i))\n score = score + 1;\n effort = effort + fighter[i].effort;\n rank = n + 1;\n for(int i = 0; i < n; i++)\n if (fighter[i].score < score - 1 || fighter[i].score <= score && (bitTurnedOnIn(mask, i))\n rank = rank - 1\n if (rank <= k)\n ans = min(ans, effort);Subproblem C2.This subtask could be solved with any reasonable polynomial algorithm. My solution was the following: iterate over the number of points P that Manao will have in the end. For each P, let us check whether it is possible to finish in top k having P points and what is the minimum effort required. This can be computed using dynamic programming: let F(i, j, k) be the minimum effort required to win k of the fights against the first i fighters and be ranked worse than j of them. I will not go into details of this solution, since there are many alternatives, and it is suboptimal anyway.Subproblem C3.Let us look deeper into what amount of points Manao might have if he finishes in top k. Since finishing in top k is the same as ranking better than at least n - k + 1 opponent, I will just assume from now on that he has to beat Q = n - k + 1 opponents. Let S(i) be the number of fighters that have i points before Manao joins the tournament. Then, if S(0) + S(1) + … + S(P) is less than Q, there is no way Manao can possibly rank better than Q opponents if he has score P in the end. So we have a lower bound on the score Manao will have in the end. On the other hand, note that if S(0) + S(1) + … + S(P - 2) is more than or equal to Q, then after scoring P points Manao will surely rank better than at least Q rivals. Thus, if P' is the minimum amount of points such that S(0) + S(1) + … + S(P' - 2) >  = Q, there is no need to go for more points. Manao can just win the P' matches which require the least amount of effort from him. These observations leave us with only two interesting values of P — the first value when S(0) + S(1) + … + S(P) >  = Q and that value plus 1.What makes these cases more complicated is the fact that now it matters which matches does Manao win or lose. Suppose Manao wants to score P points. Let S' = S(0) + S(1) + … + S(P - 2). This is the count of opponents that are definitely ranked lower than Manao if he gets P points. Each of the fighters that has P - 1 or P points will rank better than Manao if Manao loses the corresponding fight and worse otherwise. Thus, Manao needs to win at least Q - S' of the fights against those opponents. Let's collect the efforts required to beat each of the opponents with score P - 1 or P into a list and collect the efforts required to beat each of the other opponents in another list. After we sort both lists, all we need to do is find the minimum sum of Q numbers such that at least Q - S' of them are from the first list and the rest are from the second.The complexity of this algorithm is O(NlogN).Bonus: Can you solve the problem in linear time?391D2 - SupercolliderThe goal in this problem was to find a pair of horizontal and vertical segments that forms the largest plus shape, truncating the ends of the segments so the plus is completely symmetric. A naive brute force O(n2) algorithm that simply tries all such pairs, computes the size of the plus for that pair, and prints the maximum is sufficient to solve the first subtask. For the second subtask, a faster algorithm is required. As with many problems related to computational geometry it is usually easiest to think of a sweepline algorithm to process a linear number of events, with each event requiring at most logarithmic time to process.It turns out that one key insight suffices to pave the way for a relatively simple approach. If you transform the problem from a maximization problem “what is the largest plus?” into the decision problem “does there exist a plus of size k?” then your task is somewhat simplified at the cost of a O(lgW) factor to perform binary search to find the maximum valid k, where W is the bound on the coordinate values.To answer the decision problem there is another trick that helps simplify your task. If you are interested in determining whether there exists a plus of size k, it suffices to simply truncate each segment by k on each end point and check whether any pair of segments intersects -- there is no need to check how long the arms of the plus are. For example, for each horizontal segment from (x, y) to (x + l, y), then you create a new segment from (x + k, y) to (x + l - k, y) if the segment still has non-negative length, and make a similar transformation for vertical segments. After transforming the segments, you can use a sweepline algorithm that keeps track of all vertical segments that intersect with a horizontal sweepline and use a binary indexed tree or binary search tree to determine whether the end points of each horizontal line the sweepline encounters straddles an active vertical line. Either of these data structures will suffice to clear the test cases for the second subproblem. Note that the full running time for this algorithm is where n is the number of segments and W is the size of the largest segment.For the interested algorithms enthusiast, there exists a trickier algorithm that runs in time and does not require binary searching for the largest plus size, though unfortunately it is difficult to distinguish this algorithm from the above one with the input constraints of a contest due to a higher constant factor overhead for this approach. The idea may be difficult to understand if you are not familiar with sweepline algorithms and augmented binary search trees, but I will sketch it here.The idea is to make four separate sweepline passes over the input, with each pass looking for plusses in which the shortest arm of the plus is in a different direction, north, south, east, or west. For example, if we assume that the shortest arm of the plus is pointing north, we can use a diagonal sweepline that starts in the northwest corner and sweeps in the southeast direction (note that the line itself is drawn from the southwest to the northeast, but moves from the northwest to the southeast).Each time this sweepline encounters the westmost endpoint of a horizontal line, it adds the segment into a binary search tree that is ordered from north to south. Each node in the search tree is further annotated with the sum of the x and y coordinates of the eastmost end point of the horizontal segment (i.e., if the eastmost point has coordinates (x, y), we store x + y) and stores the minimum such value in the subtree rooted at that node.Now, when the northmost endpoint of a vertical segment is encountered by the sweepline, we search for the southmost horizontal segment whose y value is north of the midpoint of the vertical segment and whose (x + y)-coordinate sum is greater than the (x + y)-coordinate sum of the northmost point of the vertical segment.Note that when the sweepline hits the northmost point of a vertical segment, it will only have added horizontal segments whose “west arm” is longer than the “north arm” and the condition on the (x + y)-coordinate of the eastmost endpoint of the horizontal line ensures that the “east arm” is longer than the north arm. The additional constraint that the searched y value in the tree is north of the midpoint adds the final constraint that the north arm is shorter than the south arm. Finding the southmost horizontal segment that satisfies these constraints is equivalent to finding the largest plus that uses this vertical segment and has the north arm as the shortest of the four arms. There are still some details to work out to get the binary search to operate correctly in O(lgn) time, but we leave these as an exercise.391E2 - Three TreesSubproblem 1.Let us start with choosing a tree that will be the \"middle tree\", i.e., have connections to two other trees. Let n2 be the number of vertices in this tree and yi be its i-th vertex. Let n1 be the number of vertices and xi be the vertices of one of the other trees, and n2 be the number of vertices and zi be the vertices of another tree. Let d(i, j) be the distance between nodes i and j of the same some tree. Suppose we insert the edges (X, Y1) and (Z, Y2), where , , . The sum of distances between all pairs of points in the united tree can be divided into four components: Distances between {xi} and {yi} Distances between {yi} and {zi} Distances between pairs of vertices that were connected before we inserted the additional edges Distances between {xi} and {zi} The first component is equal to sum(d(X, xi) + d(Y1, yi) + 1, xi = 1..n1, yi = 1..n2). Note that the summands are independent, so it can be broken into sum(d(X, xi), xi = 1..n1) * n2 + sum(d(Y1, yi), yi = 1..n2) * n1 + n1 * n2.Similarly, the second component is equal to sum(d(Z, zi), zi = 1..n3) * n2 + sum(d(Y2, yi), yi = 1..n2) * n3 + n2 * n2.The third component is simply a sum of pairwise distances in each of the trees and is a constant.The fourth component is equal to sum(d(X, xi) + d(Y1, Y2) + d(Z, zi) + 2, xi = 1..n1, zi = 1..n3) = sum(d(X, xi), xi = 1..n1) * n3  + sum(d(Z, zi), zi = 1..n3) + d(Y1, Y2) * n1 * n3 + 2 * n1 * n3.Let us compute the pairwise distances within each tree. This can be done with straightforward DFS/BFS and thus takes O(n12 + n22 + n32) time. Also, let's put D(v) = sum(d(v, i)) over all i from v's tree.If we write together all the sums mentioned above, we will see that is always optimal to choose X such that it has the maximum D(X) over all vertices in its tree. The same argument holds for Z. Y1 and Y2 are both a part of two sums, so they cannot be chosen independently. Thus, let's iterate over all possible values of Y1 and Y2 and choose the pair that maximizes sum(d(Y2, yi), yi = 1..n2) * n3 + sum(d(Y1, yi), yi = 1..n2) * n1  + d(Y1, Y2) * n1 * n3 = D(Y2) * n3 + D(Y1) * n1 + d(Y1, Y2) * n1 * n3.Since precalculation of distances takes square time, and choosing the optimal pair of (Y1, Y2) also takes square time, the resulting algorithm complexity is square.Subproblem 2.Please read the explanation for the previous problem if you have not done so yet.I will assume that the reader is familiar with some tricks on trees, because it does not seem plausible to explain every step of the algorithm.The core idea of the problem is the same as for the previous subproblem: we are maximizing a sum composed of several components, the only \"hard\" part of which is D(Y2) * n3 + D(Y1) * n1 + d(Y1, Y2) * n1 * n3. As we already know, the rest can be computed independently, which involves finding the sum of distances over all nodes in a tree and finding a node with maximum possible sum of distances to all other nodes, all in linear time.To maximize D(Y2) * n3 + D(Y1) * n1 + d(Y1, Y2) * n1 * n3, let's perform some additional precalculation first. Let us root the middle tree (doesn't matter at which node). For each of the vertices, we need to assume that it is Y1 and find the two best candidates of being a Y2 from its subtree. This is easy if we know the Y2-candidates for each of the current vertex's children.Having precalculated the Y2-candidates for each subtree, let us perform another traversal of the tree. This time, we will assume for each vertex that it is Y1, but will compute the optimal Y2 along the whole tree, not just current vertex's subtree. Obviously, for the root of the tree the optimal Y2 is the best Y2-candidate in the subtree of the root. When we start moving into the depth of the tree, we need to remember the current best Y2-candidate which is \"left behind\", i.e., is not within the subtree we just entered. This way, we will choose between the Y2-candidate left behind and the Y2-candidate within the current subtree and pick the best. Note that when we pass from a vertex P to a vertex V, the Y2-candidate left behind can only change to some vertex which is within P's subtree. We need to be careful and check that the Y2-candidate within P's subtree was not actually in V's subtree also, in which case the second-best Y2-candidate of P's subtree should be used for comparison against the one left behind.391F3 - Stock TradingThis problem is a generalization of a common interview problem: given a time series of prices, find the single trade that results in the maximum gain. The best solution, in O(n) time, is an example of a very simple DP that simply scans the prices, keeps track of both the minimum price seen so far and the best gain so far, and computes the best gain achievable by selling on the current day by subtracting the running minimum from the current price. In this contest’s problem, the task is generalized to handling the case of k trades. Perhaps surprisingly, the optimal running time is still O(n) even when k is allowed to be chosen arbitrarily. To get to this optimal solution, let’s consider a series of increasingly fast algorithms for solving the problem.Subproblem 1.First, there is a very straightforward O(n2k) time DP solution in which, for each i and j we compute OPT(i, j), the optimal gain achievable by making j trades, with the sell order of the j-th trade occurring on day i or earlier. A natural recurrence relation is OPT(i, j) = max(OPT(i - 1, j), OPT(i’, j - 1) + p[i] - p[i’]foralli’ < i). Here, we are computing O(nk) optimal values, and each requires O(n) work to scan over all previous days to find the best solution for which the j-th trade ends exactly on day i. This solution is not fast enough to clear any of the three subproblems for this contest.With a bit more work, we can speed up the O(n2k) DP to run in O(nk) time, which suffices to clear the first subproblem. It is important to realize that we do not need to consider all previous days when computing OPT(i, j) so that we can compute each such value in constant time. One way to achieve this is to create a slightly different optimization problem OPT2(i, j) that represents the maximum gain achievable with j trades during the first i - 1 days, minus the minimum price seen since the sell order for the j-th trade in OPT2(i, j). We also define MIN(i, j) to be the minimum price seen after the date of the last trade made in the solution for OPT2(i, j). With these definitions, we have the following recurrence: OPT2(i, j) = max(OPT2(i - 1, j), OPT2(i - 1, j) - p[i] + MIN(i - 1, j),  OPT2(i - 1, j - 1) + p[i - 1] - p[i]). Case 1 represents using the same trades and minimum as OPT2(i - 1, j); case 2 represents using the same trades as OPT2(i - 1, j) but using p[i] as the new minimum; and case 3 represents using the optimal solution from OPT2(i - 1, j - 1) and selling for the j-th trade on day i - 1 for a gain of p[i - 1] with the new min of p[i] subtracted from the objective value. To compute MIN(i, j), we simply consider which case we fell into and set MIN(i, j) accordingly. In case 1, we set MIN(i, j) to MIN(i - 1, j); in case 2 we set MIN(i, j) = p[i]; and in case 3, we set MIN(i, j) = p[i]. The final solution, ignoring boundary cases, for OPT(n, k) is the max over all i of OPT2(i, k) + MIN(i, k).Subproblem 2.To clear the second subtask, we need additional insight about the problem so that we can achieve a sub-quadratic solution. The most important insight is that there is a way of solving this problem using a greedy algorithm if we make a transformation to the original problem. We begin by identifying the optimal solution that uses an unlimited number of trades. This produces a series of gains g1, …, gt where t is the number of trades in the optimal solution with an unbounded number of trades (this solution is easily found by identifying all possible shortest trades that produce a gain in linear time).We interleave with these gains a series of “phantom-losses” l1, ..., lt - 1. The loss li represents the absolute value of the price difference between the price on the “sell day” for gi and the “buy day” for gi + 1. We let zt represent the value of the optimal solution for t trades (i.e., sum(gi) initially). Now, we look at the sequence St = s1, ..., s2t - 1 = g1, l1, g2, l2, ..., lt - 1, gt. We can compute zt - 1 from zt by finding the lowest value in St and eliminating this gain or loss by merging it with its neighbors (to handle s1 and s2t - 1, we can pad the ends with large values s0 and s2t so we can merge all candidates with two neighbors). This leads naturally to a greedy algorithm in which we continually merge the lowest si (found using either a heap or a BST in time for each iteration) with its neighbors until t = k. This merge consists of combining si - 1, si, andsi + 1 into one new value in the sequence that has value si - 1 - si + s{i + 1}, and zt - 1 = zt - si. Eliminating an si corresponding to a gain means skipping the trade and merging the neighboring losses into a new “phantom loss”. Eliminating an si corresponding to a loss means skipping a loss to merge two gains together into one trade of longer duration.For example, if the sequence of stock prices is 4, 2, 3, 5, 4, 3, 7, 2, 6, 5, the optimal strategy with unlimited trades the following gains: 2 -  > 5, 3 -  > 7, 2 -  > 6, so that g1 = 3, g2 = 4, and g3 = 4. We also have phantom losses of l1 = 2, l2 = 5. Thus, S3 = 3, 2, 4, 5, 4 and z3 = 11 is the profit from the optimal unlimited strategy. If k = 2, we need to execute one step in the greedy algorithm, and this corresponds to removing l1, which has value 2. This removal corresponds to lengthening the duration of the first trade to include the entire time interval from when the price first reaches 2 to when the price reaches 7. The resulting sequence S2 has the intervals 5, 5, 4, representing a gain, a phantom loss, and another gain. Thus, z2 = 9 is the optimal profit achievable with two trades. If we were to greedily iterate once more to find the optimal solution with k = 1, we would delete the last gain of 4, merging it with the preceding phantom loss of 5 and the following dummy phantom loss at the end of S_2 (i.e., S2t as described above). Merging such a gain with two phantom loss neighbors represents simply skipping a trade of low profit. From this, we see that that optimum profit from one trade is 5.In the heat of a competition with open testing such as this one, one might simply guess that this works and hope that the tests pass, risking penalty time if the submission fails, but it turns out that this solution is indeed correct (proof TBD).Subproblem 3.An algorithm suffices to clear the second subproblem, and an extremely fast implementation may pass the tests for the third subproblem (for example, tourist had the only successful submission during the contest for F3 and used an algorithm that squeaked by the tests for F3, avoiding a timeout by 52 milliseconds -- many others timed out with solutions). However, to pass the tests by a more comfortable margin, one can implement an O(n) time algorithm.The idea is as follows. Rather than greedily performing one merge in each iteration, we can perform many merges during each iteration. Note that whenever we perform a merge of 3 intervals into one, the resulting interval has a larger value than the central si interval that was targeted for removal if we take care only to merge local minima. Thus, suppose we need to perform m merges. We can find the m-th smallest value si *  among the segments using linear time select, and then eliminate all segments whose value is less than si * . This can be accomplished by a linear scan across the segments, though we must be careful only to merge local minima so as to guarantee the same final result as using the greedy algorithm. This constraint of only removing local minima still allows us to remove all segments less than si *  if we are careful with how we perform our scan. The result of such a scan is that the number of merges we need to perform falls by at least one third, from m to 2m / 3 (note that after m / 3 merges have been performed, it is possible that no segments remain whose value is less than si * ). Because the number of remaining merges falls by a constant factor in each iteration, we have only iterations to reach our target value. Unfortunately, each pass requires O(n) time so this is still an algorithm. However, we can remedy this by deleting some trades that have large gains (or deleting some large phantom losses). Note that if there are two consecutive segments that have very large values, we will never perform a merge with one of the two of them as a central segment, so we can eliminate any streak of consecutive large segments and replace them with a single segment. How large is large enough that we can forget about the segments? We know that if we have m merges left to perform, we will never perform a merge on a segment whose value is greater than the 3m-th smallest segment. Further, when m is small relative to the remaining number of segments, we know that a constant fraction of segments will be involved in a streak of large values, so we can remove a constant fraction of the total number of segments from consideration. Thus, the total work required for each scan is geometrically decreasing so the total running time is O(n)!After the contest, it has been brought to our attention that this problem has been studied academically. Here is the paper describing a linear-time algorithm.",
          "author": "gojira",
          "url": "https://codeforces.com/blog/entry/10727",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 391\\s*B"
          },
          "content_length": 26632
        }
      ],
      "code_examples": [
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 1",
          "code": "i = 1\nans = 0\nwhile i <= length(s) do\n  end = length(s) + 1  // we will use this value if current sequence is the last in this string\n  for j = i + 1 .. length(s)\n    if s[j] <> s[i] then\n      end = j\n      break\n  // at this point, we have the next maximal sequence of identical characters between i and j-1, inclusive\n  if (j - i) mod 2 = 0 then\n    ans = ans + 1\n  i = j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 2",
          "code": "i = 1\nans = 0\nwhile i <= length(s) do\n  end = length(s) + 1  // we will use this value if current sequence is the last in this string\n  for j = i + 1 .. length(s)\n    if s[j] <> s[i] then\n      end = j\n      break\n  // at this point, we have the next maximal sequence of identical characters between i and j-1, inclusive\n  if (j - i) mod 2 = 0 then\n    ans = ans + 1\n  i = j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 3",
          "code": "#include<stdio.h>\nmain(){int x=-1,y=1,c,d=0;for(;10!=(c=getchar());d=c,y^=1)if(c-d)x+=y,y=1;printf(\"%d\\n\",x+y);}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 4",
          "code": "#include<stdio.h>\nmain(){int x=-1,y=1,c,d=0;for(;10!=(c=getchar());d=c,y^=1)if(c-d)x+=y,y=1;printf(\"%d\\n\",x+y);}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 5",
          "code": "5 2\n2 10\n2 10\n1 1\n3 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 6",
          "code": "5 2\n2 10\n2 10\n1 1\n3 1\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 7",
          "code": "ans = INFINITY\n    for(bitmask = 0; bitmask < 2**n; bitmask++)\n        int score = 0;\n        int effort = 0;\n        for(i = 0; i < n; i++)\n            if (bitTurnedOnIn(mask, i))\n                score = score + 1;\n                effort = effort + fighter[i].effort;\n        rank = n + 1;\n        for(int i = 0; i < n; i++)\n            if (fighter[i].score < score - 1 || fighter[i].score <= score && (bitTurnedOnIn(mask, i))\n                rank = rank - 1\n        if (rank <= k)\n            ans = min(ans, effort);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        },
        {
          "title": "Rockethon 2014 Editorial - Codeforces - Code 8",
          "code": "ans = INFINITY\n    for(bitmask = 0; bitmask < 2**n; bitmask++)\n        int score = 0;\n        int effort = 0;\n        for(i = 0; i < n; i++)\n            if (bitTurnedOnIn(mask, i))\n                score = score + 1;\n                effort = effort + fighter[i].effort;\n        rank = n + 1;\n        for(int i = 0; i < n; i++)\n            if (fighter[i].score < score - 1 || fighter[i].score <= score && (bitTurnedOnIn(mask, i))\n                rank = rank - 1\n        if (rank <= k)\n            ans = min(ans, effort);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10727",
          "author": "gojira"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,1000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,1000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,1000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"identical\") {\n        // All letters are the same\n        char c = 'A' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        // Alternate between two letters\n        char c1 = 'A' + rnd.next(26);\n        char c2 = 'A' + rnd.next(26);\n        while (c2 == c1)\n            c2 = 'A' + rnd.next(26);\n        for (int i = 0; i < n; ++i)\n            s.push_back(i % 2 == 0 ? c1 : c2);\n    } else if (type == \"random\") {\n        // Random letters\n        for (int i = 0; i < n; ++i)\n            s.push_back('A' + rnd.next(26));\n    } else if (type == \"palindrome\") {\n        // Palindromic string\n        string half;\n        for (int i = 0; i < (n + 1) / 2; ++i)\n            half.push_back('A' + rnd.next(26));\n        s = half;\n        for (int i = n / 2 - 1; i >= 0; --i)\n            s.push_back(half[i]);\n    } else if (type == \"max_pile\") {\n        // Create a string to maximize pile height\n        char c = 'A' + rnd.next(26);\n        int k = n / 2;\n        if (k == 0) k = 1;\n        string half(k, c);\n        s = half;\n        if (n % 2 == 1)\n            s.push_back(c);\n        for (int i = k - 1; i >= 0; --i)\n            s.push_back(half[i]);\n    } else if (type == \"minimal_pile\") {\n        // Max pile height 1, no two identical letters can be aligned\n        vector<char> letters;\n        for (char c = 'A'; c <= 'Z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        for (int i = 0; i < n; ++i)\n            s.push_back(letters[i % 26]);\n    } else {\n        // Default: random letters\n        for (int i = 0; i < n; ++i)\n            s.push_back('A' + rnd.next(26));\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"identical\") {\n        // All letters are the same\n        char c = 'A' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        // Alternate between two letters\n        char c1 = 'A' + rnd.next(26);\n        char c2 = 'A' + rnd.next(26);\n        while (c2 == c1)\n            c2 = 'A' + rnd.next(26);\n        for (int i = 0; i < n; ++i)\n            s.push_back(i % 2 == 0 ? c1 : c2);\n    } else if (type == \"random\") {\n        // Random letters\n        for (int i = 0; i < n; ++i)\n            s.push_back('A' + rnd.next(26));\n    } else if (type == \"palindrome\") {\n        // Palindromic string\n        string half;\n        for (int i = 0; i < (n + 1) / 2; ++i)\n            half.push_back('A' + rnd.next(26));\n        s = half;\n        for (int i = n / 2 - 1; i >= 0; --i)\n            s.push_back(half[i]);\n    } else if (type == \"max_pile\") {\n        // Create a string to maximize pile height\n        char c = 'A' + rnd.next(26);\n        int k = n / 2;\n        if (k == 0) k = 1;\n        string half(k, c);\n        s = half;\n        if (n % 2 == 1)\n            s.push_back(c);\n        for (int i = k - 1; i >= 0; --i)\n            s.push_back(half[i]);\n    } else if (type == \"minimal_pile\") {\n        // Max pile height 1, no two identical letters can be aligned\n        vector<char> letters;\n        for (char c = 'A'; c <= 'Z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        for (int i = 0; i < n; ++i)\n            s.push_back(letters[i % 26]);\n    } else {\n        // Default: random letters\n        for (int i = 0; i < n; ++i)\n            s.push_back('A' + rnd.next(26));\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identical\n./gen -n 1 -type random\n./gen -n 1 -type palindrome\n./gen -n 1 -type alternating\n./gen -n 1 -type max_pile\n./gen -n 1 -type minimal_pile\n\n./gen -n 2 -type identical\n./gen -n 2 -type random\n./gen -n 2 -type palindrome\n./gen -n 2 -type alternating\n./gen -n 2 -type max_pile\n./gen -n 2 -type minimal_pile\n\n./gen -n 5 -type identical\n./gen -n 5 -type random\n./gen -n 5 -type palindrome\n./gen -n 5 -type alternating\n./gen -n 5 -type max_pile\n./gen -n 5 -type minimal_pile\n\n./gen -n 10 -type identical\n./gen -n 10 -type random\n./gen -n 10 -type palindrome\n./gen -n 10 -type alternating\n./gen -n 10 -type max_pile\n./gen -n 10 -type minimal_pile\n\n./gen -n 50 -type identical\n./gen -n 50 -type random\n./gen -n 50 -type palindrome\n./gen -n 50 -type alternating\n./gen -n 50 -type max_pile\n./gen -n 50 -type minimal_pile\n\n./gen -n 100 -type identical\n./gen -n 100 -type random\n./gen -n 100 -type palindrome\n./gen -n 100 -type alternating\n./gen -n 100 -type max_pile\n./gen -n 100 -type minimal_pile\n\n./gen -n 500 -type identical\n./gen -n 500 -type random\n./gen -n 500 -type palindrome\n./gen -n 500 -type alternating\n./gen -n 500 -type max_pile\n./gen -n 500 -type minimal_pile\n\n./gen -n 1000 -type identical\n./gen -n 1000 -type random\n./gen -n 1000 -type palindrome\n./gen -n 1000 -type alternating\n./gen -n 1000 -type max_pile\n./gen -n 1000 -type minimal_pile\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:41.018979",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "392/A",
      "title": "A. Blocked Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (0 ≤ n ≤ 4·107).",
      "output_spec": "OutputPrint a single integer — the minimum number of points that should be blocked.",
      "sample_tests": "ExamplesInputCopy1OutputCopy4InputCopy2OutputCopy8InputCopy3OutputCopy16",
      "description": "A. Blocked Points\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (0 ≤ n ≤ 4·107).\n\nOutputPrint a single integer — the minimum number of points that should be blocked.\n\nInputCopy1OutputCopy4InputCopy2OutputCopy8InputCopy3OutputCopy16\n\nOutputCopy4\n\nOutputCopy8\n\nOutputCopy16",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 392\\s*A"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 40000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 40000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 40000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n%2 == 0 || n%3 == 0) return false;\n    for (int i=5; i*i <= n; i +=6) {\n        if (n%i ==0 || n%(i+2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int max_n = opt<int>(\"max_n\", 40000000);\n    string type = opt<string>(\"type\", \"random\");\n    int n_opt = opt<int>(\"n\", -1);  // default -1 means not provided\n\n    int n;\n\n    if (n_opt != -1) {\n        n = n_opt;\n        n = max(0, min(n, max_n));\n    } else if (type == \"min\") {\n        n = 0;\n    } else if (type == \"max\") {\n        n = max_n;\n    } else if (type == \"small\") {\n        n = rnd.next(0, 10);\n    } else if (type == \"edge\") {\n        int edges[] = {0, 1, 2, max_n-1, max_n, max_n + rnd.next(1,5)};\n        n = edges[rnd.next(0, 5)];\n        if (n > max_n) n = max_n;\n        if (n < 0) n = 0;\n    } else if (type == \"even\") {\n        n = rnd.next(0, max_n / 2) *2;\n        if (n > max_n) n = max_n;\n    } else if (type == \"odd\") {\n        n = rnd.next(0, (max_n -1)/2) *2 +1;\n        if (n > max_n) n = max_n;\n    } else if (type == \"power2\") {\n        int max_pow = (int) (log2(max_n));\n        int p = rnd.next(0, max_pow);\n        n = 1 << p;\n    } else if (type == \"prime\") {\n        int candidate = max_n;\n        // Try to find a prime less than or equal to max_n\n        for (int attempts = 0; attempts < 1000; ++attempts) {\n            candidate = rnd.next(2, max_n);\n            if (is_prime(candidate)) {\n                n = candidate;\n                break;\n            }\n        }\n        n = candidate; // may not be prime if we didn't find any\n    } else if (type == \"random\") {\n        n = rnd.next(0, max_n);\n    } else {\n        n = rnd.next(0, max_n);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n%2 == 0 || n%3 == 0) return false;\n    for (int i=5; i*i <= n; i +=6) {\n        if (n%i ==0 || n%(i+2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int max_n = opt<int>(\"max_n\", 40000000);\n    string type = opt<string>(\"type\", \"random\");\n    int n_opt = opt<int>(\"n\", -1);  // default -1 means not provided\n\n    int n;\n\n    if (n_opt != -1) {\n        n = n_opt;\n        n = max(0, min(n, max_n));\n    } else if (type == \"min\") {\n        n = 0;\n    } else if (type == \"max\") {\n        n = max_n;\n    } else if (type == \"small\") {\n        n = rnd.next(0, 10);\n    } else if (type == \"edge\") {\n        int edges[] = {0, 1, 2, max_n-1, max_n, max_n + rnd.next(1,5)};\n        n = edges[rnd.next(0, 5)];\n        if (n > max_n) n = max_n;\n        if (n < 0) n = 0;\n    } else if (type == \"even\") {\n        n = rnd.next(0, max_n / 2) *2;\n        if (n > max_n) n = max_n;\n    } else if (type == \"odd\") {\n        n = rnd.next(0, (max_n -1)/2) *2 +1;\n        if (n > max_n) n = max_n;\n    } else if (type == \"power2\") {\n        int max_pow = (int) (log2(max_n));\n        int p = rnd.next(0, max_pow);\n        n = 1 << p;\n    } else if (type == \"prime\") {\n        int candidate = max_n;\n        // Try to find a prime less than or equal to max_n\n        for (int attempts = 0; attempts < 1000; ++attempts) {\n            candidate = rnd.next(2, max_n);\n            if (is_prime(candidate)) {\n                n = candidate;\n                break;\n            }\n        }\n        n = candidate; // may not be prime if we didn't find any\n    } else if (type == \"random\") {\n        n = rnd.next(0, max_n);\n    } else {\n        n = rnd.next(0, max_n);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Fixed values of n\n./gen -n=0\n./gen -n=1\n./gen -n=2\n./gen -n=3\n./gen -n=4\n./gen -n=5\n./gen -n=6\n./gen -n=7\n./gen -n=8\n./gen -n=9\n./gen -n=10\n./gen -n=100\n./gen -n=1000\n./gen -n=9999999\n./gen -n=39999999\n./gen -n=40000000\n\n# Min and Max values of n\n./gen -max_n=40000000 -type=min         # n=0\n./gen -max_n=40000000 -type=max         # n=40000000\n\n# Small values of n\n./gen -max_n=40000000 -type=small       # n between 0 and 10\n\n# Edge values of n\n./gen -max_n=40000000 -type=edge        # n=0,1,2,39999999,40000000\n\n# Random values of n\n./gen -max_n=10 -type=random            # n between 0 and 10\n./gen -max_n=100 -type=random           # n between 0 and 100\n./gen -max_n=1000 -type=random          # n between 0 and 1000\n./gen -max_n=1000000 -type=random       # n between 0 and 1,000,000\n./gen -max_n=10000000 -type=random      # n between 0 and 10,000,000\n./gen -max_n=40000000 -type=random      # n between 0 and 40,000,000\n\n# Even values of n\n./gen -max_n=40000000 -type=even        # n is even between 0 and 40,000,000\n\n# Odd values of n\n./gen -max_n=40000000 -type=odd         # n is odd between 0 and 40,000,000\n\n# Power of two values of n\n./gen -max_n=40000000 -type=power2      # n is a power of two up to 40,000,000\n\n# Prime values of n\n./gen -max_n=5000 -type=prime           # n is a prime number ≤ 5,000\n./gen -max_n=1000000 -type=prime        # n is a prime number ≤ 1,000,000\n./gen -max_n=40000000 -type=prime       # n is a prime number ≤ 40,000,000\n\n# Additional test cases\n./gen -n=40000000 -type=even\n./gen -n=0 -type=random\n./gen -n=999999 -type=odd\n./gen -n=10000000 -type=random\n./gen -max_n=5000 -type=power2\n./gen -max_n=1000000 -type=even\n./gen -max_n=1000000 -type=odd\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:43.106800",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "392/B",
      "title": "B. Ханойская башня",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеКаждая из первых трех строк содержит три целых числа — матрицу t: j-ое число в i-ой строке tij (1 ≤ tij ≤ 10000; i ≠ j). В следующей строке записано единственное целое число n (1 ≤ n ≤ 40) — количество дисков.Гарантируется, что для всех i (1 ≤ i ≤ 3), tii = 0.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальную стоимость решения головоломки SmallR.",
      "sample_tests": "ПримерыВходные данныеСкопировать0 1 11 0 11 1 03Выходные данныеСкопировать7Входные данныеСкопировать0 2 21 0 1001 2 03Выходные данныеСкопировать19Входные данныеСкопировать0 2 11 0 1001 2 05Выходные данныеСкопировать87",
      "description": "B. Ханойская башня\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеКаждая из первых трех строк содержит три целых числа — матрицу t: j-ое число в i-ой строке tij (1 ≤ tij ≤ 10000; i ≠ j). В следующей строке записано единственное целое число n (1 ≤ n ≤ 40) — количество дисков.Гарантируется, что для всех i (1 ≤ i ≤ 3), tii = 0.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальную стоимость решения головоломки SmallR.\n\nВыходные данные\n\nВходные данныеСкопировать0 1 11 0 11 1 03Выходные данныеСкопировать7Входные данныеСкопировать0 2 21 0 1001 2 03Выходные данныеСкопировать19Входные данныеСкопировать0 2 11 0 1001 2 05Выходные данныеСкопировать87\n\nВходные данныеСкопировать0 1 11 0 11 1 03\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 2 21 0 1001 2 03\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать19\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 2 11 0 1001 2 05\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать87\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 392\\s*B"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t[3][3];\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            if (j > 0) inf.readSpace();\n            if (i == j) {\n                t[i][j] = inf.readInt(0, 0, \"t_\" + to_string(i+1) + to_string(j+1));\n            } else {\n                t[i][j] = inf.readInt(1, 10000, \"t_\" + to_string(i+1) + to_string(j+1));\n            }\n        }\n        inf.readEoln();\n    }\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t[3][3];\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            if (j > 0) inf.readSpace();\n            if (i == j) {\n                t[i][j] = inf.readInt(0, 0, \"t_\" + to_string(i+1) + to_string(j+1));\n            } else {\n                t[i][j] = inf.readInt(1, 10000, \"t_\" + to_string(i+1) + to_string(j+1));\n            }\n        }\n        inf.readEoln();\n    }\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t[3][3];\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            if (j > 0) inf.readSpace();\n            if (i == j) {\n                t[i][j] = inf.readInt(0, 0, \"t_\" + to_string(i+1) + to_string(j+1));\n            } else {\n                t[i][j] = inf.readInt(1, 10000, \"t_\" + to_string(i+1) + to_string(j+1));\n            }\n        }\n        inf.readEoln();\n    }\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int t[3][3];\n\n    if (type == \"min_t\") {\n        // t_{ij} = 1 for all i != j\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 1;\n    } else if (type == \"max_t\") {\n        // t_{ij} = 10000 for all i != j\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 10000;\n    } else if (type == \"random\") {\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : rnd.next(1, 10000);\n    } else if (type == \"asymmetric\") {\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                if (i == j) t[i][j] = 0;\n                else t[i][j] = rnd.next(1, 10000);\n        // Ensure asymmetry\n        for (int i = 0; i<3; ++i)\n            for (int j = i+1; j<3; ++j)\n                if (t[i][j] == t[j][i]) {\n                    if (t[i][j] < 10000) t[j][i] = t[i][j] + 1;\n                    else t[j][i] = t[i][j] -1;\n                }\n    } else if (type == \"prefer_direct\") {\n        for (int i=0;i<3;++i)\n            for (int j=0;j<3;++j)\n                t[i][j]=(i==j)?0:10000;\n        t[0][2]=1; // t_{1,3}=1\n    } else if (type == \"prefer_indirect\") {\n        for (int i=0;i<3;++i)\n            for (int j=0;j<3;++j)\n                t[i][j]=(i==j)?0:10000;\n        t[0][1]=1; // t_{1,2}=1\n        t[1][2]=1; // t_{2,3}=1\n    } else if (type == \"random_big_n\") {\n        n = 40;\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : rnd.next(1, 10000);\n    } else if (type == \"max_n_min_t\") {\n        n = 40;\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 1;\n    } else if (type == \"max_n_max_t\") {\n        n = 40;\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 10000;\n    } else {\n        // Default to random\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : rnd.next(1, 10000);\n    }\n\n    // Output t_{ij}\n\n    for (int i=0;i<3;++i) {\n        printf(\"%d %d %d\\n\", t[i][0], t[i][1], t[i][2]);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int t[3][3];\n\n    if (type == \"min_t\") {\n        // t_{ij} = 1 for all i != j\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 1;\n    } else if (type == \"max_t\") {\n        // t_{ij} = 10000 for all i != j\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 10000;\n    } else if (type == \"random\") {\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : rnd.next(1, 10000);\n    } else if (type == \"asymmetric\") {\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                if (i == j) t[i][j] = 0;\n                else t[i][j] = rnd.next(1, 10000);\n        // Ensure asymmetry\n        for (int i = 0; i<3; ++i)\n            for (int j = i+1; j<3; ++j)\n                if (t[i][j] == t[j][i]) {\n                    if (t[i][j] < 10000) t[j][i] = t[i][j] + 1;\n                    else t[j][i] = t[i][j] -1;\n                }\n    } else if (type == \"prefer_direct\") {\n        for (int i=0;i<3;++i)\n            for (int j=0;j<3;++j)\n                t[i][j]=(i==j)?0:10000;\n        t[0][2]=1; // t_{1,3}=1\n    } else if (type == \"prefer_indirect\") {\n        for (int i=0;i<3;++i)\n            for (int j=0;j<3;++j)\n                t[i][j]=(i==j)?0:10000;\n        t[0][1]=1; // t_{1,2}=1\n        t[1][2]=1; // t_{2,3}=1\n    } else if (type == \"random_big_n\") {\n        n = 40;\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : rnd.next(1, 10000);\n    } else if (type == \"max_n_min_t\") {\n        n = 40;\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 1;\n    } else if (type == \"max_n_max_t\") {\n        n = 40;\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : 10000;\n    } else {\n        // Default to random\n        for (int i =0; i<3; ++i)\n            for (int j=0; j<3; ++j)\n                t[i][j] = (i==j) ? 0 : rnd.next(1, 10000);\n    }\n\n    // Output t_{ij}\n\n    for (int i=0;i<3;++i) {\n        printf(\"%d %d %d\\n\", t[i][0], t[i][1], t[i][2]);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_t\n./gen -n 1 -type max_t\n./gen -n 1 -type random\n./gen -n 1 -type prefer_direct\n./gen -n 1 -type prefer_indirect\n\n./gen -n 2 -type min_t\n./gen -n 2 -type max_t\n./gen -n 2 -type random\n./gen -n 2 -type asymmetric\n./gen -n 2 -type prefer_direct\n./gen -n 2 -type prefer_indirect\n\n./gen -n 10 -type min_t\n./gen -n 10 -type max_t\n./gen -n 10 -type random\n./gen -n 10 -type asymmetric\n./gen -n 10 -type prefer_direct\n./gen -n 10 -type prefer_indirect\n\n./gen -n 20 -type random\n./gen -n 20 -type asymmetric\n\n./gen -n 30 -type random\n./gen -n 30 -type asymmetric\n\n./gen -n 39 -type min_t\n./gen -n 39 -type max_t\n./gen -n 39 -type random\n\n./gen -n 40 -type random_big_n\n./gen -n 40 -type max_n_min_t\n./gen -n 40 -type max_n_max_t\n./gen -n 40 -type random\n./gen -n 40 -type asymmetric\n./gen -n 40 -type prefer_direct\n./gen -n 40 -type prefer_indirect\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:45.172064",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "392/C",
      "title": "C. Yet Another Number Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, k (1 ≤ n ≤ 1017; 1 ≤ k ≤ 40).",
      "output_spec": "OutputPrint a single integer — the sum of the first n elements of the sequence Ai(k) modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy1InputCopy4 1OutputCopy34InputCopy5 2OutputCopy316InputCopy7 4OutputCopy73825",
      "description": "C. Yet Another Number Sequence\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, k (1 ≤ n ≤ 1017; 1 ≤ k ≤ 40).\n\nOutputPrint a single integer — the sum of the first n elements of the sequence Ai(k) modulo 1000000007 (109 + 7).\n\nInputCopy1 1OutputCopy1InputCopy4 1OutputCopy34InputCopy5 2OutputCopy316InputCopy7 4OutputCopy73825\n\nInputCopy1 1\n\nOutputCopy1\n\nInputCopy4 1\n\nOutputCopy34\n\nInputCopy5 2\n\nOutputCopy316\n\nInputCopy7 4\n\nOutputCopy73825",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 392\\s*C"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\"); // n in [1, 1e17]\n    inf.readSpace();\n    int k = inf.readInt(1, 40, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\"); // n in [1, 1e17]\n    inf.readSpace();\n    int k = inf.readInt(1, 40, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\"); // n in [1, 1e17]\n    inf.readSpace();\n    int k = inf.readInt(1, 40, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int k = opt<int>(\"k\");\n\n    /* Output n and k */\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int k = opt<int>(\"k\");\n\n    /* Output n and k */\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases with minimal n and k\n./gen -n 1 -k 1\n./gen -n 1 -k 40\n./gen -n 2 -k 1\n./gen -n 2 -k 40\n\n# Small n, varying k\n./gen -n 5 -k 1\n./gen -n 5 -k 40\n./gen -n 10 -k 20\n./gen -n 20 -k 15\n\n# n being Fibonacci numbers\n./gen -n 21 -k 15\n./gen -n 34 -k 25\n\n# Small-medium n\n./gen -n 100 -k 20\n./gen -n 1000 -k 30\n./gen -n 1000000 -k 35\n\n# Large n with small k\n./gen -n 100000000000000000 -k 1\n\n# Large n with max k\n./gen -n 100000000000000000 -k 40\n\n# Near maximum n\n./gen -n 99999999999999999 -k 1\n./gen -n 99999999999999999 -k 40\n\n# Powers of 2\n./gen -n 1073741824 -k 20 # 2^30\n./gen -n 4294967296 -k 25 # 2^32\n./gen -n 281474976710656 -k 30 # 2^48\n\n# Testing maximum n, k varying\n./gen -n 100000000000000000 -k 1\n./gen -n 100000000000000000 -k 20\n./gen -n 100000000000000000 -k 40\n\n# Random large n and k\n./gen -n 50000000000000000 -k 38\n./gen -n 75000000000000000 -k 2\n\n# Another set\n./gen -n 100000000000000000 -k 40\n./gen -n 1 -k 40\n\n# Additional small n and k\n./gen -n 3 -k 5\n./gen -n 4 -k 10\n./gen -n 5 -k 15\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:47.513020",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "392/D",
      "title": "D. Three Arrays",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — array a. The third line contains the description of array b in the same format. The fourth line contains the description of array c in the same format. The following constraint holds: 1 ≤ ai, bi, ci ≤ 109.",
      "output_spec": "OutputPrint a single integer — the minimum possible sum of u + v + w.",
      "sample_tests": "ExamplesInputCopy31 1 1011 2 13 2 1OutputCopy5InputCopy51 1 2 2 32 2 4 3 33 3 1 1 1OutputCopy5",
      "description": "D. Three Arrays\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — array a. The third line contains the description of array b in the same format. The fourth line contains the description of array c in the same format. The following constraint holds: 1 ≤ ai, bi, ci ≤ 109.\n\nOutputPrint a single integer — the minimum possible sum of u + v + w.\n\nInputCopy31 1 1011 2 13 2 1OutputCopy5InputCopy51 1 2 2 32 2 4 3 33 3 1 1 1OutputCopy5\n\nInputCopy31 1 1011 2 13 2 1\n\nOutputCopy5\n\nInputCopy51 1 2 2 32 2 4 3 33 3 1 1 1\n\nOutputCopy5\n\nNoteIn the first example you should choose u = 3, v = 0, w = 2. In the second example you should choose u = 1, v = 3, w = 1.",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 392\\s*D"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 1000000000, \"c_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 1000000000, \"c_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 1000000000, \"c_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), c(n);\n\n    if (type == \"random\") {\n        // Random arrays with elements in [1, 1e9]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(1, 1000000000);\n            c[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"small_range\") {\n        // Values in [1,10]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n            b[i] = rnd.next(1, 10);\n            c[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"all_same\") {\n        // All elements are the same number\n        int same_value = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = same_value;\n            b[i] = same_value;\n            c[i] = same_value;\n        }\n    } else if (type == \"max_u_v_w\") {\n        // Design arrays so that minimal u+v+w=3*n\n        // Use unique elements in the arrays\n        for(int i = 0; i < n; ++i) {\n            a[i] = 3*i + 1;\n            b[i] = 3*i + 2;\n            c[i] = 3*i + 3;\n        }\n    } else if (type == \"min_u_v_w\") {\n        // All arrays share the same first element\n        int same_value = rnd.next(1, 1000000000);\n        a[0] = b[0] = c[0] = same_value;\n        for(int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(1, 1000000000);\n            c[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"single_element\") {\n        // All arrays have the same single element\n        int same_value = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = same_value;\n            b[i] = same_value;\n            c[i] = same_value;\n        }\n    } else if (type == \"increasing\") {\n        // Elements in arrays are increasing\n        int value = 1;\n        for(int i = 0; i < n; ++i) {\n            a[i] = value++;\n        }\n        for(int i = 0; i < n; ++i) {\n            b[i] = value++;\n        }\n        for(int i = 0; i < n; ++i) {\n            c[i] = value++;\n        }\n    } else if (type == \"repeated_patterns\") {\n        // Arrays with repeated patterns\n        int pattern_length = rnd.next(1, min(100, n));\n        vector<int> pattern(pattern_length);\n        for(int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = pattern[i % pattern_length];\n            b[i] = pattern[(i + 1) % pattern_length];\n            c[i] = pattern[(i + 2) % pattern_length];\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(1, 1000000000);\n            c[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n    for(int i = 0; i < n; ++i) printf(\"%d%c\", b[i], \" \\n\"[i==n-1]);\n    for(int i = 0; i < n; ++i) printf(\"%d%c\", c[i], \" \\n\"[i==n-1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), c(n);\n\n    if (type == \"random\") {\n        // Random arrays with elements in [1, 1e9]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(1, 1000000000);\n            c[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"small_range\") {\n        // Values in [1,10]\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n            b[i] = rnd.next(1, 10);\n            c[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"all_same\") {\n        // All elements are the same number\n        int same_value = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = same_value;\n            b[i] = same_value;\n            c[i] = same_value;\n        }\n    } else if (type == \"max_u_v_w\") {\n        // Design arrays so that minimal u+v+w=3*n\n        // Use unique elements in the arrays\n        for(int i = 0; i < n; ++i) {\n            a[i] = 3*i + 1;\n            b[i] = 3*i + 2;\n            c[i] = 3*i + 3;\n        }\n    } else if (type == \"min_u_v_w\") {\n        // All arrays share the same first element\n        int same_value = rnd.next(1, 1000000000);\n        a[0] = b[0] = c[0] = same_value;\n        for(int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(1, 1000000000);\n            c[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"single_element\") {\n        // All arrays have the same single element\n        int same_value = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = same_value;\n            b[i] = same_value;\n            c[i] = same_value;\n        }\n    } else if (type == \"increasing\") {\n        // Elements in arrays are increasing\n        int value = 1;\n        for(int i = 0; i < n; ++i) {\n            a[i] = value++;\n        }\n        for(int i = 0; i < n; ++i) {\n            b[i] = value++;\n        }\n        for(int i = 0; i < n; ++i) {\n            c[i] = value++;\n        }\n    } else if (type == \"repeated_patterns\") {\n        // Arrays with repeated patterns\n        int pattern_length = rnd.next(1, min(100, n));\n        vector<int> pattern(pattern_length);\n        for(int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = pattern[i % pattern_length];\n            b[i] = pattern[(i + 1) % pattern_length];\n            c[i] = pattern[(i + 2) % pattern_length];\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(1, 1000000000);\n            c[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n    for(int i = 0; i < n; ++i) printf(\"%d%c\", b[i], \" \\n\"[i==n-1]);\n    for(int i = 0; i < n; ++i) printf(\"%d%c\", c[i], \" \\n\"[i==n-1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type small_range\n./gen -n 1 -type all_same\n./gen -n 1 -type min_u_v_w\n./gen -n 1 -type max_u_v_w\n./gen -n 1 -type single_element\n./gen -n 1 -type increasing\n\n./gen -n 5 -type random\n./gen -n 5 -type small_range\n./gen -n 5 -type all_same\n./gen -n 5 -type min_u_v_w\n./gen -n 5 -type max_u_v_w\n./gen -n 5 -type repeated_patterns\n\n./gen -n 10 -type random\n./gen -n 10 -type small_range\n./gen -n 10 -type all_same\n./gen -n 10 -type min_u_v_w\n./gen -n 10 -type max_u_v_w\n./gen -n 10 -type increasing\n\n./gen -n 1000 -type random\n./gen -n 1000 -type small_range\n./gen -n 1000 -type min_u_v_w\n./gen -n 1000 -type max_u_v_w\n\n./gen -n 100000 -type random\n./gen -n 100000 -type small_range\n./gen -n 100000 -type min_u_v_w\n./gen -n 100000 -type max_u_v_w\n./gen -n 100000 -type repeated_patterns\n\n./gen -n 99999 -type random\n./gen -n 98765 -type random\n\n./gen -n 100000 -type single_element\n\n./gen -n 100000 -type increasing\n\n./gen -n 100000 -type all_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:50.211437",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "392/E",
      "title": "E. Deleting Substrings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 400) — the initial length of w. The second line contains n integers v1, v2, ..., vn (0 ≤ |vi| ≤ 2000) — the costs of operations. The next line contains n integers w1, w2, ..., wn (1 ≤ wi ≤ 109) — the initial w.",
      "output_spec": "OutputPrint a single integer — the maximum total score you can get.",
      "sample_tests": "ExamplesInputCopy30 0 31 2 1OutputCopy3InputCopy61 4 5 6 7 10002 1 1 2 2 3OutputCopy12",
      "description": "E. Deleting Substrings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 400) — the initial length of w. The second line contains n integers v1, v2, ..., vn (0 ≤ |vi| ≤ 2000) — the costs of operations. The next line contains n integers w1, w2, ..., wn (1 ≤ wi ≤ 109) — the initial w.\n\nOutputPrint a single integer — the maximum total score you can get.\n\nInputCopy30 0 31 2 1OutputCopy3InputCopy61 4 5 6 7 10002 1 1 2 2 3OutputCopy12\n\nInputCopy30 0 31 2 1\n\nOutputCopy3\n\nInputCopy61 4 5 6 7 10002 1 1 2 2 3\n\nOutputCopy12",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 392\\s*E"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, -2000, 2000, \"v\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, -2000, 2000, \"v\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, -2000, 2000, \"v\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string vtype = opt<string>(\"vtype\", \"random\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n    \n    vector<int> v(n);\n    vector<long long> w(n);\n    \n    if (vtype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int sign = rnd.next(2) ? 1 : -1;\n            int abs_vi = rnd.next(0, 2000);\n            v[i] = sign * abs_vi;\n        }\n    } else if (vtype == \"allzero\") {\n        for (int i = 0; i < n; ++i) {\n            v[i] = 0;\n        }\n    } else if (vtype == \"allpos\") {\n        for (int i = 0; i < n; ++i) {\n            v[i] = rnd.next(1, 2000);\n        }\n    } else if (vtype == \"allneg\") {\n        for (int i = 0; i < n; ++i) {\n            v[i] = -rnd.next(1, 2000);\n        }\n    }\n    \n    if (wtype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1LL, 1000000000LL);\n        }\n    } else if (wtype == \"constant\") {\n        long long val = 1000000000LL; // or any fixed value within [1, 1e9]\n        for (int i = 0; i < n; ++i) {\n            w[i] = val;\n        }\n    } else if (wtype == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = i + 1;\n        }\n    } else if (wtype == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = n - i;\n        }\n    } else if (wtype == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = i % 2 + 1;\n        }\n    }\n    \n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", v[i], i == n-1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", w[i], i == n-1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string vtype = opt<string>(\"vtype\", \"random\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n    \n    vector<int> v(n);\n    vector<long long> w(n);\n    \n    if (vtype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int sign = rnd.next(2) ? 1 : -1;\n            int abs_vi = rnd.next(0, 2000);\n            v[i] = sign * abs_vi;\n        }\n    } else if (vtype == \"allzero\") {\n        for (int i = 0; i < n; ++i) {\n            v[i] = 0;\n        }\n    } else if (vtype == \"allpos\") {\n        for (int i = 0; i < n; ++i) {\n            v[i] = rnd.next(1, 2000);\n        }\n    } else if (vtype == \"allneg\") {\n        for (int i = 0; i < n; ++i) {\n            v[i] = -rnd.next(1, 2000);\n        }\n    }\n    \n    if (wtype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1LL, 1000000000LL);\n        }\n    } else if (wtype == \"constant\") {\n        long long val = 1000000000LL; // or any fixed value within [1, 1e9]\n        for (int i = 0; i < n; ++i) {\n            w[i] = val;\n        }\n    } else if (wtype == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = i + 1;\n        }\n    } else if (wtype == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = n - i;\n        }\n    } else if (wtype == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            w[i] = i % 2 + 1;\n        }\n    }\n    \n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", v[i], i == n-1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", w[i], i == n-1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -vtype allzero -wtype constant\n./gen -n 1 -vtype allpos -wtype increasing\n./gen -n 1 -vtype allneg -wtype decreasing\n./gen -n 2 -vtype allzero -wtype alternating\n./gen -n 2 -vtype allpos -wtype constant\n./gen -n 2 -vtype allneg -wtype random\n\n./gen -n 10 -vtype random -wtype random\n./gen -n 10 -vtype allpos -wtype increasing\n./gen -n 10 -vtype allneg -wtype decreasing\n./gen -n 10 -vtype allzero -wtype constant\n\n./gen -n 100 -vtype random -wtype alternating\n./gen -n 100 -vtype allpos -wtype increasing\n./gen -n 100 -vtype allneg -wtype decreasing\n./gen -n 100 -vtype allzero -wtype constant\n\n./gen -n 200 -vtype random -wtype random\n./gen -n 200 -vtype allpos -wtype constant\n./gen -n 200 -vtype allneg -wtype alternating\n./gen -n 200 -vtype allzero -wtype increasing\n\n./gen -n 400 -vtype random -wtype random\n./gen -n 400 -vtype allpos -wtype decreasing\n./gen -n 400 -vtype allneg -wtype increasing\n./gen -n 400 -vtype allzero -wtype constant\n\n./gen -n 400 -vtype random -wtype increasing\n./gen -n 400 -vtype random -wtype decreasing\n./gen -n 400 -vtype allpos -wtype alternating\n./gen -n 400 -vtype allneg -wtype alternating\n./gen -n 400 -vtype random -wtype constant\n\n./gen -n 1 -vtype random -wtype random\n\n./gen -n 50 -vtype random -wtype random\n./gen -n 150 -vtype random -wtype random\n./gen -n 350 -vtype random -wtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:52.414702",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "393/A",
      "title": "A. Nineteen",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty string s, consisting only of lowercase English letters. The length of string s doesn't exceed 100.",
      "output_spec": "OutputPrint a single integer — the maximum number of \"nineteen\"s that she can get in her string.",
      "sample_tests": "ExamplesInputCopynniinneetteeeennOutputCopy2InputCopynneteenabcnneteenabcnneteenabcnneteenabcnneteenabciiOutputCopy2InputCopynineteenineteenOutputCopy2",
      "description": "A. Nineteen\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string s, consisting only of lowercase English letters. The length of string s doesn't exceed 100.\n\nOutputPrint a single integer — the maximum number of \"nineteen\"s that she can get in her string.\n\nInputCopynniinneetteeeennOutputCopy2InputCopynneteenabcnneteenabcnneteenabcnneteenabcnneteenabciiOutputCopy2InputCopynineteenineteenOutputCopy2\n\nInputCopynniinneetteeeenn\n\nOutputCopy2\n\nInputCopynneteenabcnneteenabcnneteenabcnneteenabcnneteenabcii\n\nOutputCopy2\n\nInputCopynineteenineteen\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 393\\s*A"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Letter counts in \"nineteen\"\nconst int NEEDED_N = 3;\nconst int NEEDED_I = 1;\nconst int NEEDED_E = 3;\nconst int NEEDED_T = 1;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    string res;\n\n    if (type == \"max_nineteens\") {\n        // Maximize the number of \"nineteen\"s\n        int max_k = len / 8; // Each \"nineteen\" takes 8 letters\n        int letters_used = max_k * 8;\n        int rem = len - letters_used;\n\n        // letter counts\n        int cnt_n = NEEDED_N * max_k;\n        int cnt_i = NEEDED_I * max_k;\n        int cnt_e = NEEDED_E * max_k;\n        int cnt_t = NEEDED_T * max_k;\n\n        // Prepare the string\n        vector<char> letters;\n\n        for(int i = 0; i < cnt_n; ++i) letters.push_back('n');\n        for(int i = 0; i < cnt_i; ++i) letters.push_back('i');\n        for(int i = 0; i < cnt_e; ++i) letters.push_back('e');\n        for(int i = 0; i < cnt_t; ++i) letters.push_back('t');\n\n        // Add random letters if rem > 0\n        for(int i = 0; i < rem; ++i) {\n            letters.push_back(rnd.next('a', 'z'));\n        }\n\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n        // Build the string\n        res = string(letters.begin(), letters.end());\n\n    } else if (type == \"insufficient_counts\") {\n        // Generate counts insufficient to form maximum \"nineteen\"s\n\n        int max_k = len / 8;\n        if (max_k == 0) {\n            // If not enough length to form even one \"nineteen\"\n            res = \"\";\n            for (int i = 0; i < len; ++i) {\n                res += rnd.next('a', 'z');\n            }\n        } else {\n            // Reduce counts of one required letter\n            int cnt_n = NEEDED_N * max_k;\n            int cnt_i = NEEDED_I * max_k;\n            int cnt_e = NEEDED_E * max_k;\n            int cnt_t = NEEDED_T * max_k;\n\n            vector<char> needed_letters = {'n', 'i', 'e', 't'};\n            char insufficient_letter = needed_letters[rnd.next(0, 3)];\n\n            if (insufficient_letter == 'n' && cnt_n > 0) cnt_n -= 1;\n            else if (insufficient_letter == 'i' && cnt_i > 0) cnt_i -= 1;\n            else if (insufficient_letter == 'e' && cnt_e > 0) cnt_e -= 1;\n            else if (insufficient_letter == 't' && cnt_t > 0) cnt_t -= 1;\n\n            // Total letters used\n            int total_letters = cnt_n + cnt_i + cnt_e + cnt_t;\n            int rem = len - total_letters;\n\n            vector<char> letters;\n\n            for(int i = 0; i < cnt_n; ++i) letters.push_back('n');\n            for(int i = 0; i < cnt_i; ++i) letters.push_back('i');\n            for(int i = 0; i < cnt_e; ++i) letters.push_back('e');\n            for(int i = 0; i < cnt_t; ++i) letters.push_back('t');\n\n            // Add random letters\n            for(int i = 0; i < rem; ++i) {\n                letters.push_back(rnd.next('a', 'z'));\n            }\n\n            // Shuffle letters\n            shuffle(letters.begin(), letters.end());\n\n            res = string(letters.begin(), letters.end());\n        }\n\n    } else if (type == \"only_nineteen_letters\") {\n        // Generate random letters only from 'n', 'i', 'e', 't'\n\n        string letters_in_nineteen = \"niet\";\n        res = \"\";\n        for (int i = 0; i < len; ++i) {\n            char c = letters_in_nineteen[rnd.next(0, 3)];\n            res += c;\n        }\n\n    } else {\n        // Random letters\n        res = \"\";\n        for (int i = 0; i < len; ++i) {\n            res += rnd.next('a', 'z');\n        }\n    }\n\n    // Output the string\n    cout << res << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Letter counts in \"nineteen\"\nconst int NEEDED_N = 3;\nconst int NEEDED_I = 1;\nconst int NEEDED_E = 3;\nconst int NEEDED_T = 1;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    string res;\n\n    if (type == \"max_nineteens\") {\n        // Maximize the number of \"nineteen\"s\n        int max_k = len / 8; // Each \"nineteen\" takes 8 letters\n        int letters_used = max_k * 8;\n        int rem = len - letters_used;\n\n        // letter counts\n        int cnt_n = NEEDED_N * max_k;\n        int cnt_i = NEEDED_I * max_k;\n        int cnt_e = NEEDED_E * max_k;\n        int cnt_t = NEEDED_T * max_k;\n\n        // Prepare the string\n        vector<char> letters;\n\n        for(int i = 0; i < cnt_n; ++i) letters.push_back('n');\n        for(int i = 0; i < cnt_i; ++i) letters.push_back('i');\n        for(int i = 0; i < cnt_e; ++i) letters.push_back('e');\n        for(int i = 0; i < cnt_t; ++i) letters.push_back('t');\n\n        // Add random letters if rem > 0\n        for(int i = 0; i < rem; ++i) {\n            letters.push_back(rnd.next('a', 'z'));\n        }\n\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n        // Build the string\n        res = string(letters.begin(), letters.end());\n\n    } else if (type == \"insufficient_counts\") {\n        // Generate counts insufficient to form maximum \"nineteen\"s\n\n        int max_k = len / 8;\n        if (max_k == 0) {\n            // If not enough length to form even one \"nineteen\"\n            res = \"\";\n            for (int i = 0; i < len; ++i) {\n                res += rnd.next('a', 'z');\n            }\n        } else {\n            // Reduce counts of one required letter\n            int cnt_n = NEEDED_N * max_k;\n            int cnt_i = NEEDED_I * max_k;\n            int cnt_e = NEEDED_E * max_k;\n            int cnt_t = NEEDED_T * max_k;\n\n            vector<char> needed_letters = {'n', 'i', 'e', 't'};\n            char insufficient_letter = needed_letters[rnd.next(0, 3)];\n\n            if (insufficient_letter == 'n' && cnt_n > 0) cnt_n -= 1;\n            else if (insufficient_letter == 'i' && cnt_i > 0) cnt_i -= 1;\n            else if (insufficient_letter == 'e' && cnt_e > 0) cnt_e -= 1;\n            else if (insufficient_letter == 't' && cnt_t > 0) cnt_t -= 1;\n\n            // Total letters used\n            int total_letters = cnt_n + cnt_i + cnt_e + cnt_t;\n            int rem = len - total_letters;\n\n            vector<char> letters;\n\n            for(int i = 0; i < cnt_n; ++i) letters.push_back('n');\n            for(int i = 0; i < cnt_i; ++i) letters.push_back('i');\n            for(int i = 0; i < cnt_e; ++i) letters.push_back('e');\n            for(int i = 0; i < cnt_t; ++i) letters.push_back('t');\n\n            // Add random letters\n            for(int i = 0; i < rem; ++i) {\n                letters.push_back(rnd.next('a', 'z'));\n            }\n\n            // Shuffle letters\n            shuffle(letters.begin(), letters.end());\n\n            res = string(letters.begin(), letters.end());\n        }\n\n    } else if (type == \"only_nineteen_letters\") {\n        // Generate random letters only from 'n', 'i', 'e', 't'\n\n        string letters_in_nineteen = \"niet\";\n        res = \"\";\n        for (int i = 0; i < len; ++i) {\n            char c = letters_in_nineteen[rnd.next(0, 3)];\n            res += c;\n        }\n\n    } else {\n        // Random letters\n        res = \"\";\n        for (int i = 0; i < len; ++i) {\n            res += rnd.next('a', 'z');\n        }\n    }\n\n    // Output the string\n    cout << res << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum length\n./gen -len 1 -type random\n./gen -len 1 -type max_nineteens\n./gen -len 1 -type insufficient_counts\n./gen -len 1 -type only_nineteen_letters\n\n# Length less than needed for one \"nineteen\" (len=7)\n./gen -len 7 -type random\n./gen -len 7 -type max_nineteens\n./gen -len 7 -type insufficient_counts\n./gen -len 7 -type only_nineteen_letters\n\n# Length exactly needed for one \"nineteen\" (len=8)\n./gen -len 8 -type random\n./gen -len 8 -type max_nineteens\n./gen -len 8 -type insufficient_counts\n./gen -len 8 -type only_nineteen_letters\n\n# Length greater than needed for one \"nineteen\" (len=9)\n./gen -len 9 -type random\n./gen -len 9 -type max_nineteens\n./gen -len 9 -type insufficient_counts\n./gen -len 9 -type only_nineteen_letters\n\n# Medium lengths\n./gen -len 20 -type random\n./gen -len 20 -type max_nineteens\n./gen -len 20 -type insufficient_counts\n./gen -len 20 -type only_nineteen_letters\n\n./gen -len 50 -type random\n./gen -len 50 -type max_nineteens\n./gen -len 50 -type insufficient_counts\n./gen -len 50 -type only_nineteen_letters\n\n# Lengths not multiples of 8\n./gen -len 17 -type random\n./gen -len 17 -type max_nineteens\n./gen -len 17 -type insufficient_counts\n./gen -len 17 -type only_nineteen_letters\n\n# Maximum length\n./gen -len 100 -type random\n./gen -len 100 -type max_nineteens\n./gen -len 100 -type insufficient_counts\n./gen -len 100 -type only_nineteen_letters\n\n# Edge cases\n./gen -len 80 -type insufficient_counts\n./gen -len 88 -type max_nineteens\n\n# Random lengths with random types\n./gen -len 30 -type random\n./gen -len 45 -type random\n./gen -len 70 -type random\n./gen -len 85 -type random\n\n./gen -len 95 -type only_nineteen_letters\n\n# Edge case where counts are on edge\n./gen -len 24 -type max_nineteens\n./gen -len 25 -type max_nineteens\n\n# Random letters with short lengths\n./gen -len 5 -type random\n./gen -len 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:54.747009",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "393/B",
      "title": "B. Three matrices",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 170). Each of the following n lines contains n integers. The j-th integer in the i-th line is Wij (0 ≤ |Wij| < 1717).",
      "output_spec": "OutputThe first n lines must contain matrix A. The next n lines must contain matrix B. Print the matrices in the format equal to format of matrix W in input. It is guaranteed that the answer exists. If there are multiple answers, you are allowed to print any of them.The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 4.",
      "sample_tests": "ExamplesInputCopy21 43 2OutputCopy1.00000000 3.500000003.50000000 2.000000000.00000000 0.50000000-0.50000000 0.00000000InputCopy31 2 34 5 67 8 9OutputCopy1.00000000 3.00000000 5.000000003.00000000 5.00000000 7.000000005.00000000 7.00000000 9.000000000.00000000 -1.00000000 -2.000000001.00000000 0.00000000 -1.000000002.00000000 1.00000000 0.00000000",
      "description": "B. Three matrices\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 170). Each of the following n lines contains n integers. The j-th integer in the i-th line is Wij (0 ≤ |Wij| < 1717).\n\nOutputThe first n lines must contain matrix A. The next n lines must contain matrix B. Print the matrices in the format equal to format of matrix W in input. It is guaranteed that the answer exists. If there are multiple answers, you are allowed to print any of them.The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 4.\n\nInputCopy21 43 2OutputCopy1.00000000 3.500000003.50000000 2.000000000.00000000 0.50000000-0.50000000 0.00000000InputCopy31 2 34 5 67 8 9OutputCopy1.00000000 3.00000000 5.000000003.00000000 5.00000000 7.000000005.00000000 7.00000000 9.000000000.00000000 -1.00000000 -2.000000001.00000000 0.00000000 -1.000000002.00000000 1.00000000 0.00000000\n\nInputCopy21 43 2\n\nOutputCopy1.00000000 3.500000003.50000000 2.000000000.00000000 0.50000000-0.50000000 0.00000000\n\nInputCopy31 2 34 5 67 8 9\n\nOutputCopy1.00000000 3.00000000 5.000000003.00000000 5.00000000 7.000000005.00000000 7.00000000 9.000000000.00000000 -1.00000000 -2.000000001.00000000 0.00000000 -1.000000002.00000000 1.00000000 0.00000000",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 393\\s*B"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 170, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> w = inf.readInts(n, -1716, 1716);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 170, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> w = inf.readInts(n, -1716, 1716);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 170, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> w = inf.readInts(n, -1716, 1716);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1E-4;\n\nbool doubleEqual(double a, double b) {\n    double diff = fabs(a - b);\n    if (diff <= EPS)\n        return true;\n    double maxAbs = max(fabs(a), fabs(b));\n    if (maxAbs > 1E-12 && (diff / maxAbs) <= EPS)\n        return true;\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Read n from input file\n\n    // Read matrix W from input file\n    vector<vector<double>> W(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        vector<double> row = inf.readDoubles(n);\n        for (int j = 0; j < n; ++j) {\n            W[i][j] = row[j];\n        }\n    }\n\n    // Read matrix A from output\n    vector<vector<double>> A(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        vector<double> row = ouf.readDoubles(n);\n        if (row.size() != n) {\n            quitf(_wa, \"Cannot read %d numbers for row %d of matrix A\", n, i + 1);\n        }\n        A[i] = row;\n    }\n\n    // Check that A is symmetric\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (!doubleEqual(A[i][j], A[j][i])) {\n                quitf(_wa, \"Matrix A is not symmetric at position (%d,%d): A[%d][%d]=%.10f, A[%d][%d]=%.10f\",\n                      i + 1, j + 1, i + 1, j + 1, A[i][j], j + 1, i + 1, A[j][i]);\n            }\n        }\n    }\n\n    // Read matrix B from output\n    vector<vector<double>> B(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        vector<double> row = ouf.readDoubles(n);\n        if (row.size() != n) {\n            quitf(_wa, \"Cannot read %d numbers for row %d of matrix B\", n, i + 1);\n        }\n        B[i] = row;\n    }\n\n    // Check that B is skew-symmetric\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (!doubleEqual(B[i][j], -B[j][i])) {\n                quitf(_wa, \"Matrix B is not skew-symmetric at position (%d,%d): B[%d][%d]=%.10f, -B[%d][%d]=%.10f\",\n                      i + 1, j + 1, i + 1, j + 1, B[i][j], j + 1, i + 1, -B[j][i]);\n            }\n        }\n    }\n\n    // Check that A + B = W\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            double candidate = A[i][j] + B[i][j];\n            if (!doubleEqual(candidate, W[i][j])) {\n                quitf(_wa, \"A + B != W at position (%d,%d): A+B=%.10f, W=%.10f\", i + 1, j + 1, candidate, W[i][j]);\n            }\n        }\n    }\n\n    // All checks passed\n    quitf(_ok, \"Answer is correct.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_W = 1716;\n    vector<vector<int>> W(n, vector<int>(n));\n\n    if (type == \"zeros\") {\n        // W is all zeros\n        for (int i = 0; i < n; ++i)\n            fill(W[i].begin(), W[i].end(), 0);\n\n    } else if (type == \"symmetric\") {\n        // W is symmetric: W_ij = W_ji\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j < n; ++j) {\n                int val = rnd.next(-MAX_W, MAX_W);\n                W[i][j] = val;\n                W[j][i] = val;\n            }\n        }\n\n    } else if (type == \"skew_symmetric\") {\n        // W is skew-symmetric: W_ij = -W_ji, W_ii = 0\n        for (int i = 0; i < n; ++i)\n            W[i][i] = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int val = rnd.next(-MAX_W, MAX_W);\n                W[i][j] = val;\n                W[j][i] = -val;\n            }\n        }\n\n    } else if (type == \"max_values\") {\n        // W contains maximum allowed values\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = (rnd.next(0, 1) ? MAX_W : -MAX_W);\n\n    } else if (type == \"pattern1\") {\n        // W_ij = i + j\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = i + j;\n\n    } else if (type == \"pattern2\") {\n        // W_ij = i * j\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = i * j;\n\n    } else if (type == \"random\") {\n        // W is filled with random integers within allowed range\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = rnd.next(-MAX_W, MAX_W);\n\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = rnd.next(-MAX_W, MAX_W);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output W\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", W[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_W = 1716;\n    vector<vector<int>> W(n, vector<int>(n));\n\n    if (type == \"zeros\") {\n        // W is all zeros\n        for (int i = 0; i < n; ++i)\n            fill(W[i].begin(), W[i].end(), 0);\n\n    } else if (type == \"symmetric\") {\n        // W is symmetric: W_ij = W_ji\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j < n; ++j) {\n                int val = rnd.next(-MAX_W, MAX_W);\n                W[i][j] = val;\n                W[j][i] = val;\n            }\n        }\n\n    } else if (type == \"skew_symmetric\") {\n        // W is skew-symmetric: W_ij = -W_ji, W_ii = 0\n        for (int i = 0; i < n; ++i)\n            W[i][i] = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int val = rnd.next(-MAX_W, MAX_W);\n                W[i][j] = val;\n                W[j][i] = -val;\n            }\n        }\n\n    } else if (type == \"max_values\") {\n        // W contains maximum allowed values\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = (rnd.next(0, 1) ? MAX_W : -MAX_W);\n\n    } else if (type == \"pattern1\") {\n        // W_ij = i + j\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = i + j;\n\n    } else if (type == \"pattern2\") {\n        // W_ij = i * j\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = i * j;\n\n    } else if (type == \"random\") {\n        // W is filled with random integers within allowed range\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = rnd.next(-MAX_W, MAX_W);\n\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                W[i][j] = rnd.next(-MAX_W, MAX_W);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output W\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", W[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type symmetric\n./gen -n 1 -type skew_symmetric\n./gen -n 1 -type max_values\n./gen -n 1 -type pattern1\n./gen -n 1 -type random\n\n./gen -n 10 -type zeros\n./gen -n 10 -type symmetric\n./gen -n 10 -type skew_symmetric\n./gen -n 10 -type max_values\n./gen -n 10 -type pattern1\n./gen -n 10 -type random\n\n./gen -n 50 -type zeros\n./gen -n 50 -type symmetric\n./gen -n 50 -type skew_symmetric\n./gen -n 50 -type max_values\n./gen -n 50 -type pattern1\n./gen -n 50 -type random\n\n./gen -n 100 -type zeros\n./gen -n 100 -type symmetric\n./gen -n 100 -type skew_symmetric\n./gen -n 100 -type max_values\n./gen -n 100 -type pattern1\n./gen -n 100 -type random\n\n./gen -n 170 -type zeros\n./gen -n 170 -type symmetric\n./gen -n 170 -type skew_symmetric\n./gen -n 170 -type max_values\n./gen -n 170 -type pattern1\n./gen -n 170 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:56.715516",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "393/C",
      "title": "C. Blocked Points",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (0 ≤ n ≤ 4·107).",
      "output_spec": "OutputPrint a single integer — the minimum number of points that should be blocked.",
      "sample_tests": "ExamplesInputCopy1OutputCopy4InputCopy2OutputCopy8InputCopy3OutputCopy16",
      "description": "C. Blocked Points\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (0 ≤ n ≤ 4·107).\n\nOutputPrint a single integer — the minimum number of points that should be blocked.\n\nInputCopy1OutputCopy4InputCopy2OutputCopy8InputCopy3OutputCopy16\n\nOutputCopy4\n\nOutputCopy8\n\nOutputCopy16",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 393 和字母"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 40000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 40000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 40000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {       \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n == -1) {\n        string type = opt<string>(\"type\", \"random\");\n\n        if (type == \"zero\") {\n            n = 0;\n        } else if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"medium\") {\n            n = rnd.next(1000, 10000);\n        } else if (type == \"large\") {\n            n = rnd.next(10000000, 39999999);\n        } else if (type == \"max\") {\n            n = 40000000;\n        } else if (type == \"random\") {\n            n = rnd.next(0, 40000000);\n        } else if (type == \"precision\") {\n            // n where precision issues might occur\n            n = rnd.next(10000000, 40000000);\n            n -= rnd.next(0, 10);\n        } else if (type == \"corner\") {\n            // n is a perfect square close to the maximum value\n            int k = rnd.next(6320, 6324); // Since 6324^2 ≈ 40000000\n            n = k * k;\n            if (n > 40000000) n = 40000000;\n        } else {\n            n = rnd.next(0, 40000000);\n        }\n    }\n    // Ensure n is within the allowed range\n    if (n < 0) n = 0;\n    if (n > 40000000) n = 40000000;\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {       \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n == -1) {\n        string type = opt<string>(\"type\", \"random\");\n\n        if (type == \"zero\") {\n            n = 0;\n        } else if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"medium\") {\n            n = rnd.next(1000, 10000);\n        } else if (type == \"large\") {\n            n = rnd.next(10000000, 39999999);\n        } else if (type == \"max\") {\n            n = 40000000;\n        } else if (type == \"random\") {\n            n = rnd.next(0, 40000000);\n        } else if (type == \"precision\") {\n            // n where precision issues might occur\n            n = rnd.next(10000000, 40000000);\n            n -= rnd.next(0, 10);\n        } else if (type == \"corner\") {\n            // n is a perfect square close to the maximum value\n            int k = rnd.next(6320, 6324); // Since 6324^2 ≈ 40000000\n            n = k * k;\n            if (n > 40000000) n = 40000000;\n        } else {\n            n = rnd.next(0, 40000000);\n        }\n    }\n    // Ensure n is within the allowed range\n    if (n < 0) n = 0;\n    if (n > 40000000) n = 40000000;\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with n = 0 (minimum value)\n./gen -n 0\n\n# Small n values\n./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 5\n./gen -n 10\n./gen -n 20\n./gen -n 50\n\n# Medium n values\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 10000\n./gen -n 20000\n\n# Large n values close to the maximum limit\n./gen -n 100000\n./gen -n 500000\n./gen -n 1000000\n./gen -n 5000000\n./gen -n 10000000\n\n# n values just below the maximum limit\n./gen -n 39999999\n./gen -n 40000000\n\n# Random n values of various sizes\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Precision test cases where floating-point precision might cause issues\n./gen -type precision\n./gen -type precision\n\n# Corner cases with perfect squares and other special values\n./gen -type corner\n./gen -type corner\n\n# Maximum value test case\n./gen -n 40000000\n\n# Very small n values to test off-by-one errors\n./gen -n 0\n./gen -n 1\n\n# Test cases matching the sample inputs\n./gen -n 1\n./gen -n 2\n./gen -n 3\n\n# n is a perfect square\n./gen -n 10000\n\n# n is a large perfect square\n./gen -n 20000\n\n# n is just below the maximum limit\n./gen -n 39999999\n\n# n is maximum\n./gen -n 40000000\n\n# Additional random test cases\n./gen -type small\n./gen -type medium\n./gen -type large\n./gen -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:20:59.073369",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "393/D",
      "title": "D. Ханойская башня",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеКаждая из первых трех строк содержит три целых числа — матрицу t: j-ое число в i-ой строке tij (1 ≤ tij ≤ 10000; i ≠ j). В следующей строке записано единственное целое число n (1 ≤ n ≤ 40) — количество дисков.Гарантируется, что для всех i (1 ≤ i ≤ 3), tii = 0.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальную стоимость решения головоломки SmallR.",
      "sample_tests": "ПримерыВходные данныеСкопировать0 1 11 0 11 1 03Выходные данныеСкопировать7Входные данныеСкопировать0 2 21 0 1001 2 03Выходные данныеСкопировать19Входные данныеСкопировать0 2 11 0 1001 2 05Выходные данныеСкопировать87",
      "description": "D. Ханойская башня\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеКаждая из первых трех строк содержит три целых числа — матрицу t: j-ое число в i-ой строке tij (1 ≤ tij ≤ 10000; i ≠ j). В следующей строке записано единственное целое число n (1 ≤ n ≤ 40) — количество дисков.Гарантируется, что для всех i (1 ≤ i ≤ 3), tii = 0.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальную стоимость решения головоломки SmallR.\n\nВыходные данные\n\nВходные данныеСкопировать0 1 11 0 11 1 03Выходные данныеСкопировать7Входные данныеСкопировать0 2 21 0 1001 2 03Выходные данныеСкопировать19Входные данныеСкопировать0 2 11 0 1001 2 05Выходные данныеСкопировать87\n\nВходные данныеСкопировать0 1 11 0 11 1 03\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 2 21 0 1001 2 03\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать19\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 2 11 0 1001 2 05\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать87\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 393 和字母"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    \n    int t[4][4]; // 1-based indexing\n    for (int i = 1; i <= 3; ++i) {\n        vector<int> v = inf.readInts(3, 0, 10000);\n        inf.readEoln();\n        for (int j = 1; j <= 3; ++j) {\n            t[i][j] = v[j - 1];\n        }\n    }\n    \n    for (int i = 1; i <= 3; ++i) {\n        for (int j = 1; j <= 3; ++j) {\n            if (i == j) {\n                ensuref(t[i][j] == 0, \"t[%d][%d] must be 0\", i, j);\n            } else {\n                ensuref(t[i][j] >= 1 && t[i][j] <= 10000, \"t[%d][%d]=%d must be in range [1,10000]\", i, j, t[i][j]);\n            }\n        }\n    }\n    \n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    \n    int t[4][4]; // 1-based indexing\n    for (int i = 1; i <= 3; ++i) {\n        vector<int> v = inf.readInts(3, 0, 10000);\n        inf.readEoln();\n        for (int j = 1; j <= 3; ++j) {\n            t[i][j] = v[j - 1];\n        }\n    }\n    \n    for (int i = 1; i <= 3; ++i) {\n        for (int j = 1; j <= 3; ++j) {\n            if (i == j) {\n                ensuref(t[i][j] == 0, \"t[%d][%d] must be 0\", i, j);\n            } else {\n                ensuref(t[i][j] >= 1 && t[i][j] <= 10000, \"t[%d][%d]=%d must be in range [1,10000]\", i, j, t[i][j]);\n            }\n        }\n    }\n    \n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    \n    int t[4][4]; // 1-based indexing\n    for (int i = 1; i <= 3; ++i) {\n        vector<int> v = inf.readInts(3, 0, 10000);\n        inf.readEoln();\n        for (int j = 1; j <= 3; ++j) {\n            t[i][j] = v[j - 1];\n        }\n    }\n    \n    for (int i = 1; i <= 3; ++i) {\n        for (int j = 1; j <= 3; ++j) {\n            if (i == j) {\n                ensuref(t[i][j] == 0, \"t[%d][%d] must be 0\", i, j);\n            } else {\n                ensuref(t[i][j] >= 1 && t[i][j] <= 10000, \"t[%d][%d]=%d must be in range [1,10000]\", i, j, t[i][j]);\n            }\n        }\n    }\n    \n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_asymmetric\");\n\n    int t[3][3];\n\n    if (type == \"equal\") {\n        int val = opt<int>(\"value\", 1);\n        for(int i=0; i<3; ++i) {\n            for(int j=0; j<3; ++j) {\n                if (i == j)\n                    t[i][j] = 0;\n                else\n                    t[i][j] = val;\n            }\n        }\n    } else if (type == \"random_symmetric\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=i+1; j<3; ++j) {\n                t[i][j] = t[j][i] = rnd.next(1, 10000);\n            }\n        }\n    } else if (type == \"random_asymmetric\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if(i != j)\n                    t[i][j] = rnd.next(1, 10000);\n            }\n        }\n    } else if (type == \"max_cost\") {\n        for(int i=0; i<3; ++i)\n            for(int j=0; j<3; ++j)\n                if(i != j)\n                    t[i][j] = 10000;\n                else\n                    t[i][j] = 0;\n    } else if (type == \"min_cost\") {\n        for(int i=0; i<3; ++i)\n            for(int j=0; j<3; ++j)\n                if(i != j)\n                    t[i][j] = 1;\n                else\n                    t[i][j] = 0;\n    } else if (type == \"custom\") {\n        int t12 = opt<int>(\"t12\");\n        int t13 = opt<int>(\"t13\");\n        int t21 = opt<int>(\"t21\");\n        int t23 = opt<int>(\"t23\");\n        int t31 = opt<int>(\"t31\");\n        int t32 = opt<int>(\"t32\");\n        t[0][0]=t[1][1]=t[2][2]= 0;\n        t[0][1] = t12;\n        t[0][2] = t13;\n        t[1][0] = t21;\n        t[1][2] = t23;\n        t[2][0] = t31;\n        t[2][1] = t32;\n    } else if (type == \"biased_high\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if (i != j)\n                    t[i][j] = rnd.wnext(1, 10000, 3);\n            }\n        }\n    } else if (type == \"biased_low\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if (i != j)\n                    t[i][j] = rnd.wnext(1, 10000, -3);\n            }\n        }\n    } else {\n        // default is random_asymmetric\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if(i != j)\n                    t[i][j] = rnd.next(1, 10000);\n            }\n        }\n    }\n\n    // Output t matrix\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<3; ++j) {\n            printf(\"%d\", t[i][j]);\n            if(j<2) printf(\" \");\n            else printf(\"\\n\");\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_asymmetric\");\n\n    int t[3][3];\n\n    if (type == \"equal\") {\n        int val = opt<int>(\"value\", 1);\n        for(int i=0; i<3; ++i) {\n            for(int j=0; j<3; ++j) {\n                if (i == j)\n                    t[i][j] = 0;\n                else\n                    t[i][j] = val;\n            }\n        }\n    } else if (type == \"random_symmetric\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=i+1; j<3; ++j) {\n                t[i][j] = t[j][i] = rnd.next(1, 10000);\n            }\n        }\n    } else if (type == \"random_asymmetric\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if(i != j)\n                    t[i][j] = rnd.next(1, 10000);\n            }\n        }\n    } else if (type == \"max_cost\") {\n        for(int i=0; i<3; ++i)\n            for(int j=0; j<3; ++j)\n                if(i != j)\n                    t[i][j] = 10000;\n                else\n                    t[i][j] = 0;\n    } else if (type == \"min_cost\") {\n        for(int i=0; i<3; ++i)\n            for(int j=0; j<3; ++j)\n                if(i != j)\n                    t[i][j] = 1;\n                else\n                    t[i][j] = 0;\n    } else if (type == \"custom\") {\n        int t12 = opt<int>(\"t12\");\n        int t13 = opt<int>(\"t13\");\n        int t21 = opt<int>(\"t21\");\n        int t23 = opt<int>(\"t23\");\n        int t31 = opt<int>(\"t31\");\n        int t32 = opt<int>(\"t32\");\n        t[0][0]=t[1][1]=t[2][2]= 0;\n        t[0][1] = t12;\n        t[0][2] = t13;\n        t[1][0] = t21;\n        t[1][2] = t23;\n        t[2][0] = t31;\n        t[2][1] = t32;\n    } else if (type == \"biased_high\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if (i != j)\n                    t[i][j] = rnd.wnext(1, 10000, 3);\n            }\n        }\n    } else if (type == \"biased_low\") {\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if (i != j)\n                    t[i][j] = rnd.wnext(1, 10000, -3);\n            }\n        }\n    } else {\n        // default is random_asymmetric\n        for(int i=0; i<3; ++i) {\n            t[i][i] = 0;\n            for(int j=0; j<3; ++j) {\n                if(i != j)\n                    t[i][j] = rnd.next(1, 10000);\n            }\n        }\n    }\n\n    // Output t matrix\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<3; ++j) {\n            printf(\"%d\", t[i][j]);\n            if(j<2) printf(\" \");\n            else printf(\"\\n\");\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_cost\n./gen -n 1 -type max_cost\n./gen -n 40 -type min_cost\n./gen -n 40 -type max_cost\n./gen -n 10 -type random_symmetric\n./gen -n 20 -type random_symmetric\n./gen -n 30 -type random_symmetric\n./gen -n 10 -type random_asymmetric\n./gen -n 20 -type random_asymmetric\n./gen -n 30 -type random_asymmetric\n./gen -n 5 -type equal -value 1\n./gen -n 15 -type equal -value 10000\n./gen -n 25 -type custom -t12 1 -t13 2 -t21 10000 -t23 1 -t31 10000 -t32 1\n./gen -n 35 -type custom -t12 10000 -t13 10000 -t21 1 -t23 1 -t31 10000 -t32 10000\n./gen -n 20 -type custom -t12 1 -t13 10000 -t21 10000 -t23 1 -t31 1 -t32 10000\n./gen -n 40 -type custom -t12 1 -t13 10000 -t21 1 -t23 10000 -t31 10000 -t32 1\n./gen -n 20 -type random_asymmetric\n./gen -n 20 -type random_symmetric\n./gen -n 30 -type equal -value 5000\n./gen -n 30 -type custom -t12 10000 -t13 10000 -t21 1 -t23 10000 -t31 10000 -t32 10000\n./gen -n 30 -type custom -t12 1 -t13 1 -t21 10000 -t23 1 -t31 1 -t32 1\n./gen -n 1 -type custom -t12 10000 -t13 1 -t21 10000 -t23 1 -t31 1 -t32 10000\n./gen -n 13 -type random_asymmetric\n./gen -n 17 -type random_symmetric\n./gen -n 23 -type random_asymmetric\n./gen -n 20 -type biased_high\n./gen -n 20 -type biased_low\n./gen -n 25 -type biased_high\n./gen -n 15 -type biased_low\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:01.644437",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "393/E",
      "title": "E. Еще одна последовательность чисел",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел n, k (1 ≤ n ≤ 1017; 1 ≤ k ≤ 40).",
      "output_spec": "Выходные данныеВыведите единственное целое число — сумму первых n элементов последовательности Ai(k) по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать4 1Выходные данныеСкопировать34Входные данныеСкопировать5 2Выходные данныеСкопировать316Входные данныеСкопировать7 4Выходные данныеСкопировать73825",
      "description": "E. Еще одна последовательность чисел\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел n, k (1 ≤ n ≤ 1017; 1 ≤ k ≤ 40).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — сумму первых n элементов последовательности Ai(k) по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать4 1Выходные данныеСкопировать34Входные данныеСкопировать5 2Выходные данныеСкопировать316Входные данныеСкопировать7 4Выходные данныеСкопировать73825\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать34\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать316\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать73825\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces",
          "content": "Yesterday I saw this blog and thought that one bad editorial is better than zero good ones, right? So, enjoy it!Here are links to contests: Div. 1, Div. 2Div2A Editorial393A - NineteenLooking at examples and thinking about different cases lead to the idea that the best result would be to build a string which starts with nineteenineteenineteen...nineteenineteenineteen.... The first word nineteennineteen requires 3 letters nn, 3 letters ee, 1 letter ii and 1 letter tt. Every next occurrence of nineteennineteen requires the same set of letters, but we need only two letters nn for each new word. In other words, we can start with nn, and then every word will need exactly two extra nn-s. Let cnt[c]cnt[c] denote the number of characters cc in the string. Then the answer is min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t])min(⌊cnt[n]−12⌋,⌊cnt[e]3⌋,cnt[i],cnt[t]). (In theory this minimum could be −⌊12⌋−⌊12⌋, but in C++ it is equal to zero, so everything works fine) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n string s;\n cin >> s;\n map<char, int> cnt;\n for (auto c : s) {\n cnt[c]++;\n }\n cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n return 0;\n}Div2B Editorial393B - Три матрицыWe can write this system of equations, using the fact that B[j][i]=−B[i][j]B[j][i]=−B[i][j] and A[i][j]=A[j][i]A[i][j]=A[j][i] {A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]{A[i][j]+B[i][j]=W[i][j]A[j][i]+B[j][i]=W[j][i]⇒{A[i][j]+B[i][j]=W[i][j]A[i][j]−B[i][j]=W[j][i]From that, it is easy to conclude that A[i][j]=W[i][j]+W[j][i]2A[i][j]=W[i][j]+W[j][i]2 and B[i][j]=W[i][j]−W[j][i]2B[i][j]=W[i][j]−W[j][i]2.By the way, there is some interesting math connected to this problem: link Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<vector<double>> w(n, vector<double>(n));\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cin >> w[i][j];\n }\n }\n\n vector<vector<double>> a(n, vector<double>(n));\n vector<vector<double>> b(n, vector<double>(n));\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n a[i][j] = (w[i][j] + w[j][i]) / 2;\n b[i][j] = (w[i][j] - w[j][i]) / 2;\n }\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << a[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) {\n cout << b[i][j] << ' ';\n }\n cout << '\\n';\n }\n\n return 0;\n}Div2C/Div1A Editorial392A - Заблокированные точкиLet's look at all pairs of neighboring points such that one of them is special and the other one is not. I claim that it is necessary and sufficient to block at least one point in every such pair ProofNecessity is obvious. Let's prove sufficiency. Assume that we blocked at least one point in each pair, but there are two points AA and BB such that AA is special, BB is not and they are 4-connected. Then look at the path between these points. It starts with a special point and ends with non-special. That means that there are two adjacent points in this path such that the first one is special and the second one is not. But it contradicts our statement that we blocked at least one of the points in each pair.Now let's look at these pairs. For simplicity, we will look at only 1818-th of a circle. This oneAnd let's draw all horizontal pairs with a point inside the selected piece. SegmentsThere are also some vertical segments, but it can be proven with some geometry that the segments on the neighboring horizontal line are either on the same x-coordinate, or one is shifted by one. This means that if we choose the leftmost point in each of these segments, we will cover all vertical pairs as well.With some symmetry, this can be done for other pieces of a circle.There is only one thing left — we need to bring all pieces together. It is easy when two pieces share a horizontal or vertical line, but in the other case, we need another picture. Picture 1In this case, everything is already fine, we don't have any \"leaks\" between parts Picture 2In that case, we don't have any leaks either, but we have overlapping segments, and that means that we case save 1 point here and 4 points total.All we need now is to calculate the number of segments in a circle sector (it is n/2–√+1n/2+1) and differentiate these two cases. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n long long n;\n cin >> n;\n\n if (n == 0) {\n cout << 1 << '\\n';\n return 0;\n }\n\n int L = sqrt(n * n / 2);\n\n pair<long long, long long> near = {L + 1, L};\n\n int ans = (L * 2 + 1) * 4;\n\n if (near.first * near.first + near.second * near.second > n * n)\n ans -= 4;\n\n cout << ans << '\\n';\n\n return 0;\n}Div2D/Div1B Editorial392B - Ханойская башняFirst, understand this solution of the standard Hanoi puzzle, if you don't know it. I will use the same idea to solve this problem. Let's create a function calc(from,to,n)calc(from,to,n) which will count the minimal cost to move nn disks from fromfrom to toto. If n=1n=1 then we either move the disk directly to toto, or we first move it to the midmid (the remaining rod) and only then move to toto. If n>1n>1 then again, there are two possible strategies. Either we use moves from standard solution — move n−1n−1 disks to midmid, move 1 disk from fromfrom to toto, then move n−1n−1 disks to toto. Or we can make more moves but possibly with less cost: move n−1n−1 disks to toto, then 1 disk from fromfrom to midmid, then n−1n−1 disks back to fromfrom, then 1 disk to toto, and finally n−1n−1 disks to toto. Here are pictures for both cases: Case 1Better resolution Case 2Better resolutionFor moving n−1n−1 disks we will make recursive calls. If we just do that, we will have an exponential solution, which is not very nice. But we only have 3×2×n3×2×n different calls — 3 options for fromfrom, 2 for toto and nn. That means that we can just store every value which we already counted (or I can say a fancy word memoization, which means the same thing) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n auto p = make_pair(make_pair(from, to), n);\n if (mem.count(p))\n return mem[p];\n int mid = 3 - from - to;\n if (n == 1) {\n return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n }\n return mem[p] = min(calc(from, mid, n - 1) + t[from][to] + calc(mid, to, n - 1),\n calc(from, to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n for (int i = 0; i < 3; ++i) {\n for (int j = 0; j < 3; ++j) {\n cin >> t[i][j];\n }\n }\n\n int n;\n cin >> n;\n\n cout << calc(0, 2, n) << '\\n';\n\n return 0;\n}Div2E/Div1C Editorial392C - Еще одна последовательность чиселThis is obviously some matrix-exponentiation problem. We just have to figure out the matrix. Well, let's look at what we have Ai(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑kj=0(kj)Fi−1(i−1)j+∑kj=0(kj)Fi−2(i−2)j⋅2k−j==∑kj=0(kj)Ai−1(j)+∑kj=0(kj)Ai−2(j)⋅2k−jAi(k)=Fi⋅ik=(Fi−1+Fi−2)⋅ik=Fi−1⋅((i−1)+1)k+Fi−2⋅((i−2)+2)k==∑j=0k(kj)Fi−1(i−1)j+∑j=0k(kj)Fi−2(i−2)j⋅2k−j==∑j=0k(kj)Ai−1(j)+∑j=0k(kj)Ai−2(j)⋅2k−jThen we just have to store Ai−1(j)Ai−1(j) and Ai−2(j)Ai−2(j) for every j∈[0;k]j∈[0;k]. And also we have to store the sum, so the matrix will be of size 2(k+1)+12(k+1)+1, resulting in O(k3logn)O(k3log⁡n) in total.If you need more information about matrix exponentiation, consider watching the video from Errichto. Oh, and I almost forgot. He says exponentation instead of exponentiation. Now you will not able to forget this, enjoy! Here is the link :) (Errichto, no offence, if you are reading this :) ) Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\ntemplate<auto P>\nstruct Modular {\n using value_type = decltype(P);\n value_type value;\n\n Modular(ll k = 0) : value(norm(k)) {}\n\n Modular<P>& operator += (const Modular<P>& m) { value += m.value; if (value >= P) value -= P; return *this; }\n Modular<P> operator + (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n Modular<P>& operator -= (const Modular<P>& m) { value -= m.value; if (value < 0) value += P; return *this; }\n Modular<P> operator - (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n Modular<P> operator - () const { return Modular<P>(-value); }\n\n Modular<P>& operator *= (const Modular<P> &m) { value = value * 1ll * m.value % P; return *this; }\n Modular<P> operator * (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n Modular<P>& operator /= (const Modular<P> &m) { return *this *= m.inv(); }\n Modular<P> operator / (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n Modular<P>& operator ++ () { return *this += 1; }\n Modular<P>& operator -- () { return *this -= 1; }\n Modular<P> operator ++ (int) { Modular<P> r = *this; r += 1; return r; }\n Modular<P> operator -- (int) { Modular<P> r = *this; r -= 1; return r; }\n\n bool operator == (const Modular<P>& m) const { return value == m.value; }\n bool operator != (const Modular<P>& m) const { return value != m.value; }\n\n value_type norm(ll k) {\n if (!(-P <= k && k < P)) k %= P;\n if (k < 0) k += P;\n return k;\n }\n\n Modular<P> inv() const {\n value_type a = value, b = P, x = 0, y = 1;\n while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n return Modular<P>(x);\n }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n Modular<P> r(1);\n while (p) {\n if (p & 1) r *= m;\n m *= m;\n p >>= 1;\n }\n return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i, Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n for (int i = 0; i < a.size(); ++i) {\n for (int j = 0; j < a[0].size(); ++j) {\n for (int k = 0; k < b[0].size(); ++k) {\n c[i][k] += a[i][j] * b[j][k];\n }\n }\n }\n return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n for (int i = 0; i < res.size(); ++i) {\n res[i][i] = 1;\n }\n while (p) {\n if (p & 1) {\n res = res * a;\n }\n a = a * a;\n p /= 2;\n }\n return res;\n}\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n ll n;\n cin >> n;\n int k;\n cin >> k;\n\n vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n for (int i = 0; i < k + 1; ++i) {\n vinit[i][0] = 1;\n vinit[i + k + 1][0] = 0;\n vinit.back()[0] = 0;\n }\n vinit[k + 1][0] = 1;\n\n vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n for (int i = 0; i < C.size(); ++i) {\n C[0][i] = 0;\n C[i][0] = 1;\n }\n\n for (int i = 1; i < C.size(); ++i) {\n for (int j = 1; j < C.size(); ++j) {\n C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n }\n }\n\n vector<Mint> p2(50, 1);\n for (int i = 1; i < p2.size(); ++i)\n p2[i] = p2[i - 1] * 2;\n\n for (int p = 0; p < k + 1; ++p)\n mt[k + 1 + p][p] = 1;\n mt.back().back() = 1;\n mt.back()[k] = 1;\n\n for (int p = 0; p < k + 1; ++p) {\n for (int j = 0; j <= p; ++j) {\n mt[p][j] += C[p][j];\n mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n }\n }\n\n auto res = pow(mt, n) * vinit;\n cout << res.back()[0] << '\\n';\n\n return 0;\n}Div1D Editorial392D - Три массиваLet forget about aa for a minute and solve the problem for two arrays. Of course, it can be done with something like two pointers, but it is not extendable to three arrays (at least I don't know how). We need a more general approach. First, let's assume that bb has all elements, which cc contains. We can achieve that by copying cc at the end of bb (it is easy to see that this will not improve the answer).Suppose for some number kk it has only one occurrence in bb and only one in cc. And b[i]=c[j]=kb[i]=c[j]=k. Then we denote pos[i]=jpos[i]=j. Now, if kk has multiple occurrences in cc, we will take the smallest jj. If it has multiple occurrences in bb, we will set the first pos[i]pos[i] to jj and others to 00. Why that? Good question. Now the answer for the problem is mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). The expression in the brackets corresponds to the case when we take ii first elements from bb. Then we look for all other elements (j>ij>i) and choose the shortest prefix of cc which contains all these elements. That explains why we write the first occurrence of kk in cc to pospos. And we fill other values with zero because we don't need them if we already took the first occurrence in bb.Now get aa back. What changes if we have some numbers in aa? Well, in that case, we can set pos[i]=0pos[i]=0 for all occurrences of that number in bb (not only all except first). That means that if we iterate over prefix of aa from 00 to nn then we will have to change some pospos to zero. But I prefer changing zeros to some values, so we will iterate from nn to 00.Well, let's iterate. Suppose we decided not to take prefix of length ii in aa, and instead took prefix of length i−1i−1. If there are some occurrences of a[i]a[i] before ii, then nothing changes in pospos. But if there is no a[i]a[i] before ii, we have to update some pospos and recalculate mini((i−1)+maxj>ipos[j])mini((i−1)+maxj>ipos[j]). I believe there are different structs that can do it, I will describe what I used.In the expression, there are maximums on the suffix. They can be stored as pairs (p,m)(p,m) which means that up to position pp maximum on a suffix is at least mm (maximum-on-a-suffix is a non-increasing function, obviously). Now, to calculate the answer, we don't have to go through all ii. We only need to consider such indices pp that some pair (p−1,?)(p−1,?) exists in our set. That means that we have to check exactly one option for every pair of adjacent pairs. Remember, we only have to add pairs to this set. And it is easy — add a pair and remove enough pairs before it (while their mm less than new mm). With every addition or removal, we have O(1)O(1) additions or removals of options for an answer. Current answers can be stored in a multiset since we only need the minimal value. And if we are looking at a prefix ii of aa, then we have to update the answer with ii + (the smallest value from multiset).This is probably not the cleanest explanation, so there is a random picture which can help: PictureThe picture can contain off-by-one error, depending on your indexing and my mistakes.pos=[1,0,5,3,0,3,2]pos=[1,0,5,3,0,3,2].The picture illustrates maximums on a suffix for every ii. In a set, we store one pair for each horizontal segment. When we need to update the answer, we look at all points with a green circle (or actually 1 to the right of these points because in this picture maximum at x=2x=2 is 55, so we need (3,3)(3,3), not (2,3)(2,3), but that is exactly what I meant when I said about off-by-one errors). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> a(n), b(n), c(n);\n for (int i = 0; i < n; ++i)\n cin >> a[i];\n for (int i = 0; i < n; ++i)\n cin >> b[i];\n for (int i = 0; i < n; ++i)\n cin >> c[i];\n\n for (auto k : c) {\n b.push_back(k);\n }\n\n map<int, int> whereb;\n map<int, int> wherec;\n for (int i = (int)b.size() - 1; i >= 0; --i)\n whereb[b[i]] = i;\n for (int i = (int)c.size() - 1; i >= 0; --i)\n wherec[c[i]] = i;\n\n vector<bool> first_in_a(a.size(), false);\n vector<bool> first_in_b(b.size(), false);\n set<int> ina, inb;\n for (int i = 0; i < a.size(); ++i) {\n if (!ina.count(a[i])) {\n ina.insert(a[i]);\n first_in_a[i] = true;\n }\n }\n for (int i = 0; i < b.size(); ++i) {\n if (!inb.count(b[i])) {\n inb.insert(b[i]);\n first_in_b[i] = true;\n }\n }\n\n set<pair<int, int>> maxs;\n multiset<int> res;\n\n maxs.emplace(1e9, 0);\n maxs.emplace(-1, 1e9 + 5);\n res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n auto del = [&](pair<int, int> p) {\n auto it = maxs.find(p);\n assert(it != maxs.end());\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.erase(res.find(iprev->first + it->second + 1));\n res.erase(res.find(it->first + inext->second + 1));\n maxs.erase(it);\n res.insert(iprev->first + inext->second + 1);\n };\n\n auto add = [&](pair<int, int> p) {\n auto it = maxs.lower_bound(make_pair(p.first, -5));\n if (it->second >= p.second) return;\n if (it->first == p.first) {\n ++it;\n }\n while (prev(it)->second <= p.second)\n del(*prev(it));\n\n maxs.insert(p);\n it = maxs.find(p);\n auto inext = next(it);\n auto iprev = prev(it);\n\n res.insert(iprev->first + it->second + 1);\n res.insert(it->first + inext->second + 1);\n res.erase(res.find(iprev->first + inext->second + 1));\n };\n\n for (int i = 0; i < b.size(); ++i) {\n if (first_in_b[i] && !ina.count(b[i])) {\n int inc = 1e9;\n if (wherec.count(b[i]))\n inc = wherec[b[i]] + 1;\n add({i, inc});\n }\n }\n\n int ans = n + *res.begin();\n\n for (int i = n - 1; i >= 0; --i) {\n if (first_in_a[i]) {\n if (!inb.count(a[i])) break;\n int inc = 1e9;\n if (wherec.count(a[i]))\n inc = wherec[a[i]] + 1;\n add({whereb[a[i]], inc});\n }\n ans = min(ans, i + *res.begin());\n }\n\n cout << ans << '\\n';\n\n return 0;\n}Div1E Editorial392E - Удаляем подстрокиThere will be three different dpdp, let's get that out of the way. I wanted to make 44, but in the end decided to merge two of them.Also, before everything, let's update vv with v[i]=maxj(v[j]+v[i−j])v[i]=maxj(v[j]+v[i−j]). Because sometimes we want to remove segment of length 55, but 2+32+3 gives more points.First, let's discuss what a good substring is. It is either increasing, decreasing, or increasing up to something and then decreasing. And in any case, the difference between neighboring elements is exactly 1.dp_mon[l][r]dp_mon[l][r] — the biggest score we can get from segment [l;r][l;r] if in the end we are left with monotonous sequence, starting from w[l]w[l] and ending with w[r]w[r] (that means that we cannot remove w[l]w[l] or w[r]w[r]). If we can't do that, dp_mon[l][r]=−∞dp_mon[l][r]=−∞.dp_all[l][r]dp_all[l][r] — the biggest score we can get from removing the whole segment [l;r][l;r].dp[l][r]dp[l][r] — the best score we can get on segment [l;r][l;r] (no restrictions).The answer will be dp[1][n]dp[1][n].When we have these dpdp, it is not very hard to calculate them. To get dp_mon[l][r]dp_mon[l][r] we either have to remove everything in between (if |w[l]−w[r]|=1|w[l]−w[r]|=1), or for each number between ll and rr check if it can be in that monotonous sequence, and if it can, split by this number and add two dp_mon[l][j]+dp_mon[j][r]dp_mon[l][j]+dp_mon[j][r] (with intersection, yes).Now dp_alldp_all. First, let's update it with every dp_all[l][j]+dp_all[j+1][r]dp_all[l][j]+dp_all[j+1][r]. Now suppose there is an option, where we can't split the segment into two pieces. Consider the last segment we removed. It is some subsequence of our [l;r][l;r] segment. Elements of that subsequence split this segment into pieces. Each of these pieces is independent of each other. That means that if the first element of the subsequence is w[j]w[j] then [l;j−1][l;j−1] and [j;r][j;r] are independent and we already updated the answer with the sum of dp_alldp_all, and similarly with rr. There is one case, though. When this subsequence starts at w[l]w[l] and ends in w[r]w[r]. But that's what we have dp_mondp_mon for! Now for every element on [l;r][l;r] we have to check if this subsequence is increasing from w[l]w[l] to w[j]w[j] and then decreasing from w[j]w[j] to w[r]w[r]. That means that we add two dp_mondp_mon and after that remove this subsequence with a score of v[len_of_subsequence]v[len_of_subsequence]. The length can be calculated from |w[l]−w[j]||w[l]−w[j]| and |w[j]−w[r]||w[j]−w[r]|.The last is dpdp. That's the easiest one. Either we remove everything — this is dp_alldp_all, or there is some element which we decided not to remove. Then, as discussed in previous paragraph, it is enough to update dp[l][r]dp[l][r] by every dp[l][j]+dp[j+1][r]dp[l][j]+dp[j+1][r].And I know that probably some of dpdp are useless, but I feel like it is easier to understand the solution with multiple dpdp with different purposes. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n int n;\n cin >> n;\n vector<int> v(n);\n for (int i = 0; i < n; ++i) {\n cin >> v[i];\n }\n\n v.insert(v.begin(), 0);\n for (int i = 1; i <= n; ++i) {\n for (int j = 1; j < i; ++j) {\n v[i] = max(v[i], v[j] + v[i - j]);\n }\n }\n\n vector<int> w(n);\n for (int i = 0; i < n; ++i) {\n cin >> w[i];\n }\n\n auto getv = [&](int ln) {\n if (ln < v.size()) return v[ln];\n return -inf;\n };\n\n vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n for (int i = 0; i < n; ++i) {\n dp_mon[i][i] = 0;\n dp_all[i][i] = v[1];\n if (i != 0)\n dp_all[i][i - 1] = 0;\n }\n\n for (int k = 1; k <= n; ++k) {\n for (int l = 0; l < n; ++l) {\n int r = l + k - 1;\n if (r >= n) break;\n\n for (int j = l + 1; j <= r; ++j) {\n dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n }\n\n if (w[l] != w[r]) {\n if (abs(w[l] - w[r]) == 1) {\n dp_mon[l][r] = dp_all[l + 1][r - 1];\n } else {\n for (int j = l + 1; j < r; ++j) {\n if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n }\n }\n }\n }\n\n for (int j = l; j <= r; ++j)\n if (w[j] >= w[l] && w[j] >= w[r])\n dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n dp[l][r] = max(dp[l][r], dp_all[l][r]);\n for (int j = l + 1; j <= r; ++j)\n dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n }\n }\n\n cout << dp[0][n - 1] << '\\n';\n\n return 0;\n}This is my first editorial (and first blog too), so any suggestions, improvements, etc are welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/83942",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 393 和字母"
          },
          "content_length": 22497
        }
      ],
      "code_examples": [
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    map<char, int> cnt;\n    for (auto c : s) {\n        cnt[c]++;\n    }\n    cout << min({(cnt['n'] - 1) / 2, cnt['e'] / 3, cnt['i'], cnt['t']}) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<vector<double>> w(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n\n    vector<vector<double>> a(n, vector<double>(n));\n    vector<vector<double>> b(n, vector<double>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            a[i][j] = (w[i][j] + w[j][i]) / 2;\n            b[i][j] = (w[i][j] - w[j][i]) / 2;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << b[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    long long n;\n    cin >> n;\n\n    if (n == 0) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    int L = sqrt(n * n / 2);\n\n    pair<long long, long long> near = {L + 1, L};\n\n    int ans = (L * 2 + 1) * 4;\n\n    if (near.first * near.first + near.second * near.second > n * n)\n        ans -= 4;\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\narray<array<ll, 3>, 3> t;\nmap<pair<pair<int, int>, ll>, ll> mem;\n\nll calc(int from, int to, int n) {\n    auto p = make_pair(make_pair(from, to), n);\n    if (mem.count(p))\n        return mem[p];\n    int mid = 3 - from - to;\n    if (n == 1) {\n        return mem[p] = min(t[from][mid] + t[mid][to], t[from][to]);\n    }\n    return mem[p] = min(calc(from, mid, n - 1) + t[from][to]  + calc(mid,   to, n - 1),\n                        calc(from,  to, n - 1) + t[from][mid] + calc( to, from, n - 1) + t[mid][to] + calc(from, to, n - 1));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> t[i][j];\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    cout << calc(0, 2, n) << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular<P>& operator += (const Modular<P>& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular<P>  operator +  (const Modular<P>& m) const { Modular<P> r = *this; return r += m; }\n\n    Modular<P>& operator -= (const Modular<P>& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular<P>  operator -  (const Modular<P>& m) const { Modular<P> r = *this; return r -= m; }\n    Modular<P>  operator -                     () const { return Modular<P>(-value); }\n\n    Modular<P>& operator *= (const Modular<P> &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular<P>  operator *  (const Modular<P>& m) const { Modular<P> r = *this; return r *= m; }\n\n    Modular<P>& operator /= (const Modular<P> &m)       { return *this *= m.inv(); }\n    Modular<P>  operator /  (const Modular<P>& m) const { Modular<P> r = *this; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; r += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular<P>& m) const { return value == m.value; }\n    bool        operator != (const Modular<P>& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\nusing Mint = Modular<1000000007>;\n// using Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<vector<Mint>> operator * (vector<vector<Mint>> a, vector<vector<Mint>> b) {\n    vector<vector<Mint>> c(a.size(), vector<Mint>(b[0].size(), 0));\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < a[0].size(); ++j) {\n            for (int k = 0; k < b[0].size(); ++k) {\n                c[i][k] += a[i][j] * b[j][k];\n            }\n        }\n    }\n    return c;\n}\n\nvector<vector<Mint>> pow(vector<vector<Mint>> a, ll p) {\n    vector<vector<Mint>> res(a.size(), vector<Mint>(a.size(), 0));\n    for (int i = 0; i < res.size(); ++i) {\n        res[i][i] = 1;\n    }\n    while (p) {\n        if (p & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        p /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    ll n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector<vector<Mint>> mt((k + 1) * 2 + 1, vector<Mint>((k + 1) * 2 + 1, 0));\n\n    vector<vector<Mint>> vinit(mt.size(), vector<Mint>(1, 0));\n\n    // first k+1 elements are for F_{i-1}, next k+1 are for F_{i-2}, the last one is for sum up to A_{i-2}\n    for (int i = 0; i < k + 1; ++i) {\n        vinit[i][0] = 1;\n        vinit[i + k + 1][0] = 0;\n        vinit.back()[0] = 0;\n    }\n    vinit[k + 1][0] = 1;\n\n    vector<vector<Mint>> C(50, vector<Mint>(50, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n        }\n    }\n\n    vector<Mint> p2(50, 1);\n    for (int i = 1; i < p2.size(); ++i)\n        p2[i] = p2[i - 1] * 2;\n\n    for (int p = 0; p < k + 1; ++p)\n        mt[k + 1 + p][p] = 1;\n    mt.back().back() = 1;\n    mt.back()[k] = 1;\n\n    for (int p = 0; p < k + 1; ++p) {\n        for (int j = 0; j <= p; ++j) {\n            mt[p][j] += C[p][j];\n            mt[p][k + 1 + j] += C[p][j] * p2[p - j];\n        }\n    }\n\n    auto res = pow(mt, n) * vinit;\n    cout << res.back()[0] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < n; ++i)\n        cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        cin >> c[i];\n\n    for (auto k : c) {\n        b.push_back(k);\n    }\n\n    map<int, int> whereb;\n    map<int, int> wherec;\n    for (int i = (int)b.size() - 1; i >= 0; --i)\n        whereb[b[i]] = i;\n    for (int i = (int)c.size() - 1; i >= 0; --i)\n        wherec[c[i]] = i;\n\n    vector<bool> first_in_a(a.size(), false);\n    vector<bool> first_in_b(b.size(), false);\n    set<int> ina, inb;\n    for (int i = 0; i < a.size(); ++i) {\n        if (!ina.count(a[i])) {\n            ina.insert(a[i]);\n            first_in_a[i] = true;\n        }\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (!inb.count(b[i])) {\n            inb.insert(b[i]);\n            first_in_b[i] = true;\n        }\n    }\n\n    set<pair<int, int>> maxs;\n    multiset<int> res;\n\n    maxs.emplace(1e9, 0);\n    maxs.emplace(-1, 1e9 + 5);\n    res.insert(maxs.begin()->first + next(maxs.begin())->second + 1);\n\n    auto del = [&](pair<int, int> p) {\n        auto it = maxs.find(p);\n        assert(it != maxs.end());\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.erase(res.find(iprev->first + it->second + 1));\n        res.erase(res.find(it->first + inext->second + 1));\n        maxs.erase(it);\n        res.insert(iprev->first + inext->second + 1);\n    };\n\n    auto add = [&](pair<int, int> p) {\n        auto it = maxs.lower_bound(make_pair(p.first, -5));\n        if (it->second >= p.second) return;\n        if (it->first == p.first) {\n            ++it;\n        }\n        while (prev(it)->second <= p.second)\n            del(*prev(it));\n\n        maxs.insert(p);\n        it = maxs.find(p);\n        auto inext = next(it);\n        auto iprev = prev(it);\n\n        res.insert(iprev->first + it->second + 1);\n        res.insert(it->first + inext->second + 1);\n        res.erase(res.find(iprev->first + inext->second + 1));\n    };\n\n    for (int i = 0; i < b.size(); ++i) {\n        if (first_in_b[i] && !ina.count(b[i])) {\n            int inc = 1e9;\n            if (wherec.count(b[i]))\n                inc = wherec[b[i]] + 1;\n            add({i, inc});\n        }\n    }\n\n    int ans = n + *res.begin();\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (first_in_a[i]) {\n            if (!inb.count(a[i])) break;\n            int inc = 1e9;\n            if (wherec.count(a[i]))\n                inc = wherec[a[i]] + 1;\n            add({whereb[a[i]], inc});\n        }\n        ans = min(ans, i + *res.begin());\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        },
        {
          "title": "Unofficial editorial for Codeforces Round #230 (just a little bit late) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int inf = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    v.insert(v.begin(), 0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            v[i] = max(v[i], v[j] + v[i - j]);\n        }\n    }\n\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n\n    auto getv = [&](int ln) {\n        if (ln < v.size()) return v[ln];\n        return -inf;\n    };\n\n    vector<vector<ll>> dp_all(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp_mon(n, vector<ll>(n, -inf));\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        dp_mon[i][i] = 0;\n        dp_all[i][i] = v[1];\n        if (i != 0)\n            dp_all[i][i - 1] = 0;\n    }\n\n    for (int k = 1; k <= n; ++k) {\n        for (int l = 0; l < n; ++l) {\n            int r = l + k - 1;\n            if (r >= n) break;\n\n            for (int j = l + 1; j <= r; ++j) {\n                dp_all[l][r] = max(dp_all[l][r], dp_all[l][j - 1] + dp_all[j][r]);\n            }\n\n            if (w[l] != w[r]) {\n                if (abs(w[l] - w[r]) == 1) {\n                    dp_mon[l][r] = dp_all[l + 1][r - 1];\n                } else {\n                    for (int j = l + 1; j < r; ++j) {\n                        if (w[l] != w[j] && w[r] != w[j] && ((w[l] < w[j]) == (w[j] < w[r]))) {\n                            dp_mon[l][r] = max(dp_mon[l][r], dp_mon[l][j] + dp_mon[j][r]);\n                        }\n                    }\n                }\n            }\n\n            for (int j = l; j <= r; ++j)\n                if (w[j] >= w[l] && w[j] >= w[r])\n                    dp_all[l][r] = max(dp_all[l][r], dp_mon[l][j] + dp_mon[j][r] + getv(abs(w[l] - w[j]) + abs(w[j] - w[r]) + 1));\n\n            dp[l][r] = max(dp[l][r], dp_all[l][r]);\n            for (int j = l + 1; j <= r; ++j)\n                dp[l][r] = max(dp[l][r], dp[l][j - 1] + dp[j][r]);\n        }\n    }\n\n    cout << dp[0][n - 1] << '\\n';\n\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/83942",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 40, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 40, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 100000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 40, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    ll n = opt<ll>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (n == -1 || k == -1) {\n        if (type == \"maxn_mink\") {\n            n = (ll)1e17;\n            k = 1;\n        } else if (type == \"maxn_maxk\") {\n            n = (ll)1e17;\n            k = 40;\n        } else if (type == \"smalln_smallk\") {\n            n = rnd.next(1ll, 1000ll);\n            k = rnd.next(1, 5);\n        } else if (type == \"smalln_maxk\") {\n            n = rnd.next(1ll, 1000ll);\n            k = 40;\n        } else if (type == \"random\") {\n            n = rnd.next(1ll, (ll)1e17);\n            k = rnd.next(1, 40);\n        } else if (type == \"maxn\") {\n            n = (ll)1e17;\n            k = rnd.next(1, 40);\n        } else if (type == \"maxk\") {\n            n = rnd.next(1ll, (ll)1e17);\n            k = 40;\n        } else if (type == \"n_is_fib\") {\n            // Generate n as a Fibonacci number\n            vector<ll> fibs = {1, 2};\n            while (true) {\n                ll next = fibs.back() + fibs[fibs.size()-2];\n                if (next > (ll)1e17) break;\n                fibs.push_back(next);\n            }\n            n = fibs[rnd.next(0, (int)fibs.size()-1)];\n            k = rnd.next(1, 40);\n        } else if (type == \"n_is_power_of_two\") {\n            int max_exp = 56; // 2^56 ≈ 7e16\n            int exp = rnd.next(1, max_exp);\n            n = 1LL << exp;\n            k = rnd.next(1, 40);\n        } else {\n            // Default case: random n and k\n            n = rnd.next(1ll, (ll)1e17);\n            k = rnd.next(1, 40);\n        }\n    }\n    printf(\"%lld %d\\n\", n, k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    ll n = opt<ll>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (n == -1 || k == -1) {\n        if (type == \"maxn_mink\") {\n            n = (ll)1e17;\n            k = 1;\n        } else if (type == \"maxn_maxk\") {\n            n = (ll)1e17;\n            k = 40;\n        } else if (type == \"smalln_smallk\") {\n            n = rnd.next(1ll, 1000ll);\n            k = rnd.next(1, 5);\n        } else if (type == \"smalln_maxk\") {\n            n = rnd.next(1ll, 1000ll);\n            k = 40;\n        } else if (type == \"random\") {\n            n = rnd.next(1ll, (ll)1e17);\n            k = rnd.next(1, 40);\n        } else if (type == \"maxn\") {\n            n = (ll)1e17;\n            k = rnd.next(1, 40);\n        } else if (type == \"maxk\") {\n            n = rnd.next(1ll, (ll)1e17);\n            k = 40;\n        } else if (type == \"n_is_fib\") {\n            // Generate n as a Fibonacci number\n            vector<ll> fibs = {1, 2};\n            while (true) {\n                ll next = fibs.back() + fibs[fibs.size()-2];\n                if (next > (ll)1e17) break;\n                fibs.push_back(next);\n            }\n            n = fibs[rnd.next(0, (int)fibs.size()-1)];\n            k = rnd.next(1, 40);\n        } else if (type == \"n_is_power_of_two\") {\n            int max_exp = 56; // 2^56 ≈ 7e16\n            int exp = rnd.next(1, max_exp);\n            n = 1LL << exp;\n            k = rnd.next(1, 40);\n        } else {\n            // Default case: random n and k\n            n = rnd.next(1ll, (ll)1e17);\n            k = rnd.next(1, 40);\n        }\n    }\n    printf(\"%lld %d\\n\", n, k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and small k\n./gen -n 1 -k 1\n./gen -n 2 -k 1\n./gen -n 10 -k 3\n./gen -n 50 -k 5\n./gen -type smalln_smallk\n\n# Small n and maximum k\n./gen -n 1 -k 40\n./gen -n 2 -k 40\n./gen -n 100 -k 40\n./gen -type smalln_maxk\n\n# Maximum n and small k\n./gen -n 100000000000000000 -k 1\n./gen -n 100000000000000000 -k 5\n./gen -type maxn_mink\n\n# Maximum n and maximum k\n./gen -n 100000000000000000 -k 40\n./gen -type maxn_maxk\n\n# Random n and k\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Maximum n and random k\n./gen -type maxn\n./gen -type maxn\n\n# Random n and maximum k\n./gen -type maxk\n./gen -type maxk\n\n# n is a Fibonacci number\n./gen -type n_is_fib\n./gen -type n_is_fib\n./gen -type n_is_fib\n\n# n is a power of two\n./gen -type n_is_power_of_two\n./gen -type n_is_power_of_two\n./gen -type n_is_power_of_two\n\n# Edge cases\n./gen -n 99999999999999999 -k 39\n./gen -n 100000000000000000 -k 1\n./gen -n 100000000000000000 -k 2\n./gen -n 1 -k 40\n./gen -n 100000000000000000 -k 40\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:03.704831",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "394/A",
      "title": "A. Счетные палочки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест0.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке находится исходное выражение. Гарантируется, что выражение имеет вид A + B = C, где 1 ≤ A, B, C ≤ 100.",
      "output_spec": "Выходные данныеЕсли не существует способа так переложить палочку, что выражение станет верным, в единственной строке выведите «Impossible» (без кавычек). Если способ существует, выведите полученное выражение, следуйте формату выходных данных из тестовых примеров. Не выводите лишних пробельных символов.Если существует несколько правильных ответов, выведите любой. Для лучшего понимания условия рекомендуется изучить тестовые примеры.",
      "sample_tests": "ПримерыВходные данныеСкопировать||+|=|||||Выходные данныеСкопировать|||+|=||||Входные данныеСкопировать|||||+||=||Выходные данныеСкопироватьImpossibleВходные данныеСкопировать|+|=||||||Выходные данныеСкопироватьImpossibleВходные данныеСкопировать||||+||=||||||Выходные данныеСкопировать||||+||=||||||",
      "description": "A. Счетные палочки\n\nограничение по времени на тест0.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке находится исходное выражение. Гарантируется, что выражение имеет вид A + B = C, где 1 ≤ A, B, C ≤ 100.\n\nВходные данные\n\nВыходные данныеЕсли не существует способа так переложить палочку, что выражение станет верным, в единственной строке выведите «Impossible» (без кавычек). Если способ существует, выведите полученное выражение, следуйте формату выходных данных из тестовых примеров. Не выводите лишних пробельных символов.Если существует несколько правильных ответов, выведите любой. Для лучшего понимания условия рекомендуется изучить тестовые примеры.\n\nВыходные данные\n\nВходные данныеСкопировать||+|=|||||Выходные данныеСкопировать|||+|=||||Входные данныеСкопировать|||||+||=||Выходные данныеСкопироватьImpossibleВходные данныеСкопировать|+|=||||||Выходные данныеСкопироватьImpossibleВходные данныеСкопировать||||+||=||||||Выходные данныеСкопировать||||+||=||||||\n\nВходные данныеСкопировать||+|=|||||\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать|||+|=||||\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать|||||+||=||\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать|+|=||||||\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать||||+||=||||||\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать||||+||=||||||\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере достаточно переложить палочку из последней группы палочек в первую.Во втором тестовом примере нельзя переложить вертикальную палочку плюса во вторую группу палочек, получая таким образом вместо знака плюс знак минус.Ответа на третий тестовый пример нету, потому что убирать палочки просто так нельзя.В четвертом примере ничего не требуется перекладывать: исходное выражение и так арифметически корректное.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"Input line is empty\");\n\n    int n = s.size();\n    // Check that all chars are among '|', '+', '='\n    for(int i = 0; i < n; i++) {\n        ensuref(s[i] == '|' || s[i] == '+' || s[i] == '=', \"Invalid character in input: '%c'\", s[i]);\n    }\n    // Count number of '+' and '='\n    int plus_count = 0, equal_count = 0;\n    int pos_plus = -1, pos_equal = -1;\n    for(int i = 0; i < n; i++) {\n        if(s[i] == '+') {\n            plus_count++;\n            pos_plus = i;\n        }\n        if(s[i] == '=') {\n            equal_count++;\n            pos_equal = i;\n        }\n    }\n    ensuref(plus_count == 1, \"There must be exactly one '+' sign\");\n    ensuref(equal_count == 1, \"There must be exactly one '=' sign\");\n\n    ensuref(pos_plus < pos_equal, \"'+' sign must come before '=' sign\");\n\n    // Now extract A, B, C\n    string sA = s.substr(0, pos_plus);\n    string sB = s.substr(pos_plus + 1, pos_equal - pos_plus -1);\n    string sC = s.substr(pos_equal +1);\n\n    // Ensure that sA, sB, sC are not empty\n    ensuref(!sA.empty(), \"There must be sticks before '+' sign\");\n    ensuref(!sB.empty(), \"There must be sticks between '+' and '=' signs\");\n    ensuref(!sC.empty(), \"There must be sticks after '=' sign\");\n\n    // Count the number of '|' in sA, sB, sC\n    int A = 0, B = 0, C = 0;\n    for(char c : sA) {\n        ensuref(c == '|', \"Invalid character in A: '%c'\", c);\n        A++;\n    }\n    for(char c : sB) {\n        ensuref(c == '|', \"Invalid character in B: '%c'\", c);\n        B++;\n    }\n    for(char c : sC) {\n        ensuref(c == '|', \"Invalid character in C: '%c'\", c);\n        C++;\n    }\n    ensuref(1 <= A && A <= 100, \"A must be between 1 and 100, but A=%d\", A);\n    ensuref(1 <= B && B <= 100, \"B must be between 1 and 100, but B=%d\", B);\n    ensuref(1 <= C && C <= 100, \"C must be between 1 and 100, but C=%d\", C);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"Input line is empty\");\n\n    int n = s.size();\n    // Check that all chars are among '|', '+', '='\n    for(int i = 0; i < n; i++) {\n        ensuref(s[i] == '|' || s[i] == '+' || s[i] == '=', \"Invalid character in input: '%c'\", s[i]);\n    }\n    // Count number of '+' and '='\n    int plus_count = 0, equal_count = 0;\n    int pos_plus = -1, pos_equal = -1;\n    for(int i = 0; i < n; i++) {\n        if(s[i] == '+') {\n            plus_count++;\n            pos_plus = i;\n        }\n        if(s[i] == '=') {\n            equal_count++;\n            pos_equal = i;\n        }\n    }\n    ensuref(plus_count == 1, \"There must be exactly one '+' sign\");\n    ensuref(equal_count == 1, \"There must be exactly one '=' sign\");\n\n    ensuref(pos_plus < pos_equal, \"'+' sign must come before '=' sign\");\n\n    // Now extract A, B, C\n    string sA = s.substr(0, pos_plus);\n    string sB = s.substr(pos_plus + 1, pos_equal - pos_plus -1);\n    string sC = s.substr(pos_equal +1);\n\n    // Ensure that sA, sB, sC are not empty\n    ensuref(!sA.empty(), \"There must be sticks before '+' sign\");\n    ensuref(!sB.empty(), \"There must be sticks between '+' and '=' signs\");\n    ensuref(!sC.empty(), \"There must be sticks after '=' sign\");\n\n    // Count the number of '|' in sA, sB, sC\n    int A = 0, B = 0, C = 0;\n    for(char c : sA) {\n        ensuref(c == '|', \"Invalid character in A: '%c'\", c);\n        A++;\n    }\n    for(char c : sB) {\n        ensuref(c == '|', \"Invalid character in B: '%c'\", c);\n        B++;\n    }\n    for(char c : sC) {\n        ensuref(c == '|', \"Invalid character in C: '%c'\", c);\n        C++;\n    }\n    ensuref(1 <= A && A <= 100, \"A must be between 1 and 100, but A=%d\", A);\n    ensuref(1 <= B && B <= 100, \"B must be between 1 and 100, but B=%d\", B);\n    ensuref(1 <= C && C <= 100, \"C must be between 1 and 100, but C=%d\", C);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"Input line is empty\");\n\n    int n = s.size();\n    // Check that all chars are among '|', '+', '='\n    for(int i = 0; i < n; i++) {\n        ensuref(s[i] == '|' || s[i] == '+' || s[i] == '=', \"Invalid character in input: '%c'\", s[i]);\n    }\n    // Count number of '+' and '='\n    int plus_count = 0, equal_count = 0;\n    int pos_plus = -1, pos_equal = -1;\n    for(int i = 0; i < n; i++) {\n        if(s[i] == '+') {\n            plus_count++;\n            pos_plus = i;\n        }\n        if(s[i] == '=') {\n            equal_count++;\n            pos_equal = i;\n        }\n    }\n    ensuref(plus_count == 1, \"There must be exactly one '+' sign\");\n    ensuref(equal_count == 1, \"There must be exactly one '=' sign\");\n\n    ensuref(pos_plus < pos_equal, \"'+' sign must come before '=' sign\");\n\n    // Now extract A, B, C\n    string sA = s.substr(0, pos_plus);\n    string sB = s.substr(pos_plus + 1, pos_equal - pos_plus -1);\n    string sC = s.substr(pos_equal +1);\n\n    // Ensure that sA, sB, sC are not empty\n    ensuref(!sA.empty(), \"There must be sticks before '+' sign\");\n    ensuref(!sB.empty(), \"There must be sticks between '+' and '=' signs\");\n    ensuref(!sC.empty(), \"There must be sticks after '=' sign\");\n\n    // Count the number of '|' in sA, sB, sC\n    int A = 0, B = 0, C = 0;\n    for(char c : sA) {\n        ensuref(c == '|', \"Invalid character in A: '%c'\", c);\n        A++;\n    }\n    for(char c : sB) {\n        ensuref(c == '|', \"Invalid character in B: '%c'\", c);\n        B++;\n    }\n    for(char c : sC) {\n        ensuref(c == '|', \"Invalid character in C: '%c'\", c);\n        C++;\n    }\n    ensuref(1 <= A && A <= 100, \"A must be between 1 and 100, but A=%d\", A);\n    ensuref(1 <= B && B <= 100, \"B must be between 1 and 100, but B=%d\", B);\n    ensuref(1 <= C && C <= 100, \"C must be between 1 and 100, but C=%d\", C);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvoid parseExpression(const string& expr, vector<int>& counts, vector<char>& signs) {\n    counts.clear();\n    signs.clear();\n    int n = expr.length();\n    int pos = 0;\n\n    while (pos < n) {\n        // Skip whitespace\n        while (pos < n && isspace(expr[pos])) pos++;\n        if (pos == n) break;\n        if (expr[pos] == '+' || expr[pos] == '=') {\n            signs.push_back(expr[pos]);\n            pos++;\n        } else if (expr[pos] == '|') {\n            int count = 0;\n            while (pos < n && expr[pos] == '|') {\n                count++;\n                pos++;\n            }\n            counts.push_back(count);\n        } else {\n            quitf(_wa, \"Invalid character '%c' in expression\", expr[pos]);\n        }\n    }\n}\n\nbool isPossible(int A, int B, int C) {\n    if (A + B == C) return true;\n    int counts[3] = {A, B, C};\n    for (int from = 0; from < 3; ++from) {\n        for (int to = 0; to < 3; ++to) {\n            if (from == to) continue;\n            if (counts[from] <= 1) continue;\n            counts[from]--;\n            counts[to]++;\n            if (counts[0] + counts[1] == counts[2]) return true;\n            counts[from]++;\n            counts[to]--;\n        }\n    }\n    return false;\n}\n\nbool countsDifferByAtMostOneStick(const vector<int>& counts, const vector<int>& counts_contestant) {\n    int diffCount = 0;\n    int deltaSum = 0;\n    vector<int> deltas(3);\n    for (int i = 0; i < 3; ++i) {\n        deltas[i] = counts_contestant[i] - counts[i];\n        if (deltas[i] != 0) diffCount++;\n        deltaSum += deltas[i];\n    }\n    if (deltaSum != 0) return false; // Total sticks changed\n    if (diffCount == 0) {\n        return true; // No sticks moved\n    } else if (diffCount == 2) {\n        // Check that deltas are +1 and -1\n        if ((deltas[0] == 1 && (deltas[1] == -1 || deltas[2] == -1)) ||\n            (deltas[1] == 1 && (deltas[0] == -1 || deltas[2] == -1)) ||\n            (deltas[2] == 1 && (deltas[0] == -1 || deltas[1] == -1)))\n            return true;\n        else\n            return false;\n    } else {\n        return false;\n    }\n}\n\nstd::string toLower(const std::string& s) {\n    std::string res = s;\n    for (size_t i = 0; i < s.size(); ++i) {\n        res[i] = tolower(res[i]);\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read initial expression from inf\n    string initial_expr = inf.readLine();\n    vector<int> counts;\n    vector<char> signs;\n    parseExpression(initial_expr, counts, signs);\n    if (signs.size() != 2 || counts.size() != 3) {\n        quitf(_fail, \"Invalid initial expression format\");\n    }\n\n    // Read contestant's output\n    string cont_output = ouf.readLine();\n    // Check if contestant outputted \"Impossible\"\n    if (toLower(cont_output) == \"impossible\") {\n        // Check whether it's indeed impossible\n        if (isPossible(counts[0], counts[1], counts[2])) {\n            quitf(_wa, \"Contestant claimed 'Impossible', but it's possible to make the expression correct\");\n        } else {\n            quitf(_ok, \"Contestant correctly outputs 'Impossible'\");\n        }\n    } else {\n        // Parse contestant's expression\n        vector<int> counts_contestant;\n        vector<char> signs_contestant;\n        parseExpression(cont_output, counts_contestant, signs_contestant);\n\n        // Check signs are same\n        if (signs_contestant != signs) {\n            quitf(_wa, \"Signs in output are different\");\n        }\n\n        // Check total sticks are same\n        int total_initial = counts[0] + counts[1] + counts[2];\n        int total_contestant = counts_contestant[0] + counts_contestant[1] + counts_contestant[2];\n        if (total_initial != total_contestant) {\n            quitf(_wa, \"Total number of sticks changed\");\n        }\n\n        // Check counts differ by at most one stick movement\n        if (!countsDifferByAtMostOneStick(counts, counts_contestant)) {\n            quitf(_wa, \"Counts differ by more than one stick movement\");\n        }\n\n        // Check arithmetic expression\n        if (counts_contestant[0] + counts_contestant[1] != counts_contestant[2]) {\n            quitf(_wa, \"Arithmetic expression is incorrect in contestant's output\");\n        }\n\n        // All conditions met\n        quitf(_ok, \"Answer is correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output_expression(int A, int B, int C) {\n    // Output the A sticks\n    for(int i=0; i<A; ++i) printf(\"|\");\n\n    // Output '+'\n    printf(\"+\");\n\n    // Output the B sticks\n    for(int i=0; i<B; ++i) printf(\"|\");\n\n    // Output '='\n    printf(\"=\");\n\n    // Output the C sticks\n    for(int i=0; i<C; ++i) printf(\"|\");\n\n    printf(\"\\n\");\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 100);\n    string type = opt<string>(\"type\", \"random_possible\");\n    int A, B, C;\n\n    if (type == \"already_correct\") {\n        // Generate random A and B, and set C = A + B\n        A = rnd.next(1, n);\n        B = rnd.next(1, n);\n        C = A + B;\n        // If C exceeds n, reduce A or B accordingly\n        while (C > n) {\n            if (A > 1) A--;\n            else if (B > 1) B--;\n            else break;\n            C = A + B;\n        }\n    } else if (type == \"random_possible\") {\n        while (true) {\n            A = rnd.next(1, n);\n            B = rnd.next(1, n);\n            C = rnd.next(1, n);\n            // Make sure initial expression is incorrect\n            if (A + B == C) continue;\n\n            // Check if we can correct it by shifting one stick\n            bool possible = false;\n\n            // Shift stick from A to C\n            if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                possible = true;\n            }\n            // Shift stick from B to C\n            else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                possible = true;\n            }\n            // Shift stick from C to A\n            else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                possible = true;\n            }\n            // Shift stick from C to B\n            else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                possible = true;\n            }\n\n            if (possible) break;\n        }\n    } else if (type == \"random_impossible\") {\n        while (true) {\n            A = rnd.next(1, n);\n            B = rnd.next(1, n);\n            C = rnd.next(1, n);\n            // Make sure initial expression is incorrect\n            if (A + B == C) continue;\n\n            int diff = abs((A + B) - C);\n            if (diff >= 2) {\n                // Check all possible shifts\n                bool possible = false;\n                // Shift stick from A to C\n                if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                    possible = true;\n                }\n                // Shift stick from B to C\n                else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                    possible = true;\n                }\n                // Shift stick from C to A\n                else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                    possible = true;\n                }\n                // Shift stick from C to B\n                else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                    possible = true;\n                }\n\n                if (!possible) break;\n            }\n        }\n    } else if (type == \"max_values\") {\n        A = n;\n        B = n;\n        C = rnd.next(1, n);\n        while (A + B == C) {\n            C = rnd.next(1, n);\n        }\n    } else if (type == \"edge_cases\") {\n        // Randomly pick A, B, C among edge values 1 and n\n        vector<int> edge_values = {1, n};\n        A = edge_values[rnd.next(0, 1)];\n        B = edge_values[rnd.next(0, 1)];\n        C = edge_values[rnd.next(0, 1)];\n        // Ensure that the expression is incorrect and cannot be corrected by shifting one stick\n        int diff = abs((A + B) - C);\n        if (diff >= 2) {\n            // Check all possible shifts\n            bool possible = false;\n            // Shift stick from A to C\n            if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                possible = true;\n            }\n            // Shift stick from B to C\n            else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                possible = true;\n            }\n            // Shift stick from C to A\n            else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                possible = true;\n            }\n            // Shift stick from C to B\n            else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                possible = true;\n            }\n\n            if (!possible) {\n                // Edge case where it's impossible\n                output_expression(A, B, C);\n                return 0;\n            }\n        }\n        // If not impossible, generate again\n        A = B = C = 1;\n    } else if (type == \"specific\") {\n        // Use specific values of A, B, C provided\n        A = opt<int>(\"a\");\n        B = opt<int>(\"b\");\n        C = opt<int>(\"c\");\n    } else {\n        // Default: random_possible\n        type = \"random_possible\";\n        // Generate as per 'random_possible'\n        while (true) {\n            A = rnd.next(1, n);\n            B = rnd.next(1, n);\n            C = rnd.next(1, n);\n            // Make sure initial expression is incorrect\n            if (A + B == C) continue;\n\n            // Check if we can correct it by shifting one stick\n            bool possible = false;\n\n            // Shift stick from A to C\n            if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                possible = true;\n            }\n            // Shift stick from B to C\n            else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                possible = true;\n            }\n            // Shift stick from C to A\n            else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                possible = true;\n            }\n            // Shift stick from C to B\n            else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                possible = true;\n            }\n\n            if (possible) break;\n        }\n    }\n\n    output_expression(A, B, C);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output_expression(int A, int B, int C) {\n    // Output the A sticks\n    for(int i=0; i<A; ++i) printf(\"|\");\n\n    // Output '+'\n    printf(\"+\");\n\n    // Output the B sticks\n    for(int i=0; i<B; ++i) printf(\"|\");\n\n    // Output '='\n    printf(\"=\");\n\n    // Output the C sticks\n    for(int i=0; i<C; ++i) printf(\"|\");\n\n    printf(\"\\n\");\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 100);\n    string type = opt<string>(\"type\", \"random_possible\");\n    int A, B, C;\n\n    if (type == \"already_correct\") {\n        // Generate random A and B, and set C = A + B\n        A = rnd.next(1, n);\n        B = rnd.next(1, n);\n        C = A + B;\n        // If C exceeds n, reduce A or B accordingly\n        while (C > n) {\n            if (A > 1) A--;\n            else if (B > 1) B--;\n            else break;\n            C = A + B;\n        }\n    } else if (type == \"random_possible\") {\n        while (true) {\n            A = rnd.next(1, n);\n            B = rnd.next(1, n);\n            C = rnd.next(1, n);\n            // Make sure initial expression is incorrect\n            if (A + B == C) continue;\n\n            // Check if we can correct it by shifting one stick\n            bool possible = false;\n\n            // Shift stick from A to C\n            if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                possible = true;\n            }\n            // Shift stick from B to C\n            else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                possible = true;\n            }\n            // Shift stick from C to A\n            else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                possible = true;\n            }\n            // Shift stick from C to B\n            else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                possible = true;\n            }\n\n            if (possible) break;\n        }\n    } else if (type == \"random_impossible\") {\n        while (true) {\n            A = rnd.next(1, n);\n            B = rnd.next(1, n);\n            C = rnd.next(1, n);\n            // Make sure initial expression is incorrect\n            if (A + B == C) continue;\n\n            int diff = abs((A + B) - C);\n            if (diff >= 2) {\n                // Check all possible shifts\n                bool possible = false;\n                // Shift stick from A to C\n                if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                    possible = true;\n                }\n                // Shift stick from B to C\n                else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                    possible = true;\n                }\n                // Shift stick from C to A\n                else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                    possible = true;\n                }\n                // Shift stick from C to B\n                else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                    possible = true;\n                }\n\n                if (!possible) break;\n            }\n        }\n    } else if (type == \"max_values\") {\n        A = n;\n        B = n;\n        C = rnd.next(1, n);\n        while (A + B == C) {\n            C = rnd.next(1, n);\n        }\n    } else if (type == \"edge_cases\") {\n        // Randomly pick A, B, C among edge values 1 and n\n        vector<int> edge_values = {1, n};\n        A = edge_values[rnd.next(0, 1)];\n        B = edge_values[rnd.next(0, 1)];\n        C = edge_values[rnd.next(0, 1)];\n        // Ensure that the expression is incorrect and cannot be corrected by shifting one stick\n        int diff = abs((A + B) - C);\n        if (diff >= 2) {\n            // Check all possible shifts\n            bool possible = false;\n            // Shift stick from A to C\n            if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                possible = true;\n            }\n            // Shift stick from B to C\n            else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                possible = true;\n            }\n            // Shift stick from C to A\n            else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                possible = true;\n            }\n            // Shift stick from C to B\n            else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                possible = true;\n            }\n\n            if (!possible) {\n                // Edge case where it's impossible\n                output_expression(A, B, C);\n                return 0;\n            }\n        }\n        // If not impossible, generate again\n        A = B = C = 1;\n    } else if (type == \"specific\") {\n        // Use specific values of A, B, C provided\n        A = opt<int>(\"a\");\n        B = opt<int>(\"b\");\n        C = opt<int>(\"c\");\n    } else {\n        // Default: random_possible\n        type = \"random_possible\";\n        // Generate as per 'random_possible'\n        while (true) {\n            A = rnd.next(1, n);\n            B = rnd.next(1, n);\n            C = rnd.next(1, n);\n            // Make sure initial expression is incorrect\n            if (A + B == C) continue;\n\n            // Check if we can correct it by shifting one stick\n            bool possible = false;\n\n            // Shift stick from A to C\n            if (A > 1 && C + 1 <= n && (A - 1) + B == C + 1) {\n                possible = true;\n            }\n            // Shift stick from B to C\n            else if (B > 1 && C + 1 <= n && A + (B - 1) == C + 1) {\n                possible = true;\n            }\n            // Shift stick from C to A\n            else if (C > 1 && A + 1 <= n && (A + 1) + B == C - 1) {\n                possible = true;\n            }\n            // Shift stick from C to B\n            else if (C > 1 && B + 1 <= n && A + (B + 1) == C - 1) {\n                possible = true;\n            }\n\n            if (possible) break;\n        }\n    }\n\n    output_expression(A, B, C);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Already correct expressions\n./gen -type already_correct -n 10\n./gen -type already_correct -n 50\n./gen -type already_correct -n 100\n\n# Random possible expressions that can be corrected by shifting one stick\n./gen -type random_possible -n 10\n./gen -type random_possible -n 50\n./gen -type random_possible -n 100\n\n# Random impossible expressions that cannot be corrected by shifting one stick\n./gen -type random_impossible -n 10\n./gen -type random_impossible -n 50\n./gen -type random_impossible -n 100\n\n# Expressions with maximum values\n./gen -type max_values -n 100\n\n# Edge case expressions with A, B, or C equal to 1 or maximum\n./gen -type edge_cases -n 100\n\n# Specific expressions\n./gen -type specific -a 1 -b 1 -c 3\n./gen -type specific -a 3 -b 1 -c 1\n./gen -type specific -a 1 -b 3 -c 1\n./gen -type specific -a 2 -b 2 -c 5\n\n# More random possible expressions\n./gen -type random_possible -n 20\n./gen -type random_possible -n 30\n./gen -type random_possible -n 40\n./gen -type random_possible -n 60\n./gen -type random_possible -n 70\n./gen -type random_possible -n 80\n./gen -type random_possible -n 90\n\n# More random impossible expressions\n./gen -type random_impossible -n 20\n./gen -type random_impossible -n 30\n./gen -type random_impossible -n 40\n./gen -type random_impossible -n 60\n./gen -type random_impossible -n 70\n./gen -type random_impossible -n 80\n./gen -type random_impossible -n 90\n\n# Edge cases with minimum values\n./gen -type specific -a 1 -b 1 -c 1\n./gen -type specific -a 1 -b 1 -c 2\n./gen -type specific -a 2 -b 2 -c 1\n\n# Edge cases with maximum values\n./gen -type specific -a 100 -b 1 -c 101\n./gen -type specific -a 1 -b 100 -c 101\n./gen -type specific -a 100 -b 100 -c 199\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:05.990295",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "394/B",
      "title": "B. Very Beautiful Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains integers p, x (1 ≤ p ≤ 106, 1 ≤ x ≤ 9).",
      "output_spec": "OutputIf the teacher's made a mistake and such number doesn't exist, then print on a single line \"Impossible\" (without the quotes). Otherwise, print the \"very beautiful number\" without leading zeroes.",
      "sample_tests": "ExamplesInputCopy6 5OutputCopy142857InputCopy1 2OutputCopyImpossibleInputCopy6 4OutputCopy102564",
      "description": "B. Very Beautiful Number\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains integers p, x (1 ≤ p ≤ 106, 1 ≤ x ≤ 9).\n\nOutputIf the teacher's made a mistake and such number doesn't exist, then print on a single line \"Impossible\" (without the quotes). Otherwise, print the \"very beautiful number\" without leading zeroes.\n\nInputCopy6 5OutputCopy142857InputCopy1 2OutputCopyImpossibleInputCopy6 4OutputCopy102564\n\nInputCopy6 5\n\nOutputCopy142857\n\nInputCopy1 2\n\nOutputCopyImpossible\n\nInputCopy6 4\n\nOutputCopy102564\n\nNoteSample 1: 142857·5 = 714285.Sample 2: The number that consists of a single digit cannot stay what it is when multiplied by 2, thus, the answer to the test sample is \"Impossible\".",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000, \"p\");\n    inf.readSpace();\n    int x = inf.readInt(1, 9, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000, \"p\");\n    inf.readSpace();\n    int x = inf.readInt(1, 9, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000, \"p\");\n    inf.readSpace();\n    int x = inf.readInt(1, 9, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int p_min = opt<int>(\"p_min\", 1);\n    int p_max = opt<int>(\"p_max\", 1000000);\n    int x_min = opt<int>(\"x_min\", 1);\n    int x_max = opt<int>(\"x_max\", 9);\n    string type = opt<string>(\"type\", \"random\");\n\n    int p, x;\n\n    if (type == \"random\") {\n        // Generate random p and x within specified ranges\n        p = rnd.next(p_min, p_max);\n        x = rnd.next(x_min, x_max);\n    } else if (type == \"min_p_max_x\") {\n        // Minimal p, maximal x\n        p = p_min;\n        x = x_max;\n    } else if (type == \"max_p_min_x\") {\n        // Maximal p, minimal x\n        p = p_max;\n        x = x_min;\n    } else if (type == \"impossible\") {\n        // Generate p and x likely to have no solution\n        p = p_min;\n        x = x_min + 1;\n        if (x > x_max) x = x_min;\n    } else if (type == \"specific\") {\n        // Use specific p and x provided as parameters\n        p = opt<int>(\"p\");\n        x = opt<int>(\"x\");\n    } else {\n        // Default to random\n        p = rnd.next(p_min, p_max);\n        x = rnd.next(x_min, x_max);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", p, x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int p_min = opt<int>(\"p_min\", 1);\n    int p_max = opt<int>(\"p_max\", 1000000);\n    int x_min = opt<int>(\"x_min\", 1);\n    int x_max = opt<int>(\"x_max\", 9);\n    string type = opt<string>(\"type\", \"random\");\n\n    int p, x;\n\n    if (type == \"random\") {\n        // Generate random p and x within specified ranges\n        p = rnd.next(p_min, p_max);\n        x = rnd.next(x_min, x_max);\n    } else if (type == \"min_p_max_x\") {\n        // Minimal p, maximal x\n        p = p_min;\n        x = x_max;\n    } else if (type == \"max_p_min_x\") {\n        // Maximal p, minimal x\n        p = p_max;\n        x = x_min;\n    } else if (type == \"impossible\") {\n        // Generate p and x likely to have no solution\n        p = p_min;\n        x = x_min + 1;\n        if (x > x_max) x = x_min;\n    } else if (type == \"specific\") {\n        // Use specific p and x provided as parameters\n        p = opt<int>(\"p\");\n        x = opt<int>(\"x\");\n    } else {\n        // Default to random\n        p = rnd.next(p_min, p_max);\n        x = rnd.next(x_min, x_max);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", p, x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimal values of p and x\n./gen -p_min 1 -p_max 1 -x_min 1 -x_max 1 -type min_p_max_x\n\n# Test case 2: Maximal values of p and x\n./gen -p_min 1000000 -p_max 1000000 -x_min 9 -x_max 9 -type max_p_min_x\n\n# Test case 3: Random small p and x\n./gen -p_min 1 -p_max 10 -x_min 1 -x_max 9 -type random\n\n# Test case 4: Random medium p and x\n./gen -p_min 100 -p_max 1000 -x_min 1 -x_max 9 -type random\n\n# Test case 5: Random large p and x\n./gen -p_min 100000 -p_max 1000000 -x_min 1 -x_max 9 -type random\n\n# Test case 6: Impossible case with p = 1 and x > 1\n./gen -p_min 1 -p_max 1 -x_min 2 -x_max 9 -type impossible\n\n# Test case 7: Impossible case with p small and x = 1\n./gen -p_min 1 -p_max 1 -x_min 1 -x_max 1 -type impossible\n\n# Test case 8: Specific sample input from the problem (p=6, x=5)\n./gen -type specific -p 6 -x 5\n\n# Test case 9: Specific sample input from the problem (p=6, x=4)\n./gen -type specific -p 6 -x 4\n\n# Test case 10: Specific case with p=1 and x=2 (Impossible)\n./gen -type specific -p 1 -x 2\n\n# Test case 11: Random p with x = 1\n./gen -p_min 1 -p_max 1000000 -x_min 1 -x_max 1 -type random\n\n# Test case 12: Random p with x = 9\n./gen -p_min 1 -p_max 1000000 -x_min 9 -x_max 9 -type random\n\n# Test case 13: Random p with x in the middle\n./gen -p_min 1 -p_max 1000000 -x_min 5 -x_max 5 -type random\n\n# Test case 14: Maximal p with random x\n./gen -p_min 1000000 -p_max 1000000 -x_min 1 -x_max 9 -type random\n\n# Test case 15: Minimal p with random x\n./gen -p_min 1 -p_max 1 -x_min 1 -x_max 9 -type random\n\n# Test case 16: Random p and x in full range\n./gen -p_min 1 -p_max 1000000 -x_min 1 -x_max 9 -type random\n\n# Test case 17: Possible case with small p and large x\n./gen -p_min 1 -p_max 10 -x_min 9 -x_max 9 -type min_p_max_x\n\n# Test case 18: Possible case with large p and small x\n./gen -p_min 999990 -p_max 1000000 -x_min 1 -x_max 1 -type max_p_min_x\n\n# Test case 19: Random p in the middle range and random x\n./gen -p_min 500 -p_max 1500 -x_min 1 -x_max 9 -type random\n\n# Test case 20: Specific impossible case with p=2 and x=2\n./gen -type specific -p 2 -x 2\n\n# Test case 21: Random small p and x\n./gen -p_min 2 -p_max 10 -x_min 2 -x_max 9 -type random\n\n# Test case 22: Random large p and x\n./gen -p_min 900000 -p_max 1000000 -x_min 1 -x_max 9 -type random\n\n# Test case 23: Random p and maximal x\n./gen -p_min 1000 -p_max 1000000 -x_min 9 -x_max 9 -type random\n\n# Test case 24: Random p and minimal x\n./gen -p_min 1 -p_max 1000000 -x_min 1 -x_max 1 -type random\n\n# Test case 25: Impossible case with maximal p and x = 1\n./gen -p_min 1000000 -p_max 1000000 -x_min 1 -x_max 1 -type impossible\n\n# Test case 26: Random possible case\n./gen -p_min 3 -p_max 10 -x_min 2 -x_max 8 -type random\n\n# Test case 27: Specific large p and x\n./gen -type specific -p 999999 -x 9\n\n# Test case 28: Specific small p and x\n./gen -type specific -p 3 -x 7\n\n# Test case 29: Random p with x = 5\n./gen -p_min 1 -p_max 1000000 -x_min 5 -x_max 5 -type random\n\n# Test case 30: Random p with x = 2\n./gen -p_min 1 -p_max 1000000 -x_min 2 -x_max 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:08.049951",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "394/C",
      "title": "C. Доминошки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n, m (1 ≤ n, m ≤ 103). Далее следует описание матрицы, которую составил учитель. В каждой из следующих n строк содержится m горизонтальных доминошек: каждая доминошка обозначается двумя символами (0 или 1), записанными без пробела — цифры на левой и правой половине соответствующей доминошки.",
      "output_spec": "Выходные данныеВыведите полученную матрицу из доминошек в формате: n строк, в каждой из которых по m доминошек, записанных через пробел.Если оптимальных ответов несколько, выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 301 11 0000 01 11Выходные данныеСкопировать11 11 1000 00 01Входные данныеСкопировать4 111100100Выходные данныеСкопировать11100100",
      "description": "C. Доминошки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n, m (1 ≤ n, m ≤ 103). Далее следует описание матрицы, которую составил учитель. В каждой из следующих n строк содержится m горизонтальных доминошек: каждая доминошка обозначается двумя символами (0 или 1), записанными без пробела — цифры на левой и правой половине соответствующей доминошки.\n\nВходные данные\n\nВыходные данныеВыведите полученную матрицу из доминошек в формате: n строк, в каждой из которых по m доминошек, записанных через пробел.Если оптимальных ответов несколько, выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать2 301 11 0000 01 11Выходные данныеСкопировать11 11 1000 00 01Входные данныеСкопировать4 111100100Выходные данныеСкопировать11100100\n\nВходные данныеСкопировать2 301 11 0000 01 11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11 11 1000 00 01\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 111100100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11100100\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим ответ на первый пример. В нем максимальная сумма по столбцам равна 1 (количество столбцов — 6, а не 3). Очевидно, что меньше 1 эта сумма быть не может, значит такое расположение доминошек является оптимальным.Обратите внимание, что доминошки можно поворачивать на 180 градусов.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (j > 0) inf.readSpace();\n            string domino = inf.readToken(\"[01]{2}\", \"domino\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (j > 0) inf.readSpace();\n            string domino = inf.readToken(\"[01]{2}\", \"domino\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (j > 0) inf.readSpace();\n            string domino = inf.readToken(\"[01]{2}\", \"domino\");\n        }\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\n\nint readInputDominoes(vector<string>& dominoes) {\n    for (int i = 0; i < n; ++i) {\n        vector<string> row;\n        for (int j = 0; j < m; ++j) {\n            string s = inf.readToken(\"[01]{2}\", format(\"domino (%d, %d)\", i+1, j+1).c_str());\n            row.push_back(s);\n        }\n        dominoes.insert(dominoes.end(), row.begin(), row.end());\n    }\n    return 0;\n}\n\nvoid readOutputDominoes(InStream& stream, vector<string>& output_dominoes, vector<vector<string>>& output_matrix) {\n    for (int i = 0; i < n; ++i) {\n        vector<string> row;\n        for (int j = 0; j < m; ++j) {\n            string s = stream.readToken(\"[01]{2}\", format(\"domino (%d, %d)\", i+1, j+1).c_str());\n            row.push_back(s);\n        }\n        output_matrix.push_back(row);\n        output_dominoes.insert(output_dominoes.end(), row.begin(), row.end());\n    }\n}\n\nint computeMaxColumnSum(const vector<vector<string>>& matrix) {\n    int max_sum = 0;\n    for (int col = 0; col < 2 * m; ++col) {\n        int sum = 0;\n        for (int row = 0; row < n; ++row) {\n            int domino_index = col / 2;\n            int half = col % 2;\n            string domino = matrix[row][domino_index];\n            int value = domino[half] - '0';\n            sum += value;\n        }\n        max_sum = max(max_sum, sum);\n    }\n    return max_sum;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1000, \"n\");\n    m = inf.readInt(1, 1000, \"m\");\n\n    vector<string> input_dominoes;\n    readInputDominoes(input_dominoes);\n\n    // Create a multiset of dominoes from input, considering rotations\n    multiset<string> input_domino_set;\n    for (const string& domino : input_dominoes) {\n        input_domino_set.insert(domino);\n    }\n\n    // Read jury's answer\n    vector<string> jury_output_dominoes;\n    vector<vector<string>> jury_output_matrix;\n    readOutputDominoes(ans, jury_output_dominoes, jury_output_matrix);\n\n    // Verify that jury used the same dominoes\n    multiset<string> jury_domino_set;\n    for (const string& domino : jury_output_dominoes) {\n        // Since rotations are allowed, we store both the domino and its rotation\n        string rotated_domino = string() + domino[1] + domino[0];\n        if (input_domino_set.count(domino)) {\n            jury_domino_set.insert(domino);\n            input_domino_set.erase(input_domino_set.find(domino));\n        } else if (input_domino_set.count(rotated_domino)) {\n            jury_domino_set.insert(rotated_domino);\n            input_domino_set.erase(input_domino_set.find(rotated_domino));\n        } else {\n            ans.quitf(_fail, \"Jury output contains invalid domino: %s\", domino.c_str());\n        }\n    }\n    if (!input_domino_set.empty())\n        ans.quitf(_fail, \"Jury output missing some dominoes\");\n\n    int jury_max_sum = computeMaxColumnSum(jury_output_matrix);\n\n    // Read participant's answer\n    vector<string> participant_dominoes;\n    vector<vector<string>> participant_matrix;\n    readOutputDominoes(ouf, participant_dominoes, participant_matrix);\n\n    // Verify that participant used the same dominoes\n    multiset<string> participant_domino_set;\n    input_domino_set.clear();\n    for (const string& domino : input_dominoes) {\n        input_domino_set.insert(domino);\n    }\n    for (const string& domino : participant_dominoes) {\n        string rotated_domino = string() + domino[1] + domino[0];\n        if (input_domino_set.count(domino)) {\n            participant_domino_set.insert(domino);\n            input_domino_set.erase(input_domino_set.find(domino));\n        } else if (input_domino_set.count(rotated_domino)) {\n            participant_domino_set.insert(rotated_domino);\n            input_domino_set.erase(input_domino_set.find(rotated_domino));\n        } else {\n            ouf.quitf(_wa, \"Participant output contains invalid domino: %s\", domino.c_str());\n        }\n    }\n    if (!input_domino_set.empty())\n        ouf.quitf(_wa, \"Participant output missing some dominoes\");\n\n    int participant_max_sum = computeMaxColumnSum(participant_matrix);\n\n    if (participant_max_sum > jury_max_sum)\n        quitf(_wa, \"Participant's maximum column sum %d is larger than required %d\", participant_max_sum, jury_max_sum);\n    else if (participant_max_sum == jury_max_sum)\n        quitf(_ok, \"Correct. Maximum column sum = %d\", participant_max_sum);\n    else\n        quitf(_fail, \"Participant's maximum column sum %d is less than jury's %d\", participant_max_sum, jury_max_sum);\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<pair<int,int>>> dominoes(n, vector<pair<int,int>>(m));\n\n    if(type == \"random\"){\n        // Random zeros and ones\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j].first = rnd.next(0,1);\n                dominoes[i][j].second = rnd.next(0,1);\n            }\n        }\n    } else if(type == \"all_zero\"){\n        // All zeros\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j] = {0,0};\n            }\n        }\n    } else if(type == \"all_one\"){\n        // All ones\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j] = {1,1};\n            }\n        }\n    } else if(type == \"checkerboard\"){\n        // Checkerboard pattern\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                int val = (i + j) % 2;\n                dominoes[i][j].first = val;\n                dominoes[i][j].second = 1 - val;\n            }\n        }\n    } else if(type == \"max_column_sum\"){\n        // Maximize the sum in certain columns\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if((j % 2) == 0){\n                    dominoes[i][j] = {1,0};\n                } else {\n                    dominoes[i][j] = {0,1};\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j].first = rnd.next(0,1);\n                dominoes[i][j].second = rnd.next(0,1);\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < m; ++j){\n            printf(\"%d%d\", dominoes[i][j].first, dominoes[i][j].second);\n            if(j < m -1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<pair<int,int>>> dominoes(n, vector<pair<int,int>>(m));\n\n    if(type == \"random\"){\n        // Random zeros and ones\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j].first = rnd.next(0,1);\n                dominoes[i][j].second = rnd.next(0,1);\n            }\n        }\n    } else if(type == \"all_zero\"){\n        // All zeros\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j] = {0,0};\n            }\n        }\n    } else if(type == \"all_one\"){\n        // All ones\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j] = {1,1};\n            }\n        }\n    } else if(type == \"checkerboard\"){\n        // Checkerboard pattern\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                int val = (i + j) % 2;\n                dominoes[i][j].first = val;\n                dominoes[i][j].second = 1 - val;\n            }\n        }\n    } else if(type == \"max_column_sum\"){\n        // Maximize the sum in certain columns\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if((j % 2) == 0){\n                    dominoes[i][j] = {1,0};\n                } else {\n                    dominoes[i][j] = {0,1};\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                dominoes[i][j].first = rnd.next(0,1);\n                dominoes[i][j].second = rnd.next(0,1);\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < m; ++j){\n            printf(\"%d%d\", dominoes[i][j].first, dominoes[i][j].second);\n            if(j < m -1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_zero\n./gen -n 1 -m 1 -type all_one\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type checkerboard\n./gen -n 2 -m 2 -type random\n./gen -n 5 -m 5 -type all_zero\n./gen -n 5 -m 5 -type all_one\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type all_zero\n./gen -n 1000 -m 1000 -type all_one\n./gen -n 1000 -m 1000 -type checkerboard\n./gen -n 1000 -m 1000 -type max_column_sum\n./gen -n 100 -m 1000 -type random\n./gen -n 1000 -m 100 -type random\n./gen -n 999 -m 999 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 1 -m 1000 -type random\n./gen -n 1000 -m 1 -type random\n./gen -n 1 -m 1000 -type max_column_sum\n./gen -n 1000 -m 1 -type max_column_sum\n./gen -n 1000 -m 999 -type random\n./gen -n 999 -m 1000 -type random\n./gen -n 500 -m 1000 -type max_column_sum\n./gen -n 1000 -m 500 -type max_column_sum\n./gen -n 2 -m 1000 -type checkerboard\n./gen -n 1000 -m 2 -type checkerboard\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:10.525055",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "394/D",
      "title": "Problem 394/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    vector<int> h = inf.readInts(n, -10000, 10000, \"heights\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    vector<int> h = inf.readInts(n, -10000, 10000, \"heights\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n    vector<int> h = inf.readInts(n, -10000, 10000, \"heights\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int n = inf.readInt(2, 1000, \"n\");\n    vector<int> H(n);\n    for (int i = 0; i < n; i++) {\n        H[i] = inf.readInt(-10000, 10000, format(\"H[%d]\", i + 1).c_str());\n    }\n\n    // Read contestant's output\n    int M_c = ouf.readInt(0, 1000000000, \"M_c\");\n    int h_0 = ouf.readInt(-1000000000, 1000000000, \"h_0\");\n    int step = ouf.readInt(0, 1000000000, \"step\");\n    if (step < 0)\n        quitf(_wa, \"step is negative\");\n\n    // Build the adjusted heights\n    vector<int> A(n);\n    for (int i = 0; i < n; i++) {\n        A[i] = h_0 + step * i;\n    }\n\n    // Sort the initial heights and adjusted heights\n    sort(H.begin(), H.end());\n    sort(A.begin(), A.end());\n\n    // Calculate the number of buns each student needs\n    int M = 0;\n    for (int i = 0; i < n; i++) {\n        M = max(M, abs(H[i] - A[i]));\n    }\n\n    if (M != M_c)\n        quitf(_wa, \"Maximum number of buns computed %d does not match contestant's output %d\", M, M_c);\n\n    quitf(_ok, \"Accepted, maximum number of buns is %d\", M_c);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random heights in [-10000, 10000]\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    } else if (type == \"all_equal\") {\n        // All heights are equal\n        int h = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; i++) {\n            a[i] = h;\n        }\n    } else if (type == \"increasing\") {\n        // Heights in increasing order\n        int start = rnd.next(-10000, 10000 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Heights in decreasing order\n        int start = rnd.next(-10000 + n - 1, 10000);\n        for (int i = 0; i < n; i++) {\n            a[i] = start - i;\n        }\n    } else if (type == \"negatives\") {\n        // All negative heights\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10000, -1);\n        }\n    } else if (type == \"positives\") {\n        // All positive heights\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"zero_step\") {\n        // Heights close to each other to form a progression with step zero\n        int h = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; i++) {\n            int delta = rnd.next(-5, 5);\n            a[i] = h + delta;\n            if (a[i] > 10000) a[i] = 10000;\n            if (a[i] < -10000) a[i] = -10000;\n        }\n    } else if (type == \"max_buns\") {\n        // Heights alternating between -10000 and 10000 to maximize buns needed\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                a[i] = -10000;\n            } else {\n                a[i] = 10000;\n            }\n        }\n    } else if (type == \"large_heights\") {\n        // Heights are at extremes\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(0, 1) == 0)\n                a[i] = -10000;\n            else\n                a[i] = 10000;\n        }\n    } else {\n        // Default: random heights\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random heights in [-10000, 10000]\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    } else if (type == \"all_equal\") {\n        // All heights are equal\n        int h = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; i++) {\n            a[i] = h;\n        }\n    } else if (type == \"increasing\") {\n        // Heights in increasing order\n        int start = rnd.next(-10000, 10000 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Heights in decreasing order\n        int start = rnd.next(-10000 + n - 1, 10000);\n        for (int i = 0; i < n; i++) {\n            a[i] = start - i;\n        }\n    } else if (type == \"negatives\") {\n        // All negative heights\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10000, -1);\n        }\n    } else if (type == \"positives\") {\n        // All positive heights\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"zero_step\") {\n        // Heights close to each other to form a progression with step zero\n        int h = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; i++) {\n            int delta = rnd.next(-5, 5);\n            a[i] = h + delta;\n            if (a[i] > 10000) a[i] = 10000;\n            if (a[i] < -10000) a[i] = -10000;\n        }\n    } else if (type == \"max_buns\") {\n        // Heights alternating between -10000 and 10000 to maximize buns needed\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                a[i] = -10000;\n            } else {\n                a[i] = 10000;\n            }\n        }\n    } else if (type == \"large_heights\") {\n        // Heights are at extremes\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(0, 1) == 0)\n                a[i] = -10000;\n            else\n                a[i] = 10000;\n        }\n    } else {\n        // Default: random heights\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10000, 10000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type all_equal\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type negatives\n./gen -n 2 -type positives\n./gen -n 2 -type zero_step\n\n./gen -n 3 -type random\n./gen -n 3 -type max_buns\n\n./gen -n 10 -type random\n./gen -n 10 -type all_equal\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type negatives\n./gen -n 10 -type positives\n./gen -n 10 -type zero_step\n./gen -n 10 -type max_buns\n\n./gen -n 100 -type random\n./gen -n 100 -type all_equal\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type negatives\n./gen -n 100 -type positives\n./gen -n 100 -type zero_step\n./gen -n 100 -type max_buns\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_equal\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type negatives\n./gen -n 1000 -type positives\n./gen -n 1000 -type zero_step\n./gen -n 1000 -type max_buns\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:13.140830",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "394/E",
      "title": "E. Lightbulb for Minister",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 105) — the number of generators. Each of the next n lines contains a pair of integers xi, yi, representing the coordinates of the i-th generator in the plane of the class ceiling. It's guaranteed that no two generators have the same location.The next line contains integer m (3 ≤ m ≤ 105) — the number of vertexes in the convex polygon that describes the ceiling of the class. Each of the following m lines contains a pair of integers pi, qi, representing the coordinates of the i-th point of the polygon in the clockwise order. It's guaranteed that the polygon is strictly convex.The absolute value of all the coordinates don't exceed 106.",
      "output_spec": "OutputPrint a single real number — the minimum value of the sum of squares of distances from the generators to the point of the lightbulb's optimal position. The answer will be considered valid if its absolute or relative error doesn't exceed 10 - 4.",
      "sample_tests": "ExamplesInputCopy43 23 45 45 243 34 45 34 2OutputCopy8.00000000",
      "description": "E. Lightbulb for Minister\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 105) — the number of generators. Each of the next n lines contains a pair of integers xi, yi, representing the coordinates of the i-th generator in the plane of the class ceiling. It's guaranteed that no two generators have the same location.The next line contains integer m (3 ≤ m ≤ 105) — the number of vertexes in the convex polygon that describes the ceiling of the class. Each of the following m lines contains a pair of integers pi, qi, representing the coordinates of the i-th point of the polygon in the clockwise order. It's guaranteed that the polygon is strictly convex.The absolute value of all the coordinates don't exceed 106.\n\nOutputPrint a single real number — the minimum value of the sum of squares of distances from the generators to the point of the lightbulb's optimal position. The answer will be considered valid if its absolute or relative error doesn't exceed 10 - 4.\n\nInputCopy43 23 45 45 243 34 45 34 2OutputCopy8.00000000\n\nInputCopy43 23 45 45 243 34 45 34 2\n\nOutputCopy8.00000000\n\nNoteWe'll define a strictly convex polygon as a convex polygon with the following property: no three vertices of the polygon lie on the same line.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> generatorPoints;\n    \n    // Read n generator points\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        \n        pair<int, int> p = make_pair(xi, yi);\n        \n        // Check for duplicates\n        ensuref(generatorPoints.count(p) == 0, \"Duplicate generator point at line %d\", i+2);\n        generatorPoints.insert(p);\n    }\n    \n    // Read m\n    int m_vertices = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n    \n    vector<pair<int, int>> polygonPoints;\n    set<pair<int, int>> polygonPointSet;\n    \n    // Read m polygon points\n    for (int i = 0; i < m_vertices; ++i) {\n        int pi = inf.readInt(-1000000, 1000000, \"pi\");\n        inf.readSpace();\n        int qi = inf.readInt(-1000000, 1000000, \"qi\");\n        inf.readEoln();\n        \n        pair<int, int> p = make_pair(pi, qi);\n        \n        // Check for duplicates\n        ensuref(polygonPointSet.count(p) == 0, \"Duplicate polygon vertex at line %d\", n+3+i);\n        polygonPointSet.insert(p);\n        \n        polygonPoints.push_back(p);\n    }\n    \n    // Check that polygon is strictly convex\n    int sign = 0;\n    for (int i = 0; i < m_vertices; ++i) {\n        int x1 = polygonPoints[(i + 1) % m_vertices].first - polygonPoints[i].first;\n        int y1 = polygonPoints[(i + 1) % m_vertices].second - polygonPoints[i].second;\n        int x2 = polygonPoints[(i + 2) % m_vertices].first - polygonPoints[(i + 1) % m_vertices].first;\n        int y2 = polygonPoints[(i + 2) % m_vertices].second - polygonPoints[(i + 1) % m_vertices].second;\n        \n        int64_t cross = int64_t(x1) * y2 - int64_t(y1) * x2;\n        if (cross == 0) {\n            quitf(_fail, \"Polygon is not strictly convex (three consecutive points are colinear) at vertices %d, %d, %d\", \n                (i+1)%m_vertices+1, (i+2)%m_vertices+1, (i+3)%m_vertices+1);\n        }\n        int s = cross > 0 ? 1 : -1;\n        if (sign == 0) {\n            sign = s;\n        } else {\n            if (s != sign) {\n                quitf(_fail, \"Polygon is not convex at vertex %d\", (i+2)%m_vertices+1);\n            }\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> generatorPoints;\n    \n    // Read n generator points\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        \n        pair<int, int> p = make_pair(xi, yi);\n        \n        // Check for duplicates\n        ensuref(generatorPoints.count(p) == 0, \"Duplicate generator point at line %d\", i+2);\n        generatorPoints.insert(p);\n    }\n    \n    // Read m\n    int m_vertices = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n    \n    vector<pair<int, int>> polygonPoints;\n    set<pair<int, int>> polygonPointSet;\n    \n    // Read m polygon points\n    for (int i = 0; i < m_vertices; ++i) {\n        int pi = inf.readInt(-1000000, 1000000, \"pi\");\n        inf.readSpace();\n        int qi = inf.readInt(-1000000, 1000000, \"qi\");\n        inf.readEoln();\n        \n        pair<int, int> p = make_pair(pi, qi);\n        \n        // Check for duplicates\n        ensuref(polygonPointSet.count(p) == 0, \"Duplicate polygon vertex at line %d\", n+3+i);\n        polygonPointSet.insert(p);\n        \n        polygonPoints.push_back(p);\n    }\n    \n    // Check that polygon is strictly convex\n    int sign = 0;\n    for (int i = 0; i < m_vertices; ++i) {\n        int x1 = polygonPoints[(i + 1) % m_vertices].first - polygonPoints[i].first;\n        int y1 = polygonPoints[(i + 1) % m_vertices].second - polygonPoints[i].second;\n        int x2 = polygonPoints[(i + 2) % m_vertices].first - polygonPoints[(i + 1) % m_vertices].first;\n        int y2 = polygonPoints[(i + 2) % m_vertices].second - polygonPoints[(i + 1) % m_vertices].second;\n        \n        int64_t cross = int64_t(x1) * y2 - int64_t(y1) * x2;\n        if (cross == 0) {\n            quitf(_fail, \"Polygon is not strictly convex (three consecutive points are colinear) at vertices %d, %d, %d\", \n                (i+1)%m_vertices+1, (i+2)%m_vertices+1, (i+3)%m_vertices+1);\n        }\n        int s = cross > 0 ? 1 : -1;\n        if (sign == 0) {\n            sign = s;\n        } else {\n            if (s != sign) {\n                quitf(_fail, \"Polygon is not convex at vertex %d\", (i+2)%m_vertices+1);\n            }\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> generatorPoints;\n    \n    // Read n generator points\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n        \n        pair<int, int> p = make_pair(xi, yi);\n        \n        // Check for duplicates\n        ensuref(generatorPoints.count(p) == 0, \"Duplicate generator point at line %d\", i+2);\n        generatorPoints.insert(p);\n    }\n    \n    // Read m\n    int m_vertices = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n    \n    vector<pair<int, int>> polygonPoints;\n    set<pair<int, int>> polygonPointSet;\n    \n    // Read m polygon points\n    for (int i = 0; i < m_vertices; ++i) {\n        int pi = inf.readInt(-1000000, 1000000, \"pi\");\n        inf.readSpace();\n        int qi = inf.readInt(-1000000, 1000000, \"qi\");\n        inf.readEoln();\n        \n        pair<int, int> p = make_pair(pi, qi);\n        \n        // Check for duplicates\n        ensuref(polygonPointSet.count(p) == 0, \"Duplicate polygon vertex at line %d\", n+3+i);\n        polygonPointSet.insert(p);\n        \n        polygonPoints.push_back(p);\n    }\n    \n    // Check that polygon is strictly convex\n    int sign = 0;\n    for (int i = 0; i < m_vertices; ++i) {\n        int x1 = polygonPoints[(i + 1) % m_vertices].first - polygonPoints[i].first;\n        int y1 = polygonPoints[(i + 1) % m_vertices].second - polygonPoints[i].second;\n        int x2 = polygonPoints[(i + 2) % m_vertices].first - polygonPoints[(i + 1) % m_vertices].first;\n        int y2 = polygonPoints[(i + 2) % m_vertices].second - polygonPoints[(i + 1) % m_vertices].second;\n        \n        int64_t cross = int64_t(x1) * y2 - int64_t(y1) * x2;\n        if (cross == 0) {\n            quitf(_fail, \"Polygon is not strictly convex (three consecutive points are colinear) at vertices %d, %d, %d\", \n                (i+1)%m_vertices+1, (i+2)%m_vertices+1, (i+3)%m_vertices+1);\n        }\n        int s = cross > 0 ? 1 : -1;\n        if (sign == 0) {\n            sign = s;\n        } else {\n            if (s != sign) {\n                quitf(_fail, \"Polygon is not convex at vertex %d\", (i+2)%m_vertices+1);\n            }\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int COORD_LIMIT = int(1e6);\n\n// Function to generate a regular convex polygon with m vertices, centered at (cx, cy), radius r\nvector<pair<int, int>> generateRegularPolygon(int m, double cx, double cy, double radius) {\n    vector<pair<int, int>> polygon;\n    double angleIncrement = 2 * M_PI / m;\n    double angle = 0;\n    for (int i = 0; i < m; ++i) {\n        double x = cx + radius * cos(angle);\n        double y = cy + radius * sin(angle);\n        polygon.push_back({(int)round(x), (int)round(y)});\n        angle -= angleIncrement;  // Negative to ensure clockwise order\n    }\n    // Ensure no three vertices are colinear\n    // In a regular polygon, no three vertices are colinear\n    return polygon;\n}\n\n// Function to generate n unique generator positions according to generator_type\nvector<pair<int, int>> generateGenerators(int n, const string& generator_type, double cx, double cy, double spread) {\n    set<pair<int, int>> points;\n    vector<pair<int, int>> generators;\n\n    if (generator_type == \"random\") {\n        while ((int)points.size() < n) {\n            int x = rnd.next(-COORD_LIMIT, COORD_LIMIT);\n            int y = rnd.next(-COORD_LIMIT, COORD_LIMIT);\n            if (points.insert({x, y}).second) {\n                generators.push_back({x, y});\n            }\n        }\n    } else if (generator_type == \"clustered\") {\n        while ((int)points.size() < n) {\n            int x = (int)(rnd.next(-spread, spread) + cx);\n            int y = (int)(rnd.next(-spread, spread) + cy);\n            x = max(-COORD_LIMIT, min(COORD_LIMIT, x));\n            y = max(-COORD_LIMIT, min(COORD_LIMIT, y));\n            if (points.insert({x, y}).second) {\n                generators.push_back({x, y});\n            }\n        }\n    } else if (generator_type == \"line\") {\n        // Generate points along a line\n        int x0 = rnd.next(-COORD_LIMIT/2, COORD_LIMIT/2);\n        int y0 = rnd.next(-COORD_LIMIT/2, COORD_LIMIT/2);\n        int dx = rnd.next(1, max(1, COORD_LIMIT / n));\n        int dy = rnd.next(1, max(1, COORD_LIMIT / n));\n        for (int i = 0; i < n; ++i) {\n            int x = x0 + i * dx;\n            int y = y0 + i * dy;\n            x = max(-COORD_LIMIT, min(COORD_LIMIT, x));\n            y = max(-COORD_LIMIT, min(COORD_LIMIT, y));\n            if (points.insert({x, y}).second) {\n                generators.push_back({x, y});\n            } else {\n                // Adjust slightly if duplicate\n                x += rnd.next(-10,10);\n                y += rnd.next(-10,10);\n                x = max(-COORD_LIMIT, min(COORD_LIMIT, x));\n                y = max(-COORD_LIMIT, min(COORD_LIMIT, y));\n                if (points.insert({x, y}).second) {\n                    generators.push_back({x, y});\n                }\n            }\n        }\n    } else if (generator_type == \"circle\") {\n        double radius = min(COORD_LIMIT / 2.0, spread);\n        double angle = rnd.next(0.0, 2*M_PI);\n        double angleIncrement = 2*M_PI / n;\n        for (int i = 0; i < n; ++i) {\n            double x = cx + radius * cos(angle);\n            double y = cy + radius * sin(angle);\n            int ix = (int)round(x);\n            int iy = (int)round(y);\n            ix = max(-COORD_LIMIT, min(COORD_LIMIT, ix));\n            iy = max(-COORD_LIMIT, min(COORD_LIMIT, iy));\n            if (points.insert({ix, iy}).second) {\n                generators.push_back({ix, iy});\n            } else {\n                // Adjust slightly if duplicate\n                ix += rnd.next(-10,10);\n                iy += rnd.next(-10,10);\n                ix = max(-COORD_LIMIT, min(COORD_LIMIT, ix));\n                iy = max(-COORD_LIMIT, min(COORD_LIMIT, iy));\n                if (points.insert({ix, iy}).second) {\n                    generators.push_back({ix, iy});\n                }\n            }\n            angle += angleIncrement;\n        }\n    }\n    return generators;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string polygon_type = opt<string>(\"polygon_type\", \"big\");\n    string generator_type = opt<string>(\"generator_type\", \"random\");\n\n    // Set center and spread\n    double cx = 0.0, cy = 0.0;\n    double polygon_radius = COORD_LIMIT / 2.0;\n    double generator_spread = COORD_LIMIT / 2.0;\n\n    // Adjust center and spread based on polygon_type\n    if (polygon_type == \"big\") {\n        // Big polygon covering most of the coordinate space\n        polygon_radius = COORD_LIMIT * 0.9;\n        generator_spread = COORD_LIMIT * 0.8;\n        cx = 0; cy = 0;\n    } else if (polygon_type == \"small\") {\n        // Small polygon centered away from generators\n        cx = COORD_LIMIT * 0.8;\n        cy = COORD_LIMIT * 0.8;\n        polygon_radius = COORD_LIMIT * 0.1;\n        // Generators centered at origin\n        generator_spread = COORD_LIMIT * 0.1;\n    } else if (polygon_type == \"around_generators\") {\n        // Center polygon around generators\n        cx = 0.0;\n        cy = 0.0;\n        polygon_radius = COORD_LIMIT * 0.5;\n        generator_spread = COORD_LIMIT * 0.4;\n    }\n\n    // Generate polygon\n    vector<pair<int, int>> polygon = generateRegularPolygon(m, cx, cy, polygon_radius);\n\n    // Ensure coordinates are within limits\n    for (auto& p : polygon) {\n        p.first = max(-COORD_LIMIT, min(COORD_LIMIT, p.first));\n        p.second = max(-COORD_LIMIT, min(COORD_LIMIT, p.second));\n    }\n\n    // Now generate generators\n    // For 'small' polygon, generators are centered at (0,0)\n    // For 'big' polygon, generators are spread out around (0,0)\n    double gen_cx = 0.0, gen_cy = 0.0;\n    vector<pair<int, int>> generators = generateGenerators(n, generator_type, gen_cx, gen_cy, generator_spread);\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (const auto& gen : generators) {\n        printf(\"%d %d\\n\", gen.first, gen.second);\n    }\n    printf(\"%d\\n\", m);\n    for (const auto& p : polygon) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int COORD_LIMIT = int(1e6);\n\n// Function to generate a regular convex polygon with m vertices, centered at (cx, cy), radius r\nvector<pair<int, int>> generateRegularPolygon(int m, double cx, double cy, double radius) {\n    vector<pair<int, int>> polygon;\n    double angleIncrement = 2 * M_PI / m;\n    double angle = 0;\n    for (int i = 0; i < m; ++i) {\n        double x = cx + radius * cos(angle);\n        double y = cy + radius * sin(angle);\n        polygon.push_back({(int)round(x), (int)round(y)});\n        angle -= angleIncrement;  // Negative to ensure clockwise order\n    }\n    // Ensure no three vertices are colinear\n    // In a regular polygon, no three vertices are colinear\n    return polygon;\n}\n\n// Function to generate n unique generator positions according to generator_type\nvector<pair<int, int>> generateGenerators(int n, const string& generator_type, double cx, double cy, double spread) {\n    set<pair<int, int>> points;\n    vector<pair<int, int>> generators;\n\n    if (generator_type == \"random\") {\n        while ((int)points.size() < n) {\n            int x = rnd.next(-COORD_LIMIT, COORD_LIMIT);\n            int y = rnd.next(-COORD_LIMIT, COORD_LIMIT);\n            if (points.insert({x, y}).second) {\n                generators.push_back({x, y});\n            }\n        }\n    } else if (generator_type == \"clustered\") {\n        while ((int)points.size() < n) {\n            int x = (int)(rnd.next(-spread, spread) + cx);\n            int y = (int)(rnd.next(-spread, spread) + cy);\n            x = max(-COORD_LIMIT, min(COORD_LIMIT, x));\n            y = max(-COORD_LIMIT, min(COORD_LIMIT, y));\n            if (points.insert({x, y}).second) {\n                generators.push_back({x, y});\n            }\n        }\n    } else if (generator_type == \"line\") {\n        // Generate points along a line\n        int x0 = rnd.next(-COORD_LIMIT/2, COORD_LIMIT/2);\n        int y0 = rnd.next(-COORD_LIMIT/2, COORD_LIMIT/2);\n        int dx = rnd.next(1, max(1, COORD_LIMIT / n));\n        int dy = rnd.next(1, max(1, COORD_LIMIT / n));\n        for (int i = 0; i < n; ++i) {\n            int x = x0 + i * dx;\n            int y = y0 + i * dy;\n            x = max(-COORD_LIMIT, min(COORD_LIMIT, x));\n            y = max(-COORD_LIMIT, min(COORD_LIMIT, y));\n            if (points.insert({x, y}).second) {\n                generators.push_back({x, y});\n            } else {\n                // Adjust slightly if duplicate\n                x += rnd.next(-10,10);\n                y += rnd.next(-10,10);\n                x = max(-COORD_LIMIT, min(COORD_LIMIT, x));\n                y = max(-COORD_LIMIT, min(COORD_LIMIT, y));\n                if (points.insert({x, y}).second) {\n                    generators.push_back({x, y});\n                }\n            }\n        }\n    } else if (generator_type == \"circle\") {\n        double radius = min(COORD_LIMIT / 2.0, spread);\n        double angle = rnd.next(0.0, 2*M_PI);\n        double angleIncrement = 2*M_PI / n;\n        for (int i = 0; i < n; ++i) {\n            double x = cx + radius * cos(angle);\n            double y = cy + radius * sin(angle);\n            int ix = (int)round(x);\n            int iy = (int)round(y);\n            ix = max(-COORD_LIMIT, min(COORD_LIMIT, ix));\n            iy = max(-COORD_LIMIT, min(COORD_LIMIT, iy));\n            if (points.insert({ix, iy}).second) {\n                generators.push_back({ix, iy});\n            } else {\n                // Adjust slightly if duplicate\n                ix += rnd.next(-10,10);\n                iy += rnd.next(-10,10);\n                ix = max(-COORD_LIMIT, min(COORD_LIMIT, ix));\n                iy = max(-COORD_LIMIT, min(COORD_LIMIT, iy));\n                if (points.insert({ix, iy}).second) {\n                    generators.push_back({ix, iy});\n                }\n            }\n            angle += angleIncrement;\n        }\n    }\n    return generators;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string polygon_type = opt<string>(\"polygon_type\", \"big\");\n    string generator_type = opt<string>(\"generator_type\", \"random\");\n\n    // Set center and spread\n    double cx = 0.0, cy = 0.0;\n    double polygon_radius = COORD_LIMIT / 2.0;\n    double generator_spread = COORD_LIMIT / 2.0;\n\n    // Adjust center and spread based on polygon_type\n    if (polygon_type == \"big\") {\n        // Big polygon covering most of the coordinate space\n        polygon_radius = COORD_LIMIT * 0.9;\n        generator_spread = COORD_LIMIT * 0.8;\n        cx = 0; cy = 0;\n    } else if (polygon_type == \"small\") {\n        // Small polygon centered away from generators\n        cx = COORD_LIMIT * 0.8;\n        cy = COORD_LIMIT * 0.8;\n        polygon_radius = COORD_LIMIT * 0.1;\n        // Generators centered at origin\n        generator_spread = COORD_LIMIT * 0.1;\n    } else if (polygon_type == \"around_generators\") {\n        // Center polygon around generators\n        cx = 0.0;\n        cy = 0.0;\n        polygon_radius = COORD_LIMIT * 0.5;\n        generator_spread = COORD_LIMIT * 0.4;\n    }\n\n    // Generate polygon\n    vector<pair<int, int>> polygon = generateRegularPolygon(m, cx, cy, polygon_radius);\n\n    // Ensure coordinates are within limits\n    for (auto& p : polygon) {\n        p.first = max(-COORD_LIMIT, min(COORD_LIMIT, p.first));\n        p.second = max(-COORD_LIMIT, min(COORD_LIMIT, p.second));\n    }\n\n    // Now generate generators\n    // For 'small' polygon, generators are centered at (0,0)\n    // For 'big' polygon, generators are spread out around (0,0)\n    double gen_cx = 0.0, gen_cy = 0.0;\n    vector<pair<int, int>> generators = generateGenerators(n, generator_type, gen_cx, gen_cy, generator_spread);\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (const auto& gen : generators) {\n        printf(\"%d %d\\n\", gen.first, gen.second);\n    }\n    printf(\"%d\\n\", m);\n    for (const auto& p : polygon) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m\n./gen -n 2 -m 3 -polygon_type big -generator_type random\n./gen -n 2 -m 3 -polygon_type small -generator_type random\n\n# Generators clustered, centroid inside polygon\n./gen -n 1000 -m 1000 -polygon_type big -generator_type clustered\n\n# Generators clustered, centroid outside polygon\n./gen -n 1000 -m 1000 -polygon_type small -generator_type clustered\n\n# Generators on a line\n./gen -n 1000 -m 5000 -polygon_type big -generator_type line\n\n# Generators forming a circle\n./gen -n 1000 -m 1000 -polygon_type big -generator_type circle\n\n# Minimal m\n./gen -n 5000 -m 3 -polygon_type big -generator_type random\n\n# Maximal m\n./gen -n 5000 -m 100000 -polygon_type big -generator_type random\n\n# n and m both maximum\n./gen -n 100000 -m 100000 -polygon_type big -generator_type clustered\n\n# Edge case: centroid outside polygon\n./gen -n 50000 -m 100000 -polygon_type small -generator_type clustered\n\n# Edge case: n = 2\n./gen -n 2 -m 100000 -polygon_type big -generator_type random\n\n# Edge case: m = 3\n./gen -n 100000 -m 3 -polygon_type big -generator_type random\n\n# Random generators, polygon around generators\n./gen -n 1000 -m 1000 -polygon_type around_generators -generator_type random\n\n# Generators forming a line, centroid outside polygon\n./gen -n 100000 -m 1000 -polygon_type small -generator_type line\n\n# Generators forming circle, polygon does not contain centroid\n./gen -n 1000 -m 100000 -polygon_type small -generator_type circle\n\n# Generators clustered, small polygon\n./gen -n 99999 -m 100000 -polygon_type small -generator_type clustered\n\n# Small n, small m\n./gen -n 1 -m 3 -polygon_type big -generator_type random\n\n# Maximum coordinates\n./gen -n 100000 -m 100000 -polygon_type big -generator_type random\n\n# Mixed small and large numbers\n./gen -n 50000 -m 50000 -polygon_type big -generator_type random\n\n# Generators clustered, centroid exactly on the edge of polygon\n./gen -n 1000 -m 4 -polygon_type small -generator_type clustered\n\n# Generators in circle, large polygon\n./gen -n 50000 -m 100000 -polygon_type big -generator_type circle\n\n# Generators on a line, minimal m\n./gen -n 100000 -m 3 -polygon_type big -generator_type line\n\n# Random generators, maximal n and m\n./gen -n 100000 -m 100000 -polygon_type big -generator_type random\n\n# Generators forming a circle, small polygon\n./gen -n 1000 -m 1000 -polygon_type small -generator_type circle\n\n# Generators forming a line, small polygon\n./gen -n 1000 -m 1000 -polygon_type small -generator_type line\n\n# Generators random, polygon around generators\n./gen -n 50000 -m 50000 -polygon_type around_generators -generator_type random\n\n# Edge case: single generator\n./gen -n 2 -m 3 -polygon_type big -generator_type random\n\n# Edge case: maximum generators, minimal polygon\n./gen -n 100000 -m 3 -polygon_type big -generator_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:14.781971",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "396/A",
      "title": "A. On Number of Decompositions into Multipliers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains positive integer n (1 ≤ n ≤ 500). The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).",
      "output_spec": "OutputIn a single line print a single number k — the number of distinct decompositions of number m into n ordered multipliers modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy115OutputCopy1InputCopy31 1 2OutputCopy3InputCopy25 7OutputCopy4",
      "description": "A. On Number of Decompositions into Multipliers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains positive integer n (1 ≤ n ≤ 500). The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nOutputIn a single line print a single number k — the number of distinct decompositions of number m into n ordered multipliers modulo 1000000007 (109 + 7).\n\nInputCopy115OutputCopy1InputCopy31 1 2OutputCopy3InputCopy25 7OutputCopy4\n\nInputCopy115\n\nOutputCopy1\n\nInputCopy31 1 2\n\nOutputCopy3\n\nInputCopy25 7\n\nOutputCopy4\n\nNoteIn the second sample, the get a decomposition of number 2, you need any one number out of three to equal 2, and the rest to equal 1.In the third sample, the possible ways of decomposing into ordered multipliers are [7,5], [5,7], [1,35], [35,1].A decomposition of positive integer m into n ordered multipliers is a cortege of positive integers b = {b1, b2, ... bn} such that . Two decompositions b and c are considered different, if there exists index i such that bi ≠ ci.",
      "solutions": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces",
          "content": "Div2-ACreate an array used of 100 elements. i-th element for the segment (i, i + 1).For every student except Alexey set used[i]  =  true for each segment (i,  i  +  1) in the segment of that student. After that for each subsegment (i,  i  +  1) of Alexey's segment add 1 to result if used[i]  =  false.Div2-BFirst of all, calculate how many L's we can bring so that the result will not exceed N. It's .Now, if R·K  ≥  N we may increase any of K numbers by 1. At some moment sum will be equal to N becase sum of K R's is greater than N. So answer in this case is YES.If R·K  <  N, we can't get K or less numbers because their sum is less than N. But we can't get more than K numbers too, because their sum is more than N. So answer is NO.Complexity: O(1) for every query. Overall complexity: O(t).Div1-A/Div2-CLet's factorize all n numbers into prime factors. Now we should solve the problem for every prime independently and multiply these answers. The number of ways to split pk into n multipliers, where p is prime, is equal to C(k  +  n  -  1,  n  -  1) (it can be obtained using the method of stars and bars, you can read about it here, choose 'combinatorics'). So we have a solution that needs time.Div1-B/Div2-DFirst of all, let's consider n  +  1  =  p is prime. Then we can prove by induction that the answer is . Base for p  =  3 is obvious. If this equality holds for p, and q is the next prime, then answer for q is equal to answer for p plus q  -  p equal summands , that is , that's we wanted to prove.Next using that the distance between two consecutive primes not exceeding 109 does not exceed 300, we can find the answer as a sum of the answer for the maximal prime not exceeding n and several equal summands . We see that the denominator is a divisor of 2pq, which fits in long long.Div1-C/Div2-EWe can write all vertices in the list in order of dfs, then the descendants of the vertex from a segment of this list. Let's count for every vertex its distance to the root level[v].Let's create two segment trees st1 and st2. If we are given a query of the first type, in st1 we add x  +  level[v]·k to the segment corresponding to the vertex v, in st2 we add k to the segment corresponding to the vertex v.If we are given a query of the second type, we write st1.get(v) - st2.get(v) * level[v].The complexity is O(qlogn).You can use any other data stucture that allows to add to the segment and to find a value of an arbitrary element.Also there exists a solution using Heavy-Light decomposition.Div1-DLet's prove a useful fact: sum of number of invertions for all permutations of size k is equal to . The prove is simple: let's change in permutation p for every i pi to k  +  1  -  pi. Then the sum of number of invertions of the first and the second permutations is , and our conversion of the permutation is a biection.Now we suppose that we are given a permutation of numbers from 0 to n  -  1.Let's go at p from left to right. What permutations are less than p? Permutations having first number less than p0. If the first number is a  <  p0, than in every such permutation there are a inversions of form (first element, some other element). So in all permutations beginning with a there are a·(n  -  1)! inversions of this from. Moreover, there are inversions not including the first element, their sum is sumAll[n  -  1]. Then, counting sum for all a we have inversions. Permutations beginning with p0. At first, we should count the number of inversions, beginning in p0. There are cnt·p0 of this form, where cnt is the number of permutations beginning with p0 and not exceeding p. Then we should count the inversions not beginning in the beginning. But it is the same problem! The only exception is that if p1  >  p0, there are p1  -  1 available numbers less than p1, but not p1. So we get a solution: go from left to right, keep already used numbers in Fenwick tree, and then solve the same problem, assuming that the first number is not pi but pi - (the number of used numbers less than pi). The last we should do is to count the number of permutations not exceeding the suffix of p and beginning the same. It can be precomputed, if we go from right to left. In this case we should do the same as in the first part of solution, but consider that the minimal number is a number of already used numbers less than current.Div1-EWe will describe an algorithm and then understand why it works.For every prime we will maintain a list of intervals. At the first moment for every pi we add in its list interval [0;ai), other primes have an empty list.Then we go from big primes to small. Let's consider that current prime is p. If in its list there exists an interval [x;y), $x < k, y > k$, we divide it into two parts [x;k) and [k;y).Then for every interval [x;y), x  ≥  k (in fact, in this case x  =  k) we add to the answer for p y  -  x. For intervals, where y  ≤  k, we add to list of every prime divisor of p  -  1 invterval [x  +  1,  y  +  1). If p  -  1 has some prime if more than first power, we should add this segment several times.After that we should conduct a \"union with displacement\" operation for every prime which list was changed. If in one list there are 2 invervals [x,  y), [z,  t) so that y  ≤  z  >  x, we replace them with one interval [x,  y  +  t  -  z) (so we added t  -  z to the right border of the first interval). Then we go to next (lesser) p.Why does it works? If we take function φ one time, for every prime p which divides n, n is divided by p and multiplied by p  -  1 (or, the same, by all prime divisors p  -  1 in corresponding powers).Now we can observe that intervals in lists contains the numbers of iterations, when the number contains the corresponding prime number. Bigger primes do not affect smaller, so we can process them earlier. If after i-th iteration the number contains prime number p, after i  +  1-th iteration it contains prime divisors of p  -  1, and we add segments in accordance with this. The k-th iteration is the last, so the existence of the interval [k,  x) means that after k-th iteration we have (x  -  k)-th power of this prime. From this it is clear why we unite the intervals if that way.Why does it work fast? Because we precalculated the minimal prime divisor of each number up to MAXPRIME using linear Eratosthenes sieve. (Well, it's not necessary) Because for each prime there's no more than intervals, because for each [a,  b) range . Practically there is no more than 6 segments at once. Any questions about the editorial are welcome! Especially the English one :)This post was restored from google cache, and I have edited formula once again. If you notice some mistake, please send be a private message.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10713",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6701
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces - Code 1",
          "code": "st1.get(v) - st2.get(v) * level[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10713",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 1, 1000000000LL, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 1, 1000000000LL, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<long long> a = inf.readLongs(n, 1, 1000000000LL, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"small\") {\n        /* Generate small values for ai (from 1 to 10) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        /* Generate large values for ai (from 1e8 to 1e9) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(100000000, 1000000000);\n    } else if (type == \"ones\") {\n        /* All ai are 1 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"twos\") {\n        /* All ai are 2 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 2;\n    } else if (type == \"random\") {\n        /* Generate random values for ai (from 1 to 1e9) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    } else {\n        /* Default: Generate random values for ai (from 1 to 1e9) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output ai\n    for (int i = 0; i < n; ++i)\n        cout << ai[i] << (i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"small\") {\n        /* Generate small values for ai (from 1 to 10) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        /* Generate large values for ai (from 1e8 to 1e9) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(100000000, 1000000000);\n    } else if (type == \"ones\") {\n        /* All ai are 1 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"twos\") {\n        /* All ai are 2 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 2;\n    } else if (type == \"random\") {\n        /* Generate random values for ai (from 1 to 1e9) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    } else {\n        /* Default: Generate random values for ai (from 1 to 1e9) */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output ai\n    for (int i = 0; i < n; ++i)\n        cout << ai[i] << (i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 1 -type small\n./gen -n 1 -type large\n./gen -n 1 -type random\n\n./gen -n 2 -type ones\n./gen -n 2 -type small\n./gen -n 2 -type large\n./gen -n 2 -type random\n\n./gen -n 3 -type ones\n./gen -n 3 -type small\n./gen -n 3 -type large\n./gen -n 3 -type random\n\n./gen -n 10 -type ones\n./gen -n 10 -type small\n./gen -n 10 -type large\n./gen -n 10 -type random\n\n./gen -n 100 -type ones\n./gen -n 100 -type small\n./gen -n 100 -type large\n./gen -n 100 -type random\n\n./gen -n 500 -type ones\n./gen -n 500 -type small\n./gen -n 500 -type large\n./gen -n 500 -type random\n\n./gen -n 500 -type twos\n./gen -n 500 -type small\n./gen -n 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:16.928371",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "396/B",
      "title": "B. On Sum of Fractions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer t (1 ≤ t ≤ 500) — the number of testscases. Each of the following t lines of the input contains integer n (2 ≤ n ≤ 109).",
      "output_spec": "OutputPrint t lines: the i-th of them must contain the answer to the i-th test as an irreducible fraction \"p/q\", where p, q are integers, q > 0.",
      "sample_tests": "ExamplesInputCopy223OutputCopy1/67/30",
      "description": "B. On Sum of Fractions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer t (1 ≤ t ≤ 500) — the number of testscases. Each of the following t lines of the input contains integer n (2 ≤ n ≤ 109).\n\nOutputPrint t lines: the i-th of them must contain the answer to the i-th test as an irreducible fraction \"p/q\", where p, q are integers, q > 0.\n\nInputCopy223OutputCopy1/67/30\n\nInputCopy223\n\nOutputCopy1/67/30",
      "solutions": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces",
          "content": "Div2-ACreate an array used of 100 elements. i-th element for the segment (i, i + 1).For every student except Alexey set used[i]  =  true for each segment (i,  i  +  1) in the segment of that student. After that for each subsegment (i,  i  +  1) of Alexey's segment add 1 to result if used[i]  =  false.Div2-BFirst of all, calculate how many L's we can bring so that the result will not exceed N. It's .Now, if R·K  ≥  N we may increase any of K numbers by 1. At some moment sum will be equal to N becase sum of K R's is greater than N. So answer in this case is YES.If R·K  <  N, we can't get K or less numbers because their sum is less than N. But we can't get more than K numbers too, because their sum is more than N. So answer is NO.Complexity: O(1) for every query. Overall complexity: O(t).Div1-A/Div2-CLet's factorize all n numbers into prime factors. Now we should solve the problem for every prime independently and multiply these answers. The number of ways to split pk into n multipliers, where p is prime, is equal to C(k  +  n  -  1,  n  -  1) (it can be obtained using the method of stars and bars, you can read about it here, choose 'combinatorics'). So we have a solution that needs time.Div1-B/Div2-DFirst of all, let's consider n  +  1  =  p is prime. Then we can prove by induction that the answer is . Base for p  =  3 is obvious. If this equality holds for p, and q is the next prime, then answer for q is equal to answer for p plus q  -  p equal summands , that is , that's we wanted to prove.Next using that the distance between two consecutive primes not exceeding 109 does not exceed 300, we can find the answer as a sum of the answer for the maximal prime not exceeding n and several equal summands . We see that the denominator is a divisor of 2pq, which fits in long long.Div1-C/Div2-EWe can write all vertices in the list in order of dfs, then the descendants of the vertex from a segment of this list. Let's count for every vertex its distance to the root level[v].Let's create two segment trees st1 and st2. If we are given a query of the first type, in st1 we add x  +  level[v]·k to the segment corresponding to the vertex v, in st2 we add k to the segment corresponding to the vertex v.If we are given a query of the second type, we write st1.get(v) - st2.get(v) * level[v].The complexity is O(qlogn).You can use any other data stucture that allows to add to the segment and to find a value of an arbitrary element.Also there exists a solution using Heavy-Light decomposition.Div1-DLet's prove a useful fact: sum of number of invertions for all permutations of size k is equal to . The prove is simple: let's change in permutation p for every i pi to k  +  1  -  pi. Then the sum of number of invertions of the first and the second permutations is , and our conversion of the permutation is a biection.Now we suppose that we are given a permutation of numbers from 0 to n  -  1.Let's go at p from left to right. What permutations are less than p? Permutations having first number less than p0. If the first number is a  <  p0, than in every such permutation there are a inversions of form (first element, some other element). So in all permutations beginning with a there are a·(n  -  1)! inversions of this from. Moreover, there are inversions not including the first element, their sum is sumAll[n  -  1]. Then, counting sum for all a we have inversions. Permutations beginning with p0. At first, we should count the number of inversions, beginning in p0. There are cnt·p0 of this form, where cnt is the number of permutations beginning with p0 and not exceeding p. Then we should count the inversions not beginning in the beginning. But it is the same problem! The only exception is that if p1  >  p0, there are p1  -  1 available numbers less than p1, but not p1. So we get a solution: go from left to right, keep already used numbers in Fenwick tree, and then solve the same problem, assuming that the first number is not pi but pi - (the number of used numbers less than pi). The last we should do is to count the number of permutations not exceeding the suffix of p and beginning the same. It can be precomputed, if we go from right to left. In this case we should do the same as in the first part of solution, but consider that the minimal number is a number of already used numbers less than current.Div1-EWe will describe an algorithm and then understand why it works.For every prime we will maintain a list of intervals. At the first moment for every pi we add in its list interval [0;ai), other primes have an empty list.Then we go from big primes to small. Let's consider that current prime is p. If in its list there exists an interval [x;y), $x < k, y > k$, we divide it into two parts [x;k) and [k;y).Then for every interval [x;y), x  ≥  k (in fact, in this case x  =  k) we add to the answer for p y  -  x. For intervals, where y  ≤  k, we add to list of every prime divisor of p  -  1 invterval [x  +  1,  y  +  1). If p  -  1 has some prime if more than first power, we should add this segment several times.After that we should conduct a \"union with displacement\" operation for every prime which list was changed. If in one list there are 2 invervals [x,  y), [z,  t) so that y  ≤  z  >  x, we replace them with one interval [x,  y  +  t  -  z) (so we added t  -  z to the right border of the first interval). Then we go to next (lesser) p.Why does it works? If we take function φ one time, for every prime p which divides n, n is divided by p and multiplied by p  -  1 (or, the same, by all prime divisors p  -  1 in corresponding powers).Now we can observe that intervals in lists contains the numbers of iterations, when the number contains the corresponding prime number. Bigger primes do not affect smaller, so we can process them earlier. If after i-th iteration the number contains prime number p, after i  +  1-th iteration it contains prime divisors of p  -  1, and we add segments in accordance with this. The k-th iteration is the last, so the existence of the interval [k,  x) means that after k-th iteration we have (x  -  k)-th power of this prime. From this it is clear why we unite the intervals if that way.Why does it work fast? Because we precalculated the minimal prime divisor of each number up to MAXPRIME using linear Eratosthenes sieve. (Well, it's not necessary) Because for each prime there's no more than intervals, because for each [a,  b) range . Practically there is no more than 6 segments at once. Any questions about the editorial are welcome! Especially the English one :)This post was restored from google cache, and I have edited formula once again. If you notice some mistake, please send be a private message.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10713",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6701
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces - Code 1",
          "code": "st1.get(v) - st2.get(v) * level[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10713",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 500, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(2, 1000000000, \"n\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 500, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(2, 1000000000, \"n\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 500, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(2, 1000000000, \"n\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    vector<long long> n_values(t);\n\n    if (type == \"small_random\") {\n        // n in [2, 1000]\n        for(int i = 0; i < t; ++i) {\n            long long n = rnd.next(2LL, 1000LL);\n            n_values[i] = n;\n        }\n    } else if (type == \"large_random\") {\n        // n in [1e8, 1e9]\n        for(int i = 0; i < t; ++i) {\n            long long n = rnd.next(100000000LL, 1000000000LL);\n            n_values[i] = n;\n        }\n    } else if (type == \"n_is_prime\") {\n        // Predefined list of known primes less than or equal to 1e9\n        vector<long long> known_primes = {\n            2LL, 3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, \n            999999937LL, 999999929LL, 999999893LL, 999999883LL, \n            999999797LL, 999999761LL, 1000000007LL, 1000000009LL, \n            10000000033LL\n        };\n\n        for(int i = 0; i < t; ++i) {\n            int idx = rnd.next(0, (int)known_primes.size() - 1);\n            long long n = known_primes[idx];\n            while (n > 1000000000LL) {\n                idx = rnd.next(0, (int)known_primes.size() - 1);\n                n = known_primes[idx];\n            }\n            n_values[i] = n;\n        }\n    } else if (type == \"n_just_before_prime\") {\n        // n such that n + 1 is prime\n        vector<long long> known_primes = {\n            3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, \n            999999937LL, 999999929LL, 999999893LL, 999999883LL, \n            999999797LL, 999999761LL\n        };\n\n        for(int i = 0; i < t; ++i) {\n            int idx = rnd.next(0, (int)known_primes.size() - 1);\n            long long n = known_primes[idx] - 1;\n            if (n < 2LL) n = 2LL;\n            n_values[i] = n;\n        }\n    } else if (type == \"n_just_after_prime\") {\n        // n such that n - 1 is prime\n        vector<long long> known_primes = {\n            2LL, 3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, \n            999999937LL, 999999929LL, 999999893LL, 999999883LL, \n            999999797LL, 999999761LL\n        };\n\n        for(int i = 0; i < t; ++i) {\n            int idx = rnd.next(0, (int)known_primes.size() - 1);\n            long long n = known_primes[idx] + 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n            n_values[i] = n;\n        }\n    } else if (type == \"max_n\") {\n        for(int i = 0; i < t; ++i) {\n            n_values[i] = 1000000000LL;\n        }\n    } else if (type == \"min_n\") {\n        for(int i = 0; i < t; ++i) {\n            n_values[i] = 2LL;\n        }\n    } else {\n        // Default: n in [2, 1e9]\n        for(int i = 0; i < t; ++i) {\n            long long n = rnd.next(2LL, 1000000000LL);\n            n_values[i] = n;\n        }\n    }\n\n    // Output n_values\n    for(int i = 0; i < t; ++i) {\n        printf(\"%lld\\n\", n_values[i]);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    vector<long long> n_values(t);\n\n    if (type == \"small_random\") {\n        // n in [2, 1000]\n        for(int i = 0; i < t; ++i) {\n            long long n = rnd.next(2LL, 1000LL);\n            n_values[i] = n;\n        }\n    } else if (type == \"large_random\") {\n        // n in [1e8, 1e9]\n        for(int i = 0; i < t; ++i) {\n            long long n = rnd.next(100000000LL, 1000000000LL);\n            n_values[i] = n;\n        }\n    } else if (type == \"n_is_prime\") {\n        // Predefined list of known primes less than or equal to 1e9\n        vector<long long> known_primes = {\n            2LL, 3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, \n            999999937LL, 999999929LL, 999999893LL, 999999883LL, \n            999999797LL, 999999761LL, 1000000007LL, 1000000009LL, \n            10000000033LL\n        };\n\n        for(int i = 0; i < t; ++i) {\n            int idx = rnd.next(0, (int)known_primes.size() - 1);\n            long long n = known_primes[idx];\n            while (n > 1000000000LL) {\n                idx = rnd.next(0, (int)known_primes.size() - 1);\n                n = known_primes[idx];\n            }\n            n_values[i] = n;\n        }\n    } else if (type == \"n_just_before_prime\") {\n        // n such that n + 1 is prime\n        vector<long long> known_primes = {\n            3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, \n            999999937LL, 999999929LL, 999999893LL, 999999883LL, \n            999999797LL, 999999761LL\n        };\n\n        for(int i = 0; i < t; ++i) {\n            int idx = rnd.next(0, (int)known_primes.size() - 1);\n            long long n = known_primes[idx] - 1;\n            if (n < 2LL) n = 2LL;\n            n_values[i] = n;\n        }\n    } else if (type == \"n_just_after_prime\") {\n        // n such that n - 1 is prime\n        vector<long long> known_primes = {\n            2LL, 3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, \n            999999937LL, 999999929LL, 999999893LL, 999999883LL, \n            999999797LL, 999999761LL\n        };\n\n        for(int i = 0; i < t; ++i) {\n            int idx = rnd.next(0, (int)known_primes.size() - 1);\n            long long n = known_primes[idx] + 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n            n_values[i] = n;\n        }\n    } else if (type == \"max_n\") {\n        for(int i = 0; i < t; ++i) {\n            n_values[i] = 1000000000LL;\n        }\n    } else if (type == \"min_n\") {\n        for(int i = 0; i < t; ++i) {\n            n_values[i] = 2LL;\n        }\n    } else {\n        // Default: n in [2, 1e9]\n        for(int i = 0; i < t; ++i) {\n            long long n = rnd.next(2LL, 1000000000LL);\n            n_values[i] = n;\n        }\n    }\n\n    // Output n_values\n    for(int i = 0; i < t; ++i) {\n        printf(\"%lld\\n\", n_values[i]);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min_n\n./gen -t 1 -type max_n\n./gen -t 1 -type n_is_prime\n./gen -t 1 -type n_just_before_prime\n./gen -t 1 -type n_just_after_prime\n./gen -t 1 -type random\n\n./gen -t 10 -type small_random\n./gen -t 10 -type large_random\n./gen -t 10 -type n_is_prime\n./gen -t 10 -type n_just_before_prime\n./gen -t 10 -type n_just_after_prime\n\n./gen -t 100 -type small_random\n./gen -t 100 -type large_random\n./gen -t 100 -type random\n./gen -t 100 -type n_is_prime\n./gen -t 100 -type n_just_before_prime\n./gen -t 100 -type n_just_after_prime\n\n./gen -t 250 -type small_random\n./gen -t 250 -type large_random\n./gen -t 250 -type random\n./gen -t 250 -type n_is_prime\n./gen -t 250 -type n_just_before_prime\n./gen -t 250 -type n_just_after_prime\n\n./gen -t 500 -type small_random\n./gen -t 500 -type large_random\n./gen -t 500 -type random\n./gen -t 500 -type n_is_prime\n./gen -t 500 -type n_just_before_prime\n./gen -t 500 -type n_just_after_prime\n./gen -t 500 -type min_n\n./gen -t 500 -type max_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:19.161427",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "396/C",
      "title": "C. On Changing Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of vertices in the tree. The second line contains n - 1 integers p2, p3, ... pn (1 ≤ pi < i), where pi is the number of the vertex that is the parent of vertex i in the tree.The third line contains integer q (1 ≤ q ≤ 3·105) — the number of queries. Next q lines contain the queries, one per line. The first number in the line is type. It represents the type of the query. If type = 1, then next follow space-separated integers v, x, k (1 ≤ v ≤ n; 0 ≤ x < 109 + 7; 0 ≤ k < 109 + 7). If type = 2, then next follows integer v (1 ≤ v ≤ n) — the vertex where you need to find the value of the number.",
      "output_spec": "OutputFor each query of the second type print on a single line the number written in the vertex from the query. Print the number modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy31 131 1 2 12 12 2OutputCopy21",
      "description": "C. On Changing Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of vertices in the tree. The second line contains n - 1 integers p2, p3, ... pn (1 ≤ pi < i), where pi is the number of the vertex that is the parent of vertex i in the tree.The third line contains integer q (1 ≤ q ≤ 3·105) — the number of queries. Next q lines contain the queries, one per line. The first number in the line is type. It represents the type of the query. If type = 1, then next follow space-separated integers v, x, k (1 ≤ v ≤ n; 0 ≤ x < 109 + 7; 0 ≤ k < 109 + 7). If type = 2, then next follows integer v (1 ≤ v ≤ n) — the vertex where you need to find the value of the number.\n\nOutputFor each query of the second type print on a single line the number written in the vertex from the query. Print the number modulo 1000000007 (109 + 7).\n\nInputCopy31 131 1 2 12 12 2OutputCopy21\n\nInputCopy31 131 1 2 12 12 2\n\nOutputCopy21\n\nNoteYou can read about a rooted tree here: http://en.wikipedia.org/wiki/Tree_(graph_theory).",
      "solutions": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces",
          "content": "Div2-ACreate an array used of 100 elements. i-th element for the segment (i, i + 1).For every student except Alexey set used[i]  =  true for each segment (i,  i  +  1) in the segment of that student. After that for each subsegment (i,  i  +  1) of Alexey's segment add 1 to result if used[i]  =  false.Div2-BFirst of all, calculate how many L's we can bring so that the result will not exceed N. It's .Now, if R·K  ≥  N we may increase any of K numbers by 1. At some moment sum will be equal to N becase sum of K R's is greater than N. So answer in this case is YES.If R·K  <  N, we can't get K or less numbers because their sum is less than N. But we can't get more than K numbers too, because their sum is more than N. So answer is NO.Complexity: O(1) for every query. Overall complexity: O(t).Div1-A/Div2-CLet's factorize all n numbers into prime factors. Now we should solve the problem for every prime independently and multiply these answers. The number of ways to split pk into n multipliers, where p is prime, is equal to C(k  +  n  -  1,  n  -  1) (it can be obtained using the method of stars and bars, you can read about it here, choose 'combinatorics'). So we have a solution that needs time.Div1-B/Div2-DFirst of all, let's consider n  +  1  =  p is prime. Then we can prove by induction that the answer is . Base for p  =  3 is obvious. If this equality holds for p, and q is the next prime, then answer for q is equal to answer for p plus q  -  p equal summands , that is , that's we wanted to prove.Next using that the distance between two consecutive primes not exceeding 109 does not exceed 300, we can find the answer as a sum of the answer for the maximal prime not exceeding n and several equal summands . We see that the denominator is a divisor of 2pq, which fits in long long.Div1-C/Div2-EWe can write all vertices in the list in order of dfs, then the descendants of the vertex from a segment of this list. Let's count for every vertex its distance to the root level[v].Let's create two segment trees st1 and st2. If we are given a query of the first type, in st1 we add x  +  level[v]·k to the segment corresponding to the vertex v, in st2 we add k to the segment corresponding to the vertex v.If we are given a query of the second type, we write st1.get(v) - st2.get(v) * level[v].The complexity is O(qlogn).You can use any other data stucture that allows to add to the segment and to find a value of an arbitrary element.Also there exists a solution using Heavy-Light decomposition.Div1-DLet's prove a useful fact: sum of number of invertions for all permutations of size k is equal to . The prove is simple: let's change in permutation p for every i pi to k  +  1  -  pi. Then the sum of number of invertions of the first and the second permutations is , and our conversion of the permutation is a biection.Now we suppose that we are given a permutation of numbers from 0 to n  -  1.Let's go at p from left to right. What permutations are less than p? Permutations having first number less than p0. If the first number is a  <  p0, than in every such permutation there are a inversions of form (first element, some other element). So in all permutations beginning with a there are a·(n  -  1)! inversions of this from. Moreover, there are inversions not including the first element, their sum is sumAll[n  -  1]. Then, counting sum for all a we have inversions. Permutations beginning with p0. At first, we should count the number of inversions, beginning in p0. There are cnt·p0 of this form, where cnt is the number of permutations beginning with p0 and not exceeding p. Then we should count the inversions not beginning in the beginning. But it is the same problem! The only exception is that if p1  >  p0, there are p1  -  1 available numbers less than p1, but not p1. So we get a solution: go from left to right, keep already used numbers in Fenwick tree, and then solve the same problem, assuming that the first number is not pi but pi - (the number of used numbers less than pi). The last we should do is to count the number of permutations not exceeding the suffix of p and beginning the same. It can be precomputed, if we go from right to left. In this case we should do the same as in the first part of solution, but consider that the minimal number is a number of already used numbers less than current.Div1-EWe will describe an algorithm and then understand why it works.For every prime we will maintain a list of intervals. At the first moment for every pi we add in its list interval [0;ai), other primes have an empty list.Then we go from big primes to small. Let's consider that current prime is p. If in its list there exists an interval [x;y), $x < k, y > k$, we divide it into two parts [x;k) and [k;y).Then for every interval [x;y), x  ≥  k (in fact, in this case x  =  k) we add to the answer for p y  -  x. For intervals, where y  ≤  k, we add to list of every prime divisor of p  -  1 invterval [x  +  1,  y  +  1). If p  -  1 has some prime if more than first power, we should add this segment several times.After that we should conduct a \"union with displacement\" operation for every prime which list was changed. If in one list there are 2 invervals [x,  y), [z,  t) so that y  ≤  z  >  x, we replace them with one interval [x,  y  +  t  -  z) (so we added t  -  z to the right border of the first interval). Then we go to next (lesser) p.Why does it works? If we take function φ one time, for every prime p which divides n, n is divided by p and multiplied by p  -  1 (or, the same, by all prime divisors p  -  1 in corresponding powers).Now we can observe that intervals in lists contains the numbers of iterations, when the number contains the corresponding prime number. Bigger primes do not affect smaller, so we can process them earlier. If after i-th iteration the number contains prime number p, after i  +  1-th iteration it contains prime divisors of p  -  1, and we add segments in accordance with this. The k-th iteration is the last, so the existence of the interval [k,  x) means that after k-th iteration we have (x  -  k)-th power of this prime. From this it is clear why we unite the intervals if that way.Why does it work fast? Because we precalculated the minimal prime divisor of each number up to MAXPRIME using linear Eratosthenes sieve. (Well, it's not necessary) Because for each prime there's no more than intervals, because for each [a,  b) range . Practically there is no more than 6 segments at once. Any questions about the editorial are welcome! Especially the English one :)This post was restored from google cache, and I have edited formula once again. If you notice some mistake, please send be a private message.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10713",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6701
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces - Code 1",
          "code": "st1.get(v) - st2.get(v) * level[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10713",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    if (n == 1) {\n        // No parents to read\n    } else {\n        for (int i = 2; i <= n; ++i) {\n            int p_i = inf.readInt(1, i - 1, \"p_i\");\n            if (i < n)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000006, \"x\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000006, \"k\");\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    if (n == 1) {\n        // No parents to read\n    } else {\n        for (int i = 2; i <= n; ++i) {\n            int p_i = inf.readInt(1, i - 1, \"p_i\");\n            if (i < n)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000006, \"x\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000006, \"k\");\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    if (n == 1) {\n        // No parents to read\n    } else {\n        for (int i = 2; i <= n; ++i) {\n            int p_i = inf.readInt(1, i - 1, \"p_i\");\n            if (i < n)\n                inf.readSpace();\n            else\n                inf.readEoln();\n        }\n    }\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000006, \"x\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000006, \"k\");\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string treetype = opt<string>(\"treetype\", \"random\");\n    string querytype = opt<string>(\"querytype\", \"mixed\");\n\n    // Generate the tree according to treetype\n    vector<int> parent(n + 1); // parent[1] will not be used\n\n    if (treetype == \"chain\") {\n        // Chain tree: node i has parent i - 1\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (treetype == \"star\") {\n        // Star tree: all nodes connected to root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (treetype == \"binary\") {\n        // Generate a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n        }\n    } else if (treetype == \"caterpillar\") {\n        // Caterpillar tree: a chain with leaves attached\n        int backbone_length = n / 2;\n        for (int i = 2; i <= backbone_length; ++i) {\n            parent[i] = i - 1;\n        }\n        for (int i = backbone_length + 1; i <= n; ++i) {\n            parent[i] = rnd.next(1, backbone_length);\n        }\n    } else if (treetype == \"complete\") {\n        // Complete tree: all levels are fully filled except possibly the last\n        queue<int> q_nodes;\n        q_nodes.push(1);\n        int idx = 2;\n        while (!q_nodes.empty() && idx <= n) {\n            int u = q_nodes.front();\n            q_nodes.pop();\n            int children = 2; // Binary tree\n            for (int i = 0; i < children && idx <= n; ++i) {\n                parent[idx] = u;\n                q_nodes.push(idx);\n                ++idx;\n            }\n        }\n    } else { // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Generate the queries according to querytype\n    vector<string> queries;\n    const int MAX_VAL = 1000000006;\n\n    if (querytype == \"all1\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = rnd.next(0, MAX_VAL);\n            int k = rnd.next(0, MAX_VAL);\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"all2\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back(\"2 \" + to_string(v));\n        }\n    } else if (querytype == \"mixed\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"max\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = MAX_VAL;\n                int k = MAX_VAL;\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"min\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = 0;\n                int k = 0;\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"zero_k\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = rnd.next(0, MAX_VAL);\n            int k = 0;\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"zero_x\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = 0;\n            int k = rnd.next(0, MAX_VAL);\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"zero_xk\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = 0;\n            int k = 0;\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"root_updates\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = 1;\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"leaf_queries\") {\n        // First, find the leaves\n        vector<int> leaves;\n        vector<vector<int>> tree(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            tree[parent[i]].push_back(i);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (tree[i].empty()) leaves.push_back(i);\n        }\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            int v = leaves[rnd.next(0, (int)leaves.size() - 1)];\n            if (type == 1) {\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else {\n        // Default to mixed\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", parent[i], i == n ? '\\n' : ' ');\n    }\n\n    printf(\"%d\\n\", q);\n    for (const string& query : queries) {\n        printf(\"%s\\n\", query.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string treetype = opt<string>(\"treetype\", \"random\");\n    string querytype = opt<string>(\"querytype\", \"mixed\");\n\n    // Generate the tree according to treetype\n    vector<int> parent(n + 1); // parent[1] will not be used\n\n    if (treetype == \"chain\") {\n        // Chain tree: node i has parent i - 1\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (treetype == \"star\") {\n        // Star tree: all nodes connected to root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (treetype == \"binary\") {\n        // Generate a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n        }\n    } else if (treetype == \"caterpillar\") {\n        // Caterpillar tree: a chain with leaves attached\n        int backbone_length = n / 2;\n        for (int i = 2; i <= backbone_length; ++i) {\n            parent[i] = i - 1;\n        }\n        for (int i = backbone_length + 1; i <= n; ++i) {\n            parent[i] = rnd.next(1, backbone_length);\n        }\n    } else if (treetype == \"complete\") {\n        // Complete tree: all levels are fully filled except possibly the last\n        queue<int> q_nodes;\n        q_nodes.push(1);\n        int idx = 2;\n        while (!q_nodes.empty() && idx <= n) {\n            int u = q_nodes.front();\n            q_nodes.pop();\n            int children = 2; // Binary tree\n            for (int i = 0; i < children && idx <= n; ++i) {\n                parent[idx] = u;\n                q_nodes.push(idx);\n                ++idx;\n            }\n        }\n    } else { // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Generate the queries according to querytype\n    vector<string> queries;\n    const int MAX_VAL = 1000000006;\n\n    if (querytype == \"all1\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = rnd.next(0, MAX_VAL);\n            int k = rnd.next(0, MAX_VAL);\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"all2\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back(\"2 \" + to_string(v));\n        }\n    } else if (querytype == \"mixed\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"max\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = MAX_VAL;\n                int k = MAX_VAL;\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"min\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = 0;\n                int k = 0;\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"zero_k\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = rnd.next(0, MAX_VAL);\n            int k = 0;\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"zero_x\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = 0;\n            int k = rnd.next(0, MAX_VAL);\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"zero_xk\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = 0;\n            int k = 0;\n            queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n        }\n    } else if (querytype == \"root_updates\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = 1;\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else if (querytype == \"leaf_queries\") {\n        // First, find the leaves\n        vector<int> leaves;\n        vector<vector<int>> tree(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            tree[parent[i]].push_back(i);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (tree[i].empty()) leaves.push_back(i);\n        }\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            int v = leaves[rnd.next(0, (int)leaves.size() - 1)];\n            if (type == 1) {\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    } else {\n        // Default to mixed\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, MAX_VAL);\n                int k = rnd.next(0, MAX_VAL);\n                queries.push_back(\"1 \" + to_string(v) + \" \" + to_string(x) + \" \" + to_string(k));\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(v));\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", parent[i], i == n ? '\\n' : ' ');\n    }\n\n    printf(\"%d\\n\", q);\n    for (const string& query : queries) {\n        printf(\"%s\\n\", query.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -treetype chain -querytype mixed\n./gen -n 2 -q 2 -treetype star -querytype all1\n./gen -n 2 -q 2 -treetype star -querytype all2\n\n./gen -n 10 -q 10 -treetype chain -querytype mixed\n./gen -n 10 -q 10 -treetype star -querytype mixed\n./gen -n 10 -q 10 -treetype binary -querytype mixed\n./gen -n 10 -q 10 -treetype random -querytype mixed\n\n./gen -n 100 -q 100 -treetype chain -querytype mixed\n./gen -n 100 -q 100 -treetype star -querytype mixed\n./gen -n 100 -q 100 -treetype binary -querytype mixed\n./gen -n 100 -q 100 -treetype random -querytype mixed\n\n./gen -n 1000 -q 1000 -treetype chain -querytype mixed\n./gen -n 1000 -q 1000 -treetype star -querytype mixed\n./gen -n 1000 -q 1000 -treetype binary -querytype mixed\n./gen -n 1000 -q 1000 -treetype random -querytype mixed\n\n./gen -n 10000 -q 10000 -treetype chain -querytype mixed\n./gen -n 10000 -q 10000 -treetype star -querytype mixed\n./gen -n 10000 -q 10000 -treetype binary -querytype mixed\n./gen -n 10000 -q 10000 -treetype random -querytype mixed\n\n./gen -n 100000 -q 100000 -treetype chain -querytype mixed\n./gen -n 100000 -q 100000 -treetype star -querytype mixed\n./gen -n 100000 -q 100000 -treetype binary -querytype mixed\n./gen -n 100000 -q 100000 -treetype random -querytype mixed\n\n./gen -n 300000 -q 300000 -treetype random -querytype mixed\n\n./gen -n 100000 -q 100000 -treetype random -querytype zero_k\n./gen -n 100000 -q 100000 -treetype random -querytype zero_x\n./gen -n 100000 -q 100000 -treetype random -querytype zero_xk\n./gen -n 100000 -q 100000 -treetype random -querytype max\n./gen -n 100000 -q 100000 -treetype random -querytype min\n\n./gen -n 100000 -q 100000 -treetype chain -querytype root_updates\n./gen -n 100000 -q 100000 -treetype chain -querytype leaf_queries\n\n./gen -n 100000 -q 100000 -treetype star -querytype all1\n./gen -n 100000 -q 100000 -treetype star -querytype all2\n\n./gen -n 100000 -q 100000 -treetype binary -querytype all1\n./gen -n 100000 -q 100000 -treetype binary -querytype all2\n\n./gen -n 300000 -q 300000 -treetype complete -querytype mixed\n./gen -n 300000 -q 300000 -treetype caterpillar -querytype mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:21.663814",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "396/D",
      "title": "Problem 396/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    std::set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All p_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    std::set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All p_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    std::set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All p_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"increasing\") {\n        /* p = [1,2,...,n] */\n        for(int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        /* p = [n,n-1,...,1] */\n        for(int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"zigzag\") {\n        /* p = [n,1,n-1,2,...] */\n        int l = 1, r = n;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = r--;\n            else\n                p[i] = l++;\n        }\n    } else if (type == \"almost_increasing\") {\n        /* p = [1,2,...,n], swap two adjacent elements */\n        for(int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        if (n >= 2) {\n            int pos = rnd.next(0, n - 2);\n            swap(p[pos], p[pos + 1]);\n        }\n    } else if (type == \"almost_decreasing\") {\n        /* p = [n,n-1,...,1], swap two adjacent elements */\n        for(int i = 0; i < n; ++i)\n            p[i] = n - i;\n        if (n >= 2) {\n            int pos = rnd.next(0, n - 2);\n            swap(p[pos], p[pos + 1]);\n        }\n    } else {\n        /* Random permutation */\n        for(int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output permutation */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"increasing\") {\n        /* p = [1,2,...,n] */\n        for(int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        /* p = [n,n-1,...,1] */\n        for(int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"zigzag\") {\n        /* p = [n,1,n-1,2,...] */\n        int l = 1, r = n;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = r--;\n            else\n                p[i] = l++;\n        }\n    } else if (type == \"almost_increasing\") {\n        /* p = [1,2,...,n], swap two adjacent elements */\n        for(int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        if (n >= 2) {\n            int pos = rnd.next(0, n - 2);\n            swap(p[pos], p[pos + 1]);\n        }\n    } else if (type == \"almost_decreasing\") {\n        /* p = [n,n-1,...,1], swap two adjacent elements */\n        for(int i = 0; i < n; ++i)\n            p[i] = n - i;\n        if (n >= 2) {\n            int pos = rnd.next(0, n - 2);\n            swap(p[pos], p[pos + 1]);\n        }\n    } else {\n        /* Random permutation */\n        for(int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output permutation */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type almost_increasing\n./gen -n 2 -type almost_decreasing\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type random\n./gen -n 3 -type zigzag\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type zigzag\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type almost_increasing\n./gen -n 1000 -type random\n./gen -n 1000 -type zigzag\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 1000000 -type increasing\n./gen -n 1000000 -type decreasing\n./gen -n 1000000 -type random\n./gen -n 1000000 -type zigzag\n./gen -n 999999 -type random\n./gen -n 999998 -type almost_decreasing\n./gen -n 1000000 -type almost_increasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:23.695378",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "396/E",
      "title": "Problem 396/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    int prev_p = -1;\n\n    for (int i = 0; i < m; i++) {\n        int p = inf.readInt(2, 1000000, \"p_i\");\n        ensuref(p > prev_p, \"p_i (%d) is not in strictly increasing order\", p);\n        prev_p = p;\n\n        inf.readSpace();\n        long long ai = inf.readLong(1LL, 100000000000000000LL, \"a_i\");\n        sum_ai += ai;\n        inf.readEoln();\n    }\n\n    ensuref(sum_ai <= 100000000000000000LL, \"Sum of ai (%lld) exceeds 1e17\", sum_ai);\n\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    int prev_p = -1;\n\n    for (int i = 0; i < m; i++) {\n        int p = inf.readInt(2, 1000000, \"p_i\");\n        ensuref(p > prev_p, \"p_i (%d) is not in strictly increasing order\", p);\n        prev_p = p;\n\n        inf.readSpace();\n        long long ai = inf.readLong(1LL, 100000000000000000LL, \"a_i\");\n        sum_ai += ai;\n        inf.readEoln();\n    }\n\n    ensuref(sum_ai <= 100000000000000000LL, \"Sum of ai (%lld) exceeds 1e17\", sum_ai);\n\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    int prev_p = -1;\n\n    for (int i = 0; i < m; i++) {\n        int p = inf.readInt(2, 1000000, \"p_i\");\n        ensuref(p > prev_p, \"p_i (%d) is not in strictly increasing order\", p);\n        prev_p = p;\n\n        inf.readSpace();\n        long long ai = inf.readLong(1LL, 100000000000000000LL, \"a_i\");\n        sum_ai += ai;\n        inf.readEoln();\n    }\n\n    ensuref(sum_ai <= 100000000000000000LL, \"Sum of ai (%lld) exceeds 1e17\", sum_ai);\n\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\", -1); // Number of distinct prime divisors\n    long long k = opt<long long>(\"k\", -1); // Number of times to apply φ function\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Constraints from the problem statement\n    const int max_prime = 1000000; // Maximum value for pi\n    const long long max_exponent = 100000000000000000LL; // Maximum value for ai\n    const long long max_sum_ai = 100000000000000000LL; // Maximum sum of all ai\n\n    // Generate all prime numbers up to max_prime using Sieve of Eratosthenes\n    vector<int> primes;\n    {\n        vector<bool> is_prime(max_prime + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= max_prime; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if ((long long)i * i <= max_prime) {\n                    for (int j = i * i; j <= max_prime; j += i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // Initialize vectors to store primes and exponents\n    vector<int> pi;\n    vector<long long> ai;\n\n    // Generate test cases based on the specified type\n    if (type == \"single_prime\") {\n        // Single prime with maximum exponent\n        m = 1;\n        int p = primes[rnd.next((int)primes.size())];\n        long long a = max_exponent;\n        ai.push_back(min(a, max_sum_ai));\n        pi.push_back(p);\n    } else if (type == \"max_m\") {\n        // Maximum number of primes (m = 1e5)\n        m = 100000;\n        int total_primes = (int)primes.size();\n        m = min(m, total_primes);\n        vector<int> indices(total_primes);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"max_ai\") {\n        // Primes with maximum exponents\n        if (m == -1) m = rnd.next(1, 10);\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                ai.push_back(max_exponent);\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"max_k\") {\n        // Maximum k value\n        if (m == -1) m = rnd.next(1, 10);\n        m = min(m, (int)primes.size());\n        k = 1000000000000000000LL;\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n    } else if (type == \"ones_exponents\") {\n        // All exponents are 1\n        if (m == -1) m = rnd.next(1, 100000);\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            ai.push_back(1);\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"large_primes\") {\n        // Use the largest primes\n        if (m == -1) m = rnd.next(1, 1000);\n        m = min(m, (int)primes.size());\n        sort(primes.begin(), primes.end());\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[primes.size() - m + i]);\n            ai.push_back(rnd.next(1LL, max_exponent));\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"max_sum_ai\") {\n        // Exponents sum up to max_sum_ai\n        if (m == -1) m = rnd.next(1, 100000);\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"min_values\") {\n        // Minimal values for all parameters\n        m = 1;\n        pi.push_back(2);\n        ai.push_back(1);\n        k = 1;\n    } else if (type == \"max_values\") {\n        // Maximize all parameters\n        m = 100000;\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                ai.push_back(max_exponent);\n                remaining_a -= ai.back();\n            }\n        }\n        k = 1000000000000000000LL;\n    } else {\n        // Default random test case\n        if (m == -1) m = rnd.next(1, min(100000, (int)primes.size()));\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    }\n\n    // Output the test case according to the problem's input format\n    printf(\"%d\\n\", (int)pi.size());\n    for (size_t i = 0; i < pi.size(); ++i) {\n        printf(\"%d %lld\\n\", pi[i], ai[i]);\n    }\n    printf(\"%lld\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\", -1); // Number of distinct prime divisors\n    long long k = opt<long long>(\"k\", -1); // Number of times to apply φ function\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Constraints from the problem statement\n    const int max_prime = 1000000; // Maximum value for pi\n    const long long max_exponent = 100000000000000000LL; // Maximum value for ai\n    const long long max_sum_ai = 100000000000000000LL; // Maximum sum of all ai\n\n    // Generate all prime numbers up to max_prime using Sieve of Eratosthenes\n    vector<int> primes;\n    {\n        vector<bool> is_prime(max_prime + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= max_prime; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if ((long long)i * i <= max_prime) {\n                    for (int j = i * i; j <= max_prime; j += i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // Initialize vectors to store primes and exponents\n    vector<int> pi;\n    vector<long long> ai;\n\n    // Generate test cases based on the specified type\n    if (type == \"single_prime\") {\n        // Single prime with maximum exponent\n        m = 1;\n        int p = primes[rnd.next((int)primes.size())];\n        long long a = max_exponent;\n        ai.push_back(min(a, max_sum_ai));\n        pi.push_back(p);\n    } else if (type == \"max_m\") {\n        // Maximum number of primes (m = 1e5)\n        m = 100000;\n        int total_primes = (int)primes.size();\n        m = min(m, total_primes);\n        vector<int> indices(total_primes);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"max_ai\") {\n        // Primes with maximum exponents\n        if (m == -1) m = rnd.next(1, 10);\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                ai.push_back(max_exponent);\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"max_k\") {\n        // Maximum k value\n        if (m == -1) m = rnd.next(1, 10);\n        m = min(m, (int)primes.size());\n        k = 1000000000000000000LL;\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n    } else if (type == \"ones_exponents\") {\n        // All exponents are 1\n        if (m == -1) m = rnd.next(1, 100000);\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            ai.push_back(1);\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"large_primes\") {\n        // Use the largest primes\n        if (m == -1) m = rnd.next(1, 1000);\n        m = min(m, (int)primes.size());\n        sort(primes.begin(), primes.end());\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[primes.size() - m + i]);\n            ai.push_back(rnd.next(1LL, max_exponent));\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"max_sum_ai\") {\n        // Exponents sum up to max_sum_ai\n        if (m == -1) m = rnd.next(1, 100000);\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    } else if (type == \"min_values\") {\n        // Minimal values for all parameters\n        m = 1;\n        pi.push_back(2);\n        ai.push_back(1);\n        k = 1;\n    } else if (type == \"max_values\") {\n        // Maximize all parameters\n        m = 100000;\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                ai.push_back(max_exponent);\n                remaining_a -= ai.back();\n            }\n        }\n        k = 1000000000000000000LL;\n    } else {\n        // Default random test case\n        if (m == -1) m = rnd.next(1, min(100000, (int)primes.size()));\n        m = min(m, (int)primes.size());\n        vector<int> indices(primes.size());\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        indices.resize(m);\n        sort(indices.begin(), indices.end());\n\n        long long remaining_a = max_sum_ai;\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(primes[indices[i]]);\n            if (i == m - 1) {\n                ai.push_back(remaining_a);\n            } else {\n                long long max_exp = min(max_exponent, remaining_a - (m - i - 1));\n                ai.push_back(rnd.next(1LL, max_exp));\n                remaining_a -= ai.back();\n            }\n        }\n        if (k == -1) k = rnd.next(1LL, 1000000000000000000LL);\n    }\n\n    // Output the test case according to the problem's input format\n    printf(\"%d\\n\", (int)pi.size());\n    for (size_t i = 0; i < pi.size(); ++i) {\n        printf(\"%d %lld\\n\", pi[i], ai[i]);\n    }\n    printf(\"%lld\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_values\n\n./gen -type max_values\n\n./gen -type random -m 10\n./gen -type random -m 100\n./gen -type random -m 1000\n./gen -type random -m 10000\n./gen -type random -m 100000\n\n./gen -type random -k 1\n./gen -type random -k 1000\n./gen -type random -k 1000000\n./gen -type random -k 1000000000000000000\n\n./gen -type single_prime\n./gen -type single_prime -k 1000000000000000000\n\n./gen -type max_m\n./gen -type max_ai\n./gen -type max_k\n\n./gen -type ones_exponents -m 1\n./gen -type ones_exponents -m 10\n./gen -type ones_exponents -m 100\n./gen -type ones_exponents -m 1000\n./gen -type ones_exponents -m 100000\n\n./gen -type large_primes -m 1\n./gen -type large_primes -m 10\n./gen -type large_primes -m 100\n./gen -type large_primes -m 1000\n\n./gen -type max_sum_ai\n\n./gen -type random\n\n./gen -type random -m 50000 -k 500000000000000000\n\n./gen -type random -k 10000000000000\n\n./gen -type random -m 100000 -k 1\n\n./gen -type min_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:25.953225",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "397/A",
      "title": "Problem 397/A",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        int li = inf.readInt(0, 99, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, 100, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        int li = inf.readInt(0, 99, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, 100, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        int li = inf.readInt(0, 99, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, 100, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > segments(n);\n\n    if (type == \"random\") {\n        // Generate random segments\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, 99); // li < ri ≤ 100, so li can be at most 99\n            int r = rnd.next(l + 1, 100); // li < ri ≤ 100\n            segments[i] = make_pair(l, r);\n        }\n    } else if (type == \"full_overlap\") {\n        // All students have the full dryer\n        for (int i = 0; i < n; ++i) {\n            segments[i] = make_pair(0, 100);\n        }\n    } else if (type == \"no_overlap\") {\n        // Divide dryer into non-overlapping segments\n        int pos = 0;\n        int base_len = 100 / n;\n        int rem = 100 % n;\n        for (int i = 0; i < n; ++i) {\n            int extra = (i < rem) ? 1 : 0;\n            int len = base_len + extra;\n            int l = pos;\n            int r = l + len;\n            segments[i] = make_pair(l, r);\n            pos = r;\n        }\n    } else if (type == \"alexey_covered\") {\n        // Alexey's segment\n        segments[0] = make_pair(25, 75);\n        // Other students cover Alexey's segment\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(20, 80);\n        }\n    } else if (type == \"alexey_uncovered\") {\n        // Alexey's segment\n        segments[0] = make_pair(0, 50);\n        // Other students do not overlap with Alexey\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(51, 100);\n        }\n    } else if (type == \"edge_cases\") {\n        // Edge segments\n        segments[0] = make_pair(0, 1);\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(99, 100);\n        }\n    } else if (type == \"touching\") {\n        // Segments with touching endpoints\n        segments[0] = make_pair(0,1);\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(1, rnd.next(2, 100));\n        }\n    } else if (type == \"multiple_overlaps\") {\n        if (n < 4) n = 4;\n        segments.resize(n);\n        segments[0] = make_pair(20,80);\n        segments[1] = make_pair(10,50);\n        segments[2] = make_pair(40,60);\n        segments[3] = make_pair(70,90);\n        for (int i = 4; i < n; ++i) {\n            int l = rnd.next(segments[0].first, segments[0].second - 1);\n            int r = rnd.next(l + 1, segments[0].second);\n            segments[i] = make_pair(l, r);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, 99);\n            int r = rnd.next(l + 1, 100);\n            segments[i] = make_pair(l, r);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", segments[i].first, segments[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > segments(n);\n\n    if (type == \"random\") {\n        // Generate random segments\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, 99); // li < ri ≤ 100, so li can be at most 99\n            int r = rnd.next(l + 1, 100); // li < ri ≤ 100\n            segments[i] = make_pair(l, r);\n        }\n    } else if (type == \"full_overlap\") {\n        // All students have the full dryer\n        for (int i = 0; i < n; ++i) {\n            segments[i] = make_pair(0, 100);\n        }\n    } else if (type == \"no_overlap\") {\n        // Divide dryer into non-overlapping segments\n        int pos = 0;\n        int base_len = 100 / n;\n        int rem = 100 % n;\n        for (int i = 0; i < n; ++i) {\n            int extra = (i < rem) ? 1 : 0;\n            int len = base_len + extra;\n            int l = pos;\n            int r = l + len;\n            segments[i] = make_pair(l, r);\n            pos = r;\n        }\n    } else if (type == \"alexey_covered\") {\n        // Alexey's segment\n        segments[0] = make_pair(25, 75);\n        // Other students cover Alexey's segment\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(20, 80);\n        }\n    } else if (type == \"alexey_uncovered\") {\n        // Alexey's segment\n        segments[0] = make_pair(0, 50);\n        // Other students do not overlap with Alexey\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(51, 100);\n        }\n    } else if (type == \"edge_cases\") {\n        // Edge segments\n        segments[0] = make_pair(0, 1);\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(99, 100);\n        }\n    } else if (type == \"touching\") {\n        // Segments with touching endpoints\n        segments[0] = make_pair(0,1);\n        for (int i = 1; i < n; ++i) {\n            segments[i] = make_pair(1, rnd.next(2, 100));\n        }\n    } else if (type == \"multiple_overlaps\") {\n        if (n < 4) n = 4;\n        segments.resize(n);\n        segments[0] = make_pair(20,80);\n        segments[1] = make_pair(10,50);\n        segments[2] = make_pair(40,60);\n        segments[3] = make_pair(70,90);\n        for (int i = 4; i < n; ++i) {\n            int l = rnd.next(segments[0].first, segments[0].second - 1);\n            int r = rnd.next(l + 1, segments[0].second);\n            segments[i] = make_pair(l, r);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, 99);\n            int r = rnd.next(l + 1, 100);\n            segments[i] = make_pair(l, r);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", segments[i].first, segments[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n./gen -n 1 -type full_overlap\n./gen -n 5 -type full_overlap\n./gen -n 50 -type full_overlap\n./gen -n 100 -type full_overlap\n\n./gen -n 1 -type no_overlap\n./gen -n 5 -type no_overlap\n./gen -n 50 -type no_overlap\n./gen -n 100 -type no_overlap\n\n./gen -n 1 -type alexey_covered\n./gen -n 5 -type alexey_covered\n./gen -n 50 -type alexey_covered\n./gen -n 100 -type alexey_covered\n\n./gen -n 1 -type alexey_uncovered\n./gen -n 5 -type alexey_uncovered\n./gen -n 50 -type alexey_uncovered\n./gen -n 100 -type alexey_uncovered\n\n./gen -n 1 -type edge_cases\n./gen -n 5 -type edge_cases\n./gen -n 50 -type edge_cases\n./gen -n 100 -type edge_cases\n\n./gen -n 1 -type touching\n./gen -n 5 -type touching\n./gen -n 50 -type touching\n./gen -n 100 -type touching\n\n./gen -n 4 -type multiple_overlaps\n./gen -n 5 -type multiple_overlaps\n./gen -n 50 -type multiple_overlaps\n./gen -n 100 -type multiple_overlaps\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:27.604388",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "397/B",
      "title": "Problem 397/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int ni = inf.readInt(1, 1000000000, \"ni\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n        ensuref(li <= ri, \"In query %d, li=%d must be less than or equal to ri=%d\", i+1, li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int ni = inf.readInt(1, 1000000000, \"ni\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n        ensuref(li <= ri, \"In query %d, li=%d must be less than or equal to ri=%d\", i+1, li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int ni = inf.readInt(1, 1000000000, \"ni\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n        ensuref(li <= ri, \"In query %d, li=%d must be less than or equal to ri=%d\", i+1, li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n    for (int i = 0; i < t; i++) {\n        if (type == \"random\") {\n            // Random n, l, r within constraints\n            int l = rnd.next(1, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = rnd.next(1, (int)1e9);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"n_lt_l\") {\n            // n less than l (n < l), so answer is \"No\"\n            int l = rnd.next(2, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = rnd.next(1, l - 1);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"l_eq_r_div\") {\n            // l = r, n divisible by l, so answer is \"Yes\"\n            int l = rnd.next(1, (int)1e9);\n            int r = l;\n            int k = rnd.next(1, (int)(1e9 / l));\n            int n = l * k;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"l_eq_r_notdiv\") {\n            // l = r, n not divisible by l, so answer is \"No\"\n            int l = rnd.next(2, (int)1e9);\n            int r = l;\n            int n;\n            do {\n                n = rnd.next(1, (int)1e9);\n            } while (n % l == 0);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"l1_rmax\") {\n            // l = 1, r = 1e9, n random\n            int l = 1;\n            int r = (int)1e9;\n            int n = rnd.next(1, (int)1e9);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"n1_lgt1\") {\n            // n = 1, l > 1, so answer is \"No\"\n            int l = rnd.next(2, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = 1;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"n_eq_l\") {\n            // n equals l\n            int l = rnd.next(1, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = l;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"max\") {\n            // Maximum values\n            int n = (int)1e9;\n            int l = rnd.next(1, (int)1e9);\n            int r = (int)1e9;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"min\") {\n            // Minimum values\n            int n = 1;\n            int l = 1;\n            int r = 1;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else {\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n    for (int i = 0; i < t; i++) {\n        if (type == \"random\") {\n            // Random n, l, r within constraints\n            int l = rnd.next(1, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = rnd.next(1, (int)1e9);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"n_lt_l\") {\n            // n less than l (n < l), so answer is \"No\"\n            int l = rnd.next(2, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = rnd.next(1, l - 1);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"l_eq_r_div\") {\n            // l = r, n divisible by l, so answer is \"Yes\"\n            int l = rnd.next(1, (int)1e9);\n            int r = l;\n            int k = rnd.next(1, (int)(1e9 / l));\n            int n = l * k;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"l_eq_r_notdiv\") {\n            // l = r, n not divisible by l, so answer is \"No\"\n            int l = rnd.next(2, (int)1e9);\n            int r = l;\n            int n;\n            do {\n                n = rnd.next(1, (int)1e9);\n            } while (n % l == 0);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"l1_rmax\") {\n            // l = 1, r = 1e9, n random\n            int l = 1;\n            int r = (int)1e9;\n            int n = rnd.next(1, (int)1e9);\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"n1_lgt1\") {\n            // n = 1, l > 1, so answer is \"No\"\n            int l = rnd.next(2, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = 1;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"n_eq_l\") {\n            // n equals l\n            int l = rnd.next(1, (int)1e9);\n            int r = rnd.next(l, (int)1e9);\n            int n = l;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"max\") {\n            // Maximum values\n            int n = (int)1e9;\n            int l = rnd.next(1, (int)1e9);\n            int r = (int)1e9;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else if (type == \"min\") {\n            // Minimum values\n            int n = 1;\n            int l = 1;\n            int r = 1;\n            printf(\"%d %d %d\\n\", n, l, r);\n        } else {\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test case\n./gen -t 1 -type min\n\n# Maximal test case\n./gen -t 1 -type max\n\n# Test cases where t = 1\n./gen -t 1 -type l_eq_r_div\n./gen -t 1 -type l_eq_r_notdiv\n./gen -t 1 -type n_lt_l\n./gen -t 1 -type n_eq_l\n./gen -t 1 -type n1_lgt1\n./gen -t 1 -type l1_rmax\n./gen -t 1 -type random\n\n# Test cases where t = 10\n./gen -t 10 -type l_eq_r_div\n./gen -t 10 -type l_eq_r_notdiv\n./gen -t 10 -type n_lt_l\n./gen -t 10 -type n_eq_l\n./gen -t 10 -type n1_lgt1\n./gen -t 10 -type l1_rmax\n./gen -t 10 -type random\n\n# Test cases where t = 1000\n./gen -t 1000 -type random\n./gen -t 1000 -type l_eq_r_div\n./gen -t 1000 -type l_eq_r_notdiv\n./gen -t 1000 -type n_lt_l\n./gen -t 1000 -type n_eq_l\n./gen -t 1000 -type n1_lgt1\n./gen -t 1000 -type l1_rmax\n./gen -t 1000 -type max\n./gen -t 1000 -type min\n./gen -t 1000 -type random\n./gen -t 1000 -type random\n./gen -t 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:29.726570",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    }
  ]
}